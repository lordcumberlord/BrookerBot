{"version":3,"sources":["../index.ts","../dsp/modelinfo.ts","../util/crypto.ts","../util/sse.ts","../util/stream.ts","../util/apicall.ts","../ai/base.ts","../dsp/globals.ts","../util/log.ts","../dsp/loggers.ts","../trace/trace.ts","../util/transform.ts","../ai/util.ts","../ai/debug.ts","../ai/metrics.ts","../ai/validate.ts","../ai/anthropic/types.ts","../ai/anthropic/info.ts","../ai/anthropic/api.ts","../ai/openai/chat_types.ts","../ai/openai/responses_types.ts","../ai/openai/info.ts","../ai/openai/api.ts","../ai/azure-openai/api.ts","../ai/balance.ts","../ai/capabilities.ts","../ai/cohere/types.ts","../ai/cohere/info.ts","../ai/cohere/api.ts","../ai/deepseek/types.ts","../ai/deepseek/info.ts","../ai/deepseek/api.ts","../ai/google-gemini/types.ts","../ai/google-gemini/info.ts","../ai/google-gemini/api.ts","../util/rate-limit.ts","../ai/groq/types.ts","../ai/groq/info.ts","../ai/groq/api.ts","../ai/huggingface/info.ts","../ai/huggingface/types.ts","../ai/huggingface/api.ts","../ai/mistral/types.ts","../ai/mistral/info.ts","../ai/mistral/api.ts","../ai/mock/api.ts","../ai/multiservice.ts","../ai/ollama/api.ts","../ai/openai/responses_api.ts","../ai/openai/responses_api_base.ts","../ai/openrouter/api.ts","../ai/processor.ts","../ai/reka/types.ts","../ai/reka/info.ts","../ai/reka/api.ts","../ai/router.ts","../ai/together/info.ts","../ai/together/api.ts","../ai/webllm/types.ts","../ai/webllm/info.ts","../ai/webllm/api.ts","../ai/x-grok/types.ts","../ai/x-grok/info.ts","../ai/x-grok/api.ts","../ai/wrap.ts","../db/base.ts","../db/cloudflare.ts","../db/memory.ts","../db/pinecone.ts","../db/weaviate.ts","../db/wrap.ts","../docs/manager.ts","../dsp/generate.ts","../mem/memory.ts","../dsp/asserts.ts","../dsp/metrics.ts","../dsp/errors.ts","../dsp/jsonschema.ts","../dsp/functions.ts","../dsp/datetime.ts","../dsp/util.ts","../dsp/extract.ts","../dsp/fieldProcessor.ts","../dsp/processResponse.ts","../dsp/registry.ts","../dsp/parser.ts","../dsp/sig.ts","../dsp/program.ts","../dsp/prompt.ts","../dsp/samples.ts","../dsp/signatureToolRouter.ts","../dsp/sigTools.ts","../dsp/signatureToolCalling.ts","../dsp/strutil.ts","../docs/reranker.ts","../docs/tika.ts","../dsp/classifier.ts","../dsp/stopwords.ts","../dsp/eval.ts","../dsp/evaluate.ts","../dsp/loader.ts","../dsp/optimizerLogging.ts","../dsp/optimizer.ts","../dsp/template.ts","../dsp/optimizers/acePlaybook.ts","../dsp/optimizers/ace.ts","../dsp/optimizers/bootstrapFewshot.ts","../dsp/optimizers/paretoUtils.ts","../dsp/optimizers/gepa.ts","../dsp/optimizers/gepaFlow.ts","../dsp/optimizers/pythonOptimizerClient.ts","../dsp/optimizers/miproV2.ts","../flow/dependencyAnalyzer.ts","../flow/batchUtil.ts","../flow/executionPlanner.ts","../flow/flow.ts","../flow/logger.ts","../flow/subContext.ts","../funcs/docker.ts","../funcs/embed.ts","../mcp/client.ts","../mcp/oauth/pkce.ts","../mcp/util/http.ts","../mcp/oauth/discovery.ts","../mcp/oauth/oauthHelper.ts","../mcp/transports/httpStreamTransport.ts","../mcp/transports/sseTransport.ts","../prompts/agent.ts","../prompts/rag.ts"],"sourcesContent":["/* eslint import/order: 0 sort-imports: 0 */\n// Auto-generated index file - Do not edit\n\nimport {\n  AxAIAnthropic,\n  type AxAIAnthropicArgs,\n  axAIAnthropicDefaultConfig,\n  axAIAnthropicVertexDefaultConfig,\n} from './ai/anthropic/api.js';\nimport { axModelInfoAnthropic } from './ai/anthropic/info.js';\nimport {\n  type AxAIAnthropicChatError,\n  type AxAIAnthropicChatRequest,\n  type AxAIAnthropicChatRequestCacheParam,\n  type AxAIAnthropicChatResponse,\n  type AxAIAnthropicChatResponseDelta,\n  type AxAIAnthropicConfig,\n  type AxAIAnthropicContentBlockDeltaEvent,\n  type AxAIAnthropicContentBlockStartEvent,\n  type AxAIAnthropicContentBlockStopEvent,\n  type AxAIAnthropicErrorEvent,\n  type AxAIAnthropicFunctionTool,\n  type AxAIAnthropicMessageDeltaEvent,\n  type AxAIAnthropicMessageStartEvent,\n  type AxAIAnthropicMessageStopEvent,\n  AxAIAnthropicModel,\n  type AxAIAnthropicPingEvent,\n  type AxAIAnthropicRequestTool,\n  type AxAIAnthropicThinkingConfig,\n  type AxAIAnthropicThinkingTokenBudgetLevels,\n  AxAIAnthropicVertexModel,\n  type AxAIAnthropicWebSearchTool,\n} from './ai/anthropic/types.js';\nimport {\n  AxAIAzureOpenAI,\n  type AxAIAzureOpenAIArgs,\n  type AxAIAzureOpenAIConfig,\n  axAIAzureOpenAIBestConfig,\n  axAIAzureOpenAICreativeConfig,\n  axAIAzureOpenAIDefaultConfig,\n  axAIAzureOpenAIFastConfig,\n} from './ai/azure-openai/api.js';\nimport { AxBalancer, type AxBalancerOptions } from './ai/balance.js';\nimport {\n  type AxAIFeatures,\n  AxBaseAI,\n  type AxBaseAIArgs,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from './ai/base.js';\nimport {\n  axAnalyzeRequestRequirements,\n  axGetCompatibilityReport,\n  axGetFormatCompatibility,\n  axGetProvidersWithMediaSupport,\n  axScoreProvidersForRequest,\n  axSelectOptimalProvider,\n  axValidateProviderCapabilities,\n} from './ai/capabilities.js';\nimport {\n  AxAICohere,\n  type AxAICohereArgs,\n  axAICohereCreativeConfig,\n  axAICohereDefaultConfig,\n} from './ai/cohere/api.js';\nimport { axModelInfoCohere } from './ai/cohere/info.js';\nimport {\n  type AxAICohereChatRequest,\n  type AxAICohereChatRequestToolResults,\n  type AxAICohereChatResponse,\n  type AxAICohereChatResponseDelta,\n  type AxAICohereChatResponseToolCalls,\n  type AxAICohereConfig,\n  AxAICohereEmbedModel,\n  type AxAICohereEmbedRequest,\n  type AxAICohereEmbedResponse,\n  AxAICohereModel,\n} from './ai/cohere/types.js';\nimport {\n  AxAIDeepSeek,\n  type AxAIDeepSeekArgs,\n  axAIDeepSeekCodeConfig,\n  axAIDeepSeekDefaultConfig,\n} from './ai/deepseek/api.js';\nimport { axModelInfoDeepSeek } from './ai/deepseek/info.js';\nimport { AxAIDeepSeekModel } from './ai/deepseek/types.js';\nimport {\n  AxAIGoogleGemini,\n  type AxAIGoogleGeminiArgs,\n  type AxAIGoogleGeminiOptionsTools,\n  axAIGoogleGeminiDefaultConfig,\n  axAIGoogleGeminiDefaultCreativeConfig,\n} from './ai/google-gemini/api.js';\nimport { axModelInfoGoogleGemini } from './ai/google-gemini/info.js';\nimport {\n  type AxAIGoogleGeminiBatchEmbedRequest,\n  type AxAIGoogleGeminiBatchEmbedResponse,\n  type AxAIGoogleGeminiChatRequest,\n  type AxAIGoogleGeminiChatResponse,\n  type AxAIGoogleGeminiChatResponseDelta,\n  type AxAIGoogleGeminiConfig,\n  type AxAIGoogleGeminiContent,\n  type AxAIGoogleGeminiContentPart,\n  AxAIGoogleGeminiEmbedModel,\n  AxAIGoogleGeminiEmbedTypes,\n  type AxAIGoogleGeminiGenerationConfig,\n  AxAIGoogleGeminiModel,\n  type AxAIGoogleGeminiRetrievalConfig,\n  AxAIGoogleGeminiSafetyCategory,\n  type AxAIGoogleGeminiSafetySettings,\n  AxAIGoogleGeminiSafetyThreshold,\n  type AxAIGoogleGeminiThinkingConfig,\n  type AxAIGoogleGeminiThinkingTokenBudgetLevels,\n  type AxAIGoogleGeminiTool,\n  type AxAIGoogleGeminiToolConfig,\n  type AxAIGoogleGeminiToolFunctionDeclaration,\n  type AxAIGoogleGeminiToolGoogleMaps,\n  type AxAIGoogleGeminiToolGoogleSearchRetrieval,\n  type AxAIGoogleVertexBatchEmbedRequest,\n  type AxAIGoogleVertexBatchEmbedResponse,\n} from './ai/google-gemini/types.js';\nimport { AxAIGroq, type AxAIGroqArgs } from './ai/groq/api.js';\nimport { axModelInfoGroq } from './ai/groq/info.js';\nimport { AxAIGroqModel } from './ai/groq/types.js';\nimport {\n  AxAIHuggingFace,\n  type AxAIHuggingFaceArgs,\n  axAIHuggingFaceCreativeConfig,\n  axAIHuggingFaceDefaultConfig,\n} from './ai/huggingface/api.js';\nimport { axModelInfoHuggingFace } from './ai/huggingface/info.js';\nimport {\n  type AxAIHuggingFaceConfig,\n  AxAIHuggingFaceModel,\n  type AxAIHuggingFaceRequest,\n  type AxAIHuggingFaceResponse,\n} from './ai/huggingface/types.js';\nimport type { AxAIMetricsInstruments } from './ai/metrics.js';\nimport {\n  AxAIMistral,\n  type AxAIMistralArgs,\n  type AxAIMistralChatRequest,\n  axAIMistralBestConfig,\n  axAIMistralDefaultConfig,\n} from './ai/mistral/api.js';\nimport { axModelInfoMistral } from './ai/mistral/info.js';\nimport {\n  AxAIMistralEmbedModels,\n  AxAIMistralModel,\n} from './ai/mistral/types.js';\nimport { AxMockAIService, type AxMockAIServiceConfig } from './ai/mock/api.js';\nimport { AxMultiServiceRouter } from './ai/multiservice.js';\nimport {\n  AxAIOllama,\n  type AxAIOllamaAIConfig,\n  type AxAIOllamaArgs,\n  axAIOllamaDefaultConfig,\n  axAIOllamaDefaultCreativeConfig,\n} from './ai/ollama/api.js';\nimport {\n  AxAIOpenAI,\n  type AxAIOpenAIArgs,\n  AxAIOpenAIBase,\n  type AxAIOpenAIBaseArgs,\n  axAIOpenAIBestConfig,\n  axAIOpenAICreativeConfig,\n  axAIOpenAIDefaultConfig,\n  axAIOpenAIFastConfig,\n} from './ai/openai/api.js';\nimport {\n  type AxAIOpenAIAnnotation,\n  type AxAIOpenAIChatRequest,\n  type AxAIOpenAIChatResponse,\n  type AxAIOpenAIChatResponseDelta,\n  type AxAIOpenAIConfig,\n  AxAIOpenAIEmbedModel,\n  type AxAIOpenAIEmbedRequest,\n  type AxAIOpenAIEmbedResponse,\n  type AxAIOpenAILogprob,\n  AxAIOpenAIModel,\n  type AxAIOpenAIResponseDelta,\n  type AxAIOpenAIUrlCitation,\n  type AxAIOpenAIUsage,\n} from './ai/openai/chat_types.js';\nimport {\n  axModelInfoOpenAI,\n  axModelInfoOpenAIResponses,\n} from './ai/openai/info.js';\nimport { AxAIOpenAIResponsesImpl } from './ai/openai/responses_api.js';\nimport {\n  AxAIOpenAIResponses,\n  type AxAIOpenAIResponsesArgs,\n  AxAIOpenAIResponsesBase,\n  axAIOpenAIResponsesBestConfig,\n  axAIOpenAIResponsesCreativeConfig,\n  axAIOpenAIResponsesDefaultConfig,\n} from './ai/openai/responses_api_base.js';\nimport {\n  type AxAIOpenAIResponsesCodeInterpreterToolCall,\n  type AxAIOpenAIResponsesComputerToolCall,\n  type AxAIOpenAIResponsesConfig,\n  type AxAIOpenAIResponsesContentPartAddedEvent,\n  type AxAIOpenAIResponsesContentPartDoneEvent,\n  type AxAIOpenAIResponsesDefineFunctionTool,\n  type AxAIOpenAIResponsesErrorEvent,\n  type AxAIOpenAIResponsesFileSearchCallCompletedEvent,\n  type AxAIOpenAIResponsesFileSearchCallInProgressEvent,\n  type AxAIOpenAIResponsesFileSearchCallSearchingEvent,\n  type AxAIOpenAIResponsesFileSearchToolCall,\n  type AxAIOpenAIResponsesFunctionCallArgumentsDeltaEvent,\n  type AxAIOpenAIResponsesFunctionCallArgumentsDoneEvent,\n  type AxAIOpenAIResponsesFunctionCallItem,\n  type AxAIOpenAIResponsesImageGenerationCallCompletedEvent,\n  type AxAIOpenAIResponsesImageGenerationCallGeneratingEvent,\n  type AxAIOpenAIResponsesImageGenerationCallInProgressEvent,\n  type AxAIOpenAIResponsesImageGenerationCallPartialImageEvent,\n  type AxAIOpenAIResponsesImageGenerationToolCall,\n  type AxAIOpenAIResponsesInputAudioContentPart,\n  type AxAIOpenAIResponsesInputContentPart,\n  type AxAIOpenAIResponsesInputFunctionCallItem,\n  type AxAIOpenAIResponsesInputFunctionCallOutputItem,\n  type AxAIOpenAIResponsesInputImageUrlContentPart,\n  type AxAIOpenAIResponsesInputItem,\n  type AxAIOpenAIResponsesInputMessageItem,\n  type AxAIOpenAIResponsesInputTextContentPart,\n  type AxAIOpenAIResponsesLocalShellToolCall,\n  type AxAIOpenAIResponsesMCPCallArgumentsDeltaEvent,\n  type AxAIOpenAIResponsesMCPCallArgumentsDoneEvent,\n  type AxAIOpenAIResponsesMCPCallCompletedEvent,\n  type AxAIOpenAIResponsesMCPCallFailedEvent,\n  type AxAIOpenAIResponsesMCPCallInProgressEvent,\n  type AxAIOpenAIResponsesMCPListToolsCompletedEvent,\n  type AxAIOpenAIResponsesMCPListToolsFailedEvent,\n  type AxAIOpenAIResponsesMCPListToolsInProgressEvent,\n  type AxAIOpenAIResponsesMCPToolCall,\n  AxAIOpenAIResponsesModel,\n  type AxAIOpenAIResponsesOutputItem,\n  type AxAIOpenAIResponsesOutputItemAddedEvent,\n  type AxAIOpenAIResponsesOutputItemDoneEvent,\n  type AxAIOpenAIResponsesOutputMessageItem,\n  type AxAIOpenAIResponsesOutputRefusalContentPart,\n  type AxAIOpenAIResponsesOutputTextAnnotationAddedEvent,\n  type AxAIOpenAIResponsesOutputTextContentPart,\n  type AxAIOpenAIResponsesOutputTextDeltaEvent,\n  type AxAIOpenAIResponsesOutputTextDoneEvent,\n  type AxAIOpenAIResponsesReasoningDeltaEvent,\n  type AxAIOpenAIResponsesReasoningDoneEvent,\n  type AxAIOpenAIResponsesReasoningItem,\n  type AxAIOpenAIResponsesReasoningSummaryDeltaEvent,\n  type AxAIOpenAIResponsesReasoningSummaryDoneEvent,\n  type AxAIOpenAIResponsesReasoningSummaryPart,\n  type AxAIOpenAIResponsesReasoningSummaryPartAddedEvent,\n  type AxAIOpenAIResponsesReasoningSummaryPartDoneEvent,\n  type AxAIOpenAIResponsesReasoningSummaryTextDeltaEvent,\n  type AxAIOpenAIResponsesReasoningSummaryTextDoneEvent,\n  type AxAIOpenAIResponsesRefusalDeltaEvent,\n  type AxAIOpenAIResponsesRefusalDoneEvent,\n  type AxAIOpenAIResponsesRequest,\n  type AxAIOpenAIResponsesResponse,\n  type AxAIOpenAIResponsesResponseCompletedEvent,\n  type AxAIOpenAIResponsesResponseCreatedEvent,\n  type AxAIOpenAIResponsesResponseDelta,\n  type AxAIOpenAIResponsesResponseFailedEvent,\n  type AxAIOpenAIResponsesResponseIncompleteEvent,\n  type AxAIOpenAIResponsesResponseInProgressEvent,\n  type AxAIOpenAIResponsesResponseQueuedEvent,\n  type AxAIOpenAIResponsesStreamEvent,\n  type AxAIOpenAIResponsesStreamEventBase,\n  type AxAIOpenAIResponsesToolCall,\n  type AxAIOpenAIResponsesToolCallBase,\n  type AxAIOpenAIResponsesToolChoice,\n  type AxAIOpenAIResponsesToolDefinition,\n  type AxAIOpenAIResponsesWebSearchCallCompletedEvent,\n  type AxAIOpenAIResponsesWebSearchCallInProgressEvent,\n  type AxAIOpenAIResponsesWebSearchCallSearchingEvent,\n  type AxAIOpenAIResponsesWebSearchToolCall,\n} from './ai/openai/responses_types.js';\nimport {\n  AxAIOpenRouter,\n  type AxAIOpenRouterArgs,\n  axAIOpenRouterDefaultConfig,\n} from './ai/openrouter/api.js';\nimport {\n  axAnalyzeChatPromptRequirements,\n  axProcessContentForProvider,\n} from './ai/processor.js';\nimport {\n  AxAIReka,\n  type AxAIRekaArgs,\n  axAIRekaBestConfig,\n  axAIRekaCreativeConfig,\n  axAIRekaDefaultConfig,\n  axAIRekaFastConfig,\n} from './ai/reka/api.js';\nimport { axModelInfoReka } from './ai/reka/info.js';\nimport {\n  type AxAIRekaChatRequest,\n  type AxAIRekaChatResponse,\n  type AxAIRekaChatResponseDelta,\n  type AxAIRekaConfig,\n  AxAIRekaModel,\n  type AxAIRekaUsage,\n} from './ai/reka/types.js';\nimport {\n  type AxContentProcessingServices,\n  type AxMultiProviderConfig,\n  AxProviderRouter,\n  type AxRoutingResult,\n} from './ai/router.js';\nimport {\n  AxAITogether,\n  type AxAITogetherArgs,\n  axAITogetherDefaultConfig,\n} from './ai/together/api.js';\nimport { axModelInfoTogether } from './ai/together/info.js';\nimport type {\n  AxAIInputModelList,\n  AxAIModelList,\n  AxAIModelListBase,\n  AxAIService,\n  AxAIServiceImpl,\n  AxAIServiceMetrics,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxCitation,\n  AxEmbedRequest,\n  AxEmbedResponse,\n  AxFunction,\n  AxFunctionHandler,\n  AxFunctionJSONSchema,\n  AxFunctionResult,\n  AxInternalChatRequest,\n  AxInternalEmbedRequest,\n  AxLoggerData,\n  AxLoggerFunction,\n  AxModelConfig,\n  AxModelInfo,\n  AxModelInfoWithProvider,\n  AxModelUsage,\n  AxRateLimiterFunction,\n  AxTokenUsage,\n} from './ai/types.js';\nimport {\n  axValidateChatRequestMessage,\n  axValidateChatResponseResult,\n} from './ai/validate.js';\nimport {\n  AxAIWebLLM,\n  type AxAIWebLLMArgs,\n  axAIWebLLMCreativeConfig,\n  axAIWebLLMDefaultConfig,\n} from './ai/webllm/api.js';\nimport { axModelInfoWebLLM } from './ai/webllm/info.js';\nimport {\n  type AxAIWebLLMChatRequest,\n  type AxAIWebLLMChatResponse,\n  type AxAIWebLLMChatResponseDelta,\n  type AxAIWebLLMConfig,\n  type AxAIWebLLMEmbedModel,\n  type AxAIWebLLMEmbedRequest,\n  type AxAIWebLLMEmbedResponse,\n  AxAIWebLLMModel,\n} from './ai/webllm/types.js';\nimport {\n  AxAI,\n  type AxAIArgs,\n  type AxAIEmbedModels,\n  type AxAIModels,\n  ai,\n} from './ai/wrap.js';\nimport {\n  AxAIGrok,\n  type AxAIGrokArgs,\n  type AxAIGrokChatRequest,\n  type AxAIGrokOptionsTools,\n  type AxAIGrokSearchSource,\n  axAIGrokBestConfig,\n  axAIGrokDefaultConfig,\n} from './ai/x-grok/api.js';\nimport { axModelInfoGrok } from './ai/x-grok/info.js';\nimport { AxAIGrokEmbedModels, AxAIGrokModel } from './ai/x-grok/types.js';\nimport {\n  AxDBBase,\n  type AxDBBaseArgs,\n  type AxDBBaseOpOptions,\n} from './db/base.js';\nimport {\n  AxDBCloudflare,\n  type AxDBCloudflareArgs,\n  type AxDBCloudflareOpOptions,\n} from './db/cloudflare.js';\nimport {\n  AxDBMemory,\n  type AxDBMemoryArgs,\n  type AxDBMemoryOpOptions,\n  type AxDBState,\n} from './db/memory.js';\nimport {\n  AxDBPinecone,\n  type AxDBPineconeArgs,\n  type AxDBPineconeOpOptions,\n} from './db/pinecone.js';\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBQueryService,\n  AxDBService,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './db/types.js';\nimport {\n  AxDBWeaviate,\n  type AxDBWeaviateArgs,\n  type AxDBWeaviateOpOptions,\n} from './db/weaviate.js';\nimport { AxDB, type AxDBArgs } from './db/wrap.js';\nimport {\n  type AxDBLoaderOptions,\n  AxDBManager,\n  type AxDBManagerArgs,\n  type AxDBMatch,\n  type AxRerankerIn,\n  type AxRerankerOut,\n  type AxRewriteIn,\n  type AxRewriteOut,\n} from './docs/manager.js';\nimport { AxDefaultResultReranker } from './docs/reranker.js';\nimport {\n  AxApacheTika,\n  type AxApacheTikaArgs,\n  type AxApacheTikaConvertOptions,\n} from './docs/tika.js';\nimport {\n  type AxAssertion,\n  AxAssertionError,\n  type AxStreamingAssertion,\n} from './dsp/asserts.js';\nimport {\n  AxSimpleClassifier,\n  AxSimpleClassifierClass,\n  type AxSimpleClassifierForwardOptions,\n} from './dsp/classifier.js';\nimport type {\n  AxCheckpointLoadFn,\n  AxCheckpointSaveFn,\n  AxCompileOptions,\n  AxCostTracker,\n  AxCostTrackerOptions,\n  AxExample,\n  AxMetricFn,\n  AxMetricFnArgs,\n  AxMultiMetricFn,\n  AxOptimizationCheckpoint,\n  AxOptimizationProgress,\n  AxOptimizationStats,\n  AxOptimizerArgs,\n  AxTypedExample,\n} from './dsp/common_types.js';\nimport { AxEvalUtil } from './dsp/eval.js';\nimport { type AxEvaluateArgs, AxTestPrompt } from './dsp/evaluate.js';\nimport type {\n  AxFieldProcessor,\n  AxFieldProcessorProcess,\n  AxStreamingFieldProcessorProcess,\n} from './dsp/fieldProcessor.js';\nimport {\n  type AxChatResponseFunctionCall,\n  AxFunctionError,\n  AxFunctionProcessor,\n  type AxInputFunctionType,\n  AxStopFunctionCallException,\n} from './dsp/functions.js';\nimport {\n  AxGen,\n  AxGenerateError,\n  type AxGenerateErrorDetails,\n  type AxGenerateResult,\n  type AxResponseHandlerArgs,\n  type AxStreamingEvent,\n} from './dsp/generate.js';\nimport { type AxFunctionResultFormatter, axGlobals } from './dsp/globals.js';\nimport { type AxDataRow, AxHFDataLoader } from './dsp/loader.js';\nimport {\n  axCreateDefaultColorLogger,\n  axCreateDefaultTextLogger,\n} from './dsp/loggers.js';\nimport {\n  type AxErrorCategory,\n  type AxGenMetricsInstruments,\n  type AxMetricsConfig,\n  axCheckMetricsHealth,\n  axDefaultMetricsConfig,\n  axGetMetricsConfig,\n  axUpdateMetricsConfig,\n} from './dsp/metrics.js';\nimport {\n  AxBaseOptimizer,\n  type AxBootstrapOptimizerOptions,\n  AxDefaultCostTracker,\n  type AxMiPROOptimizerOptions,\n  type AxOptimizedProgram,\n  AxOptimizedProgramImpl,\n  type AxOptimizer,\n  type AxOptimizerMetricsConfig,\n  type AxOptimizerMetricsInstruments,\n  type AxOptimizerResult,\n  type AxParetoResult,\n  axDefaultOptimizerMetricsConfig,\n  axGetOptimizerMetricsConfig,\n  axUpdateOptimizerMetricsConfig,\n} from './dsp/optimizer.js';\nimport {\n  axCreateDefaultOptimizerColorLogger,\n  axCreateDefaultOptimizerTextLogger,\n  axDefaultOptimizerLogger,\n} from './dsp/optimizerLogging.js';\nimport {\n  AxACE,\n  AxACEOptimizedProgram,\n  type AxACEResult,\n} from './dsp/optimizers/ace.js';\nimport type {\n  AxACEBullet,\n  AxACECuratorOperation,\n  AxACECuratorOperationType,\n  AxACECuratorOutput,\n  AxACEFeedbackEvent,\n  AxACEGeneratorOutput,\n  AxACEOptimizationArtifact,\n  AxACEOptions,\n  AxACEPlaybook,\n  AxACEReflectionOutput,\n} from './dsp/optimizers/aceTypes.js';\nimport { AxBootstrapFewShot } from './dsp/optimizers/bootstrapFewshot.js';\nimport { AxGEPA } from './dsp/optimizers/gepa.js';\nimport type {\n  AxGEPAAdapter,\n  AxGEPAEvaluationBatch,\n} from './dsp/optimizers/gepaAdapter.js';\nimport { AxGEPAFlow } from './dsp/optimizers/gepaFlow.js';\nimport { AxMiPRO, type AxMiPROResult } from './dsp/optimizers/miproV2.js';\nimport type {\n  AxOptimizerLoggerData,\n  AxOptimizerLoggerFunction,\n} from './dsp/optimizerTypes.js';\nimport { AxProgram } from './dsp/program.js';\nimport {\n  type AxFieldTemplateFn,\n  AxPromptTemplate,\n  type AxPromptTemplateOptions,\n} from './dsp/prompt.js';\nimport { AxInstanceRegistry } from './dsp/registry.js';\nimport type { AxSamplePickerOptions } from './dsp/samples.js';\nimport {\n  type AxField,\n  type AxFieldType,\n  type AxFluentFieldInfo,\n  AxFluentFieldType,\n  type AxIField,\n  AxSignature,\n  AxSignatureBuilder,\n  type AxSignatureConfig,\n  f,\n} from './dsp/sig.js';\nimport { AxStringUtil } from './dsp/strutil.js';\nimport { ax, s } from './dsp/template.js';\nimport type {\n  AxAIServiceActionOptions,\n  AxAIServiceModelType,\n  AxExamples,\n  AxFieldValue,\n  AxForwardable,\n  AxGenDeltaOut,\n  AxGenIn,\n  AxGenInput,\n  AxGenOut,\n  AxGenOutput,\n  AxGenStreamingOut,\n  AxMessage,\n  AxProgramDemos,\n  AxProgramExamples,\n  AxProgramForwardOptions,\n  AxProgramForwardOptionsWithModels,\n  AxProgrammable,\n  AxProgramOptions,\n  AxProgramStreamingForwardOptions,\n  AxProgramStreamingForwardOptionsWithModels,\n  AxProgramTrace,\n  AxProgramUsage,\n  AxResultPickerFunction,\n  AxResultPickerFunctionFieldResults,\n  AxResultPickerFunctionFunctionResults,\n  AxSetExamplesOptions,\n  AxTunable,\n  AxUsable,\n} from './dsp/types.js';\nimport { AxFlowDependencyAnalyzer } from './flow/dependencyAnalyzer.js';\nimport { AxFlowExecutionPlanner } from './flow/executionPlanner.js';\nimport { AxFlow, flow } from './flow/flow.js';\nimport {\n  type AxFlowBranchEvaluationData,\n  type AxFlowCompleteData,\n  type AxFlowErrorData,\n  type AxFlowLogData,\n  type AxFlowLoggerData,\n  type AxFlowLoggerFunction,\n  type AxFlowParallelGroupCompleteData,\n  type AxFlowParallelGroupStartData,\n  type AxFlowStartData,\n  type AxFlowStepCompleteData,\n  type AxFlowStepStartData,\n  axCreateFlowColorLogger,\n  axCreateFlowTextLogger,\n  axDefaultFlowLogger,\n} from './flow/logger.js';\nimport {\n  AxFlowSubContextImpl,\n  AxFlowTypedSubContextImpl,\n} from './flow/subContext.js';\nimport type {\n  AxFlowAutoParallelConfig,\n  AxFlowable,\n  AxFlowBranchContext,\n  AxFlowDynamicContext,\n  AxFlowExecutionStep,\n  AxFlowNodeDefinition,\n  AxFlowParallelBranch,\n  AxFlowParallelGroup,\n  AxFlowState,\n  AxFlowStepFunction,\n  AxFlowSubContext,\n  AxFlowTypedParallelBranch,\n  AxFlowTypedSubContext,\n} from './flow/types.js';\nimport { type AxDockerContainer, AxDockerSession } from './funcs/docker.js';\nimport { AxEmbeddingAdapter } from './funcs/embed.js';\nimport { AxMCPClient } from './mcp/client.js';\nimport type { AxMCPOAuthOptions } from './mcp/oauth/types.js';\nimport type { AxMCPTransport } from './mcp/transport.js';\nimport { AxMCPStreambleHTTPTransport } from './mcp/transports/httpStreamTransport.js';\nimport type { AxMCPStreamableHTTPTransportOptions } from './mcp/transports/options.js';\nimport { AxMCPHTTPSSETransport } from './mcp/transports/sseTransport.js';\nimport type {\n  AxMCPFunctionDescription,\n  AxMCPInitializeParams,\n  AxMCPInitializeResult,\n  AxMCPJSONRPCErrorResponse,\n  AxMCPJSONRPCNotification,\n  AxMCPJSONRPCRequest,\n  AxMCPJSONRPCResponse,\n  AxMCPJSONRPCSuccessResponse,\n  AxMCPToolsListResult,\n} from './mcp/types.js';\nimport { AxMemory } from './mem/memory.js';\nimport type { AxAIMemory, AxMemoryData } from './mem/types.js';\nimport {\n  AxAgent,\n  type AxAgentConfig,\n  type AxAgentFeatures,\n  type AxAgentic,\n  type AxAgentOptions,\n  agent,\n} from './prompts/agent.js';\nimport { axRAG } from './prompts/rag.js';\nimport {\n  AxLLMRequestTypeValues,\n  AxSpanKindValues,\n  axSpanAttributes,\n  axSpanEvents,\n} from './trace/trace.js';\nimport {\n  AxAIRefusalError,\n  AxAIServiceAbortedError,\n  AxAIServiceAuthenticationError,\n  AxAIServiceError,\n  AxAIServiceNetworkError,\n  AxAIServiceResponseError,\n  AxAIServiceStatusError,\n  AxAIServiceStreamTerminatedError,\n  AxAIServiceTimeoutError,\n  type AxAPI,\n  type AxAPIConfig,\n  AxContentProcessingError,\n  AxMediaNotSupportedError,\n} from './util/apicall.js';\nimport {\n  AxRateLimiterTokenUsage,\n  type AxRateLimiterTokenUsageOptions,\n} from './util/rate-limit.js';\n\n// Value exports\nexport { AxACE };\nexport { AxACEOptimizedProgram };\nexport { AxAI };\nexport { AxAIAnthropic };\nexport { AxAIAnthropicModel };\nexport { AxAIAnthropicVertexModel };\nexport { AxAIAzureOpenAI };\nexport { AxAICohere };\nexport { AxAICohereEmbedModel };\nexport { AxAICohereModel };\nexport { AxAIDeepSeek };\nexport { AxAIDeepSeekModel };\nexport { AxAIGoogleGemini };\nexport { AxAIGoogleGeminiEmbedModel };\nexport { AxAIGoogleGeminiEmbedTypes };\nexport { AxAIGoogleGeminiModel };\nexport { AxAIGoogleGeminiSafetyCategory };\nexport { AxAIGoogleGeminiSafetyThreshold };\nexport { AxAIGrok };\nexport { AxAIGrokEmbedModels };\nexport { AxAIGrokModel };\nexport { AxAIGroq };\nexport { AxAIGroqModel };\nexport { AxAIHuggingFace };\nexport { AxAIHuggingFaceModel };\nexport { AxAIMistral };\nexport { AxAIMistralEmbedModels };\nexport { AxAIMistralModel };\nexport { AxAIOllama };\nexport { AxAIOpenAI };\nexport { AxAIOpenAIBase };\nexport { AxAIOpenAIEmbedModel };\nexport { AxAIOpenAIModel };\nexport { AxAIOpenAIResponses };\nexport { AxAIOpenAIResponsesBase };\nexport { AxAIOpenAIResponsesImpl };\nexport { AxAIOpenAIResponsesModel };\nexport { AxAIOpenRouter };\nexport { AxAIRefusalError };\nexport { AxAIReka };\nexport { AxAIRekaModel };\nexport { AxAIServiceAbortedError };\nexport { AxAIServiceAuthenticationError };\nexport { AxAIServiceError };\nexport { AxAIServiceNetworkError };\nexport { AxAIServiceResponseError };\nexport { AxAIServiceStatusError };\nexport { AxAIServiceStreamTerminatedError };\nexport { AxAIServiceTimeoutError };\nexport { AxAITogether };\nexport { AxAIWebLLM };\nexport { AxAIWebLLMModel };\nexport { AxAgent };\nexport { AxApacheTika };\nexport { AxAssertionError };\nexport { AxBalancer };\nexport { AxBaseAI };\nexport { AxBaseOptimizer };\nexport { AxBootstrapFewShot };\nexport { AxContentProcessingError };\nexport { AxDB };\nexport { AxDBBase };\nexport { AxDBCloudflare };\nexport { AxDBManager };\nexport { AxDBMemory };\nexport { AxDBPinecone };\nexport { AxDBWeaviate };\nexport { AxDefaultCostTracker };\nexport { AxDefaultResultReranker };\nexport { AxDockerSession };\nexport { AxEmbeddingAdapter };\nexport { AxEvalUtil };\nexport { AxFlow };\nexport { AxFlowDependencyAnalyzer };\nexport { AxFlowExecutionPlanner };\nexport { AxFlowSubContextImpl };\nexport { AxFlowTypedSubContextImpl };\nexport { AxFluentFieldType };\nexport { AxFunctionError };\nexport { AxFunctionProcessor };\nexport { AxGEPA };\nexport { AxGEPAFlow };\nexport { AxGen };\nexport { AxGenerateError };\nexport { AxHFDataLoader };\nexport { AxInstanceRegistry };\nexport { AxLLMRequestTypeValues };\nexport { AxMCPClient };\nexport { AxMCPHTTPSSETransport };\nexport { AxMCPStreambleHTTPTransport };\nexport { AxMediaNotSupportedError };\nexport { AxMemory };\nexport { AxMiPRO };\nexport { AxMockAIService };\nexport { AxMultiServiceRouter };\nexport { AxOptimizedProgramImpl };\nexport { AxProgram };\nexport { AxPromptTemplate };\nexport { AxProviderRouter };\nexport { AxRateLimiterTokenUsage };\nexport { AxSignature };\nexport { AxSignatureBuilder };\nexport { AxSimpleClassifier };\nexport { AxSimpleClassifierClass };\nexport { AxSpanKindValues };\nexport { AxStopFunctionCallException };\nexport { AxStringUtil };\nexport { AxTestPrompt };\nexport { agent };\nexport { ai };\nexport { ax };\nexport { axAIAnthropicDefaultConfig };\nexport { axAIAnthropicVertexDefaultConfig };\nexport { axAIAzureOpenAIBestConfig };\nexport { axAIAzureOpenAICreativeConfig };\nexport { axAIAzureOpenAIDefaultConfig };\nexport { axAIAzureOpenAIFastConfig };\nexport { axAICohereCreativeConfig };\nexport { axAICohereDefaultConfig };\nexport { axAIDeepSeekCodeConfig };\nexport { axAIDeepSeekDefaultConfig };\nexport { axAIGoogleGeminiDefaultConfig };\nexport { axAIGoogleGeminiDefaultCreativeConfig };\nexport { axAIGrokBestConfig };\nexport { axAIGrokDefaultConfig };\nexport { axAIHuggingFaceCreativeConfig };\nexport { axAIHuggingFaceDefaultConfig };\nexport { axAIMistralBestConfig };\nexport { axAIMistralDefaultConfig };\nexport { axAIOllamaDefaultConfig };\nexport { axAIOllamaDefaultCreativeConfig };\nexport { axAIOpenAIBestConfig };\nexport { axAIOpenAICreativeConfig };\nexport { axAIOpenAIDefaultConfig };\nexport { axAIOpenAIFastConfig };\nexport { axAIOpenAIResponsesBestConfig };\nexport { axAIOpenAIResponsesCreativeConfig };\nexport { axAIOpenAIResponsesDefaultConfig };\nexport { axAIOpenRouterDefaultConfig };\nexport { axAIRekaBestConfig };\nexport { axAIRekaCreativeConfig };\nexport { axAIRekaDefaultConfig };\nexport { axAIRekaFastConfig };\nexport { axAITogetherDefaultConfig };\nexport { axAIWebLLMCreativeConfig };\nexport { axAIWebLLMDefaultConfig };\nexport { axAnalyzeChatPromptRequirements };\nexport { axAnalyzeRequestRequirements };\nexport { axBaseAIDefaultConfig };\nexport { axBaseAIDefaultCreativeConfig };\nexport { axCheckMetricsHealth };\nexport { axCreateDefaultColorLogger };\nexport { axCreateDefaultOptimizerColorLogger };\nexport { axCreateDefaultOptimizerTextLogger };\nexport { axCreateDefaultTextLogger };\nexport { axCreateFlowColorLogger };\nexport { axCreateFlowTextLogger };\nexport { axDefaultFlowLogger };\nexport { axDefaultMetricsConfig };\nexport { axDefaultOptimizerLogger };\nexport { axDefaultOptimizerMetricsConfig };\nexport { axGetCompatibilityReport };\nexport { axGetFormatCompatibility };\nexport { axGetMetricsConfig };\nexport { axGetOptimizerMetricsConfig };\nexport { axGetProvidersWithMediaSupport };\nexport { axGlobals };\nexport { axModelInfoAnthropic };\nexport { axModelInfoCohere };\nexport { axModelInfoDeepSeek };\nexport { axModelInfoGoogleGemini };\nexport { axModelInfoGrok };\nexport { axModelInfoGroq };\nexport { axModelInfoHuggingFace };\nexport { axModelInfoMistral };\nexport { axModelInfoOpenAI };\nexport { axModelInfoOpenAIResponses };\nexport { axModelInfoReka };\nexport { axModelInfoTogether };\nexport { axModelInfoWebLLM };\nexport { axProcessContentForProvider };\nexport { axRAG };\nexport { axScoreProvidersForRequest };\nexport { axSelectOptimalProvider };\nexport { axSpanAttributes };\nexport { axSpanEvents };\nexport { axUpdateMetricsConfig };\nexport { axUpdateOptimizerMetricsConfig };\nexport { axValidateChatRequestMessage };\nexport { axValidateChatResponseResult };\nexport { axValidateProviderCapabilities };\nexport { f };\nexport { flow };\nexport { s };\n\n// Type exports\nexport type { AxACEBullet };\nexport type { AxACECuratorOperation };\nexport type { AxACECuratorOperationType };\nexport type { AxACECuratorOutput };\nexport type { AxACEFeedbackEvent };\nexport type { AxACEGeneratorOutput };\nexport type { AxACEOptimizationArtifact };\nexport type { AxACEOptions };\nexport type { AxACEPlaybook };\nexport type { AxACEReflectionOutput };\nexport type { AxACEResult };\nexport type { AxAIAnthropicArgs };\nexport type { AxAIAnthropicChatError };\nexport type { AxAIAnthropicChatRequest };\nexport type { AxAIAnthropicChatRequestCacheParam };\nexport type { AxAIAnthropicChatResponse };\nexport type { AxAIAnthropicChatResponseDelta };\nexport type { AxAIAnthropicConfig };\nexport type { AxAIAnthropicContentBlockDeltaEvent };\nexport type { AxAIAnthropicContentBlockStartEvent };\nexport type { AxAIAnthropicContentBlockStopEvent };\nexport type { AxAIAnthropicErrorEvent };\nexport type { AxAIAnthropicFunctionTool };\nexport type { AxAIAnthropicMessageDeltaEvent };\nexport type { AxAIAnthropicMessageStartEvent };\nexport type { AxAIAnthropicMessageStopEvent };\nexport type { AxAIAnthropicPingEvent };\nexport type { AxAIAnthropicRequestTool };\nexport type { AxAIAnthropicThinkingConfig };\nexport type { AxAIAnthropicThinkingTokenBudgetLevels };\nexport type { AxAIAnthropicWebSearchTool };\nexport type { AxAIArgs };\nexport type { AxAIAzureOpenAIArgs };\nexport type { AxAIAzureOpenAIConfig };\nexport type { AxAICohereArgs };\nexport type { AxAICohereChatRequest };\nexport type { AxAICohereChatRequestToolResults };\nexport type { AxAICohereChatResponse };\nexport type { AxAICohereChatResponseDelta };\nexport type { AxAICohereChatResponseToolCalls };\nexport type { AxAICohereConfig };\nexport type { AxAICohereEmbedRequest };\nexport type { AxAICohereEmbedResponse };\nexport type { AxAIDeepSeekArgs };\nexport type { AxAIEmbedModels };\nexport type { AxAIFeatures };\nexport type { AxAIGoogleGeminiArgs };\nexport type { AxAIGoogleGeminiBatchEmbedRequest };\nexport type { AxAIGoogleGeminiBatchEmbedResponse };\nexport type { AxAIGoogleGeminiChatRequest };\nexport type { AxAIGoogleGeminiChatResponse };\nexport type { AxAIGoogleGeminiChatResponseDelta };\nexport type { AxAIGoogleGeminiConfig };\nexport type { AxAIGoogleGeminiContent };\nexport type { AxAIGoogleGeminiContentPart };\nexport type { AxAIGoogleGeminiGenerationConfig };\nexport type { AxAIGoogleGeminiOptionsTools };\nexport type { AxAIGoogleGeminiRetrievalConfig };\nexport type { AxAIGoogleGeminiSafetySettings };\nexport type { AxAIGoogleGeminiThinkingConfig };\nexport type { AxAIGoogleGeminiThinkingTokenBudgetLevels };\nexport type { AxAIGoogleGeminiTool };\nexport type { AxAIGoogleGeminiToolConfig };\nexport type { AxAIGoogleGeminiToolFunctionDeclaration };\nexport type { AxAIGoogleGeminiToolGoogleMaps };\nexport type { AxAIGoogleGeminiToolGoogleSearchRetrieval };\nexport type { AxAIGoogleVertexBatchEmbedRequest };\nexport type { AxAIGoogleVertexBatchEmbedResponse };\nexport type { AxAIGrokArgs };\nexport type { AxAIGrokChatRequest };\nexport type { AxAIGrokOptionsTools };\nexport type { AxAIGrokSearchSource };\nexport type { AxAIGroqArgs };\nexport type { AxAIHuggingFaceArgs };\nexport type { AxAIHuggingFaceConfig };\nexport type { AxAIHuggingFaceRequest };\nexport type { AxAIHuggingFaceResponse };\nexport type { AxAIInputModelList };\nexport type { AxAIMemory };\nexport type { AxAIMetricsInstruments };\nexport type { AxAIMistralArgs };\nexport type { AxAIMistralChatRequest };\nexport type { AxAIModelList };\nexport type { AxAIModelListBase };\nexport type { AxAIModels };\nexport type { AxAIOllamaAIConfig };\nexport type { AxAIOllamaArgs };\nexport type { AxAIOpenAIAnnotation };\nexport type { AxAIOpenAIArgs };\nexport type { AxAIOpenAIBaseArgs };\nexport type { AxAIOpenAIChatRequest };\nexport type { AxAIOpenAIChatResponse };\nexport type { AxAIOpenAIChatResponseDelta };\nexport type { AxAIOpenAIConfig };\nexport type { AxAIOpenAIEmbedRequest };\nexport type { AxAIOpenAIEmbedResponse };\nexport type { AxAIOpenAILogprob };\nexport type { AxAIOpenAIResponseDelta };\nexport type { AxAIOpenAIResponsesArgs };\nexport type { AxAIOpenAIResponsesCodeInterpreterToolCall };\nexport type { AxAIOpenAIResponsesComputerToolCall };\nexport type { AxAIOpenAIResponsesConfig };\nexport type { AxAIOpenAIResponsesContentPartAddedEvent };\nexport type { AxAIOpenAIResponsesContentPartDoneEvent };\nexport type { AxAIOpenAIResponsesDefineFunctionTool };\nexport type { AxAIOpenAIResponsesErrorEvent };\nexport type { AxAIOpenAIResponsesFileSearchCallCompletedEvent };\nexport type { AxAIOpenAIResponsesFileSearchCallInProgressEvent };\nexport type { AxAIOpenAIResponsesFileSearchCallSearchingEvent };\nexport type { AxAIOpenAIResponsesFileSearchToolCall };\nexport type { AxAIOpenAIResponsesFunctionCallArgumentsDeltaEvent };\nexport type { AxAIOpenAIResponsesFunctionCallArgumentsDoneEvent };\nexport type { AxAIOpenAIResponsesFunctionCallItem };\nexport type { AxAIOpenAIResponsesImageGenerationCallCompletedEvent };\nexport type { AxAIOpenAIResponsesImageGenerationCallGeneratingEvent };\nexport type { AxAIOpenAIResponsesImageGenerationCallInProgressEvent };\nexport type { AxAIOpenAIResponsesImageGenerationCallPartialImageEvent };\nexport type { AxAIOpenAIResponsesImageGenerationToolCall };\nexport type { AxAIOpenAIResponsesInputAudioContentPart };\nexport type { AxAIOpenAIResponsesInputContentPart };\nexport type { AxAIOpenAIResponsesInputFunctionCallItem };\nexport type { AxAIOpenAIResponsesInputFunctionCallOutputItem };\nexport type { AxAIOpenAIResponsesInputImageUrlContentPart };\nexport type { AxAIOpenAIResponsesInputItem };\nexport type { AxAIOpenAIResponsesInputMessageItem };\nexport type { AxAIOpenAIResponsesInputTextContentPart };\nexport type { AxAIOpenAIResponsesLocalShellToolCall };\nexport type { AxAIOpenAIResponsesMCPCallArgumentsDeltaEvent };\nexport type { AxAIOpenAIResponsesMCPCallArgumentsDoneEvent };\nexport type { AxAIOpenAIResponsesMCPCallCompletedEvent };\nexport type { AxAIOpenAIResponsesMCPCallFailedEvent };\nexport type { AxAIOpenAIResponsesMCPCallInProgressEvent };\nexport type { AxAIOpenAIResponsesMCPListToolsCompletedEvent };\nexport type { AxAIOpenAIResponsesMCPListToolsFailedEvent };\nexport type { AxAIOpenAIResponsesMCPListToolsInProgressEvent };\nexport type { AxAIOpenAIResponsesMCPToolCall };\nexport type { AxAIOpenAIResponsesOutputItem };\nexport type { AxAIOpenAIResponsesOutputItemAddedEvent };\nexport type { AxAIOpenAIResponsesOutputItemDoneEvent };\nexport type { AxAIOpenAIResponsesOutputMessageItem };\nexport type { AxAIOpenAIResponsesOutputRefusalContentPart };\nexport type { AxAIOpenAIResponsesOutputTextAnnotationAddedEvent };\nexport type { AxAIOpenAIResponsesOutputTextContentPart };\nexport type { AxAIOpenAIResponsesOutputTextDeltaEvent };\nexport type { AxAIOpenAIResponsesOutputTextDoneEvent };\nexport type { AxAIOpenAIResponsesReasoningDeltaEvent };\nexport type { AxAIOpenAIResponsesReasoningDoneEvent };\nexport type { AxAIOpenAIResponsesReasoningItem };\nexport type { AxAIOpenAIResponsesReasoningSummaryDeltaEvent };\nexport type { AxAIOpenAIResponsesReasoningSummaryDoneEvent };\nexport type { AxAIOpenAIResponsesReasoningSummaryPart };\nexport type { AxAIOpenAIResponsesReasoningSummaryPartAddedEvent };\nexport type { AxAIOpenAIResponsesReasoningSummaryPartDoneEvent };\nexport type { AxAIOpenAIResponsesReasoningSummaryTextDeltaEvent };\nexport type { AxAIOpenAIResponsesReasoningSummaryTextDoneEvent };\nexport type { AxAIOpenAIResponsesRefusalDeltaEvent };\nexport type { AxAIOpenAIResponsesRefusalDoneEvent };\nexport type { AxAIOpenAIResponsesRequest };\nexport type { AxAIOpenAIResponsesResponse };\nexport type { AxAIOpenAIResponsesResponseCompletedEvent };\nexport type { AxAIOpenAIResponsesResponseCreatedEvent };\nexport type { AxAIOpenAIResponsesResponseDelta };\nexport type { AxAIOpenAIResponsesResponseFailedEvent };\nexport type { AxAIOpenAIResponsesResponseInProgressEvent };\nexport type { AxAIOpenAIResponsesResponseIncompleteEvent };\nexport type { AxAIOpenAIResponsesResponseQueuedEvent };\nexport type { AxAIOpenAIResponsesStreamEvent };\nexport type { AxAIOpenAIResponsesStreamEventBase };\nexport type { AxAIOpenAIResponsesToolCall };\nexport type { AxAIOpenAIResponsesToolCallBase };\nexport type { AxAIOpenAIResponsesToolChoice };\nexport type { AxAIOpenAIResponsesToolDefinition };\nexport type { AxAIOpenAIResponsesWebSearchCallCompletedEvent };\nexport type { AxAIOpenAIResponsesWebSearchCallInProgressEvent };\nexport type { AxAIOpenAIResponsesWebSearchCallSearchingEvent };\nexport type { AxAIOpenAIResponsesWebSearchToolCall };\nexport type { AxAIOpenAIUrlCitation };\nexport type { AxAIOpenAIUsage };\nexport type { AxAIOpenRouterArgs };\nexport type { AxAIRekaArgs };\nexport type { AxAIRekaChatRequest };\nexport type { AxAIRekaChatResponse };\nexport type { AxAIRekaChatResponseDelta };\nexport type { AxAIRekaConfig };\nexport type { AxAIRekaUsage };\nexport type { AxAIService };\nexport type { AxAIServiceActionOptions };\nexport type { AxAIServiceImpl };\nexport type { AxAIServiceMetrics };\nexport type { AxAIServiceModelType };\nexport type { AxAIServiceOptions };\nexport type { AxAITogetherArgs };\nexport type { AxAIWebLLMArgs };\nexport type { AxAIWebLLMChatRequest };\nexport type { AxAIWebLLMChatResponse };\nexport type { AxAIWebLLMChatResponseDelta };\nexport type { AxAIWebLLMConfig };\nexport type { AxAIWebLLMEmbedModel };\nexport type { AxAIWebLLMEmbedRequest };\nexport type { AxAIWebLLMEmbedResponse };\nexport type { AxAPI };\nexport type { AxAPIConfig };\nexport type { AxAgentConfig };\nexport type { AxAgentFeatures };\nexport type { AxAgentOptions };\nexport type { AxAgentic };\nexport type { AxApacheTikaArgs };\nexport type { AxApacheTikaConvertOptions };\nexport type { AxAssertion };\nexport type { AxBalancerOptions };\nexport type { AxBaseAIArgs };\nexport type { AxBootstrapOptimizerOptions };\nexport type { AxChatRequest };\nexport type { AxChatResponse };\nexport type { AxChatResponseFunctionCall };\nexport type { AxChatResponseResult };\nexport type { AxCheckpointLoadFn };\nexport type { AxCheckpointSaveFn };\nexport type { AxCitation };\nexport type { AxCompileOptions };\nexport type { AxContentProcessingServices };\nexport type { AxCostTracker };\nexport type { AxCostTrackerOptions };\nexport type { AxDBArgs };\nexport type { AxDBBaseArgs };\nexport type { AxDBBaseOpOptions };\nexport type { AxDBCloudflareArgs };\nexport type { AxDBCloudflareOpOptions };\nexport type { AxDBLoaderOptions };\nexport type { AxDBManagerArgs };\nexport type { AxDBMatch };\nexport type { AxDBMemoryArgs };\nexport type { AxDBMemoryOpOptions };\nexport type { AxDBPineconeArgs };\nexport type { AxDBPineconeOpOptions };\nexport type { AxDBQueryRequest };\nexport type { AxDBQueryResponse };\nexport type { AxDBQueryService };\nexport type { AxDBService };\nexport type { AxDBState };\nexport type { AxDBUpsertRequest };\nexport type { AxDBUpsertResponse };\nexport type { AxDBWeaviateArgs };\nexport type { AxDBWeaviateOpOptions };\nexport type { AxDataRow };\nexport type { AxDockerContainer };\nexport type { AxEmbedRequest };\nexport type { AxEmbedResponse };\nexport type { AxErrorCategory };\nexport type { AxEvaluateArgs };\nexport type { AxExample };\nexport type { AxExamples };\nexport type { AxField };\nexport type { AxFieldProcessor };\nexport type { AxFieldProcessorProcess };\nexport type { AxFieldTemplateFn };\nexport type { AxFieldType };\nexport type { AxFieldValue };\nexport type { AxFlowAutoParallelConfig };\nexport type { AxFlowBranchContext };\nexport type { AxFlowBranchEvaluationData };\nexport type { AxFlowCompleteData };\nexport type { AxFlowDynamicContext };\nexport type { AxFlowErrorData };\nexport type { AxFlowExecutionStep };\nexport type { AxFlowLogData };\nexport type { AxFlowLoggerData };\nexport type { AxFlowLoggerFunction };\nexport type { AxFlowNodeDefinition };\nexport type { AxFlowParallelBranch };\nexport type { AxFlowParallelGroup };\nexport type { AxFlowParallelGroupCompleteData };\nexport type { AxFlowParallelGroupStartData };\nexport type { AxFlowStartData };\nexport type { AxFlowState };\nexport type { AxFlowStepCompleteData };\nexport type { AxFlowStepFunction };\nexport type { AxFlowStepStartData };\nexport type { AxFlowSubContext };\nexport type { AxFlowTypedParallelBranch };\nexport type { AxFlowTypedSubContext };\nexport type { AxFlowable };\nexport type { AxFluentFieldInfo };\nexport type { AxForwardable };\nexport type { AxFunction };\nexport type { AxFunctionHandler };\nexport type { AxFunctionJSONSchema };\nexport type { AxFunctionResult };\nexport type { AxFunctionResultFormatter };\nexport type { AxGEPAAdapter };\nexport type { AxGEPAEvaluationBatch };\nexport type { AxGenDeltaOut };\nexport type { AxGenIn };\nexport type { AxGenInput };\nexport type { AxGenMetricsInstruments };\nexport type { AxGenOut };\nexport type { AxGenOutput };\nexport type { AxGenStreamingOut };\nexport type { AxGenerateErrorDetails };\nexport type { AxGenerateResult };\nexport type { AxIField };\nexport type { AxInputFunctionType };\nexport type { AxInternalChatRequest };\nexport type { AxInternalEmbedRequest };\nexport type { AxLoggerData };\nexport type { AxLoggerFunction };\nexport type { AxMCPFunctionDescription };\nexport type { AxMCPInitializeParams };\nexport type { AxMCPInitializeResult };\nexport type { AxMCPJSONRPCErrorResponse };\nexport type { AxMCPJSONRPCNotification };\nexport type { AxMCPJSONRPCRequest };\nexport type { AxMCPJSONRPCResponse };\nexport type { AxMCPJSONRPCSuccessResponse };\nexport type { AxMCPOAuthOptions };\nexport type { AxMCPStreamableHTTPTransportOptions };\nexport type { AxMCPToolsListResult };\nexport type { AxMCPTransport };\nexport type { AxMemoryData };\nexport type { AxMessage };\nexport type { AxMetricFn };\nexport type { AxMetricFnArgs };\nexport type { AxMetricsConfig };\nexport type { AxMiPROOptimizerOptions };\nexport type { AxMiPROResult };\nexport type { AxMockAIServiceConfig };\nexport type { AxModelConfig };\nexport type { AxModelInfo };\nexport type { AxModelInfoWithProvider };\nexport type { AxModelUsage };\nexport type { AxMultiMetricFn };\nexport type { AxMultiProviderConfig };\nexport type { AxOptimizationCheckpoint };\nexport type { AxOptimizationProgress };\nexport type { AxOptimizationStats };\nexport type { AxOptimizedProgram };\nexport type { AxOptimizer };\nexport type { AxOptimizerArgs };\nexport type { AxOptimizerLoggerData };\nexport type { AxOptimizerLoggerFunction };\nexport type { AxOptimizerMetricsConfig };\nexport type { AxOptimizerMetricsInstruments };\nexport type { AxOptimizerResult };\nexport type { AxParetoResult };\nexport type { AxProgramDemos };\nexport type { AxProgramExamples };\nexport type { AxProgramForwardOptions };\nexport type { AxProgramForwardOptionsWithModels };\nexport type { AxProgramOptions };\nexport type { AxProgramStreamingForwardOptions };\nexport type { AxProgramStreamingForwardOptionsWithModels };\nexport type { AxProgramTrace };\nexport type { AxProgramUsage };\nexport type { AxProgrammable };\nexport type { AxPromptTemplateOptions };\nexport type { AxRateLimiterFunction };\nexport type { AxRateLimiterTokenUsageOptions };\nexport type { AxRerankerIn };\nexport type { AxRerankerOut };\nexport type { AxResponseHandlerArgs };\nexport type { AxResultPickerFunction };\nexport type { AxResultPickerFunctionFieldResults };\nexport type { AxResultPickerFunctionFunctionResults };\nexport type { AxRewriteIn };\nexport type { AxRewriteOut };\nexport type { AxRoutingResult };\nexport type { AxSamplePickerOptions };\nexport type { AxSetExamplesOptions };\nexport type { AxSignatureConfig };\nexport type { AxSimpleClassifierForwardOptions };\nexport type { AxStreamingAssertion };\nexport type { AxStreamingEvent };\nexport type { AxStreamingFieldProcessorProcess };\nexport type { AxTokenUsage };\nexport type { AxTunable };\nexport type { AxTypedExample };\nexport type { AxUsable };\n","import type { AxAIInputModelList, AxModelInfo } from '../ai/types.js';\n\ninterface GetModelInfoParams<\n  TModel = string,\n  TEmbedModel = undefined,\n  TModelKey = string,\n> {\n  model: TModel;\n  modelInfo: readonly AxModelInfo[];\n  models?: AxAIInputModelList<TModel, TEmbedModel, TModelKey>;\n}\n\nexport function getModelInfo<\n  TModel = string,\n  TEmbedModel = undefined,\n  TModelKey = string,\n>({\n  model,\n  modelInfo,\n  models,\n}: Readonly<\n  GetModelInfoParams<TModel | TModelKey, TEmbedModel, TModelKey>\n>): Readonly<AxModelInfo> | null {\n  // First check if there's a mapping for this model\n  const modelEntry = models?.find((v) => v.key === model);\n  const mappedModel =\n    modelEntry && 'model' in modelEntry\n      ? (modelEntry.model as string)\n      : (model as string);\n\n  // Try exact match first\n  const exactMatch = modelInfo.find((v) => v.name === model);\n  if (exactMatch) return exactMatch;\n\n  // Handle normalization if no exact match\n  const normalizedName = mappedModel\n    // Remove vendor prefixes\n    .replace(/^(anthropic\\.|openai\\.)/, '')\n    // Remove various postfixes one by one, stopping after first match\n    .replace(/-latest$/, '')\n    .replace(/-\\d{8}$/, '') // YYYYMMDD\n    .replace(/-v\\d+:\\d+$/, '') // v2:0\n    .replace(/@\\d{8}$/, '') // @YYYYMMDD\n    .replace(/-\\d{2,}(-[a-zA-Z0-9-]+)?$/, '') // XX or XXXXX-something\n    .replace(/-v\\d+@\\d{8}$/, '') // vX@YYYYMMDD\n    .replace(/-v\\d+$/, ''); // Remove standalone version number\n\n  // Try to find a match with the normalized name\n  const normalizedMatch = modelInfo.find((v) => v.name === normalizedName);\n  if (normalizedMatch) return normalizedMatch;\n\n  // Return default if no match found\n  return null;\n}\n","/**\n * Cross-platform crypto utilities that work in both Node.js and browser environments\n * using Web Crypto API standards\n */\n\n// Web Crypto API is available in both modern Node.js (16+) and browsers via globalThis.crypto\nconst webCrypto = (() => {\n  if (globalThis.crypto && typeof globalThis.crypto.randomUUID === 'function') {\n    return globalThis.crypto;\n  }\n\n  throw new Error(\n    'Web Crypto API with randomUUID support not available. Requires Node.js 16+ or modern browser.'\n  );\n})();\n\n/**\n * Generate a random UUID using Web Crypto API\n * @returns A random UUID string\n */\nexport function randomUUID(): string {\n  return webCrypto.randomUUID();\n}\n\n/**\n * Create a SHA-256 hash of the input data\n * @param data - The data to hash (string or ArrayBuffer)\n * @returns A promise that resolves to the hex-encoded hash\n */\nexport async function sha256(data: string | ArrayBuffer): Promise<string> {\n  const encoder = new TextEncoder();\n  const inputData = typeof data === 'string' ? encoder.encode(data) : data;\n\n  const hashBuffer = await webCrypto.subtle.digest('SHA-256', inputData);\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  const hashHex = hashArray\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('');\n\n  return hashHex;\n}\n\n/**\n * Create a hash instance that can be updated incrementally (similar to Node.js createHash)\n * Note: This is a synchronous wrapper around async Web Crypto API - uses simplified hash for compatibility\n */\nexport class Hash {\n  private data = '';\n\n  update(chunk: string): this {\n    this.data += chunk;\n    return this;\n  }\n\n  digest(encoding: 'hex'): string {\n    if (encoding !== 'hex') {\n      throw new Error('Only hex encoding is supported');\n    }\n\n    // For browser compatibility, we use a simple hash function\n    // This maintains API compatibility but is not cryptographically secure\n    const encoder = new TextEncoder();\n    const inputData = encoder.encode(this.data);\n\n    let hash = 0;\n    for (let i = 0; i < inputData.length; i++) {\n      const char = inputData[i]!;\n      hash = (hash << 5) - hash + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n\n    // Convert to hex string\n    return Math.abs(hash).toString(16).padStart(8, '0');\n  }\n\n  async digestAsync(): Promise<string> {\n    return sha256(this.data);\n  }\n}\n\n/**\n * Create a hash instance (compatibility function)\n * @param algorithm - The hash algorithm (only 'sha256' supported)\n * @returns A Hash instance\n */\nexport function createHash(algorithm: string): Hash {\n  if (algorithm !== 'sha256') {\n    throw new Error('Only SHA-256 algorithm is supported');\n  }\n  return new Hash();\n}\n\n/**\n * Get the crypto object for use in JavaScript interpreter contexts\n * @returns The Web Crypto API object\n */\nexport function getCrypto() {\n  return webCrypto;\n}\n","// Web Streams API types are now available globally via DOM types in tsconfig\n\ninterface CurrentEventState {\n  event?: string;\n  rawData: string;\n  id?: string;\n  retry?: number;\n}\n\ninterface SSEParserOptions<T> {\n  dataParser?: (data: string) => T;\n  onError?: (error: Error, rawData: string) => void;\n}\n\nexport class SSEParser<T = unknown> extends TransformStream<string, T> {\n  private buffer = '';\n  private currentEvent: CurrentEventState = { rawData: '' };\n  private dataParser: (data: string) => T;\n  private onError: (error: Error, rawData: string) => void;\n\n  constructor(options: SSEParserOptions<T> = {}) {\n    super({\n      transform: (chunk, controller) => this.handleChunk(chunk, controller),\n      flush: (controller) => this.handleFlush(controller),\n    });\n\n    this.dataParser = options.dataParser || JSON.parse;\n    this.onError =\n      options.onError ||\n      ((error, rawData) => {\n        console.warn('Failed to parse event data:', error);\n        console.log('Raw data that failed to parse:', rawData);\n      });\n  }\n\n  private handleChunk(\n    chunk: string,\n    controller: TransformStreamDefaultController<T>\n  ): void {\n    this.buffer += chunk;\n    this.processBuffer(controller);\n  }\n\n  private handleFlush(controller: TransformStreamDefaultController<T>): void {\n    this.processBuffer(controller);\n    if (this.currentEvent.rawData) {\n      this.processEvent(controller);\n    }\n  }\n\n  private processBuffer(controller: TransformStreamDefaultController<T>): void {\n    // Normalize newlines to \\n\n    const normalizedBuffer = this.buffer.replace(/\\r\\n|\\r/g, '\\n');\n    const lines = normalizedBuffer.split('\\n');\n    this.buffer = lines.pop() || '';\n\n    for (const line of lines) {\n      if (line === '') {\n        this.processEvent(controller);\n      } else {\n        this.parseLine(line);\n      }\n    }\n  }\n\n  private parseLine(line: string): void {\n    if (line.startsWith(':')) {\n      return; // Ignore comment lines\n    }\n\n    const colonIndex = line.indexOf(':');\n    if (colonIndex === -1) {\n      this.currentEvent.rawData +=\n        (this.currentEvent.rawData && !this.currentEvent.rawData.endsWith('\\n')\n          ? '\\n'\n          : '') + line.trim();\n      return;\n    }\n\n    const field = line.slice(0, colonIndex).trim();\n    const value = line.slice(colonIndex + 1).trim();\n\n    switch (field) {\n      case 'event':\n        this.currentEvent.event = value;\n        break;\n      case 'data':\n        this.currentEvent.rawData +=\n          (this.currentEvent.rawData &&\n          !this.currentEvent.rawData.endsWith('\\n')\n            ? '\\n'\n            : '') + value;\n        break;\n      case 'id':\n        this.currentEvent.id = value;\n        break;\n      case 'retry': {\n        const retryValue = Number.parseInt(value, 10);\n        if (!Number.isNaN(retryValue)) {\n          this.currentEvent.retry = retryValue;\n        }\n        break;\n      }\n    }\n  }\n\n  private processEvent(controller: TransformStreamDefaultController<T>): void {\n    if (this.currentEvent.rawData) {\n      if (!this.currentEvent.event) {\n        this.currentEvent.event = 'message';\n      }\n\n      if (this.currentEvent.rawData.trim() === '[DONE]') {\n        // maybe we want to emit [DONE] to signal the end of the stream\n        // controller.enqueue('[DONE]' as any)\n        // Reset the current event\n        this.currentEvent = { rawData: '' };\n        return;\n      }\n\n      try {\n        const parsedData: T = this.dataParser(this.currentEvent.rawData);\n        controller.enqueue(parsedData);\n      } catch (e) {\n        this.onError(e as Error, this.currentEvent.rawData);\n      }\n\n      this.currentEvent = { rawData: '' };\n    }\n  }\n}\n","// Web Streams API types are now available globally via DOM types in tsconfig\n\nexport interface TextDecoderCommon {\n  readonly encoding: string;\n  readonly fatal: boolean;\n  readonly ignoreBOM: boolean;\n}\n\nclass TextDecodeTransformer\n  implements Transformer<ArrayBuffer | Uint8Array, string>\n{\n  private decoder;\n\n  constructor() {\n    this.decoder = new TextDecoder();\n  }\n\n  transform(\n    chunk: ArrayBuffer | Uint8Array,\n    controller: TransformStreamDefaultController<string>\n  ) {\n    if (!(chunk instanceof ArrayBuffer || ArrayBuffer.isView(chunk))) {\n      throw new TypeError('Input data must be a BufferSource');\n    }\n    const text = this.decoder.decode(chunk, { stream: true });\n    if (text.length !== 0) {\n      controller.enqueue(text);\n    }\n  }\n\n  flush(controller: TransformStreamDefaultController<string>) {\n    const text = this.decoder.decode();\n    if (text.length !== 0) {\n      controller.enqueue(text);\n    }\n  }\n}\n\nexport class TextDecoderStreamPolyfill extends TransformStream<\n  ArrayBuffer | Uint8Array,\n  string\n> {\n  constructor() {\n    super(new TextDecodeTransformer());\n  }\n}\n","// Web Streams API types are now available globally via DOM types in tsconfig\nimport type { Span } from '@opentelemetry/api';\nimport { randomUUID } from './crypto.js';\n\nimport { SSEParser } from './sse.js';\nimport { TextDecoderStreamPolyfill } from './stream.js';\n\n// Configuration Types\nexport interface RetryConfig {\n  maxRetries: number;\n  initialDelayMs: number;\n  maxDelayMs: number;\n  backoffFactor: number;\n  retryableStatusCodes: number[];\n}\n\nexport interface RequestMetrics {\n  startTime: number;\n  retryCount: number;\n  lastRetryTime?: number;\n  streamChunks?: number;\n  lastChunkTime?: number;\n  streamDuration?: number;\n  errorTime?: number;\n}\n\n// Validation Interfaces\ninterface RequestValidation {\n  validateRequest?: (request: unknown) => boolean | Promise<boolean>;\n}\n\ninterface ResponseValidation {\n  validateResponse?: (response: unknown) => boolean | Promise<boolean>;\n}\n\n// API Base Types\nexport interface AxAPI {\n  name?: string;\n  headers?: Record<string, string>;\n  put?: boolean;\n  localCall?: <TRequest, TResponse>(\n    data: TRequest,\n    stream?: boolean\n  ) => Promise<TResponse | ReadableStream<TResponse>>;\n}\n\n// Enhanced API Configuration\nexport interface AxAPIConfig\n  extends AxAPI,\n    RequestValidation,\n    ResponseValidation {\n  url?: string | URL; // Make URL optional when localCall is provided\n  stream?: boolean;\n  debug?: boolean;\n  fetch?: typeof fetch;\n  span?: Span;\n  timeout?: number;\n  retry?: Partial<RetryConfig>;\n  abortSignal?: AbortSignal;\n  corsProxy?: string;\n}\n\n// Default Configurations\nexport const defaultRetryConfig: RetryConfig = {\n  maxRetries: 3,\n  initialDelayMs: 1000,\n  maxDelayMs: 60000,\n  backoffFactor: 2,\n  retryableStatusCodes: [500, 408, 429, 502, 503, 504],\n};\n\nconst textDecoderStream =\n  (globalThis as any).TextDecoderStream ?? TextDecoderStreamPolyfill;\n\n// Error Classes\nexport class AxAIServiceError extends Error {\n  public readonly timestamp: string;\n  public readonly errorId: string;\n  public readonly context: Record<string, unknown>;\n\n  constructor(\n    message: string,\n    public readonly url: string,\n    public readonly requestBody: unknown,\n    public readonly responseBody: unknown,\n    context: Record<string, unknown> = {}\n  ) {\n    super(message);\n    this.name = this.constructor.name;\n    this.timestamp = new Date().toISOString();\n    this.errorId = randomUUID();\n    this.context = context;\n\n    this.stack = this.toString();\n  }\n\n  override toString(): string {\n    return [\n      `${this.name}: ${this.message}`,\n      `URL: ${this.url}`,\n      `Request Body: ${JSON.stringify(this.requestBody, null, 2)}`,\n      `Response Body: ${JSON.stringify(this.responseBody, null, 2)}`,\n      `Context: ${JSON.stringify(this.context, null, 2)}`,\n      `Timestamp: ${this.timestamp}`,\n      `Error ID: ${this.errorId}`,\n    ].join('\\n');\n  }\n\n  // For Node.js, override the custom inspect method so console.log shows our custom string.\n  [Symbol.for('nodejs.util.inspect.custom')](\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _depth: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options: Record<string, unknown>\n  ) {\n    return this.toString();\n  }\n}\n\nexport class AxAIServiceStatusError extends AxAIServiceError {\n  constructor(\n    public readonly status: number,\n    public readonly statusText: string,\n    url: string,\n    requestBody: unknown,\n    responseBody: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super(`HTTP ${status} - ${statusText}`, url, requestBody, {\n      httpStatus: status,\n      httpStatusText: statusText,\n      responseBody,\n      ...context,\n    });\n    this.name = this.constructor.name;\n  }\n}\n\nexport class AxAIServiceNetworkError extends AxAIServiceError {\n  constructor(\n    public readonly originalError: Error,\n    url: string,\n    requestBody: unknown,\n    responseBody: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super(\n      `Network Error: ${originalError.message}`,\n      url,\n      requestBody,\n      responseBody,\n      {\n        originalErrorName: originalError.name,\n        originalErrorStack: originalError.stack,\n        ...context,\n      }\n    );\n    this.name = this.constructor.name;\n    this.stack = originalError.stack;\n  }\n}\n\nexport class AxAIServiceResponseError extends AxAIServiceError {\n  constructor(\n    message: string,\n    url: string,\n    requestBody?: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super(message, url, requestBody, undefined, context);\n    this.name = this.constructor.name;\n  }\n}\n\nexport class AxAIServiceStreamTerminatedError extends AxAIServiceError {\n  constructor(\n    url: string,\n    requestBody?: unknown,\n    public readonly lastChunk?: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super(\n      'Stream terminated unexpectedly by remote host',\n      url,\n      requestBody,\n      undefined,\n      {\n        lastChunk,\n        ...context,\n      }\n    );\n    this.name = this.constructor.name;\n  }\n}\n\nexport class AxAIServiceTimeoutError extends AxAIServiceError {\n  constructor(\n    url: string,\n    timeoutMs: number,\n    requestBody?: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super(\n      `Request timed out after ${timeoutMs}ms`,\n      url,\n      requestBody,\n      undefined,\n      { timeoutMs, ...context }\n    );\n    this.name = this.constructor.name;\n  }\n}\n\nexport class AxAIServiceAbortedError extends AxAIServiceError {\n  constructor(\n    url: string,\n    reason?: string,\n    requestBody?: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super(\n      `Request aborted${reason ? `: ${reason}` : ''}`,\n      url,\n      requestBody,\n      undefined,\n      { abortReason: reason, ...context }\n    );\n    this.name = this.constructor.name;\n  }\n}\n\nexport class AxAIServiceAuthenticationError extends AxAIServiceError {\n  constructor(\n    url: string,\n    requestBody: unknown,\n    responseBody: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super('Authentication failed', url, requestBody, responseBody, context);\n    this.name = this.constructor.name;\n  }\n}\n\nexport class AxAIRefusalError extends Error {\n  public readonly timestamp: string;\n  public readonly errorId: string;\n\n  constructor(\n    public readonly refusalMessage: string,\n    public readonly model?: string,\n    public readonly requestId?: string\n  ) {\n    super(`Model refused to fulfill request: ${refusalMessage}`);\n    this.name = 'AxAIRefusalError';\n    this.timestamp = new Date().toISOString();\n    this.errorId = randomUUID();\n  }\n\n  override toString(): string {\n    return [\n      `${this.name}: ${this.message}`,\n      `Refusal: ${this.refusalMessage}`,\n      this.model ? `Model: ${this.model}` : '',\n      this.requestId ? `Request ID: ${this.requestId}` : '',\n      `Timestamp: ${this.timestamp}`,\n      `Error ID: ${this.errorId}`,\n    ]\n      .filter(Boolean)\n      .join('\\n');\n  }\n\n  // For Node.js, override the custom inspect method so console.log shows our custom string.\n  [Symbol.for('nodejs.util.inspect.custom')](\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _depth: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options: Record<string, unknown>\n  ) {\n    return this.toString();\n  }\n}\n\n/**\n * Error thrown when an AI provider doesn't support a required media type.\n *\n * This error is thrown during content processing when a provider cannot handle\n * a specific media type and no suitable fallback mechanism is available or configured.\n *\n * @example\n * ```typescript\n * try {\n *   await textOnlyProvider.chat(imageRequest);\n * } catch (error) {\n *   if (error instanceof AxMediaNotSupportedError) {\n *     console.log(`${error.mediaType} not supported by ${error.provider}`);\n *     if (error.fallbackAvailable) {\n *       console.log('Consider using content processing services');\n *     }\n *   }\n * }\n * ```\n */\nexport class AxMediaNotSupportedError extends Error {\n  /** ISO timestamp when the error occurred */\n  public readonly timestamp: string;\n  /** Unique identifier for this error instance */\n  public readonly errorId: string;\n\n  /**\n   * Creates a new media not supported error.\n   *\n   * @param mediaType - The type of media that is not supported (e.g., 'Images', 'Audio')\n   * @param provider - The name of the AI provider that doesn't support the media type\n   * @param fallbackAvailable - Whether fallback processing options are available\n   */\n  constructor(\n    public readonly mediaType: string,\n    public readonly provider: string,\n    public readonly fallbackAvailable: boolean = false\n  ) {\n    super(\n      `${mediaType} not supported by ${provider}${fallbackAvailable ? ' (fallback available)' : ''}`\n    );\n    this.name = 'AxMediaNotSupportedError';\n    this.timestamp = new Date().toISOString();\n    this.errorId = randomUUID();\n  }\n\n  override toString(): string {\n    return [\n      `${this.name}: ${this.message}`,\n      `Media Type: ${this.mediaType}`,\n      `Provider: ${this.provider}`,\n      `Fallback Available: ${this.fallbackAvailable}`,\n      `Timestamp: ${this.timestamp}`,\n      `Error ID: ${this.errorId}`,\n    ].join('\\n');\n  }\n\n  // For Node.js, override the custom inspect method so console.log shows our custom string.\n  [Symbol.for('nodejs.util.inspect.custom')](\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _depth: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options: Record<string, unknown>\n  ) {\n    return this.toString();\n  }\n}\n\n/**\n * Error thrown when content processing/transformation fails.\n *\n * This error wraps underlying failures from content processing services like\n * image-to-text, audio transcription, file text extraction, or URL content fetching.\n * It provides context about what type of content was being processed and at which step.\n *\n * @example\n * ```typescript\n * try {\n *   await axProcessContentForProvider(content, provider, {\n *     imageToText: imageService.analyze\n *   });\n * } catch (error) {\n *   if (error instanceof AxContentProcessingError) {\n *     console.log(`Failed processing ${error.contentType} during ${error.processingStep}`);\n *     console.log('Original error:', error.originalError.message);\n *   }\n * }\n * ```\n */\nexport class AxContentProcessingError extends Error {\n  /** ISO timestamp when the error occurred */\n  public readonly timestamp: string;\n  /** Unique identifier for this error instance */\n  public readonly errorId: string;\n\n  /**\n   * Creates a new content processing error.\n   *\n   * @param originalError - The underlying error that caused the processing failure\n   * @param contentType - The type of content being processed (e.g., 'image', 'audio', 'file')\n   * @param processingStep - The specific processing step that failed (e.g., 'vision analysis', 'transcription')\n   */\n  constructor(\n    public readonly originalError: Error,\n    public readonly contentType: string,\n    public readonly processingStep: string\n  ) {\n    super(\n      `Failed to process ${contentType} during ${processingStep}: ${originalError.message}`\n    );\n    this.name = 'AxContentProcessingError';\n    this.timestamp = new Date().toISOString();\n    this.errorId = randomUUID();\n  }\n\n  override toString(): string {\n    return [\n      `${this.name}: ${this.message}`,\n      `Content Type: ${this.contentType}`,\n      `Processing Step: ${this.processingStep}`,\n      `Original Error: ${this.originalError.message}`,\n      `Timestamp: ${this.timestamp}`,\n      `Error ID: ${this.errorId}`,\n    ].join('\\n');\n  }\n\n  // For Node.js, override the custom inspect method so console.log shows our custom string.\n  [Symbol.for('nodejs.util.inspect.custom')](\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _depth: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options: Record<string, unknown>\n  ) {\n    return this.toString();\n  }\n}\n\n// Utility Functions\nasync function safeReadResponseBody(response: Response): Promise<unknown> {\n  try {\n    if (response.headers.get('content-type')?.includes('application/json')) {\n      return await response.json();\n    }\n\n    // Clone the response so we can read it without consuming the original\n    const clonedResponse = response.clone();\n    return await clonedResponse.text();\n  } catch (e) {\n    // If we can't read the body, return a descriptive message\n    return `[ReadableStream - read failed: ${(e as Error).message}]`;\n  }\n}\n\nfunction calculateRetryDelay(\n  attempt: number,\n  config: Readonly<RetryConfig>\n): number {\n  const delay = Math.min(\n    config.maxDelayMs,\n    config.initialDelayMs * config.backoffFactor ** attempt\n  );\n  return delay * (0.75 + Math.random() * 0.5);\n}\n\nfunction createRequestMetrics(): RequestMetrics {\n  return {\n    startTime: Date.now(),\n    retryCount: 0,\n  };\n}\n\n// eslint-disable-next-line functional/prefer-immutable-types\nfunction updateRetryMetrics(metrics: RequestMetrics): void {\n  metrics.retryCount++;\n  metrics.lastRetryTime = Date.now();\n}\n\nfunction shouldRetry(\n  error: Error,\n  status: number | undefined,\n  attempt: number,\n  config: Readonly<RetryConfig>\n): boolean {\n  if (attempt >= config.maxRetries) return false;\n  if (status && config.retryableStatusCodes.includes(status)) return true;\n\n  return (\n    error instanceof AxAIServiceNetworkError &&\n    !(error instanceof AxAIServiceAuthenticationError)\n  );\n}\n\n// Enhanced API Call Function\nexport const apiCall = async <TRequest = unknown, TResponse = unknown>(\n  api: Readonly<AxAPIConfig>,\n  json: TRequest\n): Promise<TResponse | ReadableStream<TResponse>> => {\n  // If localCall is provided, use it instead of HTTP\n  if (api.localCall) {\n    return await api.localCall<TRequest, TResponse>(json, api.stream);\n  }\n\n  // Ensure URL is provided for HTTP calls\n  if (!api.url) {\n    throw new Error('API URL is required when localCall is not provided');\n  }\n\n  const retryConfig: RetryConfig = { ...defaultRetryConfig, ...api.retry };\n  const timeoutMs = api.timeout;\n  const metrics = createRequestMetrics();\n  let timeoutId: NodeJS.Timeout | undefined;\n\n  const baseUrl = new URL(api.url);\n  const apiPath = `${[baseUrl.pathname, api.name]\n    .filter(Boolean)\n    .join('/')\n    .replace(/\\/+/g, '/')}${baseUrl.search}`;\n  let apiUrl = new URL(apiPath, baseUrl);\n\n  // Apply CORS proxy if provided (for browser environments)\n  if (api.corsProxy) {\n    const originalUrl = apiUrl.href;\n    apiUrl = new URL(`${api.corsProxy}?url=${encodeURIComponent(originalUrl)}`);\n  }\n\n  const requestId = randomUUID();\n\n  // Validate request if validator is provided\n  if (api.validateRequest) {\n    const isValid = await api.validateRequest(json);\n    if (!isValid) {\n      throw new AxAIServiceResponseError(\n        'Invalid request data',\n        apiUrl.href,\n        json,\n        { validation: 'request' }\n      );\n    }\n  }\n\n  // Set up telemetry\n  api.span?.setAttributes({\n    'http.request.method': api.put ? 'PUT' : 'POST',\n    'url.full': apiUrl.href,\n    'request.id': requestId,\n    'request.startTime': metrics.startTime,\n  });\n\n  let attempt = 0;\n\n  while (true) {\n    // Combine user abort signal with timeout signal\n    const combinedAbortController = new AbortController();\n\n    // Handle user abort signal\n    if (api.abortSignal) {\n      if (api.abortSignal.aborted) {\n        throw new AxAIServiceAbortedError(\n          apiUrl.href,\n          api.abortSignal.reason,\n          json,\n          { metrics }\n        );\n      }\n\n      const userAbortHandler = () => {\n        combinedAbortController.abort(\n          api.abortSignal!.reason || 'User aborted request'\n        );\n      };\n      api.abortSignal.addEventListener('abort', userAbortHandler, {\n        once: true,\n      });\n\n      // Clean up listener if we complete before abort\n      const originalAbort = combinedAbortController.abort.bind(\n        combinedAbortController\n      );\n      combinedAbortController.abort = (reason?: string) => {\n        api.abortSignal!.removeEventListener('abort', userAbortHandler);\n        originalAbort(reason);\n      };\n    }\n\n    if (timeoutMs) {\n      timeoutId = setTimeout(() => {\n        combinedAbortController.abort('Request timeout');\n      }, timeoutMs);\n    }\n\n    try {\n      // Set up timeout with proper cleanup\n\n      const res = await (api.fetch ?? fetch)(apiUrl, {\n        method: api.put ? 'PUT' : 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Request-ID': requestId,\n          'X-Retry-Count': attempt.toString(),\n          ...api.headers,\n        },\n        body: JSON.stringify(json),\n        signal: combinedAbortController.signal,\n      });\n\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n\n      // Handle authentication errors\n      if (res.status === 401 || res.status === 403) {\n        const responseBody = await safeReadResponseBody(res);\n        throw new AxAIServiceAuthenticationError(\n          apiUrl.href,\n          json,\n          responseBody,\n          {\n            metrics,\n          }\n        );\n      }\n\n      // Handle retryable status codes\n      if (\n        res.status >= 400 &&\n        shouldRetry(new Error(), res.status, attempt, retryConfig)\n      ) {\n        const delay = calculateRetryDelay(attempt, retryConfig);\n        attempt++;\n        updateRetryMetrics(metrics);\n\n        api.span?.addEvent('retry', {\n          attempt,\n          delay,\n          status: res.status,\n          'metrics.startTime': metrics.startTime,\n          'metrics.retryCount': metrics.retryCount,\n          'metrics.lastRetryTime': metrics.lastRetryTime,\n        });\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n        continue;\n      }\n\n      if (res.status >= 400) {\n        const responseBody = await safeReadResponseBody(res);\n        throw new AxAIServiceStatusError(\n          res.status,\n          res.statusText,\n          apiUrl.href,\n          json,\n          responseBody,\n          { metrics }\n        );\n      }\n\n      // Handle non-streaming response\n      if (!api.stream) {\n        const resJson = await res.json();\n\n        // Validate response if validator is provided\n        if (api.validateResponse) {\n          const isValid = await api.validateResponse(resJson);\n          if (!isValid) {\n            throw new AxAIServiceResponseError(\n              'Invalid response data',\n              apiUrl.href,\n              json,\n              { validation: 'response' }\n            );\n          }\n        }\n\n        api.span?.setAttributes({\n          'response.time': Date.now() - metrics.startTime,\n          'response.retries': metrics.retryCount,\n        });\n\n        return resJson as TResponse;\n      }\n\n      // Handle streaming response\n      if (!res.body) {\n        throw new AxAIServiceResponseError(\n          'Response body is null',\n          apiUrl.href,\n          json,\n          { metrics }\n        );\n      }\n\n      let lastChunk: TResponse | undefined;\n      let chunkCount = 0;\n\n      // Detect if we're in a browser environment with EventSource support\n      const isBrowser =\n        typeof window !== 'undefined' && typeof EventSource !== 'undefined';\n\n      if (isBrowser) {\n        // Use browser-optimized SSE parsing that mimics EventSource behavior\n        // We can't use EventSource directly because:\n        // 1. It only supports GET requests (we need POST for LLM APIs)\n        // 2. It doesn't support custom headers (needed for auth)\n        // 3. It doesn't support request bodies (needed for prompts/config)\n        return new ReadableStream<TResponse>({\n          start(controller) {\n            const reader = res.body!.getReader();\n            const decoder = new TextDecoder();\n            let buffer = '';\n\n            async function read() {\n              try {\n                while (true) {\n                  const { done, value } = await reader.read();\n                  if (done) {\n                    closed = true;\n                    controller.close();\n                    break;\n                  }\n\n                  buffer += decoder.decode(value, { stream: true });\n\n                  // Parse SSE format: split by double newlines for events\n                  const events = buffer.split('\\n\\n');\n                  buffer = events.pop() || ''; // Keep incomplete event in buffer\n\n                  for (const event of events) {\n                    if (!event.trim()) continue;\n\n                    const lines = event.split('\\n');\n                    let data = '';\n                    let eventType = 'message';\n\n                    // Parse SSE event fields\n                    for (const line of lines) {\n                      if (line.startsWith('data: ')) {\n                        data = line.slice(6);\n                      } else if (line.startsWith('event: ')) {\n                        eventType = line.slice(7);\n                      }\n                      // We could also handle 'id:', 'retry:', etc. if needed\n                    }\n\n                    if (data) {\n                      // Handle termination signal\n                      if (data === '[DONE]') {\n                        controller.close();\n                        return;\n                      }\n\n                      try {\n                        const parsed = JSON.parse(data) as TResponse;\n                        lastChunk = parsed;\n                        chunkCount++;\n                        metrics.streamChunks = chunkCount;\n                        metrics.lastChunkTime = Date.now();\n\n                        controller.enqueue(parsed);\n\n                        api.span?.addEvent('stream.chunk', {\n                          'stream.chunks': chunkCount,\n                          'stream.duration': Date.now() - metrics.startTime,\n                          'response.retries': metrics.retryCount,\n                          'sse.event.type': eventType,\n                        });\n                      } catch (parseError) {\n                        // Skip invalid JSON chunks - this is normal for SSE\n                        if (api.debug) {\n                          console.warn(\n                            'Skipping non-JSON SSE data:',\n                            data,\n                            parseError\n                          );\n                        }\n                      }\n                    }\n                  }\n                }\n              } catch (e) {\n                const error = e as Error;\n                const streamMetrics = {\n                  ...metrics,\n                  streamDuration: Date.now() - metrics.startTime,\n                };\n\n                if (\n                  error.name === 'AbortError' ||\n                  error.message?.includes('aborted')\n                ) {\n                  controller.error(\n                    new AxAIServiceStreamTerminatedError(\n                      apiUrl.href,\n                      json,\n                      lastChunk,\n                      { streamMetrics }\n                    )\n                  );\n                } else {\n                  controller.error(\n                    new AxAIServiceNetworkError(\n                      error,\n                      apiUrl.href,\n                      json,\n                      '[ReadableStream - consumed during streaming]',\n                      {\n                        streamMetrics,\n                      }\n                    )\n                  );\n                }\n              } finally {\n                reader.releaseLock();\n              }\n            }\n\n            read();\n          },\n        });\n      }\n      // Use the existing Node.js SSEParser for server-side environments\n      const trackingStream = new TransformStream<TResponse, TResponse>({\n        transform(chunk, controller) {\n          lastChunk = chunk;\n          chunkCount++;\n          metrics.streamChunks = chunkCount;\n          metrics.lastChunkTime = Date.now();\n\n          controller.enqueue(chunk);\n\n          api.span?.addEvent('stream.chunk', {\n            'stream.chunks': chunkCount,\n            'stream.duration': Date.now() - metrics.startTime,\n            'response.retries': metrics.retryCount,\n          });\n        },\n      });\n\n      // Flag to track if the controller is closed.\n      let closed = false;\n\n      // Enhanced wrapped stream\n      return new ReadableStream<TResponse>({\n        start(controller) {\n          const reader = res\n            .body!.pipeThrough(new textDecoderStream())\n            .pipeThrough(new SSEParser<TResponse>())\n            .pipeThrough(trackingStream)\n            .getReader();\n\n          async function read() {\n            try {\n              while (true) {\n                const { done, value } = await reader.read();\n                if (done) {\n                  if (!closed) {\n                    closed = true;\n                    controller.close();\n                  }\n                  break;\n                }\n\n                // Check if the controller is already closed before enqueuing.\n                if (closed) break;\n                controller.enqueue(value);\n              }\n            } catch (e) {\n              const error = e as Error;\n              const streamMetrics = {\n                ...metrics,\n                streamDuration: Date.now() - metrics.startTime,\n              };\n\n              if (\n                error.name === 'AbortError' ||\n                error.message?.includes('aborted')\n              ) {\n                controller.error(\n                  new AxAIServiceStreamTerminatedError(\n                    apiUrl.href,\n                    json,\n                    lastChunk,\n                    { streamMetrics }\n                  )\n                );\n              } else if (\n                error instanceof TypeError &&\n                error.message.includes('cancelled')\n              ) {\n                controller.error(\n                  new AxAIServiceStreamTerminatedError(\n                    apiUrl.href,\n                    json,\n                    lastChunk,\n                    {\n                      streamMetrics,\n                      cancelReason: 'Stream cancelled by client',\n                    }\n                  )\n                );\n              } else {\n                controller.error(\n                  new AxAIServiceNetworkError(\n                    error,\n                    apiUrl.href,\n                    json,\n                    '[ReadableStream - consumed during streaming]',\n                    {\n                      streamMetrics,\n                    }\n                  )\n                );\n              }\n              throw error;\n            } finally {\n              if (timeoutId) {\n                clearTimeout(timeoutId);\n              }\n              reader.releaseLock();\n            }\n          }\n\n          read();\n        },\n        // When the consumer cancels the stream, set our flag to stop processing further.\n        cancel() {\n          closed = true;\n        },\n      });\n    } catch (error) {\n      if (error instanceof Error && error.name === 'AbortError') {\n        // Check if this was a user abort or timeout\n        if (api.abortSignal?.aborted) {\n          throw new AxAIServiceAbortedError(\n            apiUrl.href,\n            api.abortSignal.reason,\n            json,\n            { metrics }\n          );\n        }\n        throw new AxAIServiceTimeoutError(apiUrl.href, timeoutMs || 0, json, {\n          metrics,\n        });\n      }\n\n      if (api.span?.isRecording()) {\n        api.span.recordException(error as Error);\n        api.span.setAttributes({\n          'error.time': Date.now() - metrics.startTime,\n          'error.retries': metrics.retryCount,\n        });\n      }\n\n      // Handle retryable network errors\n      if (\n        error instanceof AxAIServiceNetworkError &&\n        shouldRetry(error, undefined, attempt, retryConfig)\n      ) {\n        const delay = calculateRetryDelay(attempt, retryConfig);\n        attempt++;\n        updateRetryMetrics(metrics);\n\n        api.span?.addEvent('retry', {\n          attempt,\n          delay,\n          error: error.message,\n          'metrics.startTime': metrics.startTime,\n          'metrics.retryCount': metrics.retryCount,\n          'metrics.lastRetryTime': metrics.lastRetryTime,\n        });\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n        continue;\n      }\n\n      if (error instanceof AxAIServiceError) {\n        error.context.metrics = metrics;\n      }\n\n      throw error;\n    } finally {\n      if (timeoutId !== undefined) {\n        clearTimeout(timeoutId);\n      }\n    }\n  }\n};\n\nexport function createApiConfig(\n  config: Readonly<Partial<AxAPIConfig>>\n): AxAPIConfig {\n  return {\n    retry: defaultRetryConfig,\n    ...config,\n    url: config.url!, // URL is required\n  };\n}\n","import { context, type Span, SpanKind } from '@opentelemetry/api';\nimport { axGlobals } from '../dsp/globals.js';\nimport { defaultLogger } from '../dsp/loggers.js';\nimport type { AxMessage } from '../dsp/types.js';\nimport { axSpanAttributes, axSpanEvents } from '../trace/trace.js';\nimport { apiCall } from '../util/apicall.js';\nimport { randomUUID } from '../util/crypto.js';\nimport { RespTransformStream } from '../util/transform.js';\nimport {\n  logChatRequest,\n  logEmbedRequest,\n  logEmbedResponse,\n  logResponse,\n  logResponseStreamingDoneResult,\n  logResponseStreamingResult,\n} from './debug.js';\nimport {\n  type AxAIMetricsInstruments,\n  getOrCreateAIMetricsInstruments,\n  recordAbortMetric,\n  recordContextWindowUsageMetric,\n  recordErrorMetric,\n  recordErrorRateMetric,\n  recordEstimatedCostMetric,\n  recordFunctionCallMetric,\n  recordLatencyMetric,\n  recordLatencyStatsMetrics,\n  recordModelConfigMetrics,\n  recordMultimodalRequestMetric,\n  recordPromptLengthMetric,\n  recordRequestMetric,\n  recordRequestSizeMetric,\n  recordResponseSizeMetric,\n  recordStreamingRequestMetric,\n  recordThinkingBudgetUsageMetric,\n  recordTimeoutMetric,\n  recordTokenMetric,\n} from './metrics.js';\nimport type {\n  AxAIInputModelList,\n  AxAIService,\n  AxAIServiceImpl,\n  AxAIServiceMetrics,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxEmbedRequest,\n  AxEmbedResponse,\n  AxLoggerFunction,\n  AxModelConfig,\n  AxModelInfo,\n  AxModelUsage,\n} from './types.js';\nimport { axValidateChatRequestMessage } from './validate.js';\n\nexport interface AxAIFeatures {\n  functions: boolean;\n  streaming: boolean;\n  functionCot?: boolean;\n  hasThinkingBudget?: boolean;\n  hasShowThoughts?: boolean;\n  /** Enhanced media capability specifications */\n  media: {\n    /** Image processing capabilities */\n    images: {\n      /** Whether the provider supports image inputs */\n      supported: boolean;\n      /** Supported image MIME types (e.g., ['image/jpeg', 'image/png']) */\n      formats: string[];\n      /** Maximum image size in bytes */\n      maxSize?: number;\n      /** Supported detail/quality levels for image processing */\n      detailLevels?: ('high' | 'low' | 'auto')[];\n    };\n    /** Audio processing capabilities */\n    audio: {\n      /** Whether the provider supports audio inputs */\n      supported: boolean;\n      /** Supported audio formats (e.g., ['wav', 'mp3']) */\n      formats: string[];\n      /** Maximum audio duration in seconds */\n      maxDuration?: number;\n    };\n    /** File processing capabilities */\n    files: {\n      /** Whether the provider supports file inputs */\n      supported: boolean;\n      /** Supported file MIME types (e.g., ['application/pdf', 'text/plain']) */\n      formats: string[];\n      /** Maximum file size in bytes */\n      maxSize?: number;\n      /** How files are uploaded to the provider */\n      uploadMethod: 'inline' | 'upload' | 'cloud' | 'none';\n    };\n    /** URL and web content capabilities */\n    urls: {\n      /** Whether the provider supports URL inputs */\n      supported: boolean;\n      /** Whether the provider can perform web searches */\n      webSearch: boolean;\n      /** Whether the provider can fetch web page content */\n      contextFetching: boolean;\n    };\n  };\n  /** Content caching capabilities */\n  caching: {\n    /** Whether the provider supports content caching */\n    supported: boolean;\n    /** Types of caching available */\n    types: ('ephemeral' | 'persistent')[];\n  };\n  /** Whether the provider supports thinking/reasoning modes */\n  thinking: boolean;\n  /** Whether the provider supports multi-turn conversations */\n  multiTurn: boolean;\n}\n\nexport interface AxBaseAIArgs<TModel, TEmbedModel, TModelKey> {\n  name: string;\n  apiURL?: string; // Make optional for local LLMs\n  headers: () => Promise<Record<string, string>>;\n  modelInfo: Readonly<AxModelInfo[]>;\n  defaults: Readonly<{ model: TModel; embedModel?: TEmbedModel }>;\n  options?: Readonly<AxAIServiceOptions>;\n  supportFor: AxAIFeatures | ((model: TModel) => AxAIFeatures);\n  models?: AxAIInputModelList<TModel, TEmbedModel, TModelKey>;\n}\n\nexport const axBaseAIDefaultConfig = (): AxModelConfig =>\n  structuredClone({\n    temperature: 0,\n  });\n\nexport const axBaseAIDefaultCreativeConfig = (): AxModelConfig =>\n  structuredClone({\n    temperature: 0.4,\n    frequencyPenalty: 0.2,\n  });\n\nexport class AxBaseAI<\n  TModel,\n  TEmbedModel,\n  TChatRequest,\n  TEmbedRequest,\n  TChatResponse,\n  TChatResponseDelta,\n  TEmbedResponse,\n  TModelKey,\n> implements AxAIService<TModel, TEmbedModel, TModelKey>\n{\n  #debug = false;\n\n  private rt?: AxAIServiceOptions['rateLimiter'];\n  private fetch?: AxAIServiceOptions['fetch'];\n  private tracer?: AxAIServiceOptions['tracer'];\n  private meter?: AxAIServiceOptions['meter'];\n  private timeout?: AxAIServiceOptions['timeout'];\n  private excludeContentFromTrace?: boolean;\n  private models?: AxAIInputModelList<TModel, TEmbedModel, TModelKey>;\n  private abortSignal?: AbortSignal;\n  private logger: AxLoggerFunction = axGlobals.logger ?? defaultLogger;\n  private corsProxy?: AxAIServiceOptions['corsProxy'];\n\n  private modelInfo: readonly AxModelInfo[];\n  private modelUsage?: AxModelUsage;\n  private embedModelUsage?: AxModelUsage;\n  private defaults: AxBaseAIArgs<TModel, TEmbedModel, TModelKey>['defaults'];\n  private lastUsedModelConfig?: AxModelConfig;\n  private lastUsedChatModel?: TModel;\n  private lastUsedEmbedModel?: TEmbedModel;\n\n  protected apiURL?: string;\n  protected name: string;\n  protected id: string;\n  protected headers: () => Promise<Record<string, string>>;\n  protected supportFor: AxAIFeatures | ((model: TModel) => AxAIFeatures);\n\n  // Add private metrics tracking properties\n  private metrics: AxAIServiceMetrics = {\n    latency: {\n      chat: {\n        mean: 0,\n        p95: 0,\n        p99: 0,\n        samples: [],\n      },\n      embed: {\n        mean: 0,\n        p95: 0,\n        p99: 0,\n        samples: [],\n      },\n    },\n    errors: {\n      chat: {\n        count: 0,\n        rate: 0,\n        total: 0,\n      },\n      embed: {\n        count: 0,\n        rate: 0,\n        total: 0,\n      },\n    },\n  };\n\n  constructor(\n    private readonly aiImpl: Readonly<\n      AxAIServiceImpl<\n        TModel,\n        TEmbedModel,\n        TChatRequest,\n        TEmbedRequest,\n        TChatResponse,\n        TChatResponseDelta,\n        TEmbedResponse\n      >\n    >,\n    {\n      name,\n      apiURL,\n      headers,\n      modelInfo,\n      defaults,\n      options = {},\n      supportFor,\n      models,\n    }: Readonly<AxBaseAIArgs<TModel, TEmbedModel, TModelKey>>\n  ) {\n    this.name = name;\n    this.apiURL = apiURL || '';\n    this.headers = headers;\n    this.supportFor = supportFor;\n    this.tracer = options.tracer ?? axGlobals.tracer;\n    this.meter = options.meter ?? axGlobals.meter;\n    this.modelInfo = modelInfo;\n    this.models = models;\n    this.id = randomUUID();\n\n    const model = this.getModel(defaults.model) ?? defaults.model;\n    const embedModel =\n      this.getEmbedModel(defaults.embedModel) ?? defaults.embedModel;\n\n    this.defaults = { model, embedModel };\n\n    if (\n      !defaults.model ||\n      typeof defaults.model !== 'string' ||\n      defaults.model === ''\n    ) {\n      throw new Error('No model defined');\n    }\n\n    this.setOptions(options);\n\n    if (models) {\n      _validateModels(models);\n    }\n  }\n\n  private getMetricsInstruments(): AxAIMetricsInstruments | undefined {\n    return getOrCreateAIMetricsInstruments(this.meter);\n  }\n\n  public setName(name: string): void {\n    this.name = name;\n  }\n\n  public getId(): string {\n    return this.id;\n  }\n\n  public setAPIURL(apiURL: string): void {\n    this.apiURL = apiURL;\n  }\n\n  public setHeaders(headers: () => Promise<Record<string, string>>): void {\n    this.headers = headers;\n  }\n\n  get debug(): boolean {\n    return this.#debug;\n  }\n\n  setOptions(options: Readonly<AxAIServiceOptions>): void {\n    this.#debug = options.debug ?? axGlobals.debug ?? false;\n    this.rt = options.rateLimiter;\n    this.fetch = options.fetch;\n    this.timeout = options.timeout;\n    this.tracer = options.tracer ?? axGlobals.tracer;\n    this.meter = options.meter ?? axGlobals.meter;\n    this.excludeContentFromTrace = options.excludeContentFromTrace;\n    this.abortSignal = options.abortSignal;\n    this.logger = options.logger ?? axGlobals.logger ?? this.logger;\n    this.corsProxy = options.corsProxy;\n  }\n\n  getOptions(): Readonly<AxAIServiceOptions> {\n    return {\n      debug: this.#debug,\n      rateLimiter: this.rt,\n      fetch: this.fetch,\n      tracer: this.tracer,\n      meter: this.meter,\n      timeout: this.timeout,\n      excludeContentFromTrace: this.excludeContentFromTrace,\n      abortSignal: this.abortSignal,\n      logger: this.logger,\n      corsProxy: this.corsProxy,\n    };\n  }\n\n  getLogger(): AxLoggerFunction {\n    return this.logger;\n  }\n\n  getModelList() {\n    const models = [];\n    for (const model of this.models ?? []) {\n      if (model.isInternal) {\n        continue;\n      }\n\n      if ('model' in model && model.model) {\n        models.push({\n          key: model.key as TModelKey,\n          description: model.description,\n          model: model.model as string,\n        } as const);\n      }\n\n      if ('embedModel' in model && model.embedModel) {\n        models.push({\n          key: model.key as TModelKey,\n          description: model.description,\n          embedModel: model.embedModel as string,\n        } as const);\n      }\n    }\n\n    return models;\n  }\n\n  getName(): string {\n    return this.name;\n  }\n\n  getFeatures(model?: TModel): AxAIFeatures {\n    return typeof this.supportFor === 'function'\n      ? this.supportFor(model ?? this.defaults.model)\n      : this.supportFor;\n  }\n\n  getLastUsedChatModel(): TModel | undefined {\n    return this.lastUsedChatModel;\n  }\n\n  getLastUsedEmbedModel(): TEmbedModel | undefined {\n    return this.lastUsedEmbedModel;\n  }\n\n  getLastUsedModelConfig(): AxModelConfig | undefined {\n    return this.lastUsedModelConfig;\n  }\n\n  // Method to calculate percentiles\n  private calculatePercentile(\n    samples: readonly number[],\n    percentile: number\n  ): number {\n    if (samples.length === 0) return 0;\n    const sorted = [...samples].sort((a, b) => a - b);\n    const index = Math.ceil((percentile / 100) * sorted.length) - 1;\n    return sorted[index] ?? 0;\n  }\n\n  // Method to update latency metrics\n  private updateLatencyMetrics(type: 'chat' | 'embed', duration: number): void {\n    const metrics = this.metrics.latency[type];\n    metrics.samples.push(duration);\n\n    // Keep only last 1000 samples to prevent memory issues\n    if (metrics.samples.length > 1000) {\n      metrics.samples.shift();\n    }\n\n    // Update statistics\n    metrics.mean =\n      metrics.samples.reduce((a, b) => a + b, 0) / metrics.samples.length;\n    metrics.p95 = this.calculatePercentile(metrics.samples, 95);\n    metrics.p99 = this.calculatePercentile(metrics.samples, 99);\n\n    // Export to OpenTelemetry metrics\n    const metricsInstruments = this.getMetricsInstruments();\n    if (metricsInstruments) {\n      const model =\n        type === 'chat'\n          ? (this.lastUsedChatModel as string)\n          : (this.lastUsedEmbedModel as string);\n\n      // Record individual latency measurement\n      recordLatencyMetric(metricsInstruments, type, duration, this.name, model);\n\n      // Record latency statistics as gauges\n      recordLatencyStatsMetrics(\n        metricsInstruments,\n        type,\n        metrics.mean,\n        metrics.p95,\n        metrics.p99,\n        this.name,\n        model\n      );\n    }\n  }\n\n  // Method to update error metrics\n  private updateErrorMetrics(type: 'chat' | 'embed', isError: boolean): void {\n    const metrics = this.metrics.errors[type];\n    metrics.total++;\n    if (isError) {\n      metrics.count++;\n    }\n    metrics.rate = metrics.count / metrics.total;\n\n    // Export to OpenTelemetry metrics\n    const metricsInstruments = this.getMetricsInstruments();\n    if (metricsInstruments) {\n      const model =\n        type === 'chat'\n          ? (this.lastUsedChatModel as string)\n          : (this.lastUsedEmbedModel as string);\n\n      // Always record request count\n      recordRequestMetric(metricsInstruments, type, this.name, model);\n\n      // Record error count if there was an error\n      if (isError) {\n        recordErrorMetric(metricsInstruments, type, this.name, model);\n      }\n\n      // Record current error rate as a gauge\n      recordErrorRateMetric(\n        metricsInstruments,\n        type,\n        metrics.rate,\n        this.name,\n        model\n      );\n    }\n  }\n\n  // Method to record token usage metrics\n  private recordTokenUsage(modelUsage?: AxModelUsage): void {\n    const metricsInstruments = this.getMetricsInstruments();\n    if (metricsInstruments && modelUsage?.tokens) {\n      const { promptTokens, completionTokens, totalTokens, thoughtsTokens } =\n        modelUsage.tokens;\n\n      if (promptTokens) {\n        recordTokenMetric(\n          metricsInstruments,\n          'input',\n          promptTokens,\n          this.name,\n          modelUsage.model\n        );\n      }\n\n      if (completionTokens) {\n        recordTokenMetric(\n          metricsInstruments,\n          'output',\n          completionTokens,\n          this.name,\n          modelUsage.model\n        );\n      }\n\n      if (totalTokens) {\n        recordTokenMetric(\n          metricsInstruments,\n          'total',\n          totalTokens,\n          this.name,\n          modelUsage.model\n        );\n      }\n\n      if (thoughtsTokens) {\n        recordTokenMetric(\n          metricsInstruments,\n          'thoughts',\n          thoughtsTokens,\n          this.name,\n          modelUsage.model\n        );\n      }\n    }\n  }\n\n  // Helper method to calculate request size in bytes\n  private calculateRequestSize(req: unknown): number {\n    try {\n      return new TextEncoder().encode(JSON.stringify(req)).length;\n    } catch {\n      return 0;\n    }\n  }\n\n  // Helper method to calculate response size in bytes\n  private calculateResponseSize(response: unknown): number {\n    try {\n      return new TextEncoder().encode(JSON.stringify(response)).length;\n    } catch {\n      return 0;\n    }\n  }\n\n  // Helper method to detect multimodal content\n  private detectMultimodalContent(\n    req: Readonly<AxChatRequest<TModel | TModelKey>>\n  ): {\n    hasImages: boolean;\n    hasAudio: boolean;\n  } {\n    let hasImages = false;\n    let hasAudio = false;\n\n    if (req.chatPrompt && Array.isArray(req.chatPrompt)) {\n      for (const message of req.chatPrompt) {\n        if (message.role === 'user' && Array.isArray(message.content)) {\n          for (const part of message.content) {\n            if (part.type === 'image') {\n              hasImages = true;\n            } else if (part.type === 'audio') {\n              hasAudio = true;\n            }\n          }\n        }\n      }\n    }\n\n    return { hasImages, hasAudio };\n  }\n\n  // Helper method to calculate prompt length\n  private calculatePromptLength(\n    req: Readonly<AxChatRequest<TModel | TModelKey>>\n  ): number {\n    let totalLength = 0;\n\n    if (req.chatPrompt && Array.isArray(req.chatPrompt)) {\n      for (const message of req.chatPrompt) {\n        if (message.role === 'system' || message.role === 'assistant') {\n          if (message.content) {\n            totalLength += message.content.length;\n          }\n        } else if (message.role === 'user') {\n          if (typeof message.content === 'string') {\n            totalLength += message.content.length;\n          } else if (Array.isArray(message.content)) {\n            for (const part of message.content) {\n              if (part.type === 'text') {\n                totalLength += part.text.length;\n              }\n            }\n          }\n        } else if (message.role === 'function') {\n          if (message.result) {\n            totalLength += message.result.length;\n          }\n        }\n      }\n    }\n\n    return totalLength;\n  }\n\n  // Helper method to calculate context window usage\n  private calculateContextWindowUsage(\n    model: TModel,\n    modelUsage?: AxModelUsage\n  ): number {\n    if (!modelUsage?.tokens?.promptTokens) return 0;\n\n    // Get model info to find context window size\n    const modelInfo = this.modelInfo.find(\n      (info) => info.name === (model as string)\n    );\n    if (!modelInfo?.contextWindow) return 0;\n\n    return modelUsage.tokens.promptTokens / modelInfo.contextWindow;\n  }\n\n  // Helper method to estimate cost\n  private estimateCost(model: TModel, modelUsage?: AxModelUsage): number {\n    if (!modelUsage?.tokens) return 0;\n\n    // Get model info to find pricing\n    const modelInfo = this.modelInfo.find(\n      (info) => info.name === (model as string)\n    );\n    if (\n      !modelInfo ||\n      (!modelInfo.promptTokenCostPer1M && !modelInfo.completionTokenCostPer1M)\n    )\n      return 0;\n\n    const { promptTokens = 0, completionTokens = 0 } = modelUsage.tokens;\n    const promptCostPer1M = modelInfo.promptTokenCostPer1M || 0;\n    const completionCostPer1M = modelInfo.completionTokenCostPer1M || 0;\n\n    return (\n      (promptTokens * promptCostPer1M) / 1000000 +\n      (completionTokens * completionCostPer1M) / 1000000\n    );\n  }\n\n  // Helper method to estimate cost by model name\n  private estimateCostByName(\n    modelName: string,\n    modelUsage?: AxModelUsage\n  ): number {\n    if (!modelUsage?.tokens) return 0;\n\n    // Get model info to find pricing\n    const modelInfo = this.modelInfo.find((info) => info.name === modelName);\n    if (\n      !modelInfo ||\n      (!modelInfo.promptTokenCostPer1M && !modelInfo.completionTokenCostPer1M)\n    )\n      return 0;\n\n    const { promptTokens = 0, completionTokens = 0 } = modelUsage.tokens;\n    const promptCostPer1M = modelInfo.promptTokenCostPer1M || 0;\n    const completionCostPer1M = modelInfo.completionTokenCostPer1M || 0;\n\n    return (\n      (promptTokens * promptCostPer1M) / 1000000 +\n      (completionTokens * completionCostPer1M) / 1000000\n    );\n  }\n\n  // Helper method to record function call metrics\n  private recordFunctionCallMetrics(\n    functionCalls?: readonly unknown[],\n    model?: TModel\n  ): void {\n    const metricsInstruments = this.getMetricsInstruments();\n    if (!metricsInstruments || !functionCalls) return;\n\n    for (const call of functionCalls) {\n      if (\n        call &&\n        typeof call === 'object' &&\n        'function' in call &&\n        call.function &&\n        typeof call.function === 'object' &&\n        'name' in call.function\n      ) {\n        recordFunctionCallMetric(\n          metricsInstruments,\n          (call.function as { name: string }).name,\n          undefined, // latency would need to be tracked separately\n          this.name,\n          model as string\n        );\n      }\n    }\n  }\n\n  // Helper method to record timeout metrics\n  private recordTimeoutMetric(type: 'chat' | 'embed'): void {\n    const metricsInstruments = this.getMetricsInstruments();\n    if (metricsInstruments) {\n      const model =\n        type === 'chat'\n          ? (this.lastUsedChatModel as string)\n          : (this.lastUsedEmbedModel as string);\n      recordTimeoutMetric(metricsInstruments, type, this.name, model);\n    }\n  }\n\n  // Helper method to record abort metrics\n  private recordAbortMetric(type: 'chat' | 'embed'): void {\n    const metricsInstruments = this.getMetricsInstruments();\n    if (metricsInstruments) {\n      const model =\n        type === 'chat'\n          ? (this.lastUsedChatModel as string)\n          : (this.lastUsedEmbedModel as string);\n      recordAbortMetric(metricsInstruments, type, this.name, model);\n    }\n  }\n\n  // Comprehensive method to record all chat-related metrics\n  private recordChatMetrics(\n    req: Readonly<AxChatRequest<TModel | TModelKey>>,\n    options?: Readonly<AxAIServiceOptions>,\n    result?: AxChatResponse | ReadableStream<AxChatResponse>\n  ): void {\n    const metricsInstruments = this.getMetricsInstruments();\n    if (!metricsInstruments) return;\n\n    const model = this.lastUsedChatModel as string;\n    const modelConfig = this.lastUsedModelConfig;\n\n    // Record streaming request metric\n    const isStreaming = modelConfig?.stream ?? false;\n    recordStreamingRequestMetric(\n      metricsInstruments,\n      'chat',\n      isStreaming,\n      this.name,\n      model\n    );\n\n    // Record multimodal request metric\n    const { hasImages, hasAudio } = this.detectMultimodalContent(req);\n    recordMultimodalRequestMetric(\n      metricsInstruments,\n      hasImages,\n      hasAudio,\n      this.name,\n      model\n    );\n\n    // Record prompt length metric\n    const promptLength = this.calculatePromptLength(req);\n    recordPromptLengthMetric(\n      metricsInstruments,\n      promptLength,\n      this.name,\n      model\n    );\n\n    // Record model configuration metrics\n    recordModelConfigMetrics(\n      metricsInstruments,\n      modelConfig?.temperature,\n      modelConfig?.maxTokens,\n      this.name,\n      model\n    );\n\n    // Record thinking budget usage if applicable\n    if (\n      options?.thinkingTokenBudget &&\n      this.modelUsage?.tokens?.thoughtsTokens\n    ) {\n      recordThinkingBudgetUsageMetric(\n        metricsInstruments,\n        this.modelUsage.tokens.thoughtsTokens,\n        this.name,\n        model\n      );\n    }\n\n    // Record request size\n    const requestSize = this.calculateRequestSize(req);\n    recordRequestSizeMetric(\n      metricsInstruments,\n      'chat',\n      requestSize,\n      this.name,\n      model\n    );\n\n    // Record response size and function calls for non-streaming responses\n    if (result && !isStreaming) {\n      const chatResponse = result as AxChatResponse;\n      const responseSize = this.calculateResponseSize(chatResponse);\n      recordResponseSizeMetric(\n        metricsInstruments,\n        'chat',\n        responseSize,\n        this.name,\n        model\n      );\n\n      // Record function call metrics\n      if (chatResponse.results) {\n        for (const chatResult of chatResponse.results) {\n          if (chatResult.functionCalls) {\n            this.recordFunctionCallMetrics(\n              chatResult.functionCalls,\n              this.lastUsedChatModel\n            );\n          }\n        }\n      }\n\n      // Record context window usage\n      const contextUsage = this.calculateContextWindowUsage(\n        this.lastUsedChatModel!,\n        chatResponse.modelUsage\n      );\n      if (contextUsage > 0) {\n        recordContextWindowUsageMetric(\n          metricsInstruments,\n          contextUsage,\n          this.name,\n          model\n        );\n      }\n\n      // Record estimated cost\n      const estimatedCost = this.estimateCost(\n        this.lastUsedChatModel!,\n        chatResponse.modelUsage\n      );\n      if (estimatedCost > 0) {\n        recordEstimatedCostMetric(\n          metricsInstruments,\n          'chat',\n          estimatedCost,\n          this.name,\n          model\n        );\n      }\n    }\n  }\n\n  // Comprehensive method to record all embed-related metrics\n  private recordEmbedMetrics(\n    req: Readonly<AxEmbedRequest<TEmbedModel>>,\n    result: Readonly<AxEmbedResponse>\n  ): void {\n    const metricsInstruments = this.getMetricsInstruments();\n    if (!metricsInstruments) return;\n\n    const model = this.lastUsedEmbedModel as string;\n\n    // Record request size\n    const requestSize = this.calculateRequestSize(req);\n    recordRequestSizeMetric(\n      metricsInstruments,\n      'embed',\n      requestSize,\n      this.name,\n      model\n    );\n\n    // Record response size\n    const responseSize = this.calculateResponseSize(result);\n    recordResponseSizeMetric(\n      metricsInstruments,\n      'embed',\n      responseSize,\n      this.name,\n      model\n    );\n\n    // Record estimated cost\n    const estimatedCost = this.estimateCostByName(model, result.modelUsage);\n    if (estimatedCost > 0) {\n      recordEstimatedCostMetric(\n        metricsInstruments,\n        'embed',\n        estimatedCost,\n        this.name,\n        model\n      );\n    }\n  }\n\n  // Public method to get metrics\n  public getMetrics(): AxAIServiceMetrics {\n    return structuredClone(this.metrics);\n  }\n\n  async chat(\n    req: Readonly<AxChatRequest<TModel | TModelKey>>,\n    options?: Readonly<AxAIServiceOptions>\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    const startTime = performance.now();\n    let isError = false;\n    let result: AxChatResponse | ReadableStream<AxChatResponse>;\n\n    // Merge per-model-key default options if a key entry provides them\n    const modelKeyEntry = this.getModelByKey(\n      req.model as TModel | TEmbedModel | TModelKey\n    );\n    const modelKeyThinkingTokenBudget = modelKeyEntry\n      ? (\n          modelKeyEntry as {\n            thinkingTokenBudget?: AxAIServiceOptions['thinkingTokenBudget'];\n          }\n        ).thinkingTokenBudget\n      : undefined;\n    const mergedOptions: Readonly<AxAIServiceOptions> = {\n      ...(modelKeyEntry\n        ? {\n            thinkingTokenBudget: modelKeyThinkingTokenBudget,\n            showThoughts: (\n              modelKeyEntry as {\n                showThoughts?: AxAIServiceOptions['showThoughts'];\n              }\n            ).showThoughts,\n            stream: (\n              modelKeyEntry as {\n                stream?: AxAIServiceOptions['stream'];\n              }\n            ).stream,\n            debug: (\n              modelKeyEntry as {\n                debug?: AxAIServiceOptions['debug'];\n              }\n            ).debug,\n            useExpensiveModel: (\n              modelKeyEntry as {\n                useExpensiveModel?: AxAIServiceOptions['useExpensiveModel'];\n              }\n            ).useExpensiveModel,\n          }\n        : undefined),\n      // Filter out undefined values from options to avoid overriding model key defaults\n      ...Object.fromEntries(\n        Object.entries(options ?? {}).filter(([, value]) => value !== undefined)\n      ),\n    } as AxAIServiceOptions;\n\n    try {\n      result = await this._chat1(req, mergedOptions);\n      return result;\n    } catch (error) {\n      isError = true;\n      // Check for specific error types\n      if (error instanceof Error) {\n        if (\n          error.message.includes('timeout') ||\n          error.name === 'TimeoutError'\n        ) {\n          this.recordTimeoutMetric('chat');\n        } else if (\n          error.message.includes('abort') ||\n          error.name === 'AbortError'\n        ) {\n          this.recordAbortMetric('chat');\n        }\n      }\n      throw error;\n    } finally {\n      const duration = performance.now() - startTime;\n      this.updateLatencyMetrics('chat', duration);\n      this.updateErrorMetrics('chat', isError);\n\n      // Record additional metrics if successful\n      if (!isError) {\n        this.recordChatMetrics(req, mergedOptions, result!);\n      }\n    }\n  }\n\n  private async _chat1(\n    req: Readonly<AxChatRequest<TModel | TModelKey>>,\n    options?: Readonly<AxAIServiceOptions>\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    const model =\n      this.getModel(req.model) ?? (req.model as TModel) ?? this.defaults.model;\n\n    // Validate chat prompt messages\n    if (Array.isArray(req.chatPrompt)) {\n      for (const item of req.chatPrompt) {\n        axValidateChatRequestMessage(item);\n      }\n    }\n\n    // Merge per-model-key default modelConfig if provided\n    const modelKeyEntry = this.getModelByKey(\n      req.model as TModel | TEmbedModel | TModelKey\n    );\n    const modelConfig = {\n      ...this.aiImpl.getModelConfig(),\n      ...(modelKeyEntry\n        ? (modelKeyEntry as { modelConfig?: AxModelConfig }).modelConfig\n        : undefined),\n      ...req.modelConfig,\n    } as AxModelConfig;\n\n    const selectedModelInfo = this.modelInfo.find(\n      (info) => info.name === (model as string)\n    );\n    if (selectedModelInfo?.notSupported?.temperature) {\n      if ('temperature' in modelConfig) {\n        delete (modelConfig as { temperature?: number }).temperature;\n      }\n    }\n    if (selectedModelInfo?.notSupported?.topP) {\n      if ('topP' in modelConfig) {\n        delete (modelConfig as { topP?: number }).topP;\n      }\n    }\n\n    // Check for thinkingTokenBudget support\n    if (\n      options?.thinkingTokenBudget &&\n      !this.getFeatures(model).hasThinkingBudget\n    ) {\n      throw new Error(\n        `Model ${model as string} does not support thinkingTokenBudget.`\n      );\n    }\n\n    // Check for showThoughts support\n    if (options?.showThoughts && !this.getFeatures(model).hasShowThoughts) {\n      throw new Error(\n        `Model ${model as string} does not support showThoughts.`\n      );\n    }\n\n    // Check for expensive model usage\n    const modelInfo = this.modelInfo.find(\n      (info) => info.name === (model as string)\n    );\n    if (modelInfo?.isExpensive && options?.useExpensiveModel !== 'yes') {\n      throw new Error(\n        `Model ${model as string} is marked as expensive and requires explicit confirmation. Set useExpensiveModel: \"yes\" to proceed.`\n      );\n    }\n\n    // stream is true by default unless explicitly set to false\n    modelConfig.stream =\n      (options?.stream !== undefined ? options.stream : modelConfig.stream) ??\n      true;\n\n    const canStream = this.getFeatures(model).streaming;\n    if (!canStream) {\n      modelConfig.stream = false;\n    }\n\n    if (this.tracer) {\n      return await this.tracer.startActiveSpan(\n        'AI Chat Request',\n        {\n          kind: SpanKind.SERVER,\n          attributes: {\n            [axSpanAttributes.LLM_SYSTEM]: this.name,\n            [axSpanAttributes.LLM_OPERATION_NAME]: 'chat',\n            [axSpanAttributes.LLM_REQUEST_MODEL]: model as string,\n            [axSpanAttributes.LLM_REQUEST_MAX_TOKENS]:\n              modelConfig.maxTokens ?? 'Not set',\n            [axSpanAttributes.LLM_REQUEST_TEMPERATURE]: modelConfig.temperature,\n            [axSpanAttributes.LLM_REQUEST_TOP_P]: modelConfig.topP ?? 'Not set',\n            [axSpanAttributes.LLM_REQUEST_TOP_K]: modelConfig.topK ?? 'Not set',\n            [axSpanAttributes.LLM_REQUEST_FREQUENCY_PENALTY]:\n              modelConfig.frequencyPenalty ?? 'Not set',\n            [axSpanAttributes.LLM_REQUEST_PRESENCE_PENALTY]:\n              modelConfig.presencePenalty ?? 'Not set',\n            [axSpanAttributes.LLM_REQUEST_STOP_SEQUENCES]:\n              modelConfig.stopSequences?.join(', ') ?? 'Not set',\n            [axSpanAttributes.LLM_REQUEST_LLM_IS_STREAMING]:\n              modelConfig.stream ?? 'Not set',\n          },\n        },\n        options?.traceContext ?? context.active(),\n        async (span) => {\n          return await this._chat2(model, modelConfig, req, options, span);\n        }\n      );\n    }\n    return await this._chat2(model, modelConfig, req, options);\n  }\n\n  private cleanupFunctionSchema(\n    fn: Readonly<NonNullable<AxChatRequest['functions']>[number]>\n  ): NonNullable<AxChatRequest['functions']>[number] {\n    const cleanFn = { ...fn };\n    if (cleanFn.parameters) {\n      const cleanParams = { ...cleanFn.parameters };\n\n      // Remove empty required array\n      if (\n        Array.isArray(cleanParams.required) &&\n        cleanParams.required.length === 0\n      ) {\n        delete cleanParams.required;\n      }\n\n      // Remove empty properties object\n      if (\n        cleanParams.properties &&\n        Object.keys(cleanParams.properties).length === 0\n      ) {\n        delete cleanParams.properties;\n      }\n\n      // After cleaning, remove the entire parameters object if it's effectively empty\n      // i.e., either no keys left or just { type: 'object' } remaining.\n      if (\n        Object.keys(cleanParams).length === 0 ||\n        (Object.keys(cleanParams).length === 1 && cleanParams.type === 'object')\n      ) {\n        delete cleanFn.parameters;\n      } else {\n        cleanFn.parameters = cleanParams;\n      }\n    }\n    return cleanFn;\n  }\n\n  private async _chat2(\n    model: TModel,\n    modelConfig: Readonly<AxModelConfig>,\n    chatReq: Readonly<Omit<AxChatRequest<TModel | TModelKey>, 'modelConfig'>>,\n    options?: Readonly<AxAIServiceOptions>,\n    span?: Span\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    if (!this.aiImpl.createChatReq) {\n      throw new Error('createChatReq not implemented');\n    }\n\n    const debug = options?.debug ?? this.#debug;\n\n    let functions: NonNullable<AxChatRequest['functions']> | undefined;\n\n    if (chatReq.functions && chatReq.functions.length > 0) {\n      functions = chatReq.functions.map((fn) => this.cleanupFunctionSchema(fn));\n    }\n\n    const req = {\n      ...chatReq,\n      model,\n      functions,\n      modelConfig,\n    };\n\n    // Store the last used model and config\n    this.lastUsedChatModel = model;\n    this.lastUsedModelConfig = modelConfig;\n\n    if (debug) {\n      logChatRequest(\n        req.chatPrompt,\n        options?.stepIndex ?? 0,\n        options?.logger ?? this.logger,\n        options?.debugHideSystemPrompt\n      );\n    }\n\n    // After logging, optionally emulate prompt-based function mode centrally\n    const providerSupportsFunctions = this.getFeatures(model).functions;\n    const requestedFunctionCallMode = options?.functionCallMode ?? 'auto';\n    const shouldEmulatePromptMode =\n      requestedFunctionCallMode === 'prompt' ||\n      (requestedFunctionCallMode === 'auto' && !providerSupportsFunctions);\n\n    const effectiveReq = shouldEmulatePromptMode\n      ? {\n          ...req,\n          chatPrompt: req.chatPrompt.map((msg) => {\n            if (msg.role === 'assistant') {\n              const { content, name, cache } = msg;\n              return {\n                role: 'assistant' as const,\n                content,\n                name,\n                cache,\n              } as typeof msg;\n            }\n            if (msg.role === 'function') {\n              const content = msg.result;\n              return {\n                role: 'user' as const,\n                content,\n              } as (typeof req.chatPrompt)[number];\n            }\n            return msg;\n          }),\n          functions: [],\n        }\n      : req;\n\n    const fn = async () => {\n      const [apiConfig, reqValue] = await this.aiImpl.createChatReq(\n        effectiveReq,\n        options\n      );\n\n      if (span?.isRecording()) {\n        setChatRequestEvents(chatReq, span, this.excludeContentFromTrace);\n      }\n\n      const res = await apiCall(\n        {\n          name: apiConfig.name,\n          url: this.apiURL,\n          localCall: apiConfig.localCall,\n          headers: await this.buildHeaders(apiConfig.headers),\n          stream: modelConfig.stream,\n          timeout: this.timeout,\n          debug,\n          fetch: this.fetch,\n          span,\n          abortSignal: options?.abortSignal ?? this.abortSignal,\n          corsProxy: this.corsProxy,\n        },\n        reqValue\n      );\n      return res;\n    };\n\n    const rt = options?.rateLimiter ?? this.rt;\n    const rv = rt ? await rt(fn, { modelUsage: this.modelUsage }) : await fn();\n\n    if (modelConfig.stream) {\n      if (!this.aiImpl.createChatStreamResp) {\n        throw new Error('createChatStreamResp not implemented');\n      }\n\n      const respFn = this.aiImpl.createChatStreamResp.bind(this);\n      const wrappedRespFn =\n        (state: object) => (resp: Readonly<TChatResponseDelta>) => {\n          const res = respFn(resp, state);\n          res.sessionId = options?.sessionId;\n\n          // Only call getTokenUsage if modelUsage is not already provided by the service\n          if (!res.modelUsage) {\n            const tokenUsage = this.aiImpl.getTokenUsage();\n            if (tokenUsage) {\n              res.modelUsage = {\n                ai: this.name,\n                model: model as string,\n                tokens: tokenUsage,\n              };\n            }\n          }\n          this.modelUsage = res.modelUsage;\n          this.recordTokenUsage(res.modelUsage);\n\n          if (span?.isRecording()) {\n            setChatResponseEvents(res, span, this.excludeContentFromTrace);\n          }\n\n          if (debug) {\n            // Log individual streaming results\n            for (const result of res.results) {\n              logResponseStreamingResult(\n                result,\n                result.index,\n                options?.logger ?? this.logger\n              );\n            }\n          }\n          return res;\n        };\n\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const doneCb = async (values: readonly AxChatResponse[]) => {\n        if (span?.isRecording()) {\n          span.end();\n        }\n        if (debug) {\n          logResponseStreamingDoneResult(\n            values,\n            options?.logger ?? this.logger\n          );\n        }\n      };\n\n      // Check if we're in browser environment for compatibility\n      const isBrowser = typeof window !== 'undefined';\n\n      if (isBrowser) {\n        // Use browser-compatible manual stream processing instead of pipeThrough\n        const sourceStream = rv as ReadableStream<TChatResponseDelta>;\n        const transformState = {};\n        const transformedValues: AxChatResponse[] = [];\n        const abortSignal = options?.abortSignal ?? this.abortSignal;\n        return new ReadableStream<AxChatResponse>({\n          start: (controller) => {\n            const reader = sourceStream.getReader();\n\n            const onAbort = () => {\n              try {\n                reader.cancel().catch(() => {});\n              } catch {}\n              try {\n                this.recordAbortMetric('chat');\n              } catch {}\n              try {\n                if (span?.isRecording()) span.end();\n              } catch {}\n              try {\n                // DOMException is available in browsers; fallback to Error if unavailable\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                controller.error(new DOMException('Aborted', 'AbortError'));\n              } catch {\n                controller.error(new Error('Aborted'));\n              }\n            };\n\n            if (abortSignal) {\n              if (abortSignal.aborted) {\n                onAbort();\n                return;\n              }\n              abortSignal.addEventListener('abort', onAbort, { once: true });\n            }\n\n            async function read() {\n              try {\n                while (true) {\n                  const { done, value } = await reader.read();\n                  if (done) {\n                    // Call done callback with all transformed values\n                    if (doneCb) {\n                      await doneCb(transformedValues);\n                    }\n                    controller.close();\n                    break;\n                  }\n\n                  const transformedValue = wrappedRespFn(transformState)(value);\n                  if (transformedValue) {\n                    transformedValues.push(transformedValue);\n                    controller.enqueue(transformedValue);\n                  }\n                }\n              } catch (error) {\n                controller.error(error);\n                if (span?.isRecording()) {\n                  try {\n                    span.end();\n                  } catch {}\n                }\n              } finally {\n                reader.releaseLock();\n                if (abortSignal) {\n                  try {\n                    abortSignal.removeEventListener('abort', onAbort);\n                  } catch {}\n                }\n              }\n            }\n\n            read();\n          },\n        });\n      }\n      // Use pipeThrough for Node.js environments where it's fully supported\n      const st = (rv as ReadableStream<TChatResponseDelta>).pipeThrough(\n        new RespTransformStream<TChatResponseDelta, AxChatResponse>(\n          wrappedRespFn({}),\n          doneCb\n        )\n      );\n      return st;\n    }\n\n    if (!this.aiImpl.createChatResp) {\n      throw new Error('createChatResp not implemented');\n    }\n\n    const res = this.aiImpl.createChatResp(rv as TChatResponse);\n    res.sessionId = options?.sessionId;\n\n    // Only call getTokenUsage if modelUsage is not already provided by the service\n    if (!res.modelUsage) {\n      const tokenUsage = this.aiImpl.getTokenUsage();\n      if (tokenUsage) {\n        res.modelUsage = {\n          ai: this.name,\n          model: model as string,\n          tokens: tokenUsage,\n        };\n      }\n    }\n\n    if (res.modelUsage) {\n      this.modelUsage = res.modelUsage;\n      this.recordTokenUsage(res.modelUsage);\n    }\n\n    if (span?.isRecording()) {\n      setChatResponseEvents(res, span, this.excludeContentFromTrace);\n      span.end();\n    }\n\n    if (debug) {\n      logResponse(res, options?.logger ?? this.logger);\n    }\n\n    return res;\n  }\n\n  async embed(\n    req: Readonly<AxEmbedRequest<TEmbedModel>>,\n    options?: Readonly<AxAIServiceOptions>\n  ): Promise<AxEmbedResponse> {\n    const startTime = performance.now();\n    let isError = false;\n    let result: AxEmbedResponse | undefined;\n\n    // Merge per-model-key default options if a key entry provides them\n    const modelKeyEntry = this.getModelByKey(\n      req.embedModel as TModel | TEmbedModel | TModelKey\n    );\n    const mergedOptions: Readonly<AxAIServiceOptions> = {\n      ...(modelKeyEntry\n        ? {\n            thinkingTokenBudget: (\n              modelKeyEntry as {\n                thinkingTokenBudget?: AxAIServiceOptions['thinkingTokenBudget'];\n              }\n            ).thinkingTokenBudget,\n            showThoughts: (\n              modelKeyEntry as {\n                showThoughts?: AxAIServiceOptions['showThoughts'];\n              }\n            ).showThoughts,\n            stream: (\n              modelKeyEntry as {\n                stream?: AxAIServiceOptions['stream'];\n              }\n            ).stream,\n            debug: (\n              modelKeyEntry as {\n                debug?: AxAIServiceOptions['debug'];\n              }\n            ).debug,\n            useExpensiveModel: (\n              modelKeyEntry as {\n                useExpensiveModel?: AxAIServiceOptions['useExpensiveModel'];\n              }\n            ).useExpensiveModel,\n          }\n        : undefined),\n      ...options,\n    } as AxAIServiceOptions;\n\n    try {\n      result = await this._embed1(req, mergedOptions);\n      return result;\n    } catch (error) {\n      isError = true;\n      // Check for specific error types\n      if (error instanceof Error) {\n        if (\n          error.message.includes('timeout') ||\n          error.name === 'TimeoutError'\n        ) {\n          this.recordTimeoutMetric('embed');\n        } else if (\n          error.message.includes('abort') ||\n          error.name === 'AbortError'\n        ) {\n          this.recordAbortMetric('embed');\n        }\n      }\n      throw error;\n    } finally {\n      const duration = performance.now() - startTime;\n      this.updateLatencyMetrics('embed', duration);\n      this.updateErrorMetrics('embed', isError);\n\n      // Record additional metrics if successful\n      if (!isError && result) {\n        this.recordEmbedMetrics(req, result);\n      }\n    }\n  }\n\n  private async _embed1(\n    req: Readonly<AxEmbedRequest<TEmbedModel>>,\n    options?: Readonly<AxAIServiceOptions>\n  ): Promise<AxEmbedResponse> {\n    const embedModel =\n      this.getEmbedModel(req.embedModel) ??\n      (req.embedModel as TEmbedModel) ??\n      this.defaults.embedModel;\n\n    if (!embedModel) {\n      throw new Error('No embed model defined');\n    }\n\n    if (this.tracer) {\n      return await this.tracer.startActiveSpan(\n        'AI Embed Request',\n        {\n          kind: SpanKind.SERVER,\n          attributes: {\n            [axSpanAttributes.LLM_SYSTEM]: this.name,\n            [axSpanAttributes.LLM_OPERATION_NAME]: 'embeddings',\n            [axSpanAttributes.LLM_REQUEST_MODEL]: embedModel as string,\n          },\n        },\n        options?.traceContext ?? context.active(),\n        async (span) => {\n          return await this._embed2(embedModel, req, options, span);\n        }\n      );\n    }\n    return await this._embed2(embedModel, req, options);\n  }\n\n  private async _embed2(\n    embedModel: TEmbedModel,\n    embedReq: Readonly<AxEmbedRequest<TEmbedModel>>,\n    options?: Readonly<AxAIServiceOptions>,\n    span?: Span\n  ): Promise<AxEmbedResponse> {\n    if (!this.aiImpl.createEmbedReq) {\n      throw new Error('createEmbedReq not implemented');\n    }\n    if (!this.aiImpl.createEmbedResp) {\n      throw new Error('createEmbedResp not implemented');\n    }\n\n    // Bind provider implementation method to preserve `this` and satisfy TS\n    const createEmbedReq = this.aiImpl.createEmbedReq!.bind(this.aiImpl);\n    const debug = options?.debug ?? this.#debug;\n\n    const req = {\n      ...embedReq,\n      embedModel,\n    };\n\n    // Store the last used embed model\n    this.lastUsedEmbedModel = embedModel;\n\n    if (debug) {\n      logEmbedRequest(\n        req.texts ?? [],\n        embedModel as string,\n        options?.logger ?? this.logger\n      );\n    }\n\n    const fn = async () => {\n      const [apiConfig, reqValue] = await createEmbedReq(req);\n\n      const res = await apiCall(\n        {\n          name: apiConfig.name,\n          url: this.apiURL,\n          localCall: apiConfig.localCall,\n          headers: await this.buildHeaders(apiConfig.headers),\n          debug,\n          fetch: this.fetch,\n          timeout: this.timeout,\n          span,\n          abortSignal: options?.abortSignal ?? this.abortSignal,\n          corsProxy: this.corsProxy,\n        },\n        reqValue\n      );\n      return res;\n    };\n\n    const rt = options?.rateLimiter ?? this.rt;\n    const resValue = rt\n      ? await rt(fn, { modelUsage: this.embedModelUsage })\n      : await fn();\n    const res = this.aiImpl.createEmbedResp?.(resValue as TEmbedResponse);\n\n    res.sessionId = options?.sessionId;\n\n    // Only call getTokenUsage if modelUsage is not already provided by the service\n    if (!res.modelUsage) {\n      const tokenUsage = this.aiImpl.getTokenUsage();\n      if (tokenUsage) {\n        res.modelUsage = {\n          ai: this.name,\n          model: embedModel as string,\n          tokens: tokenUsage,\n        };\n      }\n    }\n    this.embedModelUsage = res.modelUsage;\n    this.recordTokenUsage(res.modelUsage);\n\n    if (span?.isRecording() && res.modelUsage?.tokens) {\n      span.addEvent(axSpanEvents.GEN_AI_USAGE, {\n        [axSpanAttributes.LLM_USAGE_INPUT_TOKENS]:\n          res.modelUsage.tokens.promptTokens,\n        [axSpanAttributes.LLM_USAGE_OUTPUT_TOKENS]:\n          res.modelUsage.tokens.completionTokens ?? 0,\n        [axSpanAttributes.LLM_USAGE_TOTAL_TOKENS]:\n          res.modelUsage.tokens.totalTokens,\n      });\n    }\n\n    if (debug) {\n      logEmbedResponse(res.embeddings, options?.logger ?? this.logger);\n    }\n\n    span?.end();\n    return res;\n  }\n\n  private async buildHeaders(\n    headers: Record<string, string> = {}\n  ): Promise<Record<string, string>> {\n    return { ...headers, ...(await this.headers()) };\n  }\n\n  private getModelByKey(\n    modelName?: TModel | TEmbedModel | TModelKey\n  ): AxAIInputModelList<TModel, TEmbedModel, TModelKey>[number] | undefined {\n    if (!modelName) {\n      return undefined;\n    }\n    const item = this.models?.find((v) => v.key === modelName);\n    return item;\n  }\n\n  private getModel(modelName?: TModel | TModelKey): TModel | undefined {\n    const item = this.getModelByKey(modelName);\n    return item && 'model' in item ? item.model : undefined;\n  }\n\n  private getEmbedModel(\n    modelName?: TEmbedModel | TModelKey\n  ): TEmbedModel | undefined {\n    const item = this.getModelByKey(modelName);\n    return item && 'embedModel' in item ? item.embedModel : undefined;\n  }\n}\n\nexport function setChatRequestEvents(\n  req: Readonly<AxChatRequest<unknown>>,\n  span: Span,\n  excludeContentFromTrace?: boolean\n): void {\n  const userMessages: string[] = [];\n\n  if (\n    req.chatPrompt &&\n    Array.isArray(req.chatPrompt) &&\n    req.chatPrompt.length > 0\n  ) {\n    for (const prompt of req.chatPrompt) {\n      switch (prompt.role) {\n        case 'system':\n          if (prompt.content) {\n            const eventData: { content?: string } = {};\n            if (!excludeContentFromTrace) {\n              eventData.content = prompt.content;\n            }\n            span.addEvent(axSpanEvents.GEN_AI_SYSTEM_MESSAGE, eventData);\n          }\n          break;\n        case 'user':\n          if (typeof prompt.content === 'string') {\n            userMessages.push(prompt.content);\n          } else if (Array.isArray(prompt.content)) {\n            for (const part of prompt.content) {\n              if (part.type === 'text') {\n                userMessages.push(part.text);\n              }\n            }\n          }\n          break;\n        case 'assistant': {\n          const functionCalls = prompt.functionCalls?.map((call) => {\n            return {\n              id: call.id,\n              type: call.type,\n              function: call.function.name,\n              arguments: call.function.params,\n            };\n          });\n\n          if (functionCalls && functionCalls.length > 0) {\n            const eventData: { content?: string; function_calls: string } = {\n              function_calls: JSON.stringify(functionCalls, null, 2),\n            };\n            if (!excludeContentFromTrace && prompt.content) {\n              eventData.content = prompt.content;\n            }\n            span.addEvent(axSpanEvents.GEN_AI_ASSISTANT_MESSAGE, eventData);\n          } else if (prompt.content) {\n            const eventData: { content?: string } = {};\n            if (!excludeContentFromTrace) {\n              eventData.content = prompt.content;\n            }\n            span.addEvent(axSpanEvents.GEN_AI_ASSISTANT_MESSAGE, eventData);\n          }\n          break;\n        }\n\n        case 'function': {\n          const eventData: { content?: string; id: string } = {\n            id: prompt.functionId,\n          };\n          if (!excludeContentFromTrace) {\n            eventData.content = prompt.result;\n          }\n          span.addEvent(axSpanEvents.GEN_AI_TOOL_MESSAGE, eventData);\n          break;\n        }\n      }\n    }\n  }\n\n  // Always add user message event, even if empty\n  const userEventData: { content?: string } = {};\n  if (!excludeContentFromTrace) {\n    userEventData.content = userMessages.join('\\n');\n  }\n  span.addEvent(axSpanEvents.GEN_AI_USER_MESSAGE, userEventData);\n}\n\nexport function setChatResponseEvents(\n  res: Readonly<AxChatResponse>,\n  span: Span,\n  excludeContentFromTrace?: boolean\n) {\n  if (res.modelUsage?.tokens) {\n    const thoughtsTokensEntry = res.modelUsage.tokens.thoughtsTokens\n      ? {\n          [axSpanAttributes.LLM_USAGE_THOUGHTS_TOKENS]:\n            res.modelUsage.tokens.thoughtsTokens,\n        }\n      : {};\n    span.addEvent(axSpanEvents.GEN_AI_USAGE, {\n      [axSpanAttributes.LLM_USAGE_INPUT_TOKENS]:\n        res.modelUsage.tokens.promptTokens,\n      [axSpanAttributes.LLM_USAGE_OUTPUT_TOKENS]:\n        res.modelUsage.tokens.completionTokens ?? 0,\n      [axSpanAttributes.LLM_USAGE_TOTAL_TOKENS]:\n        res.modelUsage.tokens.totalTokens,\n      ...thoughtsTokensEntry,\n    });\n  }\n\n  if (!res.results) {\n    return;\n  }\n\n  for (let index = 0; index < res.results.length; index++) {\n    const result = res.results[index];\n    if (!result) {\n      continue;\n    }\n\n    // Skip empty results that have no meaningful content to avoid empty GEN_AI_CHOICE events\n    if (\n      !result.content &&\n      !result.thought &&\n      !result.functionCalls?.length &&\n      !result.finishReason\n    ) {\n      continue;\n    }\n\n    const toolCalls = result.functionCalls?.map((call) => {\n      return {\n        id: call.id,\n        type: call.type,\n        function: call.function.name,\n        arguments: call.function.params,\n      };\n    });\n\n    const message: { content?: string; tool_calls?: unknown[] } = {};\n\n    if (toolCalls && toolCalls.length > 0) {\n      if (!excludeContentFromTrace) {\n        message.content = result.content;\n      }\n      message.tool_calls = toolCalls;\n    } else {\n      if (!excludeContentFromTrace) {\n        message.content = result.content ?? '';\n      }\n    }\n\n    span.addEvent(axSpanEvents.GEN_AI_CHOICE, {\n      finish_reason: result.finishReason,\n      index,\n      message: JSON.stringify(message, null, 2),\n    });\n  }\n}\n\nexport function validateAxMessageArray<T>(\n  values: ReadonlyArray<AxMessage<T>>\n): void {\n  let index = 0;\n  for (const message of values) {\n    if (!message || typeof message !== 'object') {\n      throw new Error(\n        `AxMessage array validation failed: Item at index ${index} is not a valid message object`\n      );\n    }\n    if (message.role !== 'user' && message.role !== 'assistant') {\n      throw new Error(\n        `AxMessage array validation failed: Item at index ${index} has invalid role: ${\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (message as any).role\n        }`\n      );\n    }\n    // The current AxMessage design accepts any \"values\" payload. Do not enforce non-empty object.\n    index++;\n  }\n}\n\nfunction _validateModels<TModel, TEmbedModel, TModelKey>(\n  models: Readonly<AxAIInputModelList<TModel, TEmbedModel, TModelKey>>\n): void {\n  // Validate duplicate keys in models.\n  const keys = new Set<TModelKey>();\n  for (const model of models) {\n    if (keys.has(model.key)) {\n      throw new Error(\n        `Duplicate model key detected: \"${model.key}\". Each model key must be unique.`\n      );\n    }\n    keys.add(model.key);\n  }\n}\n","import type { Meter, Tracer } from '@opentelemetry/api';\n\nimport type { AxLoggerFunction } from '../ai/types.js';\nimport type { AxOptimizerLoggerFunction } from './optimizerTypes.js';\n\nexport type AxFunctionResultFormatter = (result: unknown) => string;\n\nexport const axGlobals = {\n  signatureStrict: true, // Controls reservedNames enforcement in signature parsing/validation\n  tracer: undefined as Tracer | undefined, // Global OpenTelemetry tracer for all AI operations\n  meter: undefined as Meter | undefined, // Global OpenTelemetry meter for metrics collection\n  logger: undefined as AxLoggerFunction | undefined, // Global logger for all AI operations\n  optimizerLogger: undefined as AxOptimizerLoggerFunction | undefined, // Global optimizer logger for all optimizer operations\n  debug: undefined as boolean | undefined, // Global debug setting for all AI operations\n  functionResultFormatter: ((result: unknown) => {\n    return typeof result === 'string'\n      ? result\n      : result === undefined || result === null\n        ? ''\n        : JSON.stringify(result, null, 2);\n  }) as AxFunctionResultFormatter, // Global function result formatter\n};\n","export class ColorLog {\n  // ANSI escape codes for different colors\n  private readonly ANSI_WHITE_BRIGHT = '\\x1b[97m';\n  private readonly ANSI_GREEN_BRIGHT = '\\x1b[92m';\n  private readonly ANSI_BLUE_BRIGHT = '\\x1b[94m';\n  private readonly ANSI_RED_BRIGHT = '\\x1b[91m';\n  private readonly ANSI_YELLOW_BRIGHT = '\\x1b[93m';\n\n  private readonly ANSI_YELLOW = '\\x1b[93m';\n  private readonly ANSI_RED = '\\x1b[91m';\n  private readonly ANSI_RESET = '\\x1b[0m';\n  private readonly ANSI_ORANGE = '\\x1b[38;5;208m';\n  private readonly ANSI_WHITE = '\\x1b[37m';\n  private readonly ANSI_CYAN_BRIGHT = '\\x1b[96m';\n  private readonly ANSI_MAGENTA_BRIGHT = '\\x1b[95m';\n  private readonly ANSI_GRAY = '\\x1b[90m';\n\n  private readonly ANSI_GREEN = '\\x1b[32m';\n  private readonly ANSI_CYAN = '\\x1b[36m';\n  private readonly ANSI_MAGENTA = '\\x1b[35m';\n  private readonly ANSI_BLUE = '\\x1b[34m';\n  private readonly ANSI_YELLOW_DIM = '\\x1b[33m';\n\n  // Method to wrap text with the specified ANSI color code\n  private colorize(text: string, colorCode: string): string {\n    return `${colorCode}${text}${this.ANSI_RESET}`;\n  }\n\n  // Public methods to colorize text in various colors\n  public whiteBright(text: string): string {\n    return this.colorize(text, this.ANSI_WHITE_BRIGHT);\n  }\n\n  public greenBright(text: string): string {\n    return this.colorize(text, this.ANSI_GREEN_BRIGHT);\n  }\n\n  public blueBright(text: string): string {\n    return this.colorize(text, this.ANSI_BLUE_BRIGHT);\n  }\n\n  public redBright(text: string): string {\n    return this.colorize(text, this.ANSI_RED_BRIGHT);\n  }\n\n  public white(text: string): string {\n    return this.colorize(text, this.ANSI_WHITE);\n  }\n\n  public yellow(text: string): string {\n    return this.colorize(text, this.ANSI_YELLOW);\n  }\n\n  public yellowBright(text: string): string {\n    return this.colorize(text, this.ANSI_YELLOW_BRIGHT);\n  }\n\n  public red(text: string): string {\n    return this.colorize(text, this.ANSI_RED);\n  }\n\n  public orange(text: string): string {\n    return this.colorize(text, this.ANSI_ORANGE);\n  }\n\n  public cyanBright(text: string): string {\n    return this.colorize(text, this.ANSI_CYAN_BRIGHT);\n  }\n\n  public magentaBright(text: string): string {\n    return this.colorize(text, this.ANSI_MAGENTA_BRIGHT);\n  }\n\n  public gray(text: string): string {\n    return this.colorize(text, this.ANSI_GRAY);\n  }\n\n  public green(text: string): string {\n    return this.colorize(text, this.ANSI_GREEN);\n  }\n\n  public cyan(text: string): string {\n    return this.colorize(text, this.ANSI_CYAN);\n  }\n\n  public magenta(text: string): string {\n    return this.colorize(text, this.ANSI_MAGENTA);\n  }\n\n  public blue(text: string): string {\n    return this.colorize(text, this.ANSI_BLUE);\n  }\n\n  public yellowDim(text: string): string {\n    return this.colorize(text, this.ANSI_YELLOW_DIM);\n  }\n}\n","import type {\n  AxChatRequest,\n  AxLoggerData,\n  AxLoggerFunction,\n} from '../ai/types.js';\nimport { ColorLog } from '../util/log.js';\n\nconst _colorLog = new ColorLog();\n\n// Default output function that writes to stdout\nconst defaultOutput = (message: string): void => {\n  console.log(message);\n};\n\n// Helper function to format chat message for display\nconst formatChatMessage = (\n  msg: AxChatRequest['chatPrompt'][number],\n  hideContent?: boolean,\n  cl?: ColorLog\n) => {\n  const colorize = (text: string, colorMethod?: keyof ColorLog) => {\n    if (cl && colorMethod && colorMethod in cl) {\n      return (cl[colorMethod] as (t: string) => string)(text);\n    }\n    return text;\n  };\n\n  switch (msg.role) {\n    case 'system':\n      return `${colorize('[ SYSTEM ]', 'magentaBright')}\\n${colorize(msg.content, 'magenta')}`;\n    case 'function':\n      return `${colorize('[ FUNCTION RESULT ]', 'yellow')}\\n${colorize(msg.result ?? '[No result]', 'yellowDim')}`;\n    case 'user': {\n      const header = `${colorize('[ USER ]', 'greenBright')}\\n`;\n      if (typeof msg.content === 'string') {\n        return header + colorize(msg.content, 'green');\n      }\n      const items = msg.content.map((item) => {\n        if (item.type === 'text') {\n          return colorize(item.text, 'green');\n        }\n        if (item.type === 'image') {\n          const content = hideContent ? '[Image]' : `[Image: ${item.image}]`;\n          return colorize(content, 'green');\n        }\n        if (item.type === 'audio') {\n          const content = hideContent ? '[Audio]' : `[Audio: ${item.data}]`;\n          return colorize(content, 'green');\n        }\n        return colorize('[Unknown content type]', 'gray');\n      });\n      return header + items.join('\\n');\n    }\n    case 'assistant': {\n      let header = colorize('[ ASSISTANT', 'cyanBright');\n      if (msg.name) {\n        header += ` ${msg.name}`;\n      }\n      header += ' ]';\n      let result = `${header}\\n`;\n      if (msg.content) {\n        result += `${colorize(msg.content, 'cyan')}\\n`;\n      }\n      if (msg.functionCalls && msg.functionCalls.length > 0) {\n        result += `${colorize('[ FUNCTION CALLS ]', 'yellow')}\\n`;\n        msg.functionCalls.forEach((call, i) => {\n          const params =\n            typeof call.function.params === 'string'\n              ? call.function.params\n              : JSON.stringify(call.function.params, null, 2);\n          result += colorize(\n            `${i + 1}. ${call.function.name}(${params}) [id: ${call.id}]`,\n            'yellowDim'\n          );\n          if (i < (msg.functionCalls?.length ?? 0) - 1) {\n            result += '\\n';\n          }\n        });\n        result += '\\n';\n      }\n      if (\n        !msg.content &&\n        (!msg.functionCalls || msg.functionCalls.length === 0)\n      ) {\n        result += colorize('[No content]', 'gray');\n      }\n      return result;\n    }\n    default:\n      return `${colorize('[ UNKNOWN ]', 'redBright')}\\n${colorize(JSON.stringify(msg), 'gray')}`;\n  }\n};\n\n// Factory function to create a default logger with customizable output\nexport const axCreateDefaultColorLogger = (\n  output: (message: string) => void = defaultOutput\n): AxLoggerFunction => {\n  const cl = new ColorLog();\n  const divider = cl.gray(`${''.repeat(60)}\\n`);\n  return (message: AxLoggerData) => {\n    const typedData = message;\n    let formattedMessage = '';\n\n    switch (typedData.name) {\n      case 'ChatRequestChatPrompt':\n        formattedMessage = `\\n${cl.blueBright(`[ CHAT REQUEST Step ${typedData.step} ]`)}\\n${divider}\\n`;\n        typedData.value.forEach((msg, i) => {\n          formattedMessage += formatChatMessage(msg, undefined, cl);\n          if (i < typedData.value.length - 1)\n            formattedMessage += `\\n${divider}\\n`;\n        });\n        formattedMessage += `\\n${divider}`; // Keep closing for steps\n        break;\n      case 'FunctionResults':\n        formattedMessage = `\\n${cl.yellow('[ FUNCTION RESULTS ]')}\\n`;\n        typedData.value.forEach((result, i) => {\n          formattedMessage += cl.yellowDim(\n            `Function: ${result.functionId}\\nResult: ${result.result}`\n          );\n          if (i < typedData.value.length - 1)\n            formattedMessage += `\\n${divider}\\n`;\n        });\n        break;\n      case 'ChatResponseResults':\n        formattedMessage = `\\n${cl.cyanBright('[ CHAT RESPONSE ]')}\\n`;\n        typedData.value.forEach((result, i) => {\n          const lines: string[] = [];\n          if (result.thoughtBlock?.data || result.thought) {\n            lines.push(\n              cl.gray(\n                `[THOUGHT${result.thoughtBlock?.encrypted ? ' (redacted)' : ''}]\\n` +\n                  (result.thoughtBlock?.data ?? result.thought ?? '')\n              )\n            );\n          }\n          if (result.content) {\n            lines.push(cl.cyan(result.content));\n          }\n          if (lines.length === 0) {\n            lines.push(cl.gray('[No content]'));\n          }\n          formattedMessage += lines.join('\\n');\n          if (i < typedData.value.length - 1)\n            formattedMessage += `\\n${divider}\\n`;\n        });\n        break;\n      case 'ChatResponseStreamingResult': {\n        const thought = typedData.value.thought;\n        const streamingContent =\n          thought || typedData.value.delta || typedData.value.content || '';\n        formattedMessage = thought\n          ? cl.gray(`[THOUGHT]\\n${thought}`)\n          : cl.cyanBright(streamingContent);\n        break;\n      }\n      case 'ChatResponseStreamingDoneResult': {\n        formattedMessage = `\\n${cl.cyanBright('[ CHAT RESPONSE ]')}\\n${divider}\\n`;\n        if (typedData.value.content) {\n          formattedMessage += cl.cyanBright(typedData.value.content);\n        }\n        if (typedData.value.thoughtBlock?.data || typedData.value.thought) {\n          formattedMessage += `\\n`;\n          formattedMessage += cl.gray(\n            `[THOUGHT${typedData.value.thoughtBlock?.encrypted ? ' (redacted)' : ''}]\\n` +\n              (typedData.value.thoughtBlock?.data ??\n                typedData.value.thought ??\n                '')\n          );\n        }\n        if (typedData.value.functionCalls) {\n          formattedMessage += cl.cyanBright(\n            JSON.stringify(typedData.value.functionCalls, null, 2)\n          );\n        }\n        break;\n      }\n      case 'FunctionError':\n        formattedMessage = `\\n${cl.redBright(`[ FUNCTION ERROR #${typedData.index} ]`)}\\n${divider}\\n${cl.white(typedData.fixingInstructions)}\\n${cl.red(`Error: ${typedData.error}`)}`;\n        break;\n      case 'ValidationError':\n        formattedMessage = `\\n${cl.redBright(`[ VALIDATION ERROR #${typedData.index} ]`)}\\n${divider}\\n${cl.white(typedData.fixingInstructions)}\\n${cl.red(`Error: ${typedData.error}`)}`;\n        break;\n      case 'AssertionError':\n        formattedMessage = `\\n${cl.redBright(`[ ASSERTION ERROR #${typedData.index} ]`)}\\n${divider}\\n${cl.white(typedData.fixingInstructions)}\\n${cl.red(`Error: ${typedData.error}`)}`;\n        break;\n      case 'ResultPickerUsed':\n        formattedMessage = `${cl.greenBright('[ RESULT PICKER ]')}\\n${divider}\\n${cl.green(`Selected sample ${typedData.selectedIndex + 1} of ${typedData.sampleCount} (${typedData.latency.toFixed(2)}ms)`)}`;\n        break;\n      case 'Notification':\n        formattedMessage = `${cl.gray(`[ NOTIFICATION ${typedData.id} ]`)}\\n${divider}\\n${cl.white(typedData.value)}`;\n        break;\n      case 'EmbedRequest':\n        formattedMessage = `${cl.orange(`[ EMBED REQUEST ${typedData.embedModel} ]`)}\\n${divider}\\n`;\n        typedData.value.forEach((text, i) => {\n          formattedMessage += cl.white(\n            `Text ${i + 1}: ${text.substring(0, 100)}${text.length > 100 ? '...' : ''}`\n          );\n          if (i < typedData.value.length - 1)\n            formattedMessage += `\\n${divider}\\n`;\n        });\n        break;\n      case 'EmbedResponse':\n        formattedMessage = `${cl.orange(`[ EMBED RESPONSE (${typedData.totalEmbeddings} embeddings) ]`)}\\n${divider}\\n`;\n        typedData.value.forEach((embedding, i) => {\n          formattedMessage += cl.white(\n            `Embedding ${i + 1}: [${embedding.sample.join(', ')}${embedding.truncated ? ', ...' : ''}] (length: ${embedding.length})`\n          );\n          if (i < typedData.value.length - 1)\n            formattedMessage += `\\n${divider}\\n`;\n        });\n        break;\n      case 'ChatResponseUsage': {\n        formattedMessage = `${cl.greenBright('\\n[ CHAT RESPONSE USAGE ]')}\\n`;\n        const usage = typedData.value;\n        formattedMessage += `${cl.white('AI:')} ${usage.ai}\\n`;\n        formattedMessage += `${cl.white('Model:')} ${usage.model}\\n`;\n        if (usage.tokens) {\n          formattedMessage += `${cl.white('Total Tokens:')} ${usage.tokens.totalTokens}\\n`;\n          formattedMessage += `${cl.white('Prompt Tokens:')} ${usage.tokens.promptTokens}\\n`;\n          formattedMessage += `${cl.white('Completion Tokens:')} ${usage.tokens.completionTokens}\\n`;\n          if (usage.tokens.thoughtsTokens !== undefined) {\n            formattedMessage += `${cl.white('Thoughts Tokens:')} ${usage.tokens.thoughtsTokens}\\n`;\n          }\n          if (usage.tokens.reasoningTokens !== undefined) {\n            formattedMessage += `${cl.white('Reasoning Tokens:')} ${usage.tokens.reasoningTokens}\\n`;\n          }\n          if (usage.tokens.cacheCreationTokens !== undefined) {\n            formattedMessage += `${cl.white('Cache Creation Tokens:')} ${usage.tokens.cacheCreationTokens}\\n`;\n          }\n          if (usage.tokens.cacheReadTokens !== undefined) {\n            formattedMessage += `${cl.white('Cache Read Tokens:')} ${usage.tokens.cacheReadTokens}\\n`;\n          }\n          if (usage.tokens.serviceTier !== undefined) {\n            formattedMessage += `${cl.white('Service Tier:')} ${usage.tokens.serviceTier}\\n`;\n          }\n        }\n        formattedMessage += divider;\n        break;\n      }\n      case 'ChatResponseCitations': {\n        formattedMessage = `${cl.blueBright('\\n[ CHAT RESPONSE CITATIONS ]')}\\n`;\n        typedData.value.forEach((citation) => {\n          formattedMessage += `${cl.white('- ')}${cl.cyan(citation.title || citation.url)}\\n`;\n          if (citation.description) {\n            formattedMessage += `  ${cl.gray(citation.description)}\\n`;\n          }\n        });\n        formattedMessage += divider;\n        break;\n      }\n      default:\n        formattedMessage = cl.gray(JSON.stringify(typedData, null, 2));\n    }\n\n    output(formattedMessage);\n  };\n};\n\nexport const defaultLogger: AxLoggerFunction = axCreateDefaultColorLogger();\n\n// Factory function to create a text-only logger (no colors) with customizable output\nexport const axCreateDefaultTextLogger = (\n  output: (message: string) => void = defaultOutput\n): AxLoggerFunction => {\n  const divider = ''.repeat(60);\n  return (message: AxLoggerData) => {\n    const typedData = message;\n    let formattedMessage = '';\n\n    switch (typedData.name) {\n      case 'ChatRequestChatPrompt':\n        formattedMessage = `\\n[ CHAT REQUEST Step ${typedData.step} ]\\n${divider}\\n`;\n        typedData.value.forEach((msg, i) => {\n          formattedMessage += formatChatMessage(msg);\n          if (i < typedData.value.length - 1)\n            formattedMessage += `\\n${divider}\\n`;\n        });\n        formattedMessage += `\\n${divider}`; // Keep closing for steps\n        break;\n      case 'FunctionResults':\n        formattedMessage = `\\n[ FUNCTION RESULTS ]\\n${divider}\\n`;\n        typedData.value.forEach((result, i) => {\n          formattedMessage += `Function: ${result.functionId}\\nResult: ${result.result}`;\n          if (i < typedData.value.length - 1)\n            formattedMessage += `\\n${divider}\\n`;\n        });\n        break;\n      case 'ChatResponseResults':\n        formattedMessage = '\\n[ CHAT RESPONSE ]\\n';\n        typedData.value.forEach((result, i) => {\n          const lines: string[] = [];\n          if (result.thoughtBlock?.data || result.thought) {\n            lines.push(\n              `[thought${result.thoughtBlock?.encrypted ? ' (redacted)' : ''}] ` +\n                (result.thoughtBlock?.data ?? result.thought ?? '')\n            );\n          }\n          if (result.content) {\n            lines.push(result.content);\n          }\n          if (lines.length === 0) {\n            lines.push('[No content]');\n          }\n          formattedMessage += lines.join('\\n');\n          if (i < typedData.value.length - 1)\n            formattedMessage += `\\n${divider}\\n`;\n        });\n        break;\n      case 'ChatResponseStreamingResult': {\n        // const streamingContent =\n        //   typedData.value.delta || typedData.value.content || '';\n        // // Add newline prefix if this is actual content (not just a delta)\n        // formattedMessage = streamingContent;\n        return;\n      }\n      case 'ChatResponseStreamingDoneResult': {\n        formattedMessage = '\\n[ CHAT RESPONSE ]\\n';\n        if (typedData.value.content) {\n          formattedMessage += typedData.value.content;\n        }\n        if (typedData.value.thoughtBlock?.data || typedData.value.thought) {\n          formattedMessage += `\\n`;\n          formattedMessage +=\n            `[thought${typedData.value.thoughtBlock?.encrypted ? ' (redacted)' : ''}] ` +\n            (typedData.value.thoughtBlock?.data ??\n              typedData.value.thought ??\n              '');\n        }\n        if (typedData.value.functionCalls) {\n          formattedMessage += JSON.stringify(\n            typedData.value.functionCalls,\n            null,\n            2\n          );\n        }\n        break;\n      }\n      case 'FunctionError':\n        formattedMessage = `\\n[ FUNCTION ERROR #${typedData.index} ]\\n${divider}\\n${typedData.fixingInstructions}\\nError: ${typedData.error}`;\n        break;\n      case 'ValidationError':\n        formattedMessage = `\\n[ VALIDATION ERROR #${typedData.index} ]\\n${divider}\\n${typedData.fixingInstructions}\\nError: ${typedData.error}`;\n        break;\n      case 'AssertionError':\n        formattedMessage = `\\n[ ASSERTION ERROR #${typedData.index} ]\\n${divider}\\n${typedData.fixingInstructions}\\nError: ${typedData.error}`;\n        break;\n      case 'ResultPickerUsed':\n        formattedMessage = `[ RESULT PICKER ]\\n${divider}\\nSelected sample ${typedData.selectedIndex + 1} of ${typedData.sampleCount} (${typedData.latency.toFixed(2)}ms)`;\n        break;\n      case 'Notification':\n        formattedMessage = `[ NOTIFICATION ${typedData.id} ]\\n${divider}\\n${typedData.value}`;\n        break;\n      case 'EmbedRequest':\n        formattedMessage = `[ EMBED REQUEST ${typedData.embedModel} ]\\n${divider}\\n`;\n        typedData.value.forEach((text, i) => {\n          formattedMessage += `Text ${i + 1}: ${text.substring(0, 100)}${text.length > 100 ? '...' : ''}`;\n          if (i < typedData.value.length - 1)\n            formattedMessage += `\\n${divider}\\n`;\n        });\n        break;\n      case 'EmbedResponse':\n        formattedMessage = `[ EMBED RESPONSE (${typedData.totalEmbeddings} embeddings) ]\\n${divider}\\n`;\n        typedData.value.forEach((embedding, i) => {\n          formattedMessage += `Embedding ${i + 1}: [${embedding.sample.join(', ')}${embedding.truncated ? ', ...' : ''}] (length: ${embedding.length})`;\n          if (i < typedData.value.length - 1)\n            formattedMessage += `\\n${divider}\\n`;\n        });\n        break;\n      case 'ChatResponseUsage': {\n        formattedMessage = '\\n[ CHAT RESPONSE USAGE ]\\n';\n        const textUsage = typedData.value;\n        formattedMessage += `AI: ${textUsage.ai}\\n`;\n        formattedMessage += `Model: ${textUsage.model}\\n`;\n        if (textUsage.tokens) {\n          formattedMessage += `Total Tokens: ${textUsage.tokens.totalTokens}\\n`;\n          formattedMessage += `Prompt Tokens: ${textUsage.tokens.promptTokens}\\n`;\n          formattedMessage += `Completion Tokens: ${textUsage.tokens.completionTokens}\\n`;\n          if (textUsage.tokens.thoughtsTokens !== undefined) {\n            formattedMessage += `Thoughts Tokens: ${textUsage.tokens.thoughtsTokens}\\n`;\n          }\n          if (textUsage.tokens.reasoningTokens !== undefined) {\n            formattedMessage += `Reasoning Tokens: ${textUsage.tokens.reasoningTokens}\\n`;\n          }\n          if (textUsage.tokens.cacheCreationTokens !== undefined) {\n            formattedMessage += `Cache Creation Tokens: ${textUsage.tokens.cacheCreationTokens}\\n`;\n          }\n          if (textUsage.tokens.cacheReadTokens !== undefined) {\n            formattedMessage += `Cache Read Tokens: ${textUsage.tokens.cacheReadTokens}\\n`;\n          }\n          if (textUsage.tokens.serviceTier !== undefined) {\n            formattedMessage += `Service Tier: ${textUsage.tokens.serviceTier}\\n`;\n          }\n        }\n        formattedMessage += `${divider}\\n`;\n        break;\n      }\n      case 'ChatResponseCitations': {\n        formattedMessage = '\\n[ CHAT RESPONSE CITATIONS ]\\n';\n        typedData.value.forEach((citation) => {\n          formattedMessage += `- ${citation.title || citation.url}\\n`;\n          if (citation.description) {\n            formattedMessage += `  ${citation.description}\\n`;\n          }\n        });\n        formattedMessage += `${divider}\\n`;\n        break;\n      }\n      default:\n        formattedMessage = JSON.stringify(typedData, null, 2);\n    }\n\n    output(formattedMessage);\n  };\n};\n","export const axSpanAttributes = {\n  // LLM\n  LLM_SYSTEM: 'gen_ai.system',\n  LLM_OPERATION_NAME: 'gen_ai.operation.name',\n  LLM_REQUEST_MODEL: 'gen_ai.request.model',\n  LLM_REQUEST_MAX_TOKENS: 'gen_ai.request.max_tokens',\n  LLM_REQUEST_TEMPERATURE: 'gen_ai.request.temperature',\n  LLM_REQUEST_TOP_K: 'gen_ai.request.top_k',\n  LLM_REQUEST_FREQUENCY_PENALTY: 'gen_ai.request.frequency_penalty',\n  LLM_REQUEST_PRESENCE_PENALTY: 'gen_ai.request.presence_penalty',\n  LLM_REQUEST_STOP_SEQUENCES: 'gen_ai.request.stop_sequences',\n  LLM_REQUEST_LLM_IS_STREAMING: 'gen_ai.request.llm_is_streaming',\n  LLM_REQUEST_TOP_P: 'gen_ai.request.top_p',\n\n  LLM_USAGE_INPUT_TOKENS: 'gen_ai.usage.input_tokens',\n  LLM_USAGE_OUTPUT_TOKENS: 'gen_ai.usage.output_tokens',\n  LLM_USAGE_TOTAL_TOKENS: 'gen_ai.usage.total_tokens',\n  LLM_USAGE_THOUGHTS_TOKENS: 'gen_ai.usage.thoughts_tokens',\n\n  // Vector DB\n  DB_SYSTEM: 'db.system',\n  DB_TABLE: 'db.table',\n  DB_NAMESPACE: 'db.namespace',\n  DB_ID: 'db.id',\n  DB_QUERY_TEXT: 'db.query.text',\n  DB_VECTOR: 'db.vector',\n  DB_OPERATION_NAME: 'db.operation.name',\n  DB_VECTOR_QUERY_TOP_K: 'db.vector.query.top_k',\n\n  DB_QUERY_EMBEDDINGS: 'db.query.embeddings',\n  DB_QUERY_RESULT: 'db.query.result',\n\n  // Query Embeddings\n  DB_QUERY_EMBEDDINGS_VECTOR: 'db.query.embeddings.vector',\n\n  // Query Result (canonical format)\n  DB_QUERY_RESULT_ID: 'db.query.result.id',\n  DB_QUERY_RESULT_SCORE: 'db.query.result.score',\n  DB_QUERY_RESULT_DISTANCE: 'db.query.result.distance',\n  DB_QUERY_RESULT_METADATA: 'db.query.result.metadata',\n  DB_QUERY_RESULT_VECTOR: 'db.query.result.vector',\n  DB_QUERY_RESULT_DOCUMENT: 'db.query.result.document',\n};\n\nexport const axSpanEvents = {\n  GEN_AI_USER_MESSAGE: 'gen_ai.user.message',\n  GEN_AI_SYSTEM_MESSAGE: 'gen_ai.system.message',\n  GEN_AI_ASSISTANT_MESSAGE: 'gen_ai.assistant.message',\n  GEN_AI_TOOL_MESSAGE: 'gen_ai.tool.message', // For tool messages in request & response tool calls\n  GEN_AI_CHOICE: 'gen_ai.choice',\n  GEN_AI_USAGE: 'gen_ai.usage',\n};\n\nexport enum AxLLMRequestTypeValues {\n  COMPLETION = 'completion',\n  CHAT = 'chat',\n  RERANK = 'rerank',\n  UNKNOWN = 'unknown',\n}\n\nexport enum AxSpanKindValues {\n  WORKFLOW = 'workflow',\n  TASK = 'task',\n  AGENT = 'agent',\n  TOOL = 'tool',\n  UNKNOWN = 'unknown',\n}\n","// Web Streams API types are now available globally via DOM types in tsconfig\n\nclass TypeTransformer<I, O> implements Transformer<I, O> {\n  private buffer?: O[];\n  private doneCallback?: (args0: readonly O[]) => Promise<void>;\n  private transformFn: (arg0: I) => O;\n\n  constructor(\n    transformFn: (arg0: I) => O,\n    doneCallback?: (args0: readonly O[]) => Promise<void>\n  ) {\n    this.transformFn = transformFn;\n    this.doneCallback = doneCallback;\n    this.buffer = doneCallback ? [] : undefined;\n  }\n\n  async transform(obj: I, controller: TransformStreamDefaultController<O>) {\n    const val = this.transformFn(obj);\n    if (val) {\n      controller.enqueue(val);\n      this.buffer?.push(val);\n    }\n  }\n\n  async flush(controller: TransformStreamDefaultController<O>) {\n    await this.doneCallback?.(this.buffer ?? []);\n    controller.terminate();\n  }\n}\n\nexport class RespTransformStream<I, O> extends TransformStream<I, O> {\n  constructor(\n    transformFn: (arg0: I) => O,\n    doneCallback?: (args0: readonly O[]) => Promise<void>\n  ) {\n    super(new TypeTransformer<I, O>(transformFn, doneCallback));\n  }\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\nimport { createHash } from '../util/crypto.js';\n\nimport type { AxChatResponseResult, AxModelInfo } from './types.js';\n\nexport const findItemByNameOrAlias = (\n  list: readonly AxModelInfo[],\n  name: string\n): AxModelInfo | undefined => {\n  for (const item of list) {\n    if (item.name === name || item.aliases?.includes(name)) {\n      return item;\n    }\n  }\n  return undefined;\n};\n\nexport const uniqBy = <T>(\n  array: readonly T[],\n  uniqueField: (value: T) => unknown\n): T[] => {\n  const uniqueValues = new Map();\n\n  array.forEach((value: T) => {\n    const field = uniqueField(value);\n\n    if (!uniqueValues.has(field)) {\n      uniqueValues.set(field, value);\n    }\n  });\n\n  return Array.from(uniqueValues.values());\n};\n\nconst functionCallRe = /(\\w+)\\((.*)\\)/s;\n\nexport const parseFunction = (\n  value: string\n): { name: string; args?: string } | undefined => {\n  let v: string[] | null;\n\n  // extract function calls\n  v = functionCallRe.exec(value);\n  if (v !== null) {\n    const name = v.at(1)?.trim();\n    const args = v.at(2)?.trim();\n    if (!name || name.length === 0) {\n      throw new Error(`Invalid function format: ${value}`);\n    }\n    return { name, args };\n  }\n  return;\n};\n\nexport interface mergeFunctionsState {\n  lastId?: string;\n}\n\nexport function mergeFunctionCalls(\n  functionCalls: NonNullable<AxChatResponseResult['functionCalls']>,\n  functionCallDeltas: Readonly<\n    NonNullable<AxChatResponseResult['functionCalls']>\n  >\n) {\n  for (const Fc of functionCallDeltas) {\n    const fc = functionCalls.find((fc) => fc.id === Fc.id);\n\n    if (fc) {\n      if (typeof Fc.function.name === 'string' && Fc.function.name.length > 0) {\n        fc.function.name += Fc.function.name;\n      }\n\n      if (\n        typeof Fc.function.params === 'string' &&\n        Fc.function.params.length > 0\n      ) {\n        fc.function.params += Fc.function.params;\n      }\n\n      if (typeof Fc.function.params === 'object') {\n        fc.function.params = Fc.function.params;\n      }\n    } else {\n      functionCalls.push(Fc);\n    }\n  }\n}\n\nexport const hashObject = (obj: object) => {\n  const hash = createHash('sha256');\n  hash.update(JSON.stringify(obj));\n  return hash.digest('hex');\n};\n","import type {\n  AxChatRequest,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxFunctionResult,\n  AxLoggerData,\n  AxLoggerFunction,\n} from './types.js';\nimport { mergeFunctionCalls } from './util.js';\n\nexport const logChatRequest = (\n  chatPrompt: Readonly<AxChatRequest['chatPrompt']>,\n  step: number,\n  logger: AxLoggerFunction,\n  hideSystemPrompt?: boolean\n) => {\n  // Filter out system messages if hideSystemPrompt is true\n  const filteredPrompt = hideSystemPrompt\n    ? chatPrompt.filter((msg) => msg.role !== 'system')\n    : [...chatPrompt]; // Create a mutable copy\n\n  const loggerData: AxLoggerData = {\n    name: 'ChatRequestChatPrompt',\n    step,\n    value: filteredPrompt as AxChatRequest['chatPrompt'],\n  };\n\n  logger(loggerData);\n};\n\nexport const logResponseResult = (\n  r: Readonly<AxChatResponse['results'][number] & { index: number }>,\n  logger: AxLoggerFunction\n) => {\n  const loggerData: AxLoggerData = {\n    name: 'ChatResponseResults',\n    value: [r],\n  };\n\n  logger(loggerData);\n};\n\nexport const logResponse = (\n  resp: Readonly<AxChatResponse>,\n  logger: AxLoggerFunction\n) => {\n  if (!resp.results) {\n    return;\n  }\n\n  const loggerData: AxLoggerData = {\n    name: 'ChatResponseResults',\n    value: resp.results as AxChatResponseResult[],\n  };\n\n  logger(loggerData);\n};\n\nexport const logResponseStreamingResult = (\n  result: AxChatResponseResult & { delta?: string },\n  index: number,\n  logger: AxLoggerFunction\n) => {\n  const loggerData: AxLoggerData = {\n    name: 'ChatResponseStreamingResult',\n    index,\n    value: result,\n  };\n\n  logger(loggerData);\n};\n\nexport function logResponseStreamingDoneResult(\n  values: readonly AxChatResponse[],\n  logger: AxLoggerFunction\n): void {\n  // Combine results by index\n  const combinedResults = new Map<number, AxChatResponseResult>();\n\n  for (const value of values) {\n    for (const result of value.results) {\n      if (!result) {\n        continue;\n      }\n\n      let existing = combinedResults.get(result.index);\n      if (!existing) {\n        existing = structuredClone(result);\n        combinedResults.set(result.index, existing);\n      } else {\n        if (result.content) {\n          existing.content = (existing.content ?? '') + result.content;\n        }\n        if (result.thought) {\n          existing.thought = (existing.thought ?? '') + result.thought;\n        }\n        if (result.finishReason) {\n          existing.finishReason = result.finishReason;\n        }\n        if (result.functionCalls) {\n          if (existing.functionCalls) {\n            mergeFunctionCalls(\n              existing.functionCalls,\n              structuredClone(result.functionCalls)\n            );\n          } else {\n            existing.functionCalls = structuredClone(result.functionCalls);\n          }\n        }\n      }\n    }\n  }\n\n  // Log each combined result\n  for (const result of combinedResults.values()) {\n    const loggerData: AxLoggerData = {\n      name: 'ChatResponseStreamingDoneResult',\n      index: result.index,\n      value: result,\n    };\n\n    logger(loggerData);\n  }\n}\n\nexport const logFunctionResults = (\n  results: Readonly<AxFunctionResult[]>,\n  logger: AxLoggerFunction\n) => {\n  const loggerData: AxLoggerData = {\n    name: 'FunctionResults',\n    value: results as AxFunctionResult[],\n  };\n\n  logger(loggerData);\n};\n\nexport const logFunctionError = (\n  error: unknown,\n  index: number,\n  fixingInstructions: string,\n  logger: AxLoggerFunction\n) => {\n  const loggerData: AxLoggerData = {\n    name: 'FunctionError',\n    index,\n    fixingInstructions,\n    error,\n  };\n\n  logger(loggerData);\n};\n\nexport const logValidationError = (\n  error: unknown,\n  index: number,\n  fixingInstructions: string,\n  logger: AxLoggerFunction\n) => {\n  const loggerData: AxLoggerData = {\n    name: 'ValidationError',\n    index,\n    fixingInstructions,\n    error,\n  };\n\n  logger(loggerData);\n};\n\nexport const logAssertionError = (\n  error: unknown,\n  index: number,\n  fixingInstructions: string,\n  logger: AxLoggerFunction\n) => {\n  const loggerData: AxLoggerData = {\n    name: 'AssertionError',\n    index,\n    fixingInstructions,\n    error,\n  };\n\n  logger(loggerData);\n};\n\nexport const logRefusalError = (\n  error: unknown,\n  index: number,\n  logger: AxLoggerFunction\n) => {\n  const loggerData: AxLoggerData = {\n    name: 'RefusalError',\n    index,\n    error,\n  };\n\n  logger(loggerData);\n};\n\nexport const logNotification = (\n  id: string,\n  value: string,\n  logger: AxLoggerFunction\n) => {\n  const loggerData: AxLoggerData = {\n    name: 'Notification',\n    id,\n    value,\n  };\n\n  logger(loggerData);\n};\n\nexport const logEmbedRequest = (\n  texts: readonly string[],\n  embedModel: string,\n  logger: AxLoggerFunction\n) => {\n  const loggerData: AxLoggerData = {\n    name: 'EmbedRequest',\n    embedModel,\n    value: texts,\n  };\n\n  logger(loggerData);\n};\n\nexport const logEmbedResponse = (\n  embeddings: readonly (readonly number[])[],\n  logger: AxLoggerFunction\n) => {\n  // Show only a few embeddings for effect, not all\n  const sampleEmbeddings = embeddings.slice(0, 3).map((embedding) => ({\n    length: embedding.length,\n    sample: embedding.slice(0, 5), // Show first 5 values\n    truncated: embedding.length > 5,\n  }));\n\n  const loggerData: AxLoggerData = {\n    name: 'EmbedResponse',\n    totalEmbeddings: embeddings.length,\n    value: sampleEmbeddings,\n  };\n\n  logger(loggerData);\n};\n\nexport const logResultPickerUsed = (\n  sampleCount: number,\n  selectedIndex: number,\n  latency: number,\n  logger: AxLoggerFunction\n) => {\n  const loggerData: AxLoggerData = {\n    name: 'ResultPickerUsed',\n    sampleCount,\n    selectedIndex,\n    latency,\n  };\n\n  logger(loggerData);\n};\n","import type { Counter, Gauge, Histogram, Meter } from '@opentelemetry/api';\n\n// Utility function to sanitize metric labels\nconst sanitizeLabels = (\n  labels: Record<string, unknown>\n): Record<string, string> => {\n  const sanitized: Record<string, string> = {};\n  for (const [key, value] of Object.entries(labels)) {\n    if (value !== undefined && value !== null) {\n      const stringValue = String(value);\n      // Limit label length to prevent excessive memory usage\n      sanitized[key] =\n        stringValue.length > 100 ? stringValue.substring(0, 100) : stringValue;\n    }\n  }\n  return sanitized;\n};\n\nexport interface AxAIMetricsInstruments {\n  latencyHistogram?: Histogram;\n  errorCounter?: Counter;\n  requestCounter?: Counter;\n  tokenCounter?: Counter;\n  inputTokenCounter?: Counter;\n  outputTokenCounter?: Counter;\n  errorRateGauge?: Gauge;\n  meanLatencyGauge?: Gauge;\n  p95LatencyGauge?: Gauge;\n  p99LatencyGauge?: Gauge;\n\n  streamingRequestsCounter?: Counter;\n\n  functionCallsCounter?: Counter;\n  functionCallLatencyHistogram?: Histogram;\n\n  requestSizeHistogram?: Histogram;\n  responseSizeHistogram?: Histogram;\n\n  temperatureGauge?: Gauge;\n  maxTokensGauge?: Gauge;\n\n  estimatedCostCounter?: Counter;\n\n  promptLengthHistogram?: Histogram;\n  contextWindowUsageGauge?: Gauge;\n\n  timeoutsCounter?: Counter;\n  abortsCounter?: Counter;\n\n  thinkingBudgetUsageCounter?: Counter;\n  multimodalRequestsCounter?: Counter;\n}\n\n// Singleton instance for AI metrics instruments\nlet globalAIMetricsInstruments: AxAIMetricsInstruments | undefined;\n\n// Function to get or create AI metrics instruments (singleton pattern)\nexport const getOrCreateAIMetricsInstruments = (\n  meter?: Meter\n): AxAIMetricsInstruments | undefined => {\n  // Return existing instance if available\n  if (globalAIMetricsInstruments) {\n    return globalAIMetricsInstruments;\n  }\n\n  if (meter) {\n    globalAIMetricsInstruments = createMetricsInstruments(meter);\n    return globalAIMetricsInstruments;\n  }\n\n  return undefined;\n};\n\n// Function to reset the AI metrics singleton (useful for testing)\nexport const resetAIMetricsInstruments = (): void => {\n  globalAIMetricsInstruments = undefined;\n};\n\nexport const createMetricsInstruments = (\n  meter: Meter\n): AxAIMetricsInstruments => {\n  return {\n    latencyHistogram: meter.createHistogram('ax_llm_request_duration_ms', {\n      description: 'Duration of LLM requests in milliseconds',\n      unit: 'ms',\n    }),\n\n    errorCounter: meter.createCounter('ax_llm_errors_total', {\n      description: 'Total number of LLM request errors',\n    }),\n\n    requestCounter: meter.createCounter('ax_llm_requests_total', {\n      description: 'Total number of LLM requests',\n    }),\n\n    tokenCounter: meter.createCounter('ax_llm_tokens_total', {\n      description: 'Total number of LLM tokens consumed',\n    }),\n\n    inputTokenCounter: meter.createCounter('ax_llm_input_tokens_total', {\n      description: 'Total number of input/prompt tokens consumed',\n    }),\n\n    outputTokenCounter: meter.createCounter('ax_llm_output_tokens_total', {\n      description: 'Total number of output/completion tokens generated',\n    }),\n\n    errorRateGauge: meter.createGauge('ax_llm_error_rate', {\n      description: 'Current error rate as a percentage (0-100)',\n    }),\n\n    meanLatencyGauge: meter.createGauge('ax_llm_mean_latency_ms', {\n      description: 'Mean latency of LLM requests in milliseconds',\n      unit: 'ms',\n    }),\n\n    p95LatencyGauge: meter.createGauge('ax_llm_p95_latency_ms', {\n      description: '95th percentile latency of LLM requests in milliseconds',\n      unit: 'ms',\n    }),\n\n    p99LatencyGauge: meter.createGauge('ax_llm_p99_latency_ms', {\n      description: '99th percentile latency of LLM requests in milliseconds',\n      unit: 'ms',\n    }),\n\n    streamingRequestsCounter: meter.createCounter(\n      'ax_llm_streaming_requests_total',\n      {\n        description: 'Total number of streaming LLM requests',\n      }\n    ),\n\n    functionCallsCounter: meter.createCounter('ax_llm_function_calls_total', {\n      description: 'Total number of function/tool calls made',\n    }),\n\n    functionCallLatencyHistogram: meter.createHistogram(\n      'ax_llm_function_call_latency_ms',\n      {\n        description: 'Latency of function calls in milliseconds',\n        unit: 'ms',\n      }\n    ),\n\n    requestSizeHistogram: meter.createHistogram('ax_llm_request_size_bytes', {\n      description: 'Size of LLM request payloads in bytes',\n      unit: 'By',\n    }),\n\n    responseSizeHistogram: meter.createHistogram('ax_llm_response_size_bytes', {\n      description: 'Size of LLM response payloads in bytes',\n      unit: 'By',\n    }),\n\n    temperatureGauge: meter.createGauge('ax_llm_temperature_gauge', {\n      description: 'Temperature setting used for LLM requests',\n    }),\n\n    maxTokensGauge: meter.createGauge('ax_llm_max_tokens_gauge', {\n      description: 'Maximum tokens setting used for LLM requests',\n    }),\n\n    estimatedCostCounter: meter.createCounter('ax_llm_estimated_cost_total', {\n      description: 'Estimated cost of LLM requests in USD',\n      unit: '$',\n    }),\n\n    promptLengthHistogram: meter.createHistogram('ax_llm_prompt_length_chars', {\n      description: 'Length of prompts in characters',\n    }),\n\n    contextWindowUsageGauge: meter.createGauge(\n      'ax_llm_context_window_usage_ratio',\n      {\n        description: 'Context window utilization ratio (0-1)',\n      }\n    ),\n\n    timeoutsCounter: meter.createCounter('ax_llm_timeouts_total', {\n      description: 'Total number of timed out LLM requests',\n    }),\n\n    abortsCounter: meter.createCounter('ax_llm_aborts_total', {\n      description: 'Total number of aborted LLM requests',\n    }),\n\n    thinkingBudgetUsageCounter: meter.createCounter(\n      'ax_llm_thinking_budget_usage_total',\n      {\n        description: 'Total thinking budget tokens used',\n      }\n    ),\n\n    multimodalRequestsCounter: meter.createCounter(\n      'ax_llm_multimodal_requests_total',\n      {\n        description: 'Total number of multimodal requests (with images/audio)',\n      }\n    ),\n  };\n};\n\nexport const recordLatencyMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  duration: number,\n  aiService: string,\n  model?: string\n): void => {\n  try {\n    if (instruments.latencyHistogram) {\n      const labels = sanitizeLabels({\n        operation: type,\n        ai_service: aiService,\n        ...(model ? { model } : {}),\n      });\n      instruments.latencyHistogram.record(duration, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record latency metric:', error);\n  }\n};\n\nexport const recordLatencyStatsMetrics = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  meanLatency: number,\n  p95Latency: number,\n  p99Latency: number,\n  aiService: string,\n  model?: string\n): void => {\n  const labels = {\n    operation: type,\n    ai_service: aiService,\n    ...(model ? { model } : {}),\n  };\n\n  if (instruments.meanLatencyGauge) {\n    instruments.meanLatencyGauge.record(meanLatency, labels);\n  }\n\n  if (instruments.p95LatencyGauge) {\n    instruments.p95LatencyGauge.record(p95Latency, labels);\n  }\n\n  if (instruments.p99LatencyGauge) {\n    instruments.p99LatencyGauge.record(p99Latency, labels);\n  }\n};\n\nexport const recordErrorMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  aiService: string,\n  model?: string\n): void => {\n  try {\n    if (instruments.errorCounter) {\n      const labels = sanitizeLabels({\n        operation: type,\n        ai_service: aiService,\n        ...(model ? { model } : {}),\n      });\n      instruments.errorCounter.add(1, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record error metric:', error);\n  }\n};\n\nexport const recordErrorRateMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  errorRate: number,\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.errorRateGauge) {\n    instruments.errorRateGauge.record(errorRate * 100, {\n      // Convert to percentage\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordRequestMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.requestCounter) {\n    instruments.requestCounter.add(1, {\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordTokenMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'input' | 'output' | 'total' | 'thoughts',\n  tokens: number,\n  aiService: string,\n  model?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n\n    // Record in the general token counter with type label\n    if (instruments.tokenCounter) {\n      instruments.tokenCounter.add(tokens, {\n        token_type: type,\n        ...labels,\n      });\n    }\n\n    // Also record in specific counters for input/output\n    if (type === 'input' && instruments.inputTokenCounter) {\n      instruments.inputTokenCounter.add(tokens, labels);\n    }\n\n    if (type === 'output' && instruments.outputTokenCounter) {\n      instruments.outputTokenCounter.add(tokens, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record token metric:', error);\n  }\n};\n\nexport const recordStreamingRequestMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  isStreaming: boolean,\n  aiService: string,\n  model?: string\n): void => {\n  if (isStreaming && instruments.streamingRequestsCounter) {\n    instruments.streamingRequestsCounter.add(1, {\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordFunctionCallMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  functionName: string,\n  latency?: number,\n  aiService?: string,\n  model?: string\n): void => {\n  const labels = {\n    function_name: functionName,\n    ...(aiService ? { ai_service: aiService } : {}),\n    ...(model ? { model } : {}),\n  };\n\n  if (instruments.functionCallsCounter) {\n    instruments.functionCallsCounter.add(1, labels);\n  }\n\n  if (latency && instruments.functionCallLatencyHistogram) {\n    instruments.functionCallLatencyHistogram.record(latency, labels);\n  }\n};\n\nexport const recordRequestSizeMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  sizeBytes: number,\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.requestSizeHistogram) {\n    instruments.requestSizeHistogram.record(sizeBytes, {\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordResponseSizeMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  sizeBytes: number,\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.responseSizeHistogram) {\n    instruments.responseSizeHistogram.record(sizeBytes, {\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordModelConfigMetrics = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  temperature?: number,\n  maxTokens?: number,\n  aiService?: string,\n  model?: string\n): void => {\n  const labels = {\n    ...(aiService ? { ai_service: aiService } : {}),\n    ...(model ? { model } : {}),\n  };\n\n  if (temperature !== undefined && instruments.temperatureGauge) {\n    instruments.temperatureGauge.record(temperature, labels);\n  }\n\n  if (maxTokens !== undefined && instruments.maxTokensGauge) {\n    instruments.maxTokensGauge.record(maxTokens, labels);\n  }\n};\n\nexport const recordEstimatedCostMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  costUSD: number,\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.estimatedCostCounter) {\n    instruments.estimatedCostCounter.add(costUSD, {\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordPromptLengthMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  lengthChars: number,\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.promptLengthHistogram) {\n    instruments.promptLengthHistogram.record(lengthChars, {\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordContextWindowUsageMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  usageRatio: number,\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.contextWindowUsageGauge) {\n    instruments.contextWindowUsageGauge.record(usageRatio, {\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordTimeoutMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.timeoutsCounter) {\n    instruments.timeoutsCounter.add(1, {\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordAbortMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.abortsCounter) {\n    instruments.abortsCounter.add(1, {\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordThinkingBudgetUsageMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  tokensUsed: number,\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.thinkingBudgetUsageCounter) {\n    instruments.thinkingBudgetUsageCounter.add(tokensUsed, {\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordMultimodalRequestMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  hasImages: boolean,\n  hasAudio: boolean,\n  aiService: string,\n  model?: string\n): void => {\n  if ((hasImages || hasAudio) && instruments.multimodalRequestsCounter) {\n    instruments.multimodalRequestsCounter.add(1, {\n      ai_service: aiService,\n      has_images: hasImages.toString(),\n      has_audio: hasAudio.toString(),\n      ...(model ? { model } : {}),\n    });\n  }\n};\n","import type { AxChatRequest, AxChatResponseResult } from './types.js';\n\ntype AxChatRequestMessage = AxChatRequest['chatPrompt'][number];\n\nfunction formatForMessage(v: unknown): string {\n  try {\n    return JSON.stringify(v, null, 2);\n  } catch {\n    return String(v);\n  }\n}\n\nfunction raiseValidationError(\n  issue: string,\n  args: {\n    item?: unknown;\n    fieldPath?: string;\n    value?: unknown;\n    note?: string;\n  } = {}\n): never {\n  const lines: string[] = [issue];\n  if (args.fieldPath !== undefined) lines.push(`Field: ${args.fieldPath}`);\n  if (args.value !== undefined)\n    lines.push(`Value: ${formatForMessage(args.value)}`);\n  if (args.note) lines.push(`Note: ${args.note}`);\n  if (args.item !== undefined)\n    lines.push(`Chat item: ${formatForMessage(args.item)}`);\n  throw new Error(lines.join('\\n'));\n}\n\n/**\n * Validates a chat request message item to ensure it meets the required criteria\n * @param item - The chat request message to validate\n * @throws {Error} When validation fails with a descriptive error message\n */\nexport function axValidateChatRequestMessage(item: AxChatRequestMessage): void {\n  const value = (v: unknown) => JSON.stringify(v, null, 2);\n\n  if (!item) {\n    throw new Error(\n      `Chat request message item cannot be null or undefined, received: ${value(item)}`\n    );\n  }\n\n  const role =\n    typeof item === 'object' &&\n    item !== null &&\n    'role' in item &&\n    typeof item.role === 'string'\n      ? item.role\n      : undefined;\n  if (!role) {\n    throw new Error(\n      `Chat request message must have a role, received: ${value(role)}`\n    );\n  }\n\n  switch (role) {\n    case 'system': {\n      const content =\n        typeof item === 'object' &&\n        item !== null &&\n        'content' in item &&\n        typeof item.content === 'string'\n          ? item.content\n          : undefined;\n      if (!content || content.trim() === '') {\n        throw new Error(\n          `System message content cannot be empty or whitespace-only, received: ${value(content)}`\n        );\n      }\n      break;\n    }\n\n    case 'user': {\n      const content =\n        typeof item === 'object' && item !== null && 'content' in item\n          ? (item as any).content\n          : undefined;\n      if (content === undefined) {\n        throw new Error(\n          `User message content cannot be undefined, received: ${value(content)}`\n        );\n      }\n\n      if (typeof content === 'string') {\n        if (content.trim() === '') {\n          throw new Error(\n            `User message content cannot be empty or whitespace-only, received: ${value(content)}`\n          );\n        }\n      } else if (Array.isArray(content)) {\n        if (content.length === 0) {\n          throw new Error(\n            `User message content array cannot be empty, received: ${value(content)}`\n          );\n        }\n\n        for (let index = 0; index < content.length; index++) {\n          const contentItem = content[index];\n          if (!contentItem || typeof contentItem !== 'object') {\n            throw new Error(\n              `User message content item at index ${index} must be an object, received: ${value(contentItem)}`\n            );\n          }\n\n          const contentType =\n            typeof contentItem === 'object' &&\n            contentItem !== null &&\n            'type' in contentItem &&\n            typeof contentItem.type === 'string'\n              ? contentItem.type\n              : undefined;\n          if (!contentType) {\n            throw new Error(\n              `User message content item at index ${index} must have a type, received: ${value(contentType)}`\n            );\n          }\n\n          switch (contentType) {\n            case 'text': {\n              const text =\n                'text' in contentItem && typeof contentItem.text === 'string'\n                  ? contentItem.text\n                  : undefined;\n              if (!text || text.trim() === '') {\n                throw new Error(\n                  `User message text content at index ${index} cannot be empty or whitespace-only, received: ${value(text)}`\n                );\n              }\n              break;\n            }\n            case 'image': {\n              const image =\n                'image' in contentItem && typeof contentItem.image === 'string'\n                  ? contentItem.image\n                  : undefined;\n              const mimeType =\n                'mimeType' in contentItem &&\n                typeof contentItem.mimeType === 'string'\n                  ? contentItem.mimeType\n                  : undefined;\n\n              if (!image || image.trim() === '') {\n                throw new Error(\n                  `User message image content at index ${index} cannot be empty, received: ${value(image)}`\n                );\n              }\n              if (!mimeType || mimeType.trim() === '') {\n                throw new Error(\n                  `User message image content at index ${index} must have a mimeType, received: ${value(mimeType)}`\n                );\n              }\n              break;\n            }\n            case 'audio': {\n              const data =\n                'data' in contentItem && typeof contentItem.data === 'string'\n                  ? contentItem.data\n                  : undefined;\n              if (!data || data.trim() === '') {\n                throw new Error(\n                  `User message audio content at index ${index} cannot be empty, received: ${value(data)}`\n                );\n              }\n              break;\n            }\n            case 'file': {\n              // Check if this is a fileUri-based file or data-based file\n              const hasFileUri =\n                'fileUri' in contentItem &&\n                typeof contentItem.fileUri === 'string';\n              const hasData =\n                'data' in contentItem && typeof contentItem.data === 'string';\n\n              // Must have either fileUri or data, but not both\n              if (!hasFileUri && !hasData) {\n                throw new Error(\n                  `User message file content at index ${index} must have either 'data' or 'fileUri', received: ${value(contentItem)}`\n                );\n              }\n\n              if (hasFileUri && hasData) {\n                throw new Error(\n                  `User message file content at index ${index} cannot have both 'data' and 'fileUri', received: ${value(contentItem)}`\n                );\n              }\n\n              // Validate fileUri if present\n              if (hasFileUri) {\n                const fileUriValue = contentItem.fileUri;\n                if (!fileUriValue || fileUriValue.trim() === '') {\n                  throw new Error(\n                    `User message file content at index ${index} fileUri cannot be empty, received: ${value(fileUriValue)}`\n                  );\n                }\n              }\n\n              // Validate data if present\n              if (hasData) {\n                const dataValue = contentItem.data;\n                if (!dataValue || dataValue.trim() === '') {\n                  throw new Error(\n                    `User message file content at index ${index} data cannot be empty, received: ${value(dataValue)}`\n                  );\n                }\n              }\n\n              // Validate mimeType (required for both cases)\n              const mimeType =\n                'mimeType' in contentItem &&\n                typeof contentItem.mimeType === 'string'\n                  ? contentItem.mimeType\n                  : null;\n              if (!mimeType || mimeType.trim() === '') {\n                throw new Error(\n                  `User message file content at index ${index} must have a mimeType, received: ${value(mimeType)}`\n                );\n              }\n              break;\n            }\n            case 'url': {\n              const url =\n                'url' in contentItem && typeof contentItem.url === 'string'\n                  ? contentItem.url\n                  : undefined;\n              if (!url || url.trim() === '') {\n                throw new Error(\n                  `User message url content at index ${index} cannot be empty, received: ${value(url)}`\n                );\n              }\n              break;\n            }\n            default:\n              throw new Error(\n                `User message content item at index ${index} has unsupported type: ${value(contentType)}`\n              );\n          }\n        }\n      } else {\n        throw new Error(\n          `User message content must be a string or array of content objects, received: ${value(content)}`\n        );\n      }\n      break;\n    }\n\n    case 'assistant': {\n      const content =\n        typeof item === 'object' && item !== null && 'content' in item\n          ? (item as any).content\n          : undefined;\n\n      const functionCalls =\n        typeof item === 'object' && item !== null && 'functionCalls' in item\n          ? (item as any).functionCalls\n          : undefined;\n\n      const hasNonEmptyContent =\n        typeof content === 'string' && content.trim() !== '';\n      const hasFunctionCalls =\n        Array.isArray(functionCalls) && functionCalls.length > 0;\n\n      if (!hasNonEmptyContent && !hasFunctionCalls) {\n        raiseValidationError(\n          'Assistant message must include non-empty content or at least one function call',\n          {\n            fieldPath: 'content | functionCalls',\n            value: { content, functionCalls },\n            item,\n          }\n        );\n      }\n\n      if (content !== undefined && typeof content !== 'string') {\n        raiseValidationError('Assistant message content must be a string', {\n          fieldPath: 'content',\n          value: content,\n          item,\n        });\n      }\n\n      if (functionCalls !== undefined && !Array.isArray(functionCalls)) {\n        raiseValidationError(\n          'Assistant message functionCalls must be an array when provided',\n          {\n            fieldPath: 'functionCalls',\n            value: functionCalls,\n            item,\n          }\n        );\n      }\n\n      if (Array.isArray(functionCalls)) {\n        for (let i = 0; i < functionCalls.length; i++) {\n          const fc = functionCalls[i];\n          if (!fc || typeof fc !== 'object') {\n            raiseValidationError('functionCalls entry must be an object', {\n              fieldPath: `functionCalls[${i}]`,\n              value: fc,\n              item,\n            });\n          }\n          if (\n            !('id' in fc) ||\n            typeof (fc as any).id !== 'string' ||\n            (fc as any).id.trim() === ''\n          ) {\n            raiseValidationError(\n              'functionCalls entry must include a non-empty string id',\n              {\n                fieldPath: `functionCalls[${i}].id`,\n                value: (fc as any).id,\n                item,\n              }\n            );\n          }\n          if (!('type' in fc) || (fc as any).type !== 'function') {\n            raiseValidationError(\n              \"functionCalls entry must have type 'function'\",\n              {\n                fieldPath: `functionCalls[${i}].type`,\n                value: (fc as any).type,\n                item,\n              }\n            );\n          }\n          if (!('function' in fc) || !(fc as any).function) {\n            raiseValidationError(\n              'functionCalls entry must include a function object',\n              {\n                fieldPath: `functionCalls[${i}].function`,\n                value: (fc as any).function,\n                item,\n              }\n            );\n          } else {\n            const funcObj = (fc as any).function;\n            if (\n              !('name' in funcObj) ||\n              typeof funcObj.name !== 'string' ||\n              funcObj.name.trim() === ''\n            ) {\n              raiseValidationError(\n                'functionCalls entry must include a non-empty function name',\n                {\n                  fieldPath: `functionCalls[${i}].function.name`,\n                  value: funcObj?.name,\n                  item,\n                }\n              );\n            }\n            if (funcObj.params !== undefined) {\n              if (\n                typeof funcObj.params !== 'string' &&\n                typeof funcObj.params !== 'object'\n              ) {\n                raiseValidationError(\n                  'functionCalls entry params must be a string or object when provided',\n                  {\n                    fieldPath: `functionCalls[${i}].function.params`,\n                    value: funcObj.params,\n                    item,\n                  }\n                );\n              }\n            }\n          }\n        }\n      }\n\n      if ((item as any).name !== undefined) {\n        const name = (item as any).name;\n        if (typeof name !== 'string' || name.trim() === '') {\n          raiseValidationError(\n            'Assistant message name must be a non-empty string when provided',\n            { fieldPath: 'name', value: name, item }\n          );\n        }\n      }\n      break;\n    }\n\n    case 'function': {\n      const functionId =\n        typeof item === 'object' &&\n        item !== null &&\n        'functionId' in item &&\n        typeof item.functionId === 'string'\n          ? item.functionId\n          : undefined;\n      const result =\n        typeof item === 'object' && item !== null && 'result' in item\n          ? item.result\n          : undefined;\n\n      if (!functionId || functionId.trim() === '') {\n        throw new Error(\n          `Function message must have a non-empty functionId, received: ${value(functionId)}`\n        );\n      }\n\n      if (result === undefined || result === null) {\n        throw new Error(\n          `Function message must have a result, received: ${value(result)}`\n        );\n      }\n\n      if (typeof result !== 'string') {\n        throw new Error(\n          `Function message result must be a string, received: ${value(result)}`\n        );\n      }\n\n      if (\n        (item as any).isError !== undefined &&\n        typeof (item as any).isError !== 'boolean'\n      ) {\n        raiseValidationError(\n          'Function message isError must be a boolean when provided',\n          {\n            fieldPath: 'isError',\n            value: (item as any).isError,\n            item,\n          }\n        );\n      }\n      break;\n    }\n\n    default:\n      throw new Error(`Unsupported message role: ${value(role)}`);\n  }\n}\n\n/**\n * Validates a chat response result to ensure it meets the required criteria\n * @param results - The chat response results to validate (single result or array)\n * @throws {Error} When validation fails with a descriptive error message\n */\nexport function axValidateChatResponseResult(\n  results: Readonly<AxChatResponseResult[]> | Readonly<AxChatResponseResult>\n): void {\n  const value = (v: unknown) => JSON.stringify(v, null, 2);\n  const resultsArray = Array.isArray(results) ? results : [results];\n\n  if (resultsArray.length === 0) {\n    throw new Error(\n      `Chat response results cannot be empty, received: ${value(resultsArray)}`\n    );\n  }\n\n  for (let arrayIndex = 0; arrayIndex < resultsArray.length; arrayIndex++) {\n    const result = resultsArray[arrayIndex];\n    if (!result) {\n      throw new Error(\n        `Chat response result at index ${arrayIndex} cannot be null or undefined, received: ${value(result)}`\n      );\n    }\n\n    // Validate index\n    if (typeof result.index !== 'number') {\n      throw new Error(\n        `Chat response result at index ${arrayIndex} must have a numeric index, received: ${value(result.index)}`\n      );\n    }\n\n    if (result.index < 0) {\n      throw new Error(\n        `Chat response result at index ${arrayIndex} must have a non-negative index, received: ${value(result.index)}`\n      );\n    }\n\n    // Validate that at least one meaningful field is present\n    if (\n      !result.content &&\n      !result.thought &&\n      !result.thoughtBlock &&\n      !result.functionCalls &&\n      !result.finishReason\n    ) {\n      throw new Error(\n        `Chat response result at index ${arrayIndex} must have at least one of: content, thought, functionCalls, or finishReason, received: ${value({ content: result.content, thought: result.thought, functionCalls: result.functionCalls, finishReason: result.finishReason })}`\n      );\n    }\n\n    // Validate content if present\n    if (result.content !== undefined && typeof result.content !== 'string') {\n      throw new Error(\n        `Chat response result content at index ${arrayIndex} must be a string, received: ${value(result.content)}`\n      );\n    }\n\n    // Validate thought if present\n    if (result.thought !== undefined && typeof result.thought !== 'string') {\n      throw new Error(\n        `Chat response result thought at index ${arrayIndex} must be a string, received: ${value(result.thought)}`\n      );\n    }\n\n    // Validate thoughtBlock if present\n    if (result.thoughtBlock !== undefined) {\n      if (\n        typeof result.thoughtBlock !== 'object' ||\n        result.thoughtBlock === null\n      ) {\n        throw new Error(\n          `Chat response result thoughtBlock at index ${arrayIndex} must be an object, received: ${value(result.thoughtBlock)}`\n        );\n      }\n      const tb: any = result.thoughtBlock;\n      if (typeof tb.data !== 'string') {\n        throw new Error(\n          `Chat response result thoughtBlock.data at index ${arrayIndex} must be a string, received: ${value(tb.data)}`\n        );\n      }\n      if (typeof tb.encrypted !== 'boolean') {\n        throw new Error(\n          `Chat response result thoughtBlock.encrypted at index ${arrayIndex} must be a boolean, received: ${value(tb.encrypted)}`\n        );\n      }\n      if (tb.signature !== undefined && typeof tb.signature !== 'string') {\n        throw new Error(\n          `Chat response result thoughtBlock.signature at index ${arrayIndex} must be a string when provided, received: ${value(tb.signature)}`\n        );\n      }\n    }\n\n    // Validate name if present\n    if (result.name !== undefined) {\n      if (typeof result.name !== 'string') {\n        throw new Error(\n          `Chat response result name at index ${arrayIndex} must be a string, received: ${value(result.name)}`\n        );\n      }\n      if (result.name.trim() === '') {\n        throw new Error(\n          `Chat response result name at index ${arrayIndex} cannot be empty or whitespace-only, received: ${value(result.name)}`\n        );\n      }\n    }\n\n    // Validate annotations if present\n    if (result.annotations !== undefined) {\n      if (!Array.isArray(result.annotations)) {\n        throw new Error(\n          `Chat response result annotations at index ${arrayIndex} must be an array, received: ${value(result.annotations)}`\n        );\n      }\n      for (let i = 0; i < result.annotations.length; i++) {\n        const annotation = result.annotations[i];\n        if (!annotation || typeof annotation !== 'object') {\n          throw new Error(\n            `Chat response result annotation at index ${arrayIndex}[${i}] must be an object, received: ${value(annotation)}`\n          );\n        }\n        if (annotation.type !== 'url_citation') {\n          throw new Error(\n            `Chat response result annotation at index ${arrayIndex}[${i}] must have type 'url_citation', received: ${value(annotation.type)}`\n          );\n        }\n        if (\n          !annotation.url_citation ||\n          typeof annotation.url_citation !== 'object'\n        ) {\n          throw new Error(\n            `Chat response result annotation at index ${arrayIndex}[${i}] must have a valid url_citation object, received: ${value(annotation.url_citation)}`\n          );\n        }\n        if (typeof annotation.url_citation.url !== 'string') {\n          throw new Error(\n            `Chat response result annotation at index ${arrayIndex}[${i}] url_citation.url must be a string, received: ${value(annotation.url_citation.url)}`\n          );\n        }\n      }\n    }\n\n    // Validate id if present\n    if (result.id !== undefined) {\n      if (typeof result.id !== 'string') {\n        throw new Error(\n          `Chat response result id at index ${arrayIndex} must be a string, received: ${value(result.id)}`\n        );\n      }\n      if (result.id.trim() === '') {\n        throw new Error(\n          `Chat response result id at index ${arrayIndex} cannot be empty or whitespace-only, received: ${value(result.id)}`\n        );\n      }\n    }\n\n    // Validate functionCalls if present\n    if (result.functionCalls !== undefined) {\n      if (!Array.isArray(result.functionCalls)) {\n        throw new Error(\n          `Chat response result functionCalls at index ${arrayIndex} must be an array, received: ${value(result.functionCalls)}`\n        );\n      }\n\n      for (\n        let callIndex = 0;\n        callIndex < result.functionCalls.length;\n        callIndex++\n      ) {\n        const functionCall = result.functionCalls[callIndex];\n        if (!functionCall) {\n          throw new Error(\n            `Function call at index ${callIndex} in result ${arrayIndex} cannot be null or undefined, received: ${value(functionCall)}`\n          );\n        }\n\n        if (\n          !functionCall.id ||\n          typeof functionCall.id !== 'string' ||\n          functionCall.id.trim() === ''\n        ) {\n          throw new Error(\n            `Function call at index ${callIndex} in result ${arrayIndex} must have a non-empty string id, received: ${value(functionCall.id)}`\n          );\n        }\n\n        if (functionCall.type !== 'function') {\n          throw new Error(\n            `Function call at index ${callIndex} in result ${arrayIndex} must have type 'function', received: ${value(functionCall.type)}`\n          );\n        }\n\n        if (!functionCall.function) {\n          throw new Error(\n            `Function call at index ${callIndex} in result ${arrayIndex} must have a function object, received: ${value(functionCall.function)}`\n          );\n        }\n\n        if (\n          !functionCall.function.name ||\n          typeof functionCall.function.name !== 'string' ||\n          functionCall.function.name.trim() === ''\n        ) {\n          throw new Error(\n            `Function call at index ${callIndex} in result ${arrayIndex} must have a non-empty function name, received: ${value(functionCall.function.name)}`\n          );\n        }\n\n        if (functionCall.function.params !== undefined) {\n          if (\n            typeof functionCall.function.params !== 'string' &&\n            typeof functionCall.function.params !== 'object'\n          ) {\n            throw new Error(\n              `Function call params at index ${callIndex} in result ${arrayIndex} must be a string or object, received: ${value(functionCall.function.params)}`\n            );\n          }\n        }\n      }\n    }\n\n    // Validate finishReason if present\n    if (result.finishReason !== undefined) {\n      const validFinishReasons = [\n        'stop',\n        'length',\n        'function_call',\n        'content_filter',\n        'error',\n      ];\n      if (!validFinishReasons.includes(result.finishReason)) {\n        throw new Error(\n          `Chat response result finishReason at index ${arrayIndex} must be one of: ${validFinishReasons.join(', ')}, received: ${value(result.finishReason)}`\n        );\n      }\n    }\n  }\n}\n","import type { AxModelConfig } from '../types.js';\n\nexport enum AxAIAnthropicModel {\n  Claude41Opus = 'claude-opus-4-1-20250805',\n  Claude4Opus = 'claude-opus-4-20250514',\n  Claude4Sonnet = 'claude-sonnet-4-20250514',\n  Claude45Sonnet = 'claude-sonnet-4-5-20250929',\n  Claude45Haiku = 'claude-haiku-4-5',\n  Claude37Sonnet = 'claude-3-7-sonnet-latest',\n\n  Claude35Sonnet = 'claude-3-5-sonnet-latest',\n  Claude35Haiku = 'claude-3-5-haiku-latest',\n\n  Claude3Opus = 'claude-3-opus-latest',\n  Claude3Sonnet = 'claude-3-sonnet-20240229',\n  Claude3Haiku = 'claude-3-haiku-20240307',\n\n  Claude21 = 'claude-2.1',\n  ClaudeInstant12 = 'claude-instant-1.2',\n}\n\nexport enum AxAIAnthropicVertexModel {\n  Claude37Sonnet = 'claude-3-7-sonnet',\n  Claude35Haiku = 'claude-3-5-haiku',\n  Claude35Sonnet = 'claude-3-5-sonnet',\n  Claude35SonnetV2 = 'claude-3-5-sonnet-v2',\n  Claude3Haiku = 'claude-3-haiku',\n  Claude3Opus = 'claude-3-opus',\n}\n\nexport type AxAIAnthropicThinkingConfig = {\n  type: 'enabled';\n  budget_tokens: number;\n  /** Optional: numeric budget hint used in config normalization */\n  thinkingTokenBudget?: number;\n  /** Optional: include provider thinking content in outputs */\n  includeThoughts?: boolean;\n};\n\nexport type AxAIAnthropicThinkingTokenBudgetLevels = {\n  minimal?: number;\n  low?: number;\n  medium?: number;\n  high?: number;\n  highest?: number;\n};\n\n// Function-style tool definition (Anthropic JSON tool)\nexport type AxAIAnthropicFunctionTool = {\n  name: string;\n  description: string;\n  input_schema?: object;\n} & AxAIAnthropicChatRequestCacheParam;\n\n// Server tool: Web Search (see Anthropic docs)\n// https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/web-search-tool\nexport type AxAIAnthropicWebSearchTool = {\n  type: 'web_search_20250305';\n  name: string; // typically \"web_search\"\n  max_uses?: number;\n  allowed_domains?: string[];\n  blocked_domains?: string[];\n  user_location?: {\n    type: 'approximate';\n    city?: string;\n    region?: string;\n    country?: string;\n    timezone?: string;\n  };\n};\n\nexport type AxAIAnthropicRequestTool =\n  | AxAIAnthropicFunctionTool\n  | AxAIAnthropicWebSearchTool;\n\nexport type AxAIAnthropicConfig = AxModelConfig & {\n  model: AxAIAnthropicModel | AxAIAnthropicVertexModel;\n  thinking?: AxAIAnthropicThinkingConfig;\n  thinkingTokenBudgetLevels?: AxAIAnthropicThinkingTokenBudgetLevels;\n  tools?: ReadonlyArray<AxAIAnthropicRequestTool>;\n};\n\nexport type AxAIAnthropicChatRequestCacheParam = {\n  cache_control?: { type: 'ephemeral' };\n};\n\n// Type for the request to create a message using Anthropic's Messages API\nexport type AxAIAnthropicChatRequest = {\n  model?: string;\n  anthropic_version?: string;\n  messages: (\n    | {\n        role: 'user';\n        content:\n          | string\n          | (\n              | ({\n                  type: 'text';\n                  text: string;\n                } & AxAIAnthropicChatRequestCacheParam)\n              | ({\n                  type: 'image';\n                  source: { type: 'base64'; media_type: string; data: string };\n                } & AxAIAnthropicChatRequestCacheParam)\n              | {\n                  type: 'tool_result';\n                  is_error?: boolean;\n                  tool_use_id: string;\n                  content:\n                    | string\n                    | (\n                        | ({\n                            type: 'text';\n                            text: string;\n                          } & AxAIAnthropicChatRequestCacheParam)\n                        | ({\n                            type: 'image';\n                            source: {\n                              type: 'base64';\n                              media_type: string;\n                              data: string;\n                            };\n                          } & AxAIAnthropicChatRequestCacheParam)\n                      )[];\n                }\n            )[];\n      }\n    | {\n        role: 'assistant';\n        content:\n          | string\n          | (\n              | { type: 'text'; text: string }\n              | { type: 'tool_use'; id: string; name: string; input: object }\n              | { type: 'thinking'; thinking: string; signature?: string }\n              | {\n                  type: 'redacted_thinking';\n                  // Anthropic requires `data` for redacted_thinking blocks in requests\n                  data: string;\n                  signature?: string;\n                }\n            )[];\n      }\n  )[];\n  tools?: AxAIAnthropicRequestTool[];\n  tool_choice?: { type: 'auto' | 'any' } | { type: 'tool'; name?: string };\n  max_tokens?: number; // Maximum number of tokens to generate\n  // Optional metadata about the request\n  stop_sequences?: string[]; // Custom sequences that trigger the end of generation\n  stream?: boolean; // Whether to stream the response incrementally\n  system?:\n    | string\n    | ({\n        type: 'text';\n        text: string;\n      } & AxAIAnthropicChatRequestCacheParam)[]; // system prompt\n  temperature?: number; // Randomness of the response\n  top_p?: number; // Nucleus sampling probability\n  top_k?: number; // Sample from the top K options\n  thinking?: AxAIAnthropicThinkingConfig; // Extended thinking configuration\n  metadata?: {\n    user_id: string;\n  };\n};\n\nexport type AxAIAnthropicChatResponse = {\n  id: string; // Unique identifier for the response\n  type: 'message'; // Object type, always 'message' for this API\n  role: 'assistant'; // Conversational role of the generated message, always 'assistant'\n  content: (\n    | {\n        type: 'text';\n        text: string;\n      }\n    | {\n        id: string;\n        name: string;\n        type: 'tool_use';\n        input?: string;\n      }\n    | {\n        type: 'thinking';\n        thinking: string;\n        signature?: string;\n      }\n    | {\n        type: 'redacted_thinking';\n        // Responses may surface either `thinking` or `data` depending on API version\n        thinking?: string;\n        data?: string;\n        signature?: string;\n      }\n  )[];\n  model: string;\n  stop_reason: 'end_turn' | 'max_tokens' | 'stop_sequence' | 'tool_use';\n  stop_sequence?: string;\n  usage: {\n    input_tokens: number;\n    output_tokens: number;\n    cache_creation_input_tokens?: number;\n    cache_read_input_tokens?: number;\n  };\n};\n\nexport type AxAIAnthropicChatError = {\n  type: 'error';\n  error: {\n    type: 'authentication_error';\n    message: string;\n  };\n};\n\n// Represents the start of a message with an empty content array\nexport interface AxAIAnthropicMessageStartEvent {\n  type: 'message_start';\n  message: {\n    id: string;\n    type: 'message';\n    role: 'assistant';\n    content: [];\n    model: string;\n    stop_reason: null | string;\n    stop_sequence: null | string;\n    usage: {\n      input_tokens: number;\n      output_tokens: number;\n    };\n  };\n}\n\n// Indicates the start of a content block within a message\nexport interface AxAIAnthropicContentBlockStartEvent {\n  index: number;\n  type: 'content_block_start';\n  content_block:\n    | {\n        type: 'text';\n        text: string;\n      }\n    | {\n        type: 'tool_use';\n        id: string;\n        name: string;\n        input: object;\n      }\n    | {\n        // Server-side tool invocation (e.g., web_search)\n        type: 'server_tool_use';\n        id: string;\n        name: string;\n        input: object;\n      }\n    | {\n        // Server tool result container (we ignore its payload in responses)\n        type: 'web_search_tool_result';\n        tool_use_id: string;\n        content: unknown[];\n      }\n    | {\n        type: 'thinking';\n        thinking: string;\n      };\n}\n\n// Represents incremental updates to a content block\nexport interface AxAIAnthropicContentBlockDeltaEvent {\n  index: number;\n  type: 'content_block_delta';\n  delta:\n    | {\n        type: 'text_delta';\n        text: string;\n      }\n    | {\n        type: 'input_json_delta';\n        partial_json: string;\n      }\n    | {\n        type: 'thinking_delta';\n        thinking: string;\n      }\n    | {\n        type: 'signature_delta';\n        signature: string;\n      };\n}\n\n// Marks the end of a content block within a message\nexport interface AxAIAnthropicContentBlockStopEvent {\n  type: 'content_block_stop';\n  index: number;\n}\n\n// Indicates top-level changes to the final message object\nexport interface AxAIAnthropicMessageDeltaEvent {\n  type: 'message_delta';\n  delta: {\n    stop_reason: 'end_turn' | 'max_tokens' | 'stop_sequence' | null;\n    stop_sequence: string | null;\n  };\n  usage: {\n    output_tokens: number;\n  };\n}\n\n// Marks the end of a message\nexport interface AxAIAnthropicMessageStopEvent {\n  type: 'message_stop';\n}\n\n// Represents a ping event, which can occur any number of times\nexport interface AxAIAnthropicPingEvent {\n  type: 'ping';\n}\n\n// Represents an error event\nexport interface AxAIAnthropicErrorEvent {\n  type: 'error';\n  error: {\n    type: 'overloaded_error';\n    message: string;\n  };\n}\n\n// Union type for all possible event types in the stream\nexport type AxAIAnthropicChatResponseDelta =\n  | AxAIAnthropicMessageStartEvent\n  | AxAIAnthropicContentBlockStartEvent\n  | AxAIAnthropicContentBlockDeltaEvent\n  | AxAIAnthropicContentBlockStopEvent\n  | AxAIAnthropicMessageDeltaEvent\n  | AxAIAnthropicMessageStopEvent\n  | AxAIAnthropicPingEvent\n  | AxAIAnthropicErrorEvent;\n","import type { AxModelInfo } from '../types.js';\n\nimport { AxAIAnthropicModel } from './types.js';\n\nexport const axModelInfoAnthropic: AxModelInfo[] = [\n  // 4.5 Sonnet (2025-09)\n  {\n    name: AxAIAnthropicModel.Claude45Sonnet,\n    currency: 'usd',\n    // Estimated/prior pricing aligned with Sonnet tier\n    promptTokenCostPer1M: 3.0,\n    completionTokenCostPer1M: 15.0,\n    maxTokens: 200000,\n    supported: { thinkingBudget: true, showThoughts: true },\n  },\n  // 4.5 Haiku (2025-10)\n  {\n    name: AxAIAnthropicModel.Claude45Haiku,\n    currency: 'usd',\n    // Pricing per Anthropic announcement: $1 input / $5 output per 1M tokens\n    promptTokenCostPer1M: 1.0,\n    completionTokenCostPer1M: 5.0,\n    maxTokens: 200000, // match modern context window similar to Sonnet 4.5 era\n    supported: { thinkingBudget: true, showThoughts: true },\n  },\n  // 4\n  {\n    name: AxAIAnthropicModel.Claude41Opus,\n    currency: 'usd',\n    promptTokenCostPer1M: 15.0,\n    completionTokenCostPer1M: 75.0,\n    maxTokens: 32000,\n    supported: { thinkingBudget: true, showThoughts: true },\n  },\n  {\n    name: AxAIAnthropicModel.Claude4Opus,\n    currency: 'usd',\n    promptTokenCostPer1M: 15.0,\n    completionTokenCostPer1M: 75.0,\n    maxTokens: 32000,\n    supported: { thinkingBudget: true, showThoughts: true },\n  },\n  {\n    name: AxAIAnthropicModel.Claude4Sonnet,\n    currency: 'usd',\n    promptTokenCostPer1M: 3.0,\n    completionTokenCostPer1M: 15.0,\n    maxTokens: 64000,\n    supported: { thinkingBudget: true, showThoughts: true },\n  },\n  // 3.7\n  {\n    name: AxAIAnthropicModel.Claude37Sonnet,\n    currency: 'usd',\n    promptTokenCostPer1M: 3.0,\n    completionTokenCostPer1M: 15.0,\n    maxTokens: 64000,\n    supported: { thinkingBudget: true, showThoughts: true },\n  },\n  // 3.5\n  {\n    name: AxAIAnthropicModel.Claude35Sonnet,\n    currency: 'usd',\n    promptTokenCostPer1M: 3.0,\n    completionTokenCostPer1M: 15.0,\n    maxTokens: 8192,\n  },\n  {\n    name: AxAIAnthropicModel.Claude35Haiku,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.8,\n    completionTokenCostPer1M: 4.0,\n    maxTokens: 8192,\n  },\n  // 3\n  {\n    name: AxAIAnthropicModel.Claude3Opus,\n    currency: 'usd',\n    promptTokenCostPer1M: 15.0,\n    completionTokenCostPer1M: 75.0,\n    maxTokens: 4096,\n  },\n  {\n    name: AxAIAnthropicModel.Claude3Sonnet,\n    currency: 'usd',\n    promptTokenCostPer1M: 3.0,\n    completionTokenCostPer1M: 15.0,\n    maxTokens: 4096,\n  },\n  {\n    name: AxAIAnthropicModel.Claude3Haiku,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.25,\n    completionTokenCostPer1M: 1.25,\n    maxTokens: 4096,\n  },\n  // 2.1\n  {\n    name: AxAIAnthropicModel.Claude21,\n    currency: 'usd',\n    promptTokenCostPer1M: 8.0,\n    completionTokenCostPer1M: 25,\n    maxTokens: 4096,\n  },\n  {\n    name: AxAIAnthropicModel.ClaudeInstant12,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.8,\n    completionTokenCostPer1M: 2.24,\n    maxTokens: 4096,\n  },\n];\n","import { getModelInfo } from '../../dsp/modelinfo.js';\nimport type { AxAPI } from '../../util/apicall.js';\nimport { AxAIRefusalError } from '../../util/apicall.js';\nimport { AxBaseAI, axBaseAIDefaultConfig } from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxInternalChatRequest,\n  AxModelConfig,\n  AxTokenUsage,\n} from '../types.js';\nimport { axModelInfoAnthropic } from './info.js';\nimport {\n  type AxAIAnthropicChatError,\n  type AxAIAnthropicChatRequest,\n  type AxAIAnthropicChatResponse,\n  type AxAIAnthropicChatResponseDelta,\n  type AxAIAnthropicConfig,\n  type AxAIAnthropicContentBlockDeltaEvent,\n  type AxAIAnthropicContentBlockStartEvent,\n  type AxAIAnthropicErrorEvent,\n  type AxAIAnthropicMessageDeltaEvent,\n  type AxAIAnthropicMessageStartEvent,\n  AxAIAnthropicModel,\n  type AxAIAnthropicThinkingConfig,\n  AxAIAnthropicVertexModel,\n} from './types.js';\n\n/**\n * Clean function schema for Anthropic API compatibility\n * Anthropic uses input_schema and may not support certain JSON Schema fields\n */\nconst cleanSchemaForAnthropic = (schema: any): any => {\n  if (!schema || typeof schema !== 'object') {\n    return schema;\n  }\n\n  const cleaned = { ...schema };\n\n  // Remove fields that might cause issues with Anthropic\n  delete cleaned.additionalProperties;\n  delete cleaned.default;\n  delete cleaned.optional;\n  delete cleaned.oneOf;\n  delete cleaned.anyOf;\n  delete cleaned.allOf;\n\n  // Recursively clean properties\n  if (cleaned.properties && typeof cleaned.properties === 'object') {\n    cleaned.properties = Object.fromEntries(\n      Object.entries(cleaned.properties).map(([key, value]) => [\n        key,\n        cleanSchemaForAnthropic(value),\n      ])\n    );\n  }\n\n  // Recursively clean items (for arrays)\n  if (cleaned.items) {\n    cleaned.items = cleanSchemaForAnthropic(cleaned.items);\n  }\n\n  return cleaned;\n};\n\nexport const axAIAnthropicDefaultConfig = (): AxAIAnthropicConfig =>\n  structuredClone({\n    model: AxAIAnthropicModel.Claude37Sonnet,\n    maxTokens: 40000, // Ensure maxTokens is higher than highest thinking budget\n    thinkingTokenBudgetLevels: {\n      minimal: 1024,\n      low: 5000,\n      medium: 10000,\n      high: 20000,\n      highest: 32000,\n    },\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAIAnthropicVertexDefaultConfig = (): AxAIAnthropicConfig =>\n  structuredClone({\n    model: AxAIAnthropicVertexModel.Claude37Sonnet,\n    maxTokens: 40000, // Ensure maxTokens is higher than highest thinking budget\n    thinkingTokenBudgetLevels: {\n      minimal: 1024,\n      low: 5000,\n      medium: 10000,\n      high: 20000,\n      highest: 32000,\n    },\n    ...axBaseAIDefaultConfig(),\n  });\n\n// Helper type to extract model keys from the models array\ntype ExtractModelKeys<T> = T extends readonly { key: infer K }[] ? K : never;\n\nexport interface AxAIAnthropicArgs<TModelKey = string> {\n  name: 'anthropic';\n  apiKey?: string | (() => Promise<string>);\n  projectId?: string;\n  region?: string;\n  config?: Readonly<Partial<AxAIAnthropicConfig>>;\n  options?: Readonly<AxAIServiceOptions>;\n  models?: AxAIInputModelList<\n    AxAIAnthropicModel | AxAIAnthropicVertexModel,\n    undefined,\n    TModelKey\n  >;\n}\n\nclass AxAIAnthropicImpl\n  implements\n    AxAIServiceImpl<\n      AxAIAnthropicModel | AxAIAnthropicVertexModel,\n      unknown,\n      AxAIAnthropicChatRequest,\n      unknown,\n      AxAIAnthropicChatResponse,\n      AxAIAnthropicChatResponseDelta,\n      unknown\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n  private currentPromptConfig?: AxAIServiceOptions;\n\n  constructor(\n    private config: AxAIAnthropicConfig,\n    private isVertex: boolean\n  ) {}\n\n  getTokenUsage(): AxTokenUsage | undefined {\n    return this.tokensUsed;\n  }\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this;\n    return {\n      maxTokens: config.maxTokens ?? 4096,\n      temperature: config.temperature,\n      topP: config.topP,\n      topK: config.topK,\n      stream: config.stream,\n      stopSequences: config.stopSequences,\n      endSequences: config.endSequences,\n      presencePenalty: config.presencePenalty,\n      frequencyPenalty: config.frequencyPenalty,\n      n: config.n,\n    } as AxModelConfig;\n  }\n\n  createChatReq = async (\n    req: Readonly<\n      AxInternalChatRequest<AxAIAnthropicModel | AxAIAnthropicVertexModel>\n    >,\n    config: Readonly<AxAIServiceOptions>\n  ): Promise<[AxAPI, AxAIAnthropicChatRequest]> => {\n    // Store config for use in response methods\n    this.currentPromptConfig = config;\n\n    const model = req.model;\n    const stream = req.modelConfig?.stream ?? this.config.stream;\n\n    let apiConfig: AxAPI;\n    if (this.isVertex) {\n      apiConfig = {\n        name: stream\n          ? `/models/${model}:streamRawPredict?alt=sse`\n          : `/models/${model}:rawPredict`,\n      };\n    } else {\n      apiConfig = {\n        name: '/messages',\n      };\n    }\n\n    let toolsChoice:\n      | { tool_choice: { type: 'auto' | 'any' | 'tool'; name?: string } }\n      | undefined;\n\n    if (req.functionCall && req.functions && req.functions.length > 0) {\n      if (typeof req.functionCall === 'string') {\n        switch (req.functionCall) {\n          case 'auto':\n            toolsChoice = { tool_choice: { type: 'auto' as const } };\n            break;\n          case 'required':\n            toolsChoice = { tool_choice: { type: 'any' as const } };\n            break;\n          case 'none':\n            throw new Error('functionCall none not supported');\n        }\n      } else if ('function' in req.functionCall) {\n        toolsChoice = {\n          tool_choice: {\n            type: 'tool' as const,\n            name: req.functionCall.function.name,\n          },\n        };\n      } else {\n        throw new Error('Invalid function call type, must be string or object');\n      }\n    }\n\n    const system = req.chatPrompt\n      .filter((msg) => msg.role === 'system')\n      .map((msg) => ({\n        type: 'text' as const,\n        text: msg.content,\n        ...(msg.cache ? { cache_control: { type: 'ephemeral' as const } } : {}),\n      }));\n\n    const otherMessages = req.chatPrompt.filter((msg) => msg.role !== 'system');\n\n    // Compose tools from request function definitions and static config tools\n    const functionToolsFromReq: AxAIAnthropicChatRequest['tools'] | undefined =\n      req.functions?.map((v) => ({\n        name: v.name,\n        description: v.description,\n        input_schema: v.parameters\n          ? cleanSchemaForAnthropic(v.parameters)\n          : undefined,\n      }));\n\n    const configToolsRaw = this.config.tools ?? [];\n    const configToolsCleaned: AxAIAnthropicChatRequest['tools'] =\n      configToolsRaw.map((tool: any) => {\n        if (tool && typeof tool === 'object' && 'type' in tool) {\n          // Server tools (e.g., web_search) are passed through as-is\n          return tool;\n        }\n        // Function-style tools: ensure input_schema is cleaned\n        return {\n          name: tool.name,\n          description: tool.description,\n          input_schema: tool.input_schema\n            ? cleanSchemaForAnthropic(tool.input_schema)\n            : undefined,\n          ...(tool.cache_control ? { cache_control: tool.cache_control } : {}),\n        };\n      });\n\n    let tools: AxAIAnthropicChatRequest['tools'] | undefined = [\n      ...(functionToolsFromReq ?? []),\n      ...configToolsCleaned,\n    ];\n\n    // Anthropic Vertex does not support server tools like web_search; filter them out\n    if (this.isVertex && tools.length > 0) {\n      tools = tools.filter(\n        (t: any) => !(t && typeof t === 'object' && 'type' in t)\n      );\n    }\n    if (tools.length === 0) {\n      tools = undefined;\n    }\n\n    const maxTokens = req.modelConfig?.maxTokens ?? this.config.maxTokens;\n    const stopSequences =\n      req.modelConfig?.stopSequences ?? this.config.stopSequences;\n    const temperature = req.modelConfig?.temperature;\n    const topP = req.modelConfig?.topP; // do not fallback to config by default\n    const topK = req.modelConfig?.topK ?? this.config.topK;\n    const n = req.modelConfig?.n ?? this.config.n;\n\n    if (n && n > 1) {\n      throw new Error('Anthropic does not support sampling (n > 1)');\n    }\n\n    // Handle thinking configuration\n    let thinkingConfig: AxAIAnthropicThinkingConfig | undefined;\n\n    if (this.config.thinking?.budget_tokens) {\n      thinkingConfig = this.config.thinking;\n    }\n\n    // Override based on prompt-specific config\n    if (config?.thinkingTokenBudget) {\n      const levels = this.config.thinkingTokenBudgetLevels;\n\n      switch (config.thinkingTokenBudget) {\n        case 'none':\n          // When thinkingTokenBudget is 'none', disable thinking entirely\n          thinkingConfig = undefined;\n          break;\n        case 'minimal':\n          thinkingConfig = {\n            type: 'enabled',\n            budget_tokens: levels?.minimal ?? 1024,\n          };\n          break;\n        case 'low':\n          thinkingConfig = {\n            type: 'enabled',\n            budget_tokens: levels?.low ?? 5000,\n          };\n          break;\n        case 'medium':\n          thinkingConfig = {\n            type: 'enabled',\n            budget_tokens: levels?.medium ?? 10000,\n          };\n          break;\n        case 'high':\n          thinkingConfig = {\n            type: 'enabled',\n            budget_tokens: levels?.high ?? 20000,\n          };\n          break;\n        case 'highest':\n          thinkingConfig = {\n            type: 'enabled',\n            budget_tokens: levels?.highest ?? 32000,\n          };\n          break;\n      }\n    }\n\n    // If per-call options selected a model via key that mapped numeric budget to a level,\n    // map that level into concrete budget here when not provided via thinkingTokenBudget.\n    if (!thinkingConfig && (config as any)?.thinkingTokenBudget === undefined) {\n      const _levels = this.config.thinkingTokenBudgetLevels;\n      // No-op: rely on defaults\n    }\n\n    const messages = createMessages(otherMessages, !!thinkingConfig);\n\n    // If the outgoing messages include an assistant message that starts with a tool_use\n    // block (i.e., we are pre-supplying a function call), Anthropic requires the final\n    // assistant message to start with a thinking/redacted_thinking block when thinking\n    // is enabled. Since we do not have a prior thinking block to echo here, disable thinking\n    // for this request to comply with their requirement.\n    const hasAssistantStartingWithToolUse = messages.some(\n      (m) =>\n        m.role === 'assistant' &&\n        Array.isArray(m.content) &&\n        m.content.length > 0 &&\n        (m.content[0] as any)?.type === 'tool_use'\n    );\n    if (hasAssistantStartingWithToolUse) {\n      thinkingConfig = undefined;\n    }\n\n    const reqValue: AxAIAnthropicChatRequest = {\n      ...(this.isVertex\n        ? { anthropic_version: 'vertex-2023-10-16' }\n        : { model }),\n      ...(maxTokens ? { max_tokens: maxTokens } : {}),\n      ...(stopSequences && stopSequences.length > 0\n        ? { stop_sequences: stopSequences }\n        : {}),\n      // Only include temperature when thinking is not enabled\n      ...(temperature !== undefined && !thinkingConfig ? { temperature } : {}),\n      // Only include top_p when thinking is not enabled, or when it's >= 0.95\n      ...(topP !== undefined && (!thinkingConfig || topP >= 0.95)\n        ? { top_p: topP }\n        : {}),\n      // Only include top_k when thinking is not enabled\n      ...(topK && !thinkingConfig ? { top_k: topK } : {}),\n      ...toolsChoice,\n      ...(tools ? { tools } : {}),\n      ...(stream ? { stream: true } : {}),\n      ...(system ? { system } : {}),\n      ...(thinkingConfig ? { thinking: thinkingConfig } : {}),\n      messages,\n    };\n\n    return [apiConfig, reqValue];\n  };\n\n  createChatResp = (\n    resp: Readonly<AxAIAnthropicChatResponse | AxAIAnthropicChatError>\n  ): AxChatResponse => {\n    if (resp.type === 'error') {\n      // Use AxAIRefusalError for authentication and API errors that could be refusal-related\n      throw new AxAIRefusalError(\n        resp.error.message,\n        undefined, // model not specified in error response\n        undefined // requestId not specified in error response\n      );\n    }\n\n    const finishReason = mapFinishReason(resp.stop_reason);\n\n    // Determine if thoughts should be shown\n    const showThoughts =\n      this.currentPromptConfig?.thinkingTokenBudget !== 'none' &&\n      this.currentPromptConfig?.showThoughts !== false;\n\n    // Aggregate all content blocks into a single result to avoid mixing\n    // thinking text into the normal content while still exposing function calls.\n    let aggregatedContent = '';\n    let aggregatedThought = '';\n    let anyRedacted = false;\n    let lastSignature: string | undefined;\n    const aggregatedFunctionCalls: NonNullable<\n      AxChatResponseResult['functionCalls']\n    > = [];\n\n    // Collect citations from text blocks (citations are embedded here)\n    const citations: NonNullable<AxChatResponseResult['citations']> = [];\n\n    for (const block of resp.content) {\n      switch (block.type) {\n        case 'text':\n          aggregatedContent += block.text ?? '';\n          // Map citations if present on the text block\n          if (Array.isArray((block as any).citations)) {\n            for (const c of (block as any).citations) {\n              if (c?.url) {\n                citations.push({\n                  url: String(c.url),\n                  title: typeof c.title === 'string' ? c.title : undefined,\n                  snippet:\n                    typeof c.cited_text === 'string' ? c.cited_text : undefined,\n                });\n              }\n            }\n          }\n          break;\n        case 'thinking':\n        case 'redacted_thinking':\n          if (showThoughts) {\n            aggregatedThought +=\n              (block as any).thinking ?? (block as any).data ?? '';\n          }\n          if (block.type === 'redacted_thinking') anyRedacted = true;\n          if (typeof (block as any).signature === 'string') {\n            lastSignature = (block as any).signature as string;\n          }\n          break;\n        case 'tool_use':\n          aggregatedFunctionCalls.push({\n            id: block.id,\n            type: 'function',\n            function: { name: block.name, params: block.input },\n          });\n          break;\n      }\n    }\n\n    const result: AxChatResponseResult = {\n      index: 0,\n      id: resp.id,\n      finishReason,\n    };\n\n    if (aggregatedContent) {\n      result.content = aggregatedContent;\n    }\n    if (aggregatedThought) {\n      result.thought = aggregatedThought;\n      result.thoughtBlock = {\n        data: aggregatedThought,\n        encrypted: anyRedacted,\n        ...(lastSignature ? { signature: lastSignature } : {}),\n      };\n    }\n    if (aggregatedFunctionCalls.length > 0) {\n      result.functionCalls = aggregatedFunctionCalls;\n    }\n    if (citations.length > 0) {\n      result.citations = citations;\n    }\n\n    const results = [result];\n\n    this.tokensUsed = {\n      promptTokens: resp.usage.input_tokens,\n      completionTokens: resp.usage.output_tokens,\n      totalTokens: resp.usage.input_tokens + resp.usage.output_tokens,\n      cacheCreationTokens: resp.usage.cache_creation_input_tokens,\n      cacheReadTokens: resp.usage.cache_read_input_tokens,\n    };\n\n    return { results, remoteId: resp.id };\n  };\n\n  createChatStreamResp = (\n    resp: Readonly<AxAIAnthropicChatResponseDelta>,\n    state: object\n  ): AxChatResponse => {\n    if (!('type' in resp)) {\n      throw new Error('Invalid Anthropic streaming event');\n    }\n\n    const sstate = state as {\n      indexIdMap: Record<number, string>;\n    };\n\n    if (!sstate.indexIdMap) {\n      sstate.indexIdMap = {};\n    }\n\n    if (resp.type === 'error') {\n      const { error } = resp as unknown as AxAIAnthropicErrorEvent;\n      throw new AxAIRefusalError(\n        error.message,\n        undefined, // model not specified in error event\n        undefined // requestId not specified in error event\n      );\n    }\n\n    const index = 0;\n\n    if (resp.type === 'message_start') {\n      const { message } = resp as unknown as AxAIAnthropicMessageStartEvent;\n      const results = [{ index, content: '', id: message.id }];\n\n      this.tokensUsed = {\n        promptTokens: message.usage?.input_tokens ?? 0,\n        completionTokens: message.usage?.output_tokens ?? 0,\n        totalTokens:\n          (message.usage?.input_tokens ?? 0) +\n          (message.usage?.output_tokens ?? 0),\n      };\n      return { results };\n    }\n\n    if (resp.type === 'content_block_start') {\n      const { content_block: contentBlock } =\n        resp as unknown as AxAIAnthropicContentBlockStartEvent;\n\n      if (contentBlock.type === 'text') {\n        const annos: NonNullable<AxChatResponseResult['citations']> = [];\n        if (Array.isArray((contentBlock as any).citations)) {\n          for (const c of (contentBlock as any).citations) {\n            if (c?.url) {\n              annos.push({\n                url: String(c.url),\n                title: typeof c.title === 'string' ? c.title : undefined,\n                snippet:\n                  typeof c.cited_text === 'string' ? c.cited_text : undefined,\n              });\n            }\n          }\n        }\n        return {\n          results: [\n            {\n              index,\n              content: contentBlock.text,\n              ...(annos.length ? { citations: annos } : {}),\n            },\n          ],\n        };\n      }\n      if (contentBlock.type === 'thinking') {\n        // Determine if thoughts should be shown\n        const showThoughts =\n          this.currentPromptConfig?.thinkingTokenBudget !== 'none' &&\n          this.currentPromptConfig?.showThoughts !== false;\n        if (showThoughts) {\n          return {\n            results: [\n              {\n                index,\n                thought: contentBlock.thinking,\n                thoughtBlock: {\n                  data: contentBlock.thinking,\n                  encrypted: false,\n                },\n              },\n            ],\n          };\n        }\n        return {\n          results: [{ index, content: '' }],\n        };\n      }\n      if (contentBlock.type === 'tool_use') {\n        if (\n          typeof contentBlock.id === 'string' &&\n          typeof resp.index === 'number' &&\n          !sstate.indexIdMap[resp.index]\n        ) {\n          sstate.indexIdMap[resp.index] = contentBlock.id;\n          const functionCalls = [\n            {\n              id: contentBlock.id,\n              type: 'function' as const,\n              function: {\n                name: contentBlock.name,\n                params: '',\n              },\n            },\n          ];\n          return {\n            results: [{ index, functionCalls }],\n          };\n        }\n      }\n      if (\n        contentBlock.type === 'web_search_tool_result' ||\n        contentBlock.type === 'server_tool_use'\n      ) {\n        return {\n          results: [{ index, content: '' }],\n        };\n      }\n    }\n\n    if (resp.type === 'content_block_delta') {\n      const { delta } = resp as unknown as AxAIAnthropicContentBlockDeltaEvent;\n      // Emit standalone annotations when Anthropic streams citations separately\n      if ((delta as any).type === 'citations_delta') {\n        const c = (delta as any).citation;\n        if (c && typeof c.url === 'string' && c.url.length > 0) {\n          const annos: NonNullable<AxChatResponseResult['citations']> = [\n            {\n              url: String(c.url),\n              title: typeof c.title === 'string' ? c.title : undefined,\n              snippet:\n                typeof c.cited_text === 'string' ? c.cited_text : undefined,\n            },\n          ];\n          return {\n            results: [\n              {\n                index,\n                content: '',\n                citations: annos,\n              },\n            ],\n          };\n        }\n        return { results: [{ index, content: '' }] };\n      }\n      if (delta.type === 'text_delta') {\n        const annos: NonNullable<AxChatResponseResult['citations']> = [];\n        if (Array.isArray((delta as any).citations)) {\n          for (const c of (delta as any).citations) {\n            if (c?.url) {\n              annos.push({\n                url: String(c.url),\n                title: typeof c.title === 'string' ? c.title : undefined,\n                snippet:\n                  typeof c.cited_text === 'string' ? c.cited_text : undefined,\n              });\n            }\n          }\n        }\n        return {\n          results: [\n            {\n              index,\n              content: delta.text,\n              ...(annos.length ? { citations: annos } : {}),\n            },\n          ],\n        };\n      }\n      if (delta.type === 'thinking_delta') {\n        // Determine if thoughts should be shown\n        const showThoughts =\n          this.currentPromptConfig?.thinkingTokenBudget !== 'none' &&\n          this.currentPromptConfig?.showThoughts !== false;\n        if (showThoughts) {\n          return {\n            results: [\n              {\n                index,\n                thought: delta.thinking,\n                thoughtBlock: { data: delta.thinking, encrypted: false },\n              },\n            ],\n          };\n        }\n        return {\n          results: [{ index, content: '' }],\n        };\n      }\n      if (delta.type === 'signature_delta') {\n        // Signature deltas are handled internally by Anthropic,\n        // we don't need to expose them in the response\n        return {\n          results: [{ index, content: '' }],\n        };\n      }\n      if (delta.type === 'input_json_delta') {\n        const id = sstate.indexIdMap[resp.index];\n        if (!id) {\n          return { results: [{ index, content: '' }] };\n        }\n        const functionCalls = [\n          {\n            id,\n            type: 'function' as const,\n            function: {\n              name: '',\n              params: delta.partial_json,\n            },\n          },\n        ];\n        return {\n          results: [{ index, functionCalls }],\n        };\n      }\n    }\n\n    if (resp.type === 'message_delta') {\n      const { delta, usage } =\n        resp as unknown as AxAIAnthropicMessageDeltaEvent;\n\n      this.tokensUsed = {\n        promptTokens: 0,\n        completionTokens: usage.output_tokens,\n        totalTokens: usage.output_tokens,\n      };\n\n      const results = [\n        {\n          index,\n          content: '',\n          finishReason: mapFinishReason(delta.stop_reason),\n        },\n      ];\n      return { results };\n    }\n\n    return {\n      results: [{ index, content: '' }],\n    };\n  };\n}\n\nexport class AxAIAnthropic<TModelKey = string> extends AxBaseAI<\n  AxAIAnthropicModel | AxAIAnthropicVertexModel,\n  unknown,\n  AxAIAnthropicChatRequest,\n  never,\n  AxAIAnthropicChatResponse,\n  AxAIAnthropicChatResponseDelta,\n  never,\n  TModelKey\n> {\n  // Static factory method for automatic type inference\n  static create<const T extends AxAIAnthropicArgs<any>>(\n    options: T\n  ): T extends { models: infer M }\n    ? AxAIAnthropic<ExtractModelKeys<M>>\n    : AxAIAnthropic<string> {\n    return new AxAIAnthropic(options) as any;\n  }\n\n  constructor({\n    apiKey,\n    projectId,\n    region,\n    config,\n    options,\n    models,\n  }: Readonly<Omit<AxAIAnthropicArgs<TModelKey>, 'name'>>) {\n    const isVertex = projectId !== undefined && region !== undefined;\n\n    let apiURL: string;\n    let headers: () => Promise<Record<string, string>>;\n\n    if (isVertex) {\n      if (!apiKey) {\n        throw new Error('Anthropic Vertex API key not set');\n      }\n      if (typeof apiKey !== 'function') {\n        throw new Error(\n          'Anthropic Vertex API key must be a function for token-based authentication'\n        );\n      }\n      apiURL = `https://${region}-aiplatform.googleapis.com/v1/projects/${projectId}/locations/${region}/publishers/anthropic/`;\n      headers = async () => ({\n        Authorization: `Bearer ${await apiKey()}`,\n      });\n    } else {\n      if (!apiKey) {\n        throw new Error('Anthropic API key not set');\n      }\n      apiURL = 'https://api.anthropic.com/v1';\n      headers = async () => ({\n        'anthropic-version': '2023-06-01',\n        'anthropic-beta': 'prompt-caching-2024-07-31',\n        'x-api-key': typeof apiKey === 'function' ? await apiKey() : apiKey,\n      });\n    }\n\n    const Config = {\n      ...axAIAnthropicDefaultConfig(),\n      ...config,\n    };\n\n    const aiImpl = new AxAIAnthropicImpl(Config, isVertex);\n\n    const supportFor = (\n      model: AxAIAnthropicModel | AxAIAnthropicVertexModel\n    ) => {\n      const mi = getModelInfo<\n        AxAIAnthropicModel | AxAIAnthropicVertexModel,\n        undefined,\n        TModelKey\n      >({\n        model,\n        modelInfo: axModelInfoAnthropic,\n        models,\n      });\n      return {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: mi?.supported?.thinkingBudget ?? false,\n        hasShowThoughts: mi?.supported?.showThoughts ?? false,\n        functionCot: true,\n        media: {\n          images: {\n            supported: true,\n            formats: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],\n            maxSize: 5 * 1024 * 1024, // 5MB\n            detailLevels: ['high', 'low', 'auto'] as (\n              | 'high'\n              | 'low'\n              | 'auto'\n            )[],\n          },\n          audio: {\n            supported: false,\n            formats: [],\n            maxDuration: 0,\n          },\n          files: {\n            supported: false,\n            formats: [],\n            maxSize: 0,\n            uploadMethod: 'none' as 'inline' | 'upload' | 'cloud' | 'none',\n          },\n          urls: {\n            supported: false,\n            webSearch: false,\n            contextFetching: false,\n          },\n        },\n        caching: {\n          supported: true,\n          types: ['ephemeral'] as ('ephemeral' | 'persistent')[],\n        },\n        thinking: mi?.supported?.thinkingBudget ?? false,\n        multiTurn: true,\n      };\n    };\n\n    // Normalize per-model presets: allow provider-specific config on each model list item\n    const normalizedModels = models?.map((item) => {\n      const anyItem = item as any;\n      const cfg = anyItem?.config as Partial<AxAIAnthropicConfig> | undefined;\n      if (!cfg) return item;\n\n      const modelConfig: Partial<AxModelConfig> = {};\n      if (cfg.maxTokens !== undefined) modelConfig.maxTokens = cfg.maxTokens;\n      if (cfg.temperature !== undefined)\n        modelConfig.temperature = cfg.temperature;\n      if (cfg.topP !== undefined) modelConfig.topP = cfg.topP as number;\n      if (cfg.topK !== undefined) modelConfig.topK = cfg.topK as number;\n      if (cfg.presencePenalty !== undefined)\n        modelConfig.presencePenalty = cfg.presencePenalty as number;\n      if (cfg.frequencyPenalty !== undefined)\n        modelConfig.frequencyPenalty = cfg.frequencyPenalty as number;\n      if (cfg.stopSequences !== undefined)\n        modelConfig.stopSequences = cfg.stopSequences as string[];\n      if ((cfg as any).endSequences !== undefined)\n        (modelConfig as any).endSequences = (cfg as any).endSequences;\n      if (cfg.stream !== undefined) modelConfig.stream = cfg.stream as boolean;\n      if (cfg.n !== undefined) modelConfig.n = cfg.n as number;\n\n      const out: any = { ...anyItem };\n      if (Object.keys(modelConfig).length > 0) {\n        out.modelConfig = { ...(anyItem.modelConfig ?? {}), ...modelConfig };\n      }\n\n      // Map numeric thinking budget to closest Ax level\n      const numericBudget = cfg.thinking?.thinkingTokenBudget;\n      if (typeof numericBudget === 'number') {\n        const levels = Config.thinkingTokenBudgetLevels;\n        const candidates = [\n          ['minimal', levels?.minimal ?? 200],\n          ['low', levels?.low ?? 800],\n          ['medium', levels?.medium ?? 5000],\n          ['high', levels?.high ?? 10000],\n          ['highest', levels?.highest ?? 24500],\n        ] as const;\n        let bestName: 'minimal' | 'low' | 'medium' | 'high' | 'highest' =\n          'minimal';\n        let bestDiff = Number.POSITIVE_INFINITY;\n        for (const [name, value] of candidates) {\n          const diff = Math.abs(numericBudget - value);\n          if (diff < bestDiff) {\n            bestDiff = diff;\n            bestName = name as typeof bestName;\n          }\n        }\n        out.thinkingTokenBudget = bestName;\n      }\n      if (cfg.thinking?.includeThoughts !== undefined) {\n        out.showThoughts = !!cfg.thinking.includeThoughts;\n      }\n\n      return out as typeof item;\n    });\n\n    super(aiImpl, {\n      name: 'Anthropic',\n      apiURL,\n      headers,\n      modelInfo: axModelInfoAnthropic,\n      defaults: { model: Config.model },\n      options,\n      supportFor,\n      models: normalizedModels ?? models,\n    });\n  }\n}\n\ntype AnthropicMsg = AxAIAnthropicChatRequest['messages'][0];\ntype AnthropicMsgRoleUser = Extract<AnthropicMsg, { role: 'user' }>;\ntype AnthropicMsgRoleUserToolResult = Extract<\n  AnthropicMsgRoleUser['content'][0],\n  { type: 'tool_result' }\n>;\n\nfunction createMessages(\n  chatPrompt: Readonly<AxChatRequest['chatPrompt']>,\n  _thinkingEnabled?: boolean\n): AxAIAnthropicChatRequest['messages'] {\n  const items: AxAIAnthropicChatRequest['messages'] = chatPrompt.map((msg) => {\n    switch (msg.role) {\n      case 'function': {\n        const content: AnthropicMsgRoleUserToolResult[] = [\n          {\n            type: 'tool_result' as const,\n            content: msg.result,\n            tool_use_id: msg.functionId,\n            ...(msg.isError ? { is_error: true } : {}),\n            ...(msg.cache ? { cache: { type: 'ephemeral' } } : {}),\n          },\n        ];\n\n        return {\n          role: 'user' as const,\n          content,\n        };\n      }\n      case 'user': {\n        if (typeof msg.content === 'string') {\n          return {\n            role: 'user' as const,\n            content: msg.content,\n          };\n        }\n        const content = msg.content.map((v) => {\n          switch (v.type) {\n            case 'text':\n              return {\n                type: 'text' as const,\n                text: v.text,\n                ...(v.cache ? { cache: { type: 'ephemeral' } } : {}),\n              };\n            case 'image':\n              return {\n                type: 'image' as const,\n                source: {\n                  type: 'base64' as const,\n                  media_type: v.mimeType,\n                  data: v.image,\n                },\n                ...(v.cache ? { cache: { type: 'ephemeral' } } : {}),\n              };\n            default:\n              throw new Error('Invalid content type');\n          }\n        });\n        return {\n          role: 'user' as const,\n          content,\n        };\n      }\n      case 'assistant': {\n        let content: Extract<\n          AxAIAnthropicChatRequest['messages'][0],\n          { role: 'assistant' }\n        >['content'] = '';\n\n        // Preserve prior thinking blocks from memory when available\n        const preservedThinkingBlocks: (\n          | { type: 'thinking'; thinking: string; signature?: string }\n          | { type: 'redacted_thinking'; data: string; signature?: string }\n        )[] = [];\n        const tb: any = (msg as any).thoughtBlock;\n        if (tb && typeof tb.data === 'string' && tb.data.length > 0) {\n          if (tb.encrypted) {\n            preservedThinkingBlocks.push(\n              tb.signature\n                ? {\n                    type: 'redacted_thinking',\n                    data: tb.data,\n                    signature: tb.signature,\n                  }\n                : { type: 'redacted_thinking', data: tb.data }\n            );\n          } else {\n            preservedThinkingBlocks.push(\n              tb.signature\n                ? {\n                    type: 'thinking',\n                    thinking: tb.data,\n                    signature: tb.signature,\n                  }\n                : { type: 'thinking', thinking: tb.data }\n            );\n          }\n        }\n\n        if (typeof msg.content === 'string') {\n          // If we have preserved thinking, convert to block array and append text\n          if (preservedThinkingBlocks.length > 0) {\n            content = [\n              ...preservedThinkingBlocks,\n              { type: 'text' as const, text: msg.content },\n            ];\n          } else {\n            content = msg.content;\n          }\n        }\n        if (typeof msg.functionCalls !== 'undefined') {\n          content = msg.functionCalls.map((v) => {\n            let input: object = {};\n            if (typeof v.function.params === 'string') {\n              input = JSON.parse(v.function.params);\n            } else if (typeof v.function.params === 'object') {\n              input = v.function.params as object;\n            }\n            return {\n              type: 'tool_use' as const,\n              id: v.id,\n              name: v.function.name,\n              input,\n              ...(msg.cache ? { cache: { type: 'ephemeral' } } : {}),\n            };\n          });\n          if (Array.isArray(content) && preservedThinkingBlocks.length > 0) {\n            content = [\n              ...preservedThinkingBlocks,\n              ...(content as Extract<\n                AxAIAnthropicChatRequest['messages'][0],\n                { role: 'assistant' }\n              >['content'] as any[]),\n            ];\n          }\n        }\n        return {\n          role: 'assistant' as const,\n          content,\n        };\n      }\n      default:\n        throw new Error('Invalid role');\n    }\n  });\n\n  const merged = mergeAssistantMessages(items);\n  return trimAssistantStringContent(merged);\n}\n\n// Anthropic and some others need this in non-streaming mode\nfunction mergeAssistantMessages(\n  messages: Readonly<AxAIAnthropicChatRequest['messages']>\n): AxAIAnthropicChatRequest['messages'] {\n  const mergedMessages: AxAIAnthropicChatRequest['messages'] = [];\n\n  for (const [i, cur] of messages.entries()) {\n    // Continue if not an assistant message or first message\n    if (cur.role !== 'assistant') {\n      mergedMessages.push(cur);\n      continue;\n    }\n\n    // Merge current message with the previous one if both are from the assistant\n    if (i > 0 && messages.at(i - 1)?.role === 'assistant') {\n      const lastMessage = mergedMessages.pop();\n\n      mergedMessages.push({\n        ...(lastMessage ? lastMessage : {}),\n        ...cur,\n      });\n    } else {\n      mergedMessages.push(cur);\n    }\n  }\n\n  return mergedMessages;\n}\n\nfunction trimAssistantStringContent(\n  messages: Readonly<AxAIAnthropicChatRequest['messages']>\n): AxAIAnthropicChatRequest['messages'] {\n  return messages.map((m) => {\n    if (m.role === 'assistant' && typeof m.content === 'string') {\n      return { ...m, content: m.content.replace(/\\s+$/, '') };\n    }\n    return m;\n  });\n}\n\nfunction mapFinishReason(\n  stopReason?: AxAIAnthropicChatResponse['stop_reason'] | null\n): AxChatResponse['results'][0]['finishReason'] | undefined {\n  if (!stopReason) {\n    return undefined;\n  }\n  switch (stopReason) {\n    case 'stop_sequence':\n      return 'stop';\n    case 'max_tokens':\n      return 'length';\n    case 'tool_use':\n      return 'function_call';\n    case 'end_turn':\n      return 'stop';\n    default:\n      return 'stop';\n  }\n}\n","import type { AxModelConfig } from '../types.js';\n\nexport enum AxAIOpenAIModel {\n  // Non-reasoning models\n  GPT4 = 'gpt-4',\n  GPT41 = 'gpt-4.1',\n  GPT41Mini = 'gpt-4.1-mini',\n  GPT41Nano = 'gpt-4.1-nano',\n  GPT4O = 'gpt-4o',\n  GPT4OMini = 'gpt-4o-mini',\n  GPT4ChatGPT4O = 'chatgpt-4o-latest',\n  GPT4Turbo = 'gpt-4-turbo',\n  GPT35Turbo = 'gpt-3.5-turbo',\n  GPT35TurboInstruct = 'gpt-3.5-turbo-instruct',\n  GPT35TextDavinci002 = 'text-davinci-002',\n  GPT3TextBabbage002 = 'text-babbage-002',\n  GPT3TextAda001 = 'text-ada-001',\n  // GPT-5 models\n  GPT5 = 'gpt-5',\n  GPT5Nano = 'gpt-5-nano',\n  GPT5Mini = 'gpt-5-mini',\n  GPT5Chat = 'gpt-5-chat',\n  // Reasoning models\n  O1 = 'o1',\n  O1Mini = 'o1-mini',\n  O3 = 'o3',\n  O3Mini = 'o3-mini',\n  O4Mini = 'o4-mini',\n}\n\nexport enum AxAIOpenAIEmbedModel {\n  TextEmbeddingAda002 = 'text-embedding-ada-002',\n  TextEmbedding3Small = 'text-embedding-3-small',\n  TextEmbedding3Large = 'text-embedding-3-large',\n}\n\n// Web search annotation types\nexport type AxAIOpenAIUrlCitation = {\n  url: string;\n  title?: string;\n  description?: string;\n};\n\nexport type AxAIOpenAIAnnotation = {\n  type: 'url_citation';\n  url_citation: AxAIOpenAIUrlCitation;\n};\n\nexport type AxAIOpenAIConfig<TModel, TEmbedModel> = Omit<\n  AxModelConfig,\n  'topK'\n> & {\n  model: TModel;\n  embedModel?: TEmbedModel;\n  user?: string;\n  responseFormat?: 'json_object';\n  bestOf?: number;\n  logitBias?: Map<string, number>;\n  suffix?: string | null;\n  stop?: string[];\n  logprobs?: number;\n  echo?: boolean;\n  dimensions?: number;\n  reasoningEffort?: 'minimal' | 'low' | 'medium' | 'high';\n  store?: boolean;\n  serviceTier?: 'auto' | 'default' | 'flex';\n  webSearchOptions?: {\n    searchContextSize?: 'low' | 'medium' | 'high';\n    userLocation?: {\n      approximate: {\n        type: 'approximate';\n        city?: string;\n        country?: string;\n        region?: string;\n        timezone?: string;\n      };\n    } | null;\n  };\n};\n\nexport type AxAIOpenAILogprob = {\n  tokens: string[];\n  token_logprobs: number[];\n  top_logprobs: Map<string, number>;\n  text_offset: number[];\n};\n\nexport type AxAIOpenAIUsage = {\n  prompt_tokens: number;\n  completion_tokens: number;\n  total_tokens: number;\n};\n\nexport interface AxAIOpenAIResponseDelta<T> {\n  id: string;\n  object: string;\n  created: number;\n  model: string;\n  choices: {\n    index: number;\n    delta: T;\n    finish_reason: 'stop' | 'length' | 'content_filter' | 'tool_calls';\n  }[];\n  usage?: AxAIOpenAIUsage;\n  system_fingerprint: string;\n}\n\nexport type AxAIOpenAIChatRequest<TModel> = {\n  model: TModel;\n  reasoning_effort?: 'minimal' | 'low' | 'medium' | 'high';\n  store?: boolean;\n  messages: (\n    | { role: 'system'; content: string }\n    | {\n        role: 'user';\n        content:\n          | string\n          | (\n              | {\n                  type: string;\n                  text: string;\n                }\n              | {\n                  type: 'image_url';\n                  image_url: { url: string; details?: 'high' | 'low' | 'auto' };\n                }\n              | {\n                  type: 'input_audio';\n                  input_audio: { data: string; format?: 'wav' };\n                }\n              | {\n                  type: 'file';\n                  file: {\n                    file_data: string;\n                    filename: string;\n                  };\n                }\n            )[];\n        name?: string;\n      }\n    | {\n        role: 'assistant';\n        content:\n          | string\n          | {\n              type: string;\n              text: string;\n            };\n        name?: string;\n      }\n    | {\n        role: 'assistant';\n        content?:\n          | string\n          | {\n              type: string;\n              text: string;\n            };\n        name?: string;\n        tool_calls: {\n          type: 'function';\n          function: {\n            name: string;\n            // eslint-disable-next-line functional/functional-parameters\n            arguments?: string;\n          };\n        }[];\n      }\n    | { role: 'tool'; content: string; tool_call_id: string }\n  )[];\n  tools?: {\n    type: 'function';\n    function: {\n      name: string;\n      description: string;\n      parameters?: object;\n    };\n  }[];\n  tool_choice?:\n    | 'none'\n    | 'auto'\n    | 'required'\n    | { type: 'function'; function: { name: string } };\n  response_format?: { type: string };\n  max_completion_tokens?: number;\n  temperature?: number;\n  top_p?: number;\n  n?: number;\n  stream?: boolean;\n  stop?: readonly string[];\n  presence_penalty?: number;\n  frequency_penalty?: number;\n  logit_bias?: Map<string, number>;\n  user?: string;\n  organization?: string;\n  web_search_options?: {\n    search_context_size?: 'low' | 'medium' | 'high';\n    user_location?: {\n      approximate: {\n        type: 'approximate';\n        city?: string;\n        country?: string;\n        region?: string;\n        timezone?: string;\n      };\n    } | null;\n  };\n};\n\nexport type AxAIOpenAIChatResponse = {\n  id: string;\n  object: 'chat.completion';\n  created: number;\n  model: string;\n  choices: {\n    index: number;\n    message: {\n      role: string;\n      content: string | null;\n      refusal: string | null;\n      reasoning_content?: string;\n      annotations?: AxAIOpenAIAnnotation[];\n      tool_calls?: {\n        id: string;\n        type: 'function';\n        // eslint-disable-next-line functional/functional-parameters\n        function: { name: string; arguments: string };\n      }[];\n    };\n    finish_reason: 'stop' | 'length' | 'content_filter' | 'tool_calls';\n  }[];\n  usage?: AxAIOpenAIUsage;\n  error?: {\n    message: string;\n    type: string;\n    param: string;\n    code: number;\n  };\n  system_fingerprint: string;\n};\n\nexport type AxAIOpenAIChatResponseDelta = AxAIOpenAIResponseDelta<{\n  content: string | null;\n  refusal?: string | null;\n  reasoning_content?: string;\n  role?: string;\n  annotations?: AxAIOpenAIAnnotation[];\n  tool_calls?: (NonNullable<\n    AxAIOpenAIChatResponse['choices'][0]['message']['tool_calls']\n  >[0] & {\n    index: number;\n  })[];\n}>;\n\nexport type AxAIOpenAIEmbedRequest<TEmbedModel> = {\n  input: readonly string[];\n  model: TEmbedModel;\n  dimensions?: number;\n  user?: string;\n};\n\nexport type AxAIOpenAIEmbedResponse = {\n  model: string;\n  data: {\n    embedding: readonly number[];\n    index: number;\n  }[];\n  usage: AxAIOpenAIUsage;\n};\n","import type {\n  AxChatRequest,\n  AxChatResponseResult,\n  AxModelConfig,\n} from '../types.js';\n\n// Extended model enum for the responses API that includes models only available on responses API\nexport enum AxAIOpenAIResponsesModel {\n  // Non-reasoning models\n  GPT4 = 'gpt-4',\n  GPT41 = 'gpt-4.1',\n  GPT41Mini = 'gpt-4.1-mini',\n  GPT41Nano = 'gpt-4.1-nano',\n  GPT4O = 'gpt-4o',\n  GPT4OMini = 'gpt-4o-mini',\n  GPT4ChatGPT4O = 'chatgpt-4o-latest',\n  GPT4Turbo = 'gpt-4-turbo',\n  GPT35Turbo = 'gpt-3.5-turbo',\n  GPT35TurboInstruct = 'gpt-3.5-turbo-instruct',\n  GPT35TextDavinci002 = 'text-davinci-002',\n  GPT3TextBabbage002 = 'text-babbage-002',\n  GPT3TextAda001 = 'text-ada-001',\n  // GPT-5 models\n  GPT5 = 'gpt-5',\n  GPT5Nano = 'gpt-5-nano',\n  GPT5Mini = 'gpt-5-mini',\n  GPT5Chat = 'gpt-5-chat',\n  // Reasoning models\n  O1Pro = 'o1-pro',\n  O1 = 'o1',\n  O1Mini = 'o1-mini',\n  O3Pro = 'o3-pro',\n  O3 = 'o3',\n  O3Mini = 'o3-mini',\n  O4Mini = 'o4-mini',\n}\n\n// Define content part types directly based on AxChatRequest structure\nexport interface TextContentPart {\n  type: 'text';\n  text: string;\n  cache?: boolean;\n}\n\nexport interface ImageContentPart {\n  type: 'image';\n  mimeType: string;\n  image: string;\n  details?: 'high' | 'low' | 'auto';\n  cache?: boolean;\n}\n\nexport interface AudioContentPart {\n  type: 'audio';\n  data: string;\n  format?: 'wav';\n  cache?: boolean;\n}\n\n// Union of all content part types\nexport type UserMessageContentItem =\n  | TextContentPart\n  | ImageContentPart\n  | AudioContentPart;\n\n// export type  for function calls as defined in AxChatResponseResult\nexport type FunctionCallType = NonNullable<\n  AxChatResponseResult['functionCalls']\n>[number];\n\n// export type  for the items in req.functions\nexport type RequestFunctionDefinition = NonNullable<\n  AxChatRequest['functions']\n>[number];\n\n// --- AxAIOpenAI /v1/responses Specific Request Types ---\n\n// Content parts for input messages\nexport interface AxAIOpenAIResponsesInputTextContentPart {\n  readonly type: 'input_text';\n  text: string; // Made mutable for stream aggregation\n}\n\nexport interface AxAIOpenAIResponsesInputImageUrlContentPart {\n  readonly type: 'input_image';\n  readonly image_url: {\n    readonly url: string;\n    readonly details?: 'low' | 'high' | 'auto';\n  };\n}\n\nexport interface AxAIOpenAIResponsesInputAudioContentPart {\n  readonly type: 'input_audio'; // This is an assumption based on compatibility needs\n  readonly input_audio: {\n    readonly data: string; // base64 encoded audio\n    readonly format?: string; // e.g., 'wav', 'mp3'\n  };\n}\n\nexport type AxAIOpenAIResponsesInputContentPart =\n  | AxAIOpenAIResponsesInputTextContentPart\n  | AxAIOpenAIResponsesInputImageUrlContentPart\n  | AxAIOpenAIResponsesInputAudioContentPart\n  // Allow referencing prior assistant outputs in the input context\n  | AxAIOpenAIResponsesOutputTextContentPart;\n\n// Input Item: Message\nexport interface AxAIOpenAIResponsesInputMessageItem {\n  readonly type: 'message';\n  readonly role: 'system' | 'user' | 'assistant' | 'developer';\n  readonly content: string | ReadonlyArray<AxAIOpenAIResponsesInputContentPart>;\n  readonly name?: string; // Optional name for user/assistant messages\n  // status?: 'in_progress' | 'completed' | 'incomplete' // Typically for response items\n}\n\n// Input Item: Function Call (representing a past call by the model)\nexport interface AxAIOpenAIResponsesInputFunctionCallItem {\n  readonly type: 'function_call';\n  readonly id?: string; // Optional unique ID of this item in the context\n  readonly call_id: string; // The ID that links this call to its output\n  readonly name: string;\n  // eslint-disable-next-line functional/functional-parameters\n  readonly arguments: string; // JSON string of arguments\n  // status?: string // Typically for response items\n}\n\n// Input Item: Function Call Output (representing the result of a past call)\nexport interface AxAIOpenAIResponsesInputFunctionCallOutputItem {\n  readonly type: 'function_call_output';\n  readonly id?: string; // Optional unique ID of this item in the context\n  readonly call_id: string;\n  readonly output: string; // JSON string of the output\n  // status?: string // Typically for response items\n}\n\n// Union of all possible input items\n// Add other item types here as needed (e.g., FileSearch, WebSearch, Reasoning items)\nexport type AxAIOpenAIResponsesInputItem =\n  | string // Simple text input\n  | AxAIOpenAIResponsesInputMessageItem\n  | AxAIOpenAIResponsesInputFunctionCallItem\n  | AxAIOpenAIResponsesInputFunctionCallOutputItem;\n\n// Tool Definitions\nexport interface AxAIOpenAIResponsesDefineFunctionTool {\n  readonly type: 'function';\n  readonly name: string;\n  readonly description?: string;\n  readonly parameters: object; // JSON schema\n  readonly strict?: boolean; // Default true\n}\n\n// Add other tool definitions (FileSearch, WebSearch, etc.)\n// export interface AxAIOpenAIResponsesDefineFileSearchTool { type: 'file_search'; vector_store_ids: string[]; ... }\n// export interface AxAIOpenAIResponsesDefineWebSearchTool { type: 'web_search_preview'; ... }\n\nexport type AxAIOpenAIResponsesToolDefinition =\n  AxAIOpenAIResponsesDefineFunctionTool; // | AxAIOpenAIResponsesDefineFileSearchTool | ...\n\n// Tool Choice\nexport type AxAIOpenAIResponsesToolChoice =\n  | 'none'\n  | 'auto'\n  | 'required'\n  | { readonly type: 'function'; readonly name: string }\n  | { readonly type: 'file_search' }; // And other hosted tools\n// | { type: 'web_search_preview' }\n// | { type: 'code_interpreter' }\n\n// Main Request for /v1/responses\nexport interface AxAIOpenAIResponsesRequest<TModel = AxAIOpenAIResponsesModel> {\n  readonly input: string | ReadonlyArray<AxAIOpenAIResponsesInputItem>;\n  readonly model: TModel;\n  readonly background?: boolean | null;\n  readonly include?: ReadonlyArray<\n    | 'file_search_call.results'\n    | 'message.input_image.image_url'\n    | 'computer_call_output.output.image_url'\n    | 'reasoning.encrypted_content'\n    | 'code_interpreter_call.outputs'\n  > | null;\n  readonly instructions?: string | null; // Maps to system prompt\n  readonly max_output_tokens?: number | null;\n  readonly metadata?: Readonly<Record<string, string>> | null;\n  readonly parallel_tool_calls?: boolean | null;\n  readonly previous_response_id?: string | null;\n  readonly reasoning?: {\n    readonly effort?: 'minimal' | 'low' | 'medium' | 'high' | null;\n    readonly summary?: 'auto' | 'concise' | 'detailed' | null; // 'generate_summary' is deprecated\n  } | null;\n  readonly service_tier?: 'auto' | 'default' | 'flex' | null;\n  readonly store?: boolean | null; // Whether to store for later retrieval\n  readonly stream?: boolean | null;\n  readonly temperature?: number | null;\n  readonly text?: {\n    readonly format?:\n      | { readonly type: 'text' }\n      | { readonly type: 'json_object' } // Older JSON mode\n      | { readonly type: 'json_schema'; readonly json_schema?: object } // Structured Outputs\n      | null;\n  } | null;\n  readonly tool_choice?: AxAIOpenAIResponsesToolChoice | null;\n  readonly tools?: ReadonlyArray<AxAIOpenAIResponsesToolDefinition> | null;\n  readonly top_p?: number | null;\n  readonly truncation?: 'auto' | 'disabled' | null; // How to handle context window overflow\n  readonly user?: string | null; // User identifier for tracking/moderation\n  readonly seed?: number | null; // Added seed from later in the code\n}\n\n// --- AxAIOpenAI /v1/responses Specific Response Types ---\n\n// Output Item: Message (from assistant)\nexport interface AxAIOpenAIResponsesOutputMessageItem {\n  type: 'message'; // Mutable during construction\n  id: string; // Mutable during construction\n  role: 'assistant'; // Mutable during construction\n  content: ReadonlyArray<\n    | AxAIOpenAIResponsesOutputTextContentPart\n    | AxAIOpenAIResponsesOutputRefusalContentPart\n  >;\n  status: 'in_progress' | 'completed' | 'incomplete'; // Mutable during construction\n}\n\n// Output Item: Function Call (emitted by the model)\nexport interface AxAIOpenAIResponsesFunctionCallItem {\n  type: 'function_call'; // Mutable during construction\n  id: string; // Mutable during construction\n  call_id: string; // Mutable during construction\n  name: string; // Mutable during construction\n  // eslint-disable-next-line functional/functional-parameters\n  arguments: string; // Mutable during construction (appendable)\n  status?: 'in_progress' | 'completed' | 'incomplete' | 'searching' | 'failed'; // Mutable\n}\n\n// Output Item: Reasoning (if requested and supported)\nexport interface AxAIOpenAIResponsesReasoningItem {\n  readonly type: 'reasoning'; // Typically not built incrementally in the same way by client\n  readonly id: string;\n  readonly summary: ReadonlyArray<{\n    type: 'summary_text';\n    text: string;\n  }>;\n  readonly encrypted_content?: string | null;\n  readonly status?: 'in_progress' | 'completed' | 'incomplete';\n}\n\n// Add this new export interface for output_text parts\nexport interface AxAIOpenAIResponsesOutputTextContentPart {\n  readonly type: 'output_text';\n  readonly text: string;\n  readonly annotations?: ReadonlyArray<unknown>;\n}\n\nexport interface AxAIOpenAIResponsesOutputRefusalContentPart {\n  readonly type: 'refusal';\n  readonly refusal: string;\n}\n\n// Add export interface for reasoning summary parts\nexport interface AxAIOpenAIResponsesReasoningSummaryPart {\n  readonly type: 'summary_text';\n  readonly text: string;\n}\n\n// Update the union of all possible output items\nexport type AxAIOpenAIResponsesOutputItem =\n  | AxAIOpenAIResponsesOutputMessageItem\n  | AxAIOpenAIResponsesFunctionCallItem\n  | AxAIOpenAIResponsesReasoningItem\n  | AxAIOpenAIResponsesFileSearchToolCall\n  | AxAIOpenAIResponsesWebSearchToolCall\n  | AxAIOpenAIResponsesComputerToolCall\n  | AxAIOpenAIResponsesCodeInterpreterToolCall\n  | AxAIOpenAIResponsesImageGenerationToolCall\n  | AxAIOpenAIResponsesLocalShellToolCall\n  | AxAIOpenAIResponsesMCPToolCall;\n\n// Main Response from /v1/responses (non-streaming)\nexport interface AxAIOpenAIResponsesResponse {\n  readonly id: string; // Response ID\n  readonly object: string; // e.g., \"response\"\n  readonly created: number; // Timestamp\n  readonly model: string; // Model ID used\n  readonly output: ReadonlyArray<AxAIOpenAIResponsesOutputItem>;\n  readonly usage?: {\n    readonly prompt_tokens: number;\n    readonly completion_tokens?: number; // Some variants use output_tokens\n    readonly output_tokens?: number; // Alias seen in some responses\n    readonly total_tokens: number;\n    // reasoning_tokens?: number // if applicable and included\n  } | null;\n}\n\n// --- Streaming Event Types for /v1/responses ---\n\n// Base streaming event interface\nexport interface AxAIOpenAIResponsesStreamEventBase {\n  readonly type: string;\n  readonly sequence_number: number;\n}\n\n// Response lifecycle events\nexport interface AxAIOpenAIResponsesResponseCreatedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.created';\n  readonly response: Readonly<AxAIOpenAIResponsesResponse>;\n}\n\nexport interface AxAIOpenAIResponsesResponseInProgressEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.in_progress';\n  readonly response: Readonly<AxAIOpenAIResponsesResponse>;\n}\n\nexport interface AxAIOpenAIResponsesResponseCompletedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.completed';\n  readonly response: Readonly<AxAIOpenAIResponsesResponse>;\n}\n\nexport interface AxAIOpenAIResponsesResponseFailedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.failed';\n  readonly response: Readonly<AxAIOpenAIResponsesResponse>;\n}\n\nexport interface AxAIOpenAIResponsesResponseIncompleteEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.incomplete';\n  readonly response: Readonly<AxAIOpenAIResponsesResponse>;\n}\n\nexport interface AxAIOpenAIResponsesResponseQueuedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.queued';\n  readonly response: Readonly<AxAIOpenAIResponsesResponse>;\n}\n\n// Output item events\nexport interface AxAIOpenAIResponsesOutputItemAddedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.output_item.added';\n  readonly output_index: number;\n  readonly item: Readonly<AxAIOpenAIResponsesOutputItem>;\n}\n\nexport interface AxAIOpenAIResponsesOutputItemDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.output_item.done';\n  readonly output_index: number;\n  readonly item: Readonly<AxAIOpenAIResponsesOutputItem>;\n}\n\n// Content part events\nexport interface AxAIOpenAIResponsesContentPartAddedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.content_part.added';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly part: Readonly<\n    | AxAIOpenAIResponsesOutputTextContentPart\n    | AxAIOpenAIResponsesOutputRefusalContentPart\n  >;\n}\n\nexport interface AxAIOpenAIResponsesContentPartDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.content_part.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly part: Readonly<\n    | AxAIOpenAIResponsesOutputTextContentPart\n    | AxAIOpenAIResponsesOutputRefusalContentPart\n  >;\n}\n\n// Text delta events\nexport interface AxAIOpenAIResponsesOutputTextDeltaEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.output_text.delta';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly delta: string;\n}\n\nexport interface AxAIOpenAIResponsesOutputTextDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.output_text.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly text: string;\n}\n\n// Refusal events\nexport interface AxAIOpenAIResponsesRefusalDeltaEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.refusal.delta';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly delta: string;\n}\n\nexport interface AxAIOpenAIResponsesRefusalDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.refusal.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly refusal: string;\n}\n\n// Function call events\nexport interface AxAIOpenAIResponsesFunctionCallArgumentsDeltaEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.function_call_arguments.delta';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly delta: string;\n}\n\nexport interface AxAIOpenAIResponsesFunctionCallArgumentsDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.function_call_arguments.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  // eslint-disable-next-line functional/functional-parameters\n  readonly arguments: string;\n}\n\n// File search events\nexport interface AxAIOpenAIResponsesFileSearchCallInProgressEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.file_search_call.in_progress';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesFileSearchCallSearchingEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.file_search_call.searching';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesFileSearchCallCompletedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.file_search_call.completed';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\n// Web search events\nexport interface AxAIOpenAIResponsesWebSearchCallInProgressEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.web_search_call.in_progress';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesWebSearchCallSearchingEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.web_search_call.searching';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesWebSearchCallCompletedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.web_search_call.completed';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\n// Reasoning events\nexport interface AxAIOpenAIResponsesReasoningDeltaEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning.delta';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly delta: object;\n}\n\nexport interface AxAIOpenAIResponsesReasoningDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly text: string;\n}\n\n// Reasoning summary events\nexport interface AxAIOpenAIResponsesReasoningSummaryPartAddedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning_summary_part.added';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly summary_index: number;\n  readonly part: Readonly<AxAIOpenAIResponsesReasoningSummaryPart>;\n}\n\nexport interface AxAIOpenAIResponsesReasoningSummaryPartDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning_summary_part.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly summary_index: number;\n  readonly part: Readonly<AxAIOpenAIResponsesReasoningSummaryPart>;\n}\n\nexport interface AxAIOpenAIResponsesReasoningSummaryTextDeltaEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning_summary_text.delta';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly summary_index: number;\n  readonly delta: string;\n}\n\nexport interface AxAIOpenAIResponsesReasoningSummaryTextDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning_summary_text.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly summary_index: number;\n  readonly text: string;\n}\n\nexport interface AxAIOpenAIResponsesReasoningSummaryDeltaEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning_summary.delta';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly summary_index: number;\n  readonly delta: object;\n}\n\nexport interface AxAIOpenAIResponsesReasoningSummaryDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning_summary.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly summary_index: number;\n  readonly text: string;\n}\n\n// Image generation events\nexport interface AxAIOpenAIResponsesImageGenerationCallInProgressEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.image_generation_call.in_progress';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesImageGenerationCallGeneratingEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.image_generation_call.generating';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesImageGenerationCallCompletedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.image_generation_call.completed';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesImageGenerationCallPartialImageEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.image_generation_call.partial_image';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly partial_image_index: number;\n  readonly partial_image_b64: string;\n}\n\n// MCP events\nexport interface AxAIOpenAIResponsesMCPCallInProgressEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_call.in_progress';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesMCPCallArgumentsDeltaEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_call.arguments.delta';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly delta: object;\n}\n\nexport interface AxAIOpenAIResponsesMCPCallArgumentsDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_call.arguments.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  // eslint-disable-next-line functional/functional-parameters\n  readonly arguments: object;\n}\n\nexport interface AxAIOpenAIResponsesMCPCallCompletedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_call.completed';\n}\n\nexport interface AxAIOpenAIResponsesMCPCallFailedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_call.failed';\n}\n\nexport interface AxAIOpenAIResponsesMCPListToolsInProgressEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_list_tools.in_progress';\n}\n\nexport interface AxAIOpenAIResponsesMCPListToolsCompletedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_list_tools.completed';\n}\n\nexport interface AxAIOpenAIResponsesMCPListToolsFailedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_list_tools.failed';\n}\n\n// Annotation events\nexport interface AxAIOpenAIResponsesOutputTextAnnotationAddedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.output_text_annotation.added';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly annotation_index: number;\n  readonly annotation: object;\n}\n\n// Error event\nexport interface AxAIOpenAIResponsesErrorEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'error';\n  readonly code: string | null;\n  readonly message: string;\n  readonly param: string | null;\n}\n\n// Union of all streaming events\nexport type AxAIOpenAIResponsesStreamEvent =\n  | AxAIOpenAIResponsesResponseCreatedEvent\n  | AxAIOpenAIResponsesResponseInProgressEvent\n  | AxAIOpenAIResponsesResponseCompletedEvent\n  | AxAIOpenAIResponsesResponseFailedEvent\n  | AxAIOpenAIResponsesResponseIncompleteEvent\n  | AxAIOpenAIResponsesResponseQueuedEvent\n  | AxAIOpenAIResponsesOutputItemAddedEvent\n  | AxAIOpenAIResponsesOutputItemDoneEvent\n  | AxAIOpenAIResponsesContentPartAddedEvent\n  | AxAIOpenAIResponsesContentPartDoneEvent\n  | AxAIOpenAIResponsesOutputTextDeltaEvent\n  | AxAIOpenAIResponsesOutputTextDoneEvent\n  | AxAIOpenAIResponsesRefusalDeltaEvent\n  | AxAIOpenAIResponsesRefusalDoneEvent\n  | AxAIOpenAIResponsesFunctionCallArgumentsDeltaEvent\n  | AxAIOpenAIResponsesFunctionCallArgumentsDoneEvent\n  | AxAIOpenAIResponsesFileSearchCallInProgressEvent\n  | AxAIOpenAIResponsesFileSearchCallSearchingEvent\n  | AxAIOpenAIResponsesFileSearchCallCompletedEvent\n  | AxAIOpenAIResponsesWebSearchCallInProgressEvent\n  | AxAIOpenAIResponsesWebSearchCallSearchingEvent\n  | AxAIOpenAIResponsesWebSearchCallCompletedEvent\n  | AxAIOpenAIResponsesReasoningDeltaEvent\n  | AxAIOpenAIResponsesReasoningDoneEvent\n  | AxAIOpenAIResponsesReasoningSummaryPartAddedEvent\n  | AxAIOpenAIResponsesReasoningSummaryPartDoneEvent\n  | AxAIOpenAIResponsesReasoningSummaryTextDeltaEvent\n  | AxAIOpenAIResponsesReasoningSummaryTextDoneEvent\n  | AxAIOpenAIResponsesReasoningSummaryDeltaEvent\n  | AxAIOpenAIResponsesReasoningSummaryDoneEvent\n  | AxAIOpenAIResponsesImageGenerationCallInProgressEvent\n  | AxAIOpenAIResponsesImageGenerationCallGeneratingEvent\n  | AxAIOpenAIResponsesImageGenerationCallCompletedEvent\n  | AxAIOpenAIResponsesImageGenerationCallPartialImageEvent\n  | AxAIOpenAIResponsesMCPCallInProgressEvent\n  | AxAIOpenAIResponsesMCPCallArgumentsDeltaEvent\n  | AxAIOpenAIResponsesMCPCallArgumentsDoneEvent\n  | AxAIOpenAIResponsesMCPCallCompletedEvent\n  | AxAIOpenAIResponsesMCPCallFailedEvent\n  | AxAIOpenAIResponsesMCPListToolsInProgressEvent\n  | AxAIOpenAIResponsesMCPListToolsCompletedEvent\n  | AxAIOpenAIResponsesMCPListToolsFailedEvent\n  | AxAIOpenAIResponsesOutputTextAnnotationAddedEvent\n  | AxAIOpenAIResponsesErrorEvent;\n\n// Legacy delta export interface for backward compatibility - now maps to the new streaming events\nexport interface AxAIOpenAIResponsesResponseDelta {\n  readonly id?: string; // Overall response ID, appears in first event usually\n  readonly model?: string; // Model ID, might appear in first event\n  readonly event?: string; // e.g., 'response.delta', 'response.item_delta', 'response.done'\n\n  // If event is 'response.delta' or 'response.item_delta'\n  readonly delta?: {\n    // For message content delta\n    readonly content?: string; // If item is a message part\n    // For tool call argument delta\n    // eslint-disable-next-line functional/functional-parameters\n    readonly arguments?: string; // If item is a function_call part\n    // Other potential delta fields based on item type\n  };\n\n  // If event is 'response.item_created', 'response.item_delta', 'response.item_completed'\n  readonly item_index?: number; // Index of the item in the `items` array\n  readonly item?: Partial<Readonly<AxAIOpenAIResponsesOutputItem>>; // The item being streamed or its delta\n\n  // If event is 'response.done'\n  readonly response?: Readonly<AxAIOpenAIResponsesResponse>; // The final full response object (often without items if streamed separately)\n  readonly usage?: {\n    readonly prompt_tokens: number;\n    readonly completion_tokens: number;\n    readonly total_tokens: number;\n    // reasoning_tokens?: number\n  } | null; // Usage often comes in the 'response.done' event or with stream_options\n}\n\n// export type  for the function that updates the request before sending\nexport type ResponsesReqUpdater<\n  TModel,\n  TResponsesReq extends AxAIOpenAIResponsesRequest<TModel>,\n> = (req: Readonly<TResponsesReq>) => Readonly<TResponsesReq>;\n\n// Utility export type  to make properties of T mutable\nexport type Mutable<T> = { -readonly [P in keyof T]: T[P] };\n\nexport type AxAIOpenAIResponsesConfig<TModel, TEmbedModel> = Omit<\n  AxModelConfig,\n  'topK'\n> & {\n  model: TModel;\n  embedModel?: TEmbedModel;\n  user?: string;\n  bestOf?: number;\n  logitBias?: Map<string, number>;\n  suffix?: string | null;\n  stop?: string[];\n  logprobs?: number;\n  echo?: boolean;\n  dimensions?: number;\n  reasoningEffort?: 'minimal' | 'low' | 'medium' | 'high';\n  reasoningSummary?: 'auto' | 'concise' | 'detailed';\n  store?: boolean;\n  systemPrompt?: string;\n  parallelToolCalls?: boolean;\n  seed?: number;\n  responseFormat?: 'text' | 'json_object' | 'json_schema';\n  serviceTier?: 'auto' | 'default' | 'flex';\n};\n\n// ToolCall response types\nexport interface AxAIOpenAIResponsesToolCallBase {\n  id: string;\n  type: string;\n  status?: string;\n}\n\nexport interface AxAIOpenAIResponsesFileSearchToolCall\n  extends AxAIOpenAIResponsesToolCallBase {\n  type: 'file_search_call';\n  queries: string[];\n  results?: {\n    file_id: string;\n    filename: string;\n    score: number;\n    text: string;\n    attributes?: Record<string, string | boolean | number>;\n  }[];\n}\n\nexport interface AxAIOpenAIResponsesWebSearchToolCall\n  extends AxAIOpenAIResponsesToolCallBase {\n  type: 'web_search_call';\n  queries: string[];\n}\n\nexport interface AxAIOpenAIResponsesComputerToolCall\n  extends AxAIOpenAIResponsesToolCallBase {\n  type: 'computer_call';\n  action: object;\n}\n\nexport interface AxAIOpenAIResponsesCodeInterpreterToolCall\n  extends AxAIOpenAIResponsesToolCallBase {\n  type: 'code_interpreter_call';\n  code: string;\n  results?: unknown[];\n}\n\nexport interface AxAIOpenAIResponsesImageGenerationToolCall\n  extends AxAIOpenAIResponsesToolCallBase {\n  type: 'image_generation_call';\n  result?: string;\n}\n\nexport interface AxAIOpenAIResponsesLocalShellToolCall\n  extends AxAIOpenAIResponsesToolCallBase {\n  type: 'local_shell_call';\n  action: object;\n}\n\nexport interface AxAIOpenAIResponsesMCPToolCall\n  extends AxAIOpenAIResponsesToolCallBase {\n  type: 'mcp_call';\n  name: string;\n  args: string;\n  server_label: string;\n  output?: string;\n  error?: string;\n}\n\nexport type AxAIOpenAIResponsesToolCall =\n  | AxAIOpenAIResponsesFunctionCallItem\n  | AxAIOpenAIResponsesFileSearchToolCall\n  | AxAIOpenAIResponsesWebSearchToolCall\n  | AxAIOpenAIResponsesComputerToolCall\n  | AxAIOpenAIResponsesCodeInterpreterToolCall\n  | AxAIOpenAIResponsesImageGenerationToolCall\n  | AxAIOpenAIResponsesLocalShellToolCall\n  | AxAIOpenAIResponsesMCPToolCall;\n","import type { AxModelInfo } from '../types.js';\n\nimport { AxAIOpenAIEmbedModel, AxAIOpenAIModel } from './chat_types.js';\nimport { AxAIOpenAIResponsesModel } from './responses_types.js';\n\n/**\n * OpenAI: Model information\n */\nexport const axModelInfoOpenAI: AxModelInfo[] = [\n  // Not Reasoning models\n  {\n    name: AxAIOpenAIModel.GPT4,\n    currency: 'usd',\n    promptTokenCostPer1M: 30,\n    completionTokenCostPer1M: 60,\n  },\n  {\n    name: AxAIOpenAIModel.GPT41,\n    currency: 'usd',\n    promptTokenCostPer1M: 2,\n    completionTokenCostPer1M: 8,\n  },\n  {\n    name: AxAIOpenAIModel.GPT41Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.4,\n    completionTokenCostPer1M: 1.6,\n  },\n  {\n    name: AxAIOpenAIModel.GPT41Nano,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.4,\n  },\n  {\n    name: AxAIOpenAIModel.GPT4O,\n    currency: 'usd',\n    promptTokenCostPer1M: 5,\n    completionTokenCostPer1M: 15,\n  },\n  {\n    name: AxAIOpenAIModel.GPT4OMini,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.15,\n    completionTokenCostPer1M: 0.6,\n  },\n  {\n    name: AxAIOpenAIModel.GPT4ChatGPT4O,\n    currency: 'usd',\n    promptTokenCostPer1M: 5,\n    completionTokenCostPer1M: 15,\n  },\n  {\n    name: AxAIOpenAIModel.GPT4Turbo,\n    currency: 'usd',\n    promptTokenCostPer1M: 10,\n    completionTokenCostPer1M: 30,\n  },\n  {\n    name: AxAIOpenAIModel.GPT35Turbo,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.5,\n    completionTokenCostPer1M: 1.5,\n  },\n  // GPT-5 models\n  {\n    name: AxAIOpenAIModel.GPT5Nano,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.5,\n    completionTokenCostPer1M: 1.5,\n    notSupported: { temperature: true, topP: true },\n  },\n  {\n    name: AxAIOpenAIModel.GPT5Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 2,\n    completionTokenCostPer1M: 6,\n    notSupported: { temperature: true, topP: true },\n  },\n  {\n    name: AxAIOpenAIModel.GPT5,\n    currency: 'usd',\n    promptTokenCostPer1M: 10,\n    completionTokenCostPer1M: 30,\n    notSupported: { temperature: true, topP: true },\n  },\n  {\n    name: AxAIOpenAIModel.GPT5Chat,\n    currency: 'usd',\n    promptTokenCostPer1M: 12,\n    completionTokenCostPer1M: 36,\n    notSupported: { temperature: true, topP: true },\n  },\n  {\n    name: AxAIOpenAIModel.GPT5,\n    currency: 'usd',\n    promptTokenCostPer1M: 20,\n    completionTokenCostPer1M: 60,\n    notSupported: { temperature: true, topP: true },\n  },\n  // Reasoning models\n  {\n    name: AxAIOpenAIModel.O1,\n    currency: 'usd',\n    promptTokenCostPer1M: 15,\n    completionTokenCostPer1M: 60,\n  },\n  {\n    name: AxAIOpenAIModel.O1Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 1.1,\n    completionTokenCostPer1M: 14.4,\n  },\n  {\n    name: AxAIOpenAIModel.O3,\n    currency: 'usd',\n    promptTokenCostPer1M: 15,\n    completionTokenCostPer1M: 60,\n  },\n  {\n    name: AxAIOpenAIModel.O4Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 1.1,\n    completionTokenCostPer1M: 4.4,\n  },\n  // Embedding models\n  {\n    name: AxAIOpenAIEmbedModel.TextEmbeddingAda002,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.1,\n  },\n  {\n    name: AxAIOpenAIEmbedModel.TextEmbedding3Small,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.02,\n    completionTokenCostPer1M: 0.02,\n  },\n  {\n    name: AxAIOpenAIEmbedModel.TextEmbedding3Large,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.13,\n    completionTokenCostPer1M: 0.13,\n  },\n];\n\n/**\n * OpenAI: Model information\n */\nexport const axModelInfoOpenAIResponses: AxModelInfo[] = [\n  // Not Reasoning models\n  {\n    name: AxAIOpenAIResponsesModel.GPT4,\n    currency: 'usd',\n    promptTokenCostPer1M: 30,\n    completionTokenCostPer1M: 60,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT41,\n    currency: 'usd',\n    promptTokenCostPer1M: 2,\n    completionTokenCostPer1M: 8,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT41Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.4,\n    completionTokenCostPer1M: 1.6,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT41Nano,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.4,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT4O,\n    currency: 'usd',\n    promptTokenCostPer1M: 5,\n    completionTokenCostPer1M: 15,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT4OMini,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.15,\n    completionTokenCostPer1M: 0.6,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT4ChatGPT4O,\n    currency: 'usd',\n    promptTokenCostPer1M: 5,\n    completionTokenCostPer1M: 15,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT4Turbo,\n    currency: 'usd',\n    promptTokenCostPer1M: 10,\n    completionTokenCostPer1M: 30,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT35Turbo,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.5,\n    completionTokenCostPer1M: 1.5,\n  },\n  // GPT-5 models\n  {\n    name: AxAIOpenAIResponsesModel.GPT5Nano,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.5,\n    completionTokenCostPer1M: 1.5,\n    notSupported: { temperature: true, topP: true },\n    supported: { thinkingBudget: true, showThoughts: true },\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT5Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 2,\n    completionTokenCostPer1M: 6,\n    notSupported: { temperature: true, topP: true },\n    supported: { thinkingBudget: true, showThoughts: true },\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT5,\n    currency: 'usd',\n    promptTokenCostPer1M: 10,\n    completionTokenCostPer1M: 30,\n    notSupported: { temperature: true, topP: true },\n    supported: { thinkingBudget: true, showThoughts: true },\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT5Chat,\n    currency: 'usd',\n    promptTokenCostPer1M: 12,\n    completionTokenCostPer1M: 36,\n    notSupported: { temperature: true, topP: true },\n    supported: { thinkingBudget: true, showThoughts: true },\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT5,\n    currency: 'usd',\n    promptTokenCostPer1M: 20,\n    completionTokenCostPer1M: 60,\n    notSupported: { temperature: true, topP: true },\n    supported: { thinkingBudget: true, showThoughts: true },\n  },\n  // Reasoning models\n  {\n    name: AxAIOpenAIResponsesModel.O1Pro,\n    currency: 'usd',\n    promptTokenCostPer1M: 150,\n    completionTokenCostPer1M: 600,\n    supported: { thinkingBudget: true, showThoughts: true },\n    isExpensive: true,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.O1,\n    currency: 'usd',\n    promptTokenCostPer1M: 15,\n    completionTokenCostPer1M: 60,\n    supported: { thinkingBudget: true, showThoughts: true },\n  },\n  {\n    name: AxAIOpenAIResponsesModel.O3Pro,\n    currency: 'usd',\n    promptTokenCostPer1M: 20,\n    completionTokenCostPer1M: 80,\n    supported: { thinkingBudget: true, showThoughts: true },\n    isExpensive: true,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.O3,\n    currency: 'usd',\n    promptTokenCostPer1M: 15,\n    completionTokenCostPer1M: 60,\n    supported: { thinkingBudget: true, showThoughts: true },\n  },\n  {\n    name: AxAIOpenAIModel.O3Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 1.1,\n    completionTokenCostPer1M: 4.4,\n    supported: { thinkingBudget: true, showThoughts: true },\n  },\n  {\n    name: AxAIOpenAIResponsesModel.O4Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 1.1,\n    completionTokenCostPer1M: 4.4,\n    supported: { thinkingBudget: true, showThoughts: true },\n  },\n];\n","import { getModelInfo } from '../../dsp/modelinfo.js';\nimport type { AxAPI } from '../../util/apicall.js';\nimport { AxAIRefusalError } from '../../util/apicall.js';\nimport {\n  type AxAIFeatures,\n  AxBaseAI,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxEmbedResponse,\n  AxInternalChatRequest,\n  AxInternalEmbedRequest,\n  AxModelConfig,\n  AxModelInfo,\n  AxTokenUsage,\n} from '../types.js';\nimport {\n  type AxAIOpenAIChatRequest,\n  type AxAIOpenAIChatResponse,\n  type AxAIOpenAIChatResponseDelta,\n  type AxAIOpenAIConfig,\n  AxAIOpenAIEmbedModel,\n  type AxAIOpenAIEmbedRequest,\n  type AxAIOpenAIEmbedResponse,\n  AxAIOpenAIModel,\n} from './chat_types.js';\nimport { axModelInfoOpenAI } from './info.js';\n\n/**\n * Checks if the given OpenAI model is a thinking/reasoning model.\n * Thinking models (o1, o3, o4 series) have different parameter restrictions.\n */\nexport const isOpenAIThinkingModel = (model: string): boolean => {\n  const thinkingModels = [\n    AxAIOpenAIModel.O1,\n    AxAIOpenAIModel.O1Mini,\n    AxAIOpenAIModel.O3,\n    AxAIOpenAIModel.O3Mini,\n    AxAIOpenAIModel.O4Mini,\n    // Pro models (string values since they're not in the regular chat enum)\n    'o1-pro',\n    'o3-pro',\n  ];\n  return (\n    thinkingModels.includes(model as AxAIOpenAIModel) ||\n    thinkingModels.includes(model)\n  );\n};\n\nexport const axAIOpenAIDefaultConfig = (): AxAIOpenAIConfig<\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel\n> =>\n  structuredClone({\n    model: AxAIOpenAIModel.GPT5Mini,\n    embedModel: AxAIOpenAIEmbedModel.TextEmbedding3Small,\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAIOpenAIBestConfig = (): AxAIOpenAIConfig<\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel\n> =>\n  structuredClone({\n    ...axAIOpenAIDefaultConfig(),\n    model: AxAIOpenAIModel.GPT5,\n  });\n\nexport const axAIOpenAICreativeConfig = (): AxAIOpenAIConfig<\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel\n> =>\n  structuredClone({\n    model: AxAIOpenAIModel.GPT5Mini,\n    embedModel: AxAIOpenAIEmbedModel.TextEmbedding3Small,\n    ...axBaseAIDefaultCreativeConfig(),\n  });\n\nexport const axAIOpenAIFastConfig = (): AxAIOpenAIConfig<\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel\n> => ({\n  ...axAIOpenAIDefaultConfig(),\n  model: AxAIOpenAIModel.GPT5Nano,\n});\n\nexport interface AxAIOpenAIArgs<\n  TName = 'openai',\n  TModel = AxAIOpenAIModel,\n  TEmbedModel = AxAIOpenAIEmbedModel,\n  TModelKey = string,\n  TChatReq extends\n    AxAIOpenAIChatRequest<TModel> = AxAIOpenAIChatRequest<TModel>,\n> extends Omit<\n    AxAIOpenAIBaseArgs<TModel, TEmbedModel, TModelKey, TChatReq>,\n    'config' | 'supportFor' | 'modelInfo'\n  > {\n  name: TName;\n  modelInfo?: AxModelInfo[];\n  config?: Partial<\n    AxAIOpenAIBaseArgs<TModel, TEmbedModel, TModelKey, TChatReq>['config']\n  >;\n}\n\ntype ChatReqUpdater<TModel, TChatReq extends AxAIOpenAIChatRequest<TModel>> = (\n  req: Readonly<TChatReq>\n) => TChatReq;\n\nexport interface AxAIOpenAIBaseArgs<\n  TModel,\n  TEmbedModel,\n  TModelKey,\n  TChatReq extends AxAIOpenAIChatRequest<TModel>,\n> {\n  apiKey: string;\n  apiURL?: string;\n  config: Readonly<AxAIOpenAIConfig<TModel, TEmbedModel>>;\n  options?: Readonly<AxAIServiceOptions & { streamingUsage?: boolean }>;\n  modelInfo: Readonly<AxModelInfo[]>;\n  models?: AxAIInputModelList<TModel, TEmbedModel, TModelKey>;\n  chatReqUpdater?: ChatReqUpdater<TModel, TChatReq>;\n  supportFor: AxAIFeatures | ((model: TModel) => AxAIFeatures);\n}\n\nclass AxAIOpenAIImpl<\n  TModel,\n  TEmbedModel,\n  TChatReq extends AxAIOpenAIChatRequest<TModel>,\n> implements\n    AxAIServiceImpl<\n      TModel,\n      TEmbedModel,\n      AxAIOpenAIChatRequest<TModel>,\n      AxAIOpenAIEmbedRequest<TEmbedModel>,\n      AxAIOpenAIChatResponse,\n      AxAIOpenAIChatResponseDelta,\n      AxAIOpenAIEmbedResponse\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n\n  constructor(\n    private readonly config: Readonly<AxAIOpenAIConfig<TModel, TEmbedModel>>,\n    private streamingUsage: boolean,\n    private readonly chatReqUpdater?: ChatReqUpdater<TModel, TChatReq>\n  ) {}\n\n  getTokenUsage(): AxTokenUsage | undefined {\n    return this.tokensUsed;\n  }\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this;\n\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      presencePenalty: config.presencePenalty,\n      frequencyPenalty: config.frequencyPenalty,\n      stopSequences: config.stopSequences,\n      endSequences: config.endSequences,\n      topP: config.topP,\n      n: config.n,\n      stream: config.stream,\n    };\n  }\n\n  createChatReq = (\n    req: Readonly<AxInternalChatRequest<TModel>>,\n    config: Readonly<AxAIServiceOptions>\n  ): [AxAPI, AxAIOpenAIChatRequest<TModel>] => {\n    const model = req.model;\n\n    if (!req.chatPrompt || req.chatPrompt.length === 0) {\n      throw new Error('Chat prompt is empty');\n    }\n\n    const apiConfig = {\n      name: '/chat/completions',\n    };\n\n    const tools = req.functions?.map((v) => ({\n      type: 'function' as const,\n      function: {\n        name: v.name,\n        description: v.description,\n        parameters: v.parameters,\n      },\n    }));\n\n    const toolsChoice =\n      !req.functionCall && req.functions && req.functions.length > 0\n        ? 'auto'\n        : req.functionCall;\n\n    const messages = createMessages(req);\n\n    const frequencyPenalty =\n      req.modelConfig?.frequencyPenalty ?? this.config.frequencyPenalty;\n\n    const stream = req.modelConfig?.stream ?? this.config.stream;\n\n    const store = this.config.store;\n\n    const isThinkingModel = isOpenAIThinkingModel(model as string);\n\n    let reqValue: AxAIOpenAIChatRequest<TModel> = {\n      model,\n      messages,\n      ...(this.config?.responseFormat\n        ? { response_format: { type: this.config.responseFormat } }\n        : {}),\n      ...(tools ? { tools } : {}),\n      ...(toolsChoice ? { tool_choice: toolsChoice } : {}),\n      // For thinking models, don't set these parameters as they're not supported\n      ...(isThinkingModel\n        ? {}\n        : {\n            ...((req.modelConfig?.maxTokens ?? this.config.maxTokens) !==\n            undefined\n              ? {\n                  max_completion_tokens: (req.modelConfig?.maxTokens ??\n                    this.config.maxTokens)!,\n                }\n              : {}),\n            ...(req.modelConfig?.temperature !== undefined\n              ? { temperature: req.modelConfig.temperature }\n              : {}),\n            ...(req.modelConfig?.topP !== undefined\n              ? { top_p: req.modelConfig.topP }\n              : {}),\n            ...((req.modelConfig?.n ?? this.config.n) !== undefined\n              ? { n: (req.modelConfig?.n ?? this.config.n)! }\n              : {}),\n            ...((req.modelConfig?.presencePenalty ??\n              this.config.presencePenalty) !== undefined\n              ? {\n                  presence_penalty: (req.modelConfig?.presencePenalty ??\n                    this.config.presencePenalty)!,\n                }\n              : {}),\n            ...(frequencyPenalty !== undefined\n              ? { frequency_penalty: frequencyPenalty }\n              : {}),\n          }),\n      ...((req.modelConfig?.stopSequences ?? this.config.stop) &&\n      (req.modelConfig?.stopSequences ?? this.config.stop)!.length > 0\n        ? { stop: (req.modelConfig?.stopSequences ?? this.config.stop)! }\n        : {}),\n      ...(this.config.logitBias !== undefined\n        ? { logit_bias: this.config.logitBias }\n        : {}),\n      ...(stream && this.streamingUsage\n        ? { stream: true, stream_options: { include_usage: true } }\n        : {}),\n      ...(store ? { store: store } : {}),\n      ...(this.config.serviceTier\n        ? { service_tier: this.config.serviceTier }\n        : {}),\n      ...(this.config.user ? { user: this.config.user } : {}),\n    };\n\n    if (this.config.reasoningEffort) {\n      reqValue.reasoning_effort = this.config.reasoningEffort;\n    }\n\n    if (this.config.webSearchOptions) {\n      reqValue.web_search_options = {\n        ...(this.config.webSearchOptions.searchContextSize && {\n          search_context_size: this.config.webSearchOptions.searchContextSize,\n        }),\n        ...(this.config.webSearchOptions.userLocation && {\n          user_location: {\n            approximate: {\n              type: 'approximate',\n              ...(this.config.webSearchOptions.userLocation.approximate\n                .city && {\n                city: this.config.webSearchOptions.userLocation.approximate\n                  .city,\n              }),\n              ...(this.config.webSearchOptions.userLocation.approximate\n                .country && {\n                country:\n                  this.config.webSearchOptions.userLocation.approximate.country,\n              }),\n              ...(this.config.webSearchOptions.userLocation.approximate\n                .region && {\n                region:\n                  this.config.webSearchOptions.userLocation.approximate.region,\n              }),\n              ...(this.config.webSearchOptions.userLocation.approximate\n                .timezone && {\n                timezone:\n                  this.config.webSearchOptions.userLocation.approximate\n                    .timezone,\n              }),\n            },\n          },\n        }),\n      };\n    }\n\n    // Then, override based on prompt-specific config\n    if (config?.thinkingTokenBudget) {\n      switch (config.thinkingTokenBudget) {\n        case 'none':\n          reqValue.reasoning_effort = undefined; // Explicitly set to undefined\n          break;\n        case 'minimal':\n          reqValue.reasoning_effort = 'minimal';\n          break;\n        case 'low':\n          reqValue.reasoning_effort = 'medium';\n          break;\n        case 'medium':\n          reqValue.reasoning_effort = 'high';\n          break;\n        case 'high':\n          reqValue.reasoning_effort = 'high';\n          break;\n        case 'highest':\n          reqValue.reasoning_effort = 'high';\n          break;\n      }\n    }\n\n    // If a per-model key mapped numeric thinking budget to an Ax level via models[],\n    // set reasoning_effort accordingly when not overridden above\n    if (!reqValue.reasoning_effort && (config as any)?.thinkingTokenBudget) {\n      switch ((config as any).thinkingTokenBudget) {\n        case 'minimal':\n          reqValue.reasoning_effort = 'minimal';\n          break;\n        case 'low':\n          reqValue.reasoning_effort = 'medium';\n          break;\n        case 'medium':\n        case 'high':\n        case 'highest':\n          reqValue.reasoning_effort = 'high';\n          break;\n      }\n    }\n\n    if (this.chatReqUpdater) {\n      reqValue = this.chatReqUpdater(reqValue as TChatReq);\n    }\n\n    return [apiConfig, reqValue];\n  };\n\n  createEmbedReq = (\n    req: Readonly<AxInternalEmbedRequest<TEmbedModel>>\n  ): [AxAPI, AxAIOpenAIEmbedRequest<TEmbedModel>] => {\n    const model = req.embedModel;\n\n    if (!model) {\n      throw new Error('Embed model not set');\n    }\n\n    if (!req.texts || req.texts.length === 0) {\n      throw new Error('Embed texts is empty');\n    }\n\n    const apiConfig = {\n      name: '/embeddings',\n    };\n\n    const reqValue = {\n      model: model,\n      input: req.texts,\n      dimensions: this.config.dimensions,\n    };\n\n    return [apiConfig, reqValue];\n  };\n\n  createChatResp(resp: Readonly<AxAIOpenAIChatResponse>): AxChatResponse {\n    const { id, usage, choices, error } = resp;\n\n    if (error) {\n      throw error;\n    }\n    this.tokensUsed = usage\n      ? {\n          promptTokens: usage.prompt_tokens,\n          completionTokens: usage.completion_tokens,\n          totalTokens: usage.total_tokens,\n        }\n      : undefined;\n\n    const results = choices.map((choice) => {\n      // Check for refusal and throw exception if present\n      if (choice.message.refusal) {\n        throw new AxAIRefusalError(choice.message.refusal, resp.model, resp.id);\n      }\n\n      const finishReason = mapFinishReason(choice.finish_reason);\n\n      const functionCalls = choice.message.tool_calls?.map(\n        ({ id, function: { arguments: params, name } }) => ({\n          id: id,\n          type: 'function' as const,\n          function: { name, params },\n        })\n      );\n\n      return {\n        index: choice.index,\n        id: `${choice.index}`,\n        content: choice.message.content ?? undefined,\n        thought: choice.message.reasoning_content,\n        citations: choice.message.annotations\n          ?.filter((a) => a?.type === 'url_citation' && (a as any).url_citation)\n          .map((a) => ({\n            url: (a as any).url_citation?.url,\n            title: (a as any).url_citation?.title,\n            description: (a as any).url_citation?.description,\n          })),\n        functionCalls,\n        finishReason,\n      };\n    });\n\n    return {\n      results,\n      remoteId: id,\n    };\n  }\n\n  createChatStreamResp(\n    resp: Readonly<AxAIOpenAIChatResponseDelta>,\n    state: object\n  ): AxChatResponse {\n    const { id, usage, choices } = resp;\n\n    this.tokensUsed = usage\n      ? {\n          promptTokens: usage.prompt_tokens,\n          completionTokens: usage.completion_tokens,\n          totalTokens: usage.total_tokens,\n        }\n      : undefined;\n\n    const sstate = state as {\n      indexIdMap: Record<number, string>;\n    };\n\n    if (!sstate.indexIdMap) {\n      sstate.indexIdMap = {};\n    }\n\n    const results = choices.map(\n      ({\n        index,\n        delta: {\n          content,\n          role,\n          refusal,\n          tool_calls: toolCalls,\n          reasoning_content: thought,\n          annotations,\n        },\n        finish_reason: oaiFinishReason,\n      }) => {\n        // Check for refusal and throw exception if present\n        if (refusal) {\n          throw new AxAIRefusalError(refusal, undefined, id);\n        }\n\n        const finishReason = mapFinishReason(oaiFinishReason);\n\n        const functionCalls = toolCalls\n          ?.map(({ id: Id, index, function: { name, arguments: params } }) => {\n            if (\n              typeof Id === 'string' &&\n              typeof index === 'number' &&\n              !sstate.indexIdMap[index]\n            ) {\n              sstate.indexIdMap[index] = Id;\n            }\n\n            const id = sstate.indexIdMap[index];\n            if (!id) {\n              return null;\n            }\n\n            return {\n              id,\n              type: 'function' as const,\n              function: { name, params },\n            };\n          })\n          .filter((v) => v !== null);\n\n        return {\n          index,\n          content: content ?? undefined,\n          role,\n          thought,\n          citations: annotations\n            ?.filter(\n              (a) => a?.type === 'url_citation' && (a as any).url_citation\n            )\n            .map((a) => ({\n              url: (a as any).url_citation?.url,\n              title: (a as any).url_citation?.title,\n              description: (a as any).url_citation?.description,\n            })),\n          functionCalls,\n          finishReason,\n          id,\n        };\n      }\n    );\n\n    return { results };\n  }\n\n  createEmbedResp(resp: Readonly<AxAIOpenAIEmbedResponse>): AxEmbedResponse {\n    const { data, usage } = resp;\n\n    this.tokensUsed = usage\n      ? {\n          promptTokens: usage.prompt_tokens,\n          completionTokens: usage.completion_tokens,\n          totalTokens: usage.total_tokens,\n        }\n      : undefined;\n\n    return { embeddings: data.map((v) => v.embedding) };\n  }\n}\n\nconst mapFinishReason = (\n  finishReason: AxAIOpenAIChatResponse['choices'][0]['finish_reason']\n): AxChatResponseResult['finishReason'] => {\n  switch (finishReason) {\n    case 'stop':\n      return 'stop' as const;\n    case 'length':\n      return 'length' as const;\n    case 'content_filter':\n      return 'error' as const;\n    case 'tool_calls':\n      return 'function_call' as const;\n  }\n};\n\nfunction createMessages<TModel>(\n  req: Readonly<AxInternalChatRequest<TModel>>\n): AxAIOpenAIChatRequest<TModel>['messages'] {\n  type UserContent = Extract<\n    AxAIOpenAIChatRequest<TModel>['messages'][number],\n    { role: 'user' }\n  >['content'];\n\n  const openaiReq = req.chatPrompt.map((msg) => {\n    switch (msg.role) {\n      case 'system':\n        return { role: 'system' as const, content: msg.content };\n\n      case 'user': {\n        const content: UserContent = Array.isArray(msg.content)\n          ? msg.content.map((c) => {\n              switch (c.type) {\n                case 'text':\n                  return { type: 'text' as const, text: c.text };\n                case 'image': {\n                  const url = `data:${c.mimeType};base64,${c.image}`;\n                  return {\n                    type: 'image_url' as const,\n                    image_url: { url, details: c.details ?? 'auto' },\n                  };\n                }\n                case 'audio': {\n                  const data = c.data;\n                  return {\n                    type: 'input_audio' as const,\n                    input_audio: {\n                      data,\n                      format: c.format === 'wav' ? 'wav' : undefined,\n                    },\n                  };\n                }\n                default:\n                  throw new Error('Invalid content type');\n              }\n            })\n          : msg.content;\n        return {\n          role: 'user' as const,\n          ...(msg.name ? { name: msg.name } : {}),\n          content,\n        };\n      }\n\n      case 'assistant': {\n        const toolCalls = msg.functionCalls?.map((v) => ({\n          id: v.id,\n          type: 'function' as const,\n          function: {\n            name: v.function.name,\n            arguments:\n              typeof v.function.params === 'object'\n                ? JSON.stringify(v.function.params)\n                : v.function.params,\n          },\n        }));\n\n        if (toolCalls && toolCalls.length > 0) {\n          return {\n            role: 'assistant' as const,\n            ...(msg.content ? { content: msg.content } : {}),\n            name: msg.name,\n            tool_calls: toolCalls,\n          };\n        }\n\n        if (msg.content === undefined) {\n          throw new Error(\n            'Assistant content is required when no tool calls are provided'\n          );\n        }\n\n        return {\n          role: 'assistant' as const,\n          content: msg.content,\n          ...(msg.name ? { name: msg.name } : {}),\n        };\n      }\n\n      case 'function':\n        return {\n          role: 'tool' as const,\n          content: msg.result,\n          tool_call_id: msg.functionId,\n        };\n      default:\n        throw new Error('Invalid role');\n    }\n  });\n  return openaiReq;\n}\n\nexport class AxAIOpenAIBase<\n  TModel,\n  TEmbedModel,\n  TModelKey,\n  TChatReq extends\n    AxAIOpenAIChatRequest<TModel> = AxAIOpenAIChatRequest<TModel>,\n> extends AxBaseAI<\n  TModel,\n  TEmbedModel,\n  AxAIOpenAIChatRequest<TModel>,\n  AxAIOpenAIEmbedRequest<TEmbedModel>,\n  AxAIOpenAIChatResponse,\n  AxAIOpenAIChatResponseDelta,\n  AxAIOpenAIEmbedResponse,\n  TModelKey\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    apiURL,\n    modelInfo,\n    models,\n    chatReqUpdater,\n    supportFor,\n  }: Readonly<\n    Omit<AxAIOpenAIBaseArgs<TModel, TEmbedModel, TModelKey, TChatReq>, 'name'>\n  >) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('OpenAI API key not set');\n    }\n\n    const aiImpl = new AxAIOpenAIImpl<TModel, TEmbedModel, TChatReq>(\n      config,\n      options?.streamingUsage ?? true,\n      chatReqUpdater\n    );\n\n    super(aiImpl, {\n      name: 'OpenAI',\n      apiURL: apiURL ? apiURL : 'https://api.openai.com/v1',\n      headers: async () => ({ Authorization: `Bearer ${apiKey}` }),\n      modelInfo,\n      defaults: {\n        model: config.model,\n        embedModel: config.embedModel,\n      },\n      options,\n      supportFor,\n      models,\n    });\n  }\n}\n\nexport class AxAIOpenAI<TModelKey = string> extends AxAIOpenAIBase<\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel,\n  TModelKey\n> {\n  constructor({\n    apiKey,\n    apiURL,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<\n    Omit<\n      AxAIOpenAIArgs<\n        'openai',\n        AxAIOpenAIModel,\n        AxAIOpenAIEmbedModel,\n        TModelKey\n      >,\n      'name'\n    >\n  >) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('OpenAI API key not set');\n    }\n\n    modelInfo = [...axModelInfoOpenAI, ...(modelInfo ?? [])];\n\n    const supportFor = (model: AxAIOpenAIModel) => {\n      const mi = getModelInfo<AxAIOpenAIModel, AxAIOpenAIEmbedModel, TModelKey>(\n        {\n          model,\n          modelInfo,\n          models: models as AxAIInputModelList<\n            AxAIOpenAIModel,\n            AxAIOpenAIEmbedModel,\n            TModelKey\n          >,\n        }\n      );\n      return {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: mi?.supported?.thinkingBudget ?? false,\n        hasShowThoughts: mi?.supported?.showThoughts ?? false,\n        media: {\n          images: {\n            supported: true,\n            formats: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],\n            maxSize: 20 * 1024 * 1024, // 20MB\n            detailLevels: ['high', 'low', 'auto'] as (\n              | 'high'\n              | 'low'\n              | 'auto'\n            )[],\n          },\n          audio: {\n            supported: true,\n            formats: ['wav', 'mp3', 'ogg'],\n            maxDuration: 25 * 60, // 25 minutes\n          },\n          files: {\n            supported: true,\n            formats: [\n              'text/plain',\n              'application/pdf',\n              'image/jpeg',\n              'image/png',\n            ],\n            maxSize: 512 * 1024 * 1024, // 512MB\n            uploadMethod: 'upload' as 'inline' | 'upload' | 'cloud' | 'none',\n          },\n          urls: {\n            supported: false,\n            webSearch: true, // Available via web search options\n            contextFetching: false,\n          },\n        },\n        caching: {\n          supported: false,\n          types: [],\n        },\n        thinking: mi?.supported?.thinkingBudget ?? false,\n        multiTurn: true,\n      };\n    };\n\n    // Normalize per-model presets to allow provider-specific item.config to influence defaults\n    const normalizedModels = models?.map((item) => {\n      const anyItem = item as any;\n      const cfg = anyItem?.config as\n        | Partial<AxAIOpenAIConfig<AxAIOpenAIModel, AxAIOpenAIEmbedModel>>\n        | undefined;\n      if (!cfg) return item;\n\n      const modelConfig: Partial<AxModelConfig> = {};\n      if (cfg.maxTokens !== undefined) modelConfig.maxTokens = cfg.maxTokens;\n      if (cfg.temperature !== undefined)\n        modelConfig.temperature = cfg.temperature;\n      if (cfg.topP !== undefined) modelConfig.topP = cfg.topP;\n      if (cfg.presencePenalty !== undefined)\n        modelConfig.presencePenalty = cfg.presencePenalty as number;\n      if (cfg.frequencyPenalty !== undefined)\n        modelConfig.frequencyPenalty = cfg.frequencyPenalty as number;\n      // Support both AxModelConfig.stopSequences and OpenAI's stop\n      const stopSeq = (cfg as any).stopSequences ?? (cfg as any).stop;\n      if (stopSeq !== undefined)\n        modelConfig.stopSequences = stopSeq as string[];\n      if (cfg.n !== undefined) modelConfig.n = cfg.n as number;\n      if (cfg.stream !== undefined) modelConfig.stream = cfg.stream as boolean;\n\n      const out: any = { ...anyItem };\n      if (Object.keys(modelConfig).length > 0) {\n        out.modelConfig = { ...(anyItem.modelConfig ?? {}), ...modelConfig };\n      }\n\n      // Map numeric thinking budget to closest Ax level for convenience\n      const numericBudget = (cfg as any)?.thinking?.thinkingTokenBudget;\n      if (typeof numericBudget === 'number') {\n        const candidates = [\n          ['minimal', 200],\n          ['low', 800],\n          ['medium', 5000],\n          ['high', 10000],\n          ['highest', 24500],\n        ] as const;\n        let bestName: 'minimal' | 'low' | 'medium' | 'high' | 'highest' =\n          'minimal';\n        let bestDiff = Number.POSITIVE_INFINITY;\n        for (const [name, value] of candidates) {\n          const diff = Math.abs(numericBudget - value);\n          if (diff < bestDiff) {\n            bestDiff = diff;\n            bestName = name as typeof bestName;\n          }\n        }\n        out.thinkingTokenBudget = bestName;\n      }\n      if ((cfg as any)?.thinking?.includeThoughts !== undefined) {\n        out.showThoughts = !!(cfg as any).thinking.includeThoughts;\n      }\n\n      return out as typeof item;\n    });\n\n    super({\n      apiKey,\n      apiURL,\n      config: {\n        ...axAIOpenAIDefaultConfig(),\n        ...config,\n      },\n      options,\n      modelInfo,\n      models: normalizedModels ?? models,\n      supportFor,\n    });\n\n    super.setName('OpenAI');\n  }\n}\n","import { getModelInfo } from '../../dsp/modelinfo.js';\nimport {\n  type AxAIOpenAIArgs,\n  AxAIOpenAIBase,\n  axAIOpenAIBestConfig,\n  axAIOpenAICreativeConfig,\n  axAIOpenAIDefaultConfig,\n  axAIOpenAIFastConfig,\n} from '../openai/api.js';\nimport type {\n  AxAIOpenAIConfig,\n  AxAIOpenAIEmbedModel,\n  AxAIOpenAIModel,\n} from '../openai/chat_types.js';\nimport { axModelInfoOpenAI } from '../openai/info.js';\n\nexport const axAIAzureOpenAIDefaultConfig = axAIOpenAIDefaultConfig;\n\nexport const axAIAzureOpenAICreativeConfig = axAIOpenAICreativeConfig;\n\nexport const axAIAzureOpenAIFastConfig = axAIOpenAIFastConfig;\n\nexport const axAIAzureOpenAIBestConfig = axAIOpenAIBestConfig;\n\nexport type AxAIAzureOpenAIConfig = AxAIOpenAIConfig<\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel\n>;\nexport type AxAIAzureOpenAIArgs<TModelKey> = AxAIOpenAIArgs<\n  'azure-openai',\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel,\n  TModelKey\n> & {\n  resourceName: string;\n  deploymentName: string;\n  version?: string;\n};\n\nexport class AxAIAzureOpenAI<TModelKey> extends AxAIOpenAIBase<\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel,\n  TModelKey\n> {\n  constructor({\n    apiKey,\n    resourceName,\n    deploymentName,\n    version = 'api-version=2024-02-15-preview',\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAIAzureOpenAIArgs<TModelKey>, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Azure OpenAPI API key not set');\n    }\n    if (!resourceName || resourceName === '') {\n      throw new Error('Azure OpenAPI resource name not set');\n    }\n    if (!deploymentName || deploymentName === '') {\n      throw new Error('Azure OpenAPI deployment id not set');\n    }\n\n    const Config = {\n      ...axAIAzureOpenAIDefaultConfig(),\n      ...config,\n    };\n\n    modelInfo = [...axModelInfoOpenAI, ...(modelInfo ?? [])];\n\n    const supportFor = (model: AxAIOpenAIModel) => {\n      const mi = getModelInfo<AxAIOpenAIModel, AxAIOpenAIEmbedModel, TModelKey>(\n        {\n          model,\n          modelInfo,\n          models,\n        }\n      );\n      return {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: mi?.supported?.thinkingBudget ?? false,\n        hasShowThoughts: mi?.supported?.showThoughts ?? false,\n        functionCot: false,\n        media: {\n          images: {\n            supported: true,\n            formats: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],\n            maxSize: 20 * 1024 * 1024, // 20MB\n            detailLevels: ['high', 'low', 'auto'] as (\n              | 'high'\n              | 'low'\n              | 'auto'\n            )[],\n          },\n          audio: {\n            supported: false,\n            formats: [],\n            maxDuration: 0,\n          },\n          files: {\n            supported: false,\n            formats: [],\n            maxSize: 0,\n            uploadMethod: 'none' as 'inline' | 'upload' | 'cloud' | 'none',\n          },\n          urls: {\n            supported: false,\n            webSearch: false,\n            contextFetching: false,\n          },\n        },\n        caching: {\n          supported: false,\n          types: [],\n        },\n        thinking: mi?.supported?.thinkingBudget ?? false,\n        multiTurn: true,\n      };\n    };\n\n    super({\n      apiKey,\n      config: Config,\n      options,\n      models,\n      modelInfo,\n      supportFor,\n    });\n\n    const host = resourceName.includes('://')\n      ? resourceName\n      : `https://${resourceName}.openai.azure.com/`;\n\n    super.setName('Azure OpenAI');\n\n    super.setAPIURL(\n      new URL(\n        `/openai/deployments/${deploymentName}?api-version=${version}`,\n        host\n      ).href\n    );\n\n    super.setHeaders(async () => ({ 'api-key': apiKey }));\n  }\n}\n","// ReadableStream is available globally in modern browsers and Node.js 16+\n\nimport {\n  AxAIServiceAuthenticationError,\n  AxAIServiceError,\n  AxAIServiceNetworkError,\n  AxAIServiceResponseError,\n  AxAIServiceStatusError,\n  AxAIServiceStreamTerminatedError,\n  AxAIServiceTimeoutError,\n} from '../util/apicall.js';\n\nimport type {\n  AxAIModelList,\n  AxAIService,\n  AxAIServiceMetrics,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxEmbedRequest,\n  AxEmbedResponse,\n  AxLoggerFunction,\n  AxModelConfig,\n} from './types.js';\n\n// Helper type to extract model keys from a service\ntype ExtractServiceModelKeys<T> = T extends AxAIService<any, any, infer K>\n  ? K\n  : never;\n\n// Helper type to extract model keys from an array of services\ntype ExtractAllModelKeys<T extends readonly any[]> = T extends readonly [\n  infer First,\n  ...infer Rest,\n]\n  ? ExtractServiceModelKeys<First> | ExtractAllModelKeys<Rest>\n  : never;\n\n/**\n * Options for the balancer.\n */\nexport type AxBalancerOptions<TModelKey = string> = {\n  comparator?: (\n    a: AxAIService<unknown, unknown, TModelKey>,\n    b: AxAIService<unknown, unknown, TModelKey>\n  ) => number;\n  debug?: boolean;\n  initialBackoffMs?: number;\n  maxBackoffMs?: number;\n  maxRetries?: number;\n};\n\n/**\n * Balancer that rotates through services.\n */\nexport class AxBalancer<\n  TServices extends readonly AxAIService<\n    any,\n    any,\n    any\n  >[] = readonly AxAIService[],\n  TModelKey = ExtractAllModelKeys<TServices>,\n> implements AxAIService<unknown, unknown, TModelKey>\n{\n  private services: AxAIService<unknown, unknown, TModelKey>[];\n  private currentServiceIndex = 0;\n  private currentService: AxAIService<unknown, unknown, TModelKey>;\n  private debug: boolean;\n  private initialBackoffMs: number;\n  private maxBackoffMs: number;\n  private maxRetries: number;\n  private serviceFailures: Map<\n    string,\n    { retries: number; lastFailureTime: number }\n  > = new Map();\n\n  constructor(services: TServices, options?: AxBalancerOptions<TModelKey>) {\n    if (services.length === 0) {\n      throw new Error('No AI services provided.');\n    }\n\n    validateModels(\n      services as readonly AxAIService<unknown, unknown, TModelKey>[]\n    );\n\n    this.services = [...services].sort(\n      options?.comparator ?? AxBalancer.metricComparator<TModelKey>\n    ) as AxAIService<unknown, unknown, TModelKey>[];\n\n    const cs = this.services[this.currentServiceIndex];\n    if (cs === undefined) {\n      throw new Error('Error initializing the AI services.'); // More specific error message\n    }\n    this.currentService = cs;\n    this.debug = options?.debug ?? true;\n    this.initialBackoffMs = options?.initialBackoffMs ?? 1000;\n    this.maxBackoffMs = options?.maxBackoffMs ?? 32000;\n    this.maxRetries = options?.maxRetries ?? 3;\n  }\n\n  /**\n   * Static factory method for type-safe balancer creation with automatic model key inference.\n   */\n  static create<const TServices extends readonly AxAIService<any, any, any>[]>(\n    services: TServices,\n    options?: AxBalancerOptions<ExtractAllModelKeys<TServices>>\n  ): AxBalancer<TServices, ExtractAllModelKeys<TServices>> {\n    return new AxBalancer(services, options);\n  }\n  getLastUsedChatModel(): unknown {\n    return this.currentService.getLastUsedChatModel();\n  }\n  getLastUsedEmbedModel(): unknown {\n    return this.currentService.getLastUsedEmbedModel();\n  }\n  getLastUsedModelConfig(): AxModelConfig | undefined {\n    return this.currentService.getLastUsedModelConfig();\n  }\n\n  /**\n   * Service comparator that respects the input order of services.\n   */\n  public static inputOrderComparator = () => 0;\n\n  /**\n   * Service comparator that sorts services by cost.\n   */\n\n  // Requires a rethink\n  /*\n    public static costComparator = (a: AxAIService, b: AxAIService) => {\n      const aInfo = a.getModelInfo()\n      const bInfo = b.getModelInfo()\n      const aTotalCost =\n        (aInfo.promptTokenCostPer1M || Infinity) +\n        (aInfo.completionTokenCostPer1M || Infinity)\n      const bTotalCost =\n        (bInfo.promptTokenCostPer1M || Infinity) +\n        (bInfo.completionTokenCostPer1M || Infinity)\n      return aTotalCost - bTotalCost\n    }\n    */\n\n  public static metricComparator = <TModelKey = string>(\n    a: AxAIService<unknown, unknown, TModelKey>,\n    b: AxAIService<unknown, unknown, TModelKey>\n  ) => {\n    const aMetrics = a.getMetrics();\n    const bMetrics = b.getMetrics();\n    // Compare mean chat latency between services\n    return aMetrics.latency.chat.mean - bMetrics.latency.chat.mean;\n  };\n\n  getModelList(): AxAIModelList<TModelKey> | undefined {\n    return this.currentService.getModelList();\n  }\n\n  private getNextService(): boolean {\n    const cs = this.services[++this.currentServiceIndex];\n    if (cs === undefined) {\n      return false;\n    }\n    this.currentService = cs;\n    return true;\n  }\n\n  private reset(): void {\n    this.currentServiceIndex = 0;\n    const cs = this.services[this.currentServiceIndex];\n    if (cs === undefined) {\n      throw new Error('No AI services provided.');\n    }\n    this.currentService = cs;\n  }\n\n  getName(): string {\n    return this.currentService.getName();\n  }\n\n  getId(): string {\n    return this.currentService.getId();\n  }\n\n  getFeatures(model?: string) {\n    return this.currentService.getFeatures(model);\n  }\n\n  getMetrics(): AxAIServiceMetrics {\n    return this.currentService.getMetrics();\n  }\n\n  private canRetryService(): boolean {\n    const failure = this.serviceFailures.get(this.currentService.getId());\n    if (!failure) return true;\n\n    const { retries, lastFailureTime } = failure;\n    const timeSinceLastFailure = Date.now() - lastFailureTime;\n\n    const backoffMs = Math.min(\n      this.initialBackoffMs * 2 ** retries,\n      this.maxBackoffMs\n    );\n    return timeSinceLastFailure >= backoffMs;\n  }\n\n  private handleFailure(e: AxAIServiceError): boolean {\n    const failure = this.serviceFailures.get(this.currentService.getId());\n    const retries = (failure?.retries ?? 0) + 1;\n\n    this.serviceFailures.set(this.currentService.getId(), {\n      retries,\n      lastFailureTime: Date.now(),\n    });\n\n    if (this.debug) {\n      console.warn(\n        `AxBalancer: Service ${this.currentService.getName()} failed (retry ${retries}/${this.maxRetries})`,\n        e\n      );\n    }\n\n    if (retries >= this.maxRetries) {\n      const gotNextService = this.getNextService();\n      if (this.debug) {\n        console.warn(\n          `AxBalancer: Switching to service ${this.currentService.getName()}`,\n          e\n        );\n      }\n      return gotNextService;\n    }\n\n    return true;\n  }\n\n  private handleSuccess(): void {\n    this.serviceFailures.delete(this.currentService.getId());\n  }\n\n  async chat(\n    req: Readonly<AxChatRequest<TModelKey>>,\n    options?: Readonly<AxAIServiceOptions>\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    this.reset();\n\n    while (true) {\n      if (!this.canRetryService()) {\n        if (!this.getNextService()) {\n          throw new Error('All services exhausted');\n        }\n        continue;\n      }\n\n      try {\n        const response = await this.currentService.chat(req, options);\n        this.handleSuccess();\n        return response;\n      } catch (e) {\n        if (!(e instanceof AxAIServiceError)) {\n          throw e;\n        }\n\n        switch (e.constructor) {\n          case AxAIServiceAuthenticationError:\n            // Handle authentication failure, e.g., refresh token, prompt user to re-login\n            throw e;\n\n          case AxAIServiceStatusError:\n            // Handle specific HTTP error codes, e.g., display a user-friendly message for a 404 Not Found\n            break;\n\n          case AxAIServiceNetworkError:\n            // Handle network issues, e.g., display a message about checking network connectivity\n            break;\n\n          case AxAIServiceResponseError:\n            // Handle errors related to processing the response, e.g., log the error and retry the request\n            break;\n\n          case AxAIServiceStreamTerminatedError:\n            // Handle unexpected stream termination, e.g., retry the request or display an error message\n            break;\n\n          case AxAIServiceTimeoutError:\n            // Handle request timeouts, e.g., increase timeout, retry, or display an error message\n            break;\n\n          default:\n            throw e;\n          // Handle unexpected AxAIServiceErrors\n        }\n\n        if (!this.handleFailure(e)) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  async embed(\n    req: Readonly<AxEmbedRequest<TModelKey>>,\n    options?: Readonly<AxAIServiceOptions>\n  ): Promise<AxEmbedResponse> {\n    this.reset();\n\n    while (true) {\n      if (!this.canRetryService()) {\n        if (!this.getNextService()) {\n          throw new Error('All services exhausted');\n        }\n        continue;\n      }\n\n      try {\n        const response = await this.currentService.embed(req, options);\n        this.handleSuccess();\n        return response;\n      } catch (e) {\n        if (!(e instanceof AxAIServiceError) || !this.handleFailure(e)) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  setOptions(options: Readonly<AxAIServiceOptions>): void {\n    this.currentService.setOptions(options);\n  }\n\n  getOptions(): Readonly<AxAIServiceOptions> {\n    return this.currentService.getOptions();\n  }\n\n  getLogger(): AxLoggerFunction {\n    return this.currentService.getLogger();\n  }\n}\n\nfunction validateModels<TModelKey = string>(\n  services: readonly AxAIService<unknown, unknown, TModelKey>[]\n) {\n  // Check if any service has a model list.\n  const serviceWithModel = services.find(\n    (service) => service.getModelList() !== undefined\n  );\n  if (!serviceWithModel) {\n    // No service provides a model list; no validation needed.\n    return;\n  }\n\n  // Use the first service with a model list as the reference.\n  const referenceModelList = serviceWithModel.getModelList();\n  if (!referenceModelList) {\n    throw new Error('No model list found in any service.');\n  }\n  const referenceKeys = new Set(referenceModelList.map((model) => model.key));\n\n  // Validate that all services provide a model list with the same keys.\n  for (let i = 0; i < services.length; i++) {\n    const service = services[i];\n    if (!service) {\n      throw new Error(`Service at index ${i} is undefined`);\n    }\n    const modelList = service.getModelList();\n    if (!modelList) {\n      throw new Error(\n        `Service at index ${i} (${service.getName()}) has no model list while another service does.`\n      );\n    }\n\n    const serviceKeys = new Set(modelList.map((model) => model.key));\n\n    // Check for missing keys compared to the reference\n    for (const key of referenceKeys) {\n      if (!serviceKeys.has(key)) {\n        throw new Error(\n          `Service at index ${i} (${service.getName()}) is missing model \"${key}\"`\n        );\n      }\n    }\n    // Check for extra keys not in the reference\n    for (const key of serviceKeys) {\n      if (!referenceKeys.has(key)) {\n        throw new Error(\n          `Service at index ${i} (${service.getName()}) has extra model \"${key}\"`\n        );\n      }\n    }\n  }\n}\n","import type { AxAIService, AxChatRequest } from './types.js';\nimport type { MediaRequirements } from './processor.js';\n\n/**\n * Represents a provider's compatibility score for a specific request\n */\nexport interface ProviderCapabilityScore {\n  /** The AI service provider */\n  provider: AxAIService;\n  /** Numerical score based on capability match (higher is better) */\n  score: number;\n  /** List of capabilities the provider is missing for this request */\n  missingCapabilities: string[];\n  /** List of capabilities the provider supports for this request */\n  supportedCapabilities: string[];\n}\n\n/**\n * Result of validating whether a provider can handle a request\n */\nexport interface CapabilityValidationResult {\n  /** Whether the provider fully supports the request */\n  isSupported: boolean;\n  /** List of capabilities the provider is missing */\n  missingCapabilities: string[];\n  /** Non-critical issues or limitations */\n  warnings: string[];\n  /** Suggested alternatives for missing capabilities */\n  alternatives: string[];\n}\n\n/**\n * Analyzes a chat request to determine what capabilities it requires from AI providers.\n *\n * This function examines the request content to identify:\n * - Media types (images, audio, files, URLs)\n * - Function calling requirements\n * - Streaming requirements\n * - Caching requirements\n * - Token usage estimation\n *\n * @param request - The chat request to analyze\n * @returns Object containing detailed capability requirements and token estimation\n *\n * @example\n * ```typescript\n * const requirements = axAnalyzeRequestRequirements({\n *   chatPrompt: [{\n *     role: 'user',\n *     content: [\n *       { type: 'text', text: 'Analyze this image:' },\n *       { type: 'image', image: 'base64...', details: 'high' }\n *     ]\n *   }]\n * });\n *\n * console.log(requirements.hasImages); // true\n * console.log(requirements.estimatedTokens); // ~95\n * ```\n */\nexport function axAnalyzeRequestRequirements(\n  request: AxChatRequest\n): MediaRequirements & {\n  requiresFunctions: boolean;\n  requiresStreaming: boolean;\n  requiresCaching: boolean;\n  contentTypes: Set<string>;\n  estimatedTokens: number;\n} {\n  let hasImages = false;\n  let hasAudio = false;\n  let hasFiles = false;\n  let hasUrls = false;\n  let requiresFunctions = false;\n  let requiresStreaming = false;\n  let requiresCaching = false;\n  const contentTypes = new Set<string>();\n  let estimatedTokens = 0;\n\n  // Analyze chat prompt content\n  if (request.chatPrompt && Array.isArray(request.chatPrompt)) {\n    for (const message of request.chatPrompt) {\n      if (message.role === 'user' && Array.isArray(message.content)) {\n        for (const part of message.content) {\n          contentTypes.add(part.type);\n\n          switch (part.type) {\n            case 'image':\n              hasImages = true;\n              if (part.cache) requiresCaching = true;\n              // Estimate ~85 tokens per image (OpenAI's default)\n              estimatedTokens += 85;\n              break;\n            case 'audio':\n              hasAudio = true;\n              if (part.cache) requiresCaching = true;\n              // Estimate based on duration (rough: 1 token per second)\n              estimatedTokens += part.duration || 60;\n              break;\n            case 'file':\n              hasFiles = true;\n              if (part.cache) requiresCaching = true;\n              // Estimate based on extracted text length\n              estimatedTokens += Math.ceil(\n                (part.extractedText?.length || 1000) / 4\n              );\n              break;\n            case 'url':\n              hasUrls = true;\n              if (part.cache) requiresCaching = true;\n              // Estimate based on cached content length\n              estimatedTokens += Math.ceil(\n                (part.cachedContent?.length || 2000) / 4\n              );\n              break;\n            case 'text':\n              if (part.cache) requiresCaching = true;\n              // Standard token estimation: ~4 characters per token\n              estimatedTokens += Math.ceil(part.text.length / 4);\n              break;\n          }\n        }\n      } else if ('content' in message && typeof message.content === 'string') {\n        estimatedTokens += Math.ceil(message.content.length / 4);\n      }\n\n      if ('cache' in message && message.cache) requiresCaching = true;\n    }\n  }\n\n  // Check for function requirements\n  if (request.functions && request.functions.length > 0) {\n    requiresFunctions = true;\n  }\n\n  // Check for streaming requirements\n  if (request.modelConfig?.stream === true) {\n    requiresStreaming = true;\n  }\n\n  // Check capability preferences\n  if (request.capabilities) {\n    if (request.capabilities.requiresImages) hasImages = true;\n    if (request.capabilities.requiresAudio) hasAudio = true;\n    if (request.capabilities.requiresFiles) hasFiles = true;\n    if (request.capabilities.requiresWebSearch) hasUrls = true;\n  }\n\n  return {\n    hasImages,\n    hasAudio,\n    hasFiles,\n    hasUrls,\n    requiresFunctions,\n    requiresStreaming,\n    requiresCaching,\n    contentTypes,\n    estimatedTokens,\n  };\n}\n\n/**\n * Validates whether an AI provider can handle a request with specific requirements.\n *\n * Compares the provider's feature set against the analyzed request requirements\n * to determine compatibility, missing capabilities, and potential issues.\n *\n * @param provider - The AI service provider to validate\n * @param requirements - Requirements object from axAnalyzeRequestRequirements()\n * @returns Validation result with support status, missing capabilities, and alternatives\n *\n * @example\n * ```typescript\n * const requirements = axAnalyzeRequestRequirements(request);\n * const validation = axValidateProviderCapabilities(openaiProvider, requirements);\n *\n * if (!validation.isSupported) {\n *   console.log('Missing:', validation.missingCapabilities);\n *   console.log('Try:', validation.alternatives);\n * }\n * ```\n */\nexport function axValidateProviderCapabilities(\n  provider: AxAIService,\n  requirements: ReturnType<typeof axAnalyzeRequestRequirements>\n): CapabilityValidationResult {\n  const features = provider.getFeatures();\n  const missingCapabilities: string[] = [];\n  const warnings: string[] = [];\n  const alternatives: string[] = [];\n\n  // Check media capabilities\n  if (requirements.hasImages && !features.media.images.supported) {\n    missingCapabilities.push('Image support');\n    alternatives.push('Use altText for images or imageToText service');\n  }\n\n  if (requirements.hasAudio && !features.media.audio.supported) {\n    missingCapabilities.push('Audio support');\n    alternatives.push('Pre-transcribe audio or use transcription field');\n  }\n\n  if (requirements.hasFiles && !features.media.files.supported) {\n    missingCapabilities.push('File support');\n    alternatives.push('Pre-extract text content or use extractedText field');\n  }\n\n  if (requirements.hasUrls && !features.media.urls.supported) {\n    missingCapabilities.push('URL/Web search support');\n    alternatives.push('Pre-fetch content or use cachedContent field');\n  }\n\n  // Check function capabilities\n  if (requirements.requiresFunctions && !features.functions) {\n    missingCapabilities.push('Function calling');\n  }\n\n  // Check streaming capabilities\n  if (requirements.requiresStreaming && !features.streaming) {\n    missingCapabilities.push('Streaming responses');\n    alternatives.push('Use non-streaming mode');\n  }\n\n  // Check caching capabilities\n  if (requirements.requiresCaching && !features.caching.supported) {\n    missingCapabilities.push('Content caching');\n    alternatives.push('Repeated content will not be cached');\n  }\n\n  // Add warnings for potential issues\n  if (requirements.hasImages && features.media.images.supported) {\n    const maxSize = features.media.images.maxSize;\n    if (maxSize && maxSize < 10 * 1024 * 1024) {\n      // Less than 10MB\n      warnings.push(\n        `Image size limit is ${Math.round(maxSize / (1024 * 1024))}MB`\n      );\n    }\n  }\n\n  if (requirements.hasAudio && features.media.audio.supported) {\n    const maxDuration = features.media.audio.maxDuration;\n    if (maxDuration && maxDuration < 600) {\n      // Less than 10 minutes\n      warnings.push(\n        `Audio duration limit is ${Math.round(maxDuration / 60)} minutes`\n      );\n    }\n  }\n\n  const isSupported = missingCapabilities.length === 0;\n\n  return {\n    isSupported,\n    missingCapabilities,\n    warnings,\n    alternatives,\n  };\n}\n\n/**\n * Scores multiple AI providers based on how well they meet request requirements.\n *\n * Uses a weighted scoring system where providers earn points for supported capabilities:\n * - Base functionality: +10 points\n * - Media support (images/audio/files/URLs): +25 points each\n * - Core features (functions/streaming/caching): +8-15 points each\n * - Missing critical capabilities: -10 points each\n * - Bonus points for advanced features (large file support, persistent caching, etc.)\n *\n * @param providers - Array of AI service providers to score\n * @param requirements - Requirements object from axAnalyzeRequestRequirements()\n * @returns Array of scored providers sorted by score (highest first)\n *\n * @example\n * ```typescript\n * const requirements = axAnalyzeRequestRequirements(request);\n * const scores = axScoreProvidersForRequest([openai, gemini, cohere], requirements);\n *\n * console.log(`Best: ${scores[0].provider.getName()} (${scores[0].score} points)`);\n * console.log(`Supports: ${scores[0].supportedCapabilities.join(', ')}`);\n * ```\n */\nexport function axScoreProvidersForRequest(\n  providers: AxAIService[],\n  requirements: ReturnType<typeof axAnalyzeRequestRequirements>\n): ProviderCapabilityScore[] {\n  return providers\n    .map((provider) => {\n      const features = provider.getFeatures();\n      const validation = axValidateProviderCapabilities(provider, requirements);\n\n      let score = 0;\n      const supportedCapabilities: string[] = [];\n\n      // Base score for being a functioning provider\n      score += 10;\n\n      // Media support scoring (high weight)\n      if (requirements.hasImages) {\n        if (features.media.images.supported) {\n          score += 25;\n          supportedCapabilities.push('Images');\n\n          // Bonus for better image capabilities\n          if (features.media.images.detailLevels?.includes('high')) {\n            score += 5;\n          }\n          if (\n            features.media.images.maxSize &&\n            features.media.images.maxSize > 10 * 1024 * 1024\n          ) {\n            score += 3; // Large image support\n          }\n        }\n      }\n\n      if (requirements.hasAudio) {\n        if (features.media.audio.supported) {\n          score += 25;\n          supportedCapabilities.push('Audio');\n\n          // Bonus for longer audio support\n          if (\n            features.media.audio.maxDuration &&\n            features.media.audio.maxDuration > 600\n          ) {\n            score += 5;\n          }\n        }\n      }\n\n      if (requirements.hasFiles) {\n        if (features.media.files.supported) {\n          score += 25;\n          supportedCapabilities.push('Files');\n\n          // Bonus for different upload methods\n          if (features.media.files.uploadMethod === 'cloud') {\n            score += 3;\n          }\n        }\n      }\n\n      if (requirements.hasUrls) {\n        if (features.media.urls.supported) {\n          score += 25;\n          supportedCapabilities.push('URLs');\n\n          // Bonus for web search\n          if (features.media.urls.webSearch) {\n            score += 5;\n          }\n        }\n      }\n\n      // Core capability scoring (medium weight)\n      if (requirements.requiresFunctions) {\n        if (features.functions) {\n          score += 15;\n          supportedCapabilities.push('Functions');\n\n          // Bonus for chain-of-thought with functions\n          if (features.functionCot) {\n            score += 3;\n          }\n        }\n      }\n\n      if (requirements.requiresStreaming) {\n        if (features.streaming) {\n          score += 10;\n          supportedCapabilities.push('Streaming');\n        }\n      }\n\n      if (requirements.requiresCaching) {\n        if (features.caching.supported) {\n          score += 8;\n          supportedCapabilities.push('Caching');\n\n          // Bonus for persistent caching\n          if (features.caching.types.includes('persistent')) {\n            score += 3;\n          }\n        }\n      }\n\n      // Additional capability bonuses (low weight)\n      if (features.thinking) {\n        score += 2;\n      }\n\n      if (features.multiTurn) {\n        score += 2;\n      }\n\n      if (features.hasThinkingBudget) {\n        score += 1;\n      }\n\n      if (features.hasShowThoughts) {\n        score += 1;\n      }\n\n      // Penalty for missing critical capabilities\n      score -= validation.missingCapabilities.length * 10;\n\n      return {\n        provider,\n        score,\n        missingCapabilities: validation.missingCapabilities,\n        supportedCapabilities,\n      };\n    })\n    .sort((a, b) => b.score - a.score); // Sort by score descending\n}\n\n/**\n * Automatically selects the optimal AI provider for a given request.\n *\n * Analyzes the request requirements, scores available providers, and returns\n * the best match based on capability compatibility and scoring algorithm.\n *\n * @param request - The chat request to find a provider for\n * @param availableProviders - Array of available AI service providers\n * @param options - Selection options\n * @param options.requireExactMatch - Only return providers with full capability support\n * @param options.allowDegradation - Allow providers that require content processing fallbacks\n * @returns The optimal AI service provider\n * @throws Error if no suitable provider found or requirements not met\n *\n * @example\n * ```typescript\n * // Automatic selection with degradation allowed\n * const provider = axSelectOptimalProvider(\n *   multiModalRequest,\n *   [openai, gemini, cohere],\n *   { allowDegradation: true }\n * );\n *\n * // Strict matching - must support all features natively\n * const provider = axSelectOptimalProvider(\n *   imageRequest,\n *   [openai, gemini],\n *   { requireExactMatch: true }\n * );\n * ```\n */\nexport function axSelectOptimalProvider(\n  request: AxChatRequest,\n  availableProviders: AxAIService[],\n  options: {\n    requireExactMatch?: boolean;\n    allowDegradation?: boolean;\n  } = {}\n): AxAIService {\n  if (availableProviders.length === 0) {\n    throw new Error('No providers available');\n  }\n\n  const requirements = axAnalyzeRequestRequirements(request);\n  const scoredProviders = axScoreProvidersForRequest(\n    availableProviders,\n    requirements\n  );\n\n  if (options.requireExactMatch) {\n    // Only consider providers that fully support all requirements\n    const fullyCompatible = scoredProviders.filter(\n      (p) => p.missingCapabilities.length === 0\n    );\n    if (fullyCompatible.length === 0) {\n      throw new Error(\n        `No providers fully support the request requirements: ${\n          scoredProviders[0]?.missingCapabilities.join(', ') ||\n          'unknown requirements'\n        }`\n      );\n    }\n    return fullyCompatible[0].provider;\n  }\n\n  if (!options.allowDegradation) {\n    // Check if the best provider is missing critical capabilities\n    const bestProvider = scoredProviders[0];\n    if (bestProvider.missingCapabilities.length > 0) {\n      throw new Error(\n        `Best available provider (${bestProvider.provider.getName()}) is missing: ${bestProvider.missingCapabilities.join(\n          ', '\n        )}`\n      );\n    }\n  }\n\n  return scoredProviders[0].provider;\n}\n\n/**\n * Generates a comprehensive compatibility report for a request across all providers.\n *\n * Provides detailed analysis including requirement breakdown, provider scoring,\n * recommendations, and human-readable compatibility summary.\n *\n * @param request - The chat request to analyze\n * @param availableProviders - Array of available AI service providers\n * @returns Comprehensive compatibility report with analysis and recommendations\n *\n * @example\n * ```typescript\n * const report = axGetCompatibilityReport(request, [openai, gemini, cohere]);\n *\n * console.log(report.summary); // \"OpenAI supports 4/4 requirements (100% compatibility)\"\n * console.log('Requirements:', report.requirements);\n *\n * for (const score of report.providerScores) {\n *   console.log(`${score.provider.getName()}: ${score.score} points`);\n *   console.log(`  Missing: ${score.missingCapabilities.join(', ')}`);\n * }\n * ```\n */\nexport function axGetCompatibilityReport(\n  request: AxChatRequest,\n  availableProviders: AxAIService[]\n): {\n  requirements: ReturnType<typeof axAnalyzeRequestRequirements>;\n  providerScores: ProviderCapabilityScore[];\n  recommendedProvider: AxAIService | null;\n  summary: string;\n} {\n  const requirements = axAnalyzeRequestRequirements(request);\n  const providerScores = axScoreProvidersForRequest(\n    availableProviders,\n    requirements\n  );\n\n  const recommendedProvider = providerScores[0]?.provider || null;\n\n  const totalRequirements = [\n    requirements.hasImages && 'images',\n    requirements.hasAudio && 'audio',\n    requirements.hasFiles && 'files',\n    requirements.hasUrls && 'URLs',\n    requirements.requiresFunctions && 'functions',\n    requirements.requiresStreaming && 'streaming',\n    requirements.requiresCaching && 'caching',\n  ].filter(Boolean).length;\n\n  const supportedRequirements = recommendedProvider\n    ? providerScores[0].supportedCapabilities.length\n    : 0;\n\n  const summary = recommendedProvider\n    ? `${recommendedProvider.getName()} supports ${supportedRequirements}/${totalRequirements} requirements (${Math.round(\n        (supportedRequirements / Math.max(totalRequirements, 1)) * 100\n      )}% compatibility)`\n    : 'No suitable providers found';\n\n  return {\n    requirements,\n    providerScores,\n    recommendedProvider,\n    summary,\n  };\n}\n\n/**\n * Filters providers that support a specific media type.\n *\n * @param providers - Array of AI service providers to filter\n * @param mediaType - The media type to check support for\n * @returns Array of providers that support the specified media type\n *\n * @example\n * ```typescript\n * const imageProviders = axGetProvidersWithMediaSupport(allProviders, 'images');\n * console.log(`${imageProviders.length} providers support images`);\n * ```\n */\nexport function axGetProvidersWithMediaSupport(\n  providers: AxAIService[],\n  mediaType: 'images' | 'audio' | 'files' | 'urls'\n): AxAIService[] {\n  return providers.filter((provider) => {\n    const features = provider.getFeatures();\n    return features.media[mediaType].supported;\n  });\n}\n\n/**\n * Analyzes format compatibility across providers for a specific media type.\n *\n * @param providers - Array of AI service providers to analyze\n * @param mediaType - The media type to check format support for\n * @returns Object mapping each supported format to the providers that support it\n *\n * @example\n * ```typescript\n * const compatibility = axGetFormatCompatibility(allProviders, 'images');\n * console.log('JPEG support:', compatibility['image/jpeg']?.map(p => p.getName()));\n * console.log('PNG support:', compatibility['image/png']?.map(p => p.getName()));\n * ```\n */\nexport function axGetFormatCompatibility(\n  providers: AxAIService[],\n  mediaType: 'images' | 'audio' | 'files'\n): {\n  [format: string]: AxAIService[];\n} {\n  const compatibility: { [format: string]: AxAIService[] } = {};\n\n  for (const provider of providers) {\n    const features = provider.getFeatures();\n    const mediaFeatures = features.media[mediaType];\n\n    if (mediaFeatures.supported) {\n      for (const format of mediaFeatures.formats) {\n        if (!compatibility[format]) {\n          compatibility[format] = [];\n        }\n        compatibility[format].push(provider);\n      }\n    }\n  }\n\n  return compatibility;\n}\n","import type { AxModelConfig } from '../types.js';\n\n/**\n * Cohere: Models for text generation\n */\nexport enum AxAICohereModel {\n  CommandRPlus = 'command-r-plus',\n  CommandR = 'command-r',\n  Command = 'command',\n  CommandLight = 'command-light',\n}\n\n/**\n * Cohere: Models for use in embeddings\n */\nexport enum AxAICohereEmbedModel {\n  EmbedEnglishV30 = 'embed-english-v3.0',\n  EmbedEnglishLightV30 = 'embed-english-light-v3.0',\n  EmbedMultiLingualV30 = 'embed-multilingual-v3.0',\n  EmbedMultiLingualLightV30 = 'embed-multilingual-light-v3.0',\n}\n\n/**\n * Cohere: Model options for text generation\n */\nexport type AxAICohereConfig = AxModelConfig & {\n  model: AxAICohereModel;\n  embedModel?: AxAICohereEmbedModel;\n};\n\nexport type AxAICohereChatResponseToolCalls = {\n  name: string;\n  parameters?: object;\n}[];\n\nexport type AxAICohereChatRequestToolResults = {\n  call: AxAICohereChatResponseToolCalls[0];\n  outputs: object[];\n}[];\n\nexport type AxAICohereChatRequest = {\n  message?: string;\n  preamble?: string;\n  chat_history: (\n    | {\n        role: 'CHATBOT';\n        message: string;\n        tool_calls?: AxAICohereChatResponseToolCalls;\n      }\n    | {\n        role: 'SYSTEM';\n        message: string;\n      }\n    | {\n        role: 'USER';\n        message: string;\n      }\n    | {\n        role: 'TOOL';\n        message?: string;\n        tool_results: AxAICohereChatRequestToolResults;\n      }\n  )[];\n\n  model: AxAICohereModel;\n  max_tokens?: number;\n  temperature?: number;\n  k?: number;\n  p?: number;\n  frequency_penalty?: number;\n  presence_penalty?: number;\n  end_sequences?: readonly string[];\n  stop_sequences?: string[];\n  tools?: {\n    name: string;\n    description: string;\n    parameter_definitions: Record<\n      string,\n      {\n        description: string;\n        type: string;\n        required: boolean;\n      }\n    >;\n  }[];\n  tool_results?: AxAICohereChatRequestToolResults;\n};\n\nexport type AxAICohereChatResponse = {\n  response_id: string;\n  meta: {\n    billed_units: {\n      input_tokens: number;\n      output_tokens: number;\n    };\n  };\n  generation_id: string;\n  text: string;\n  finish_reason:\n    | 'COMPLETE'\n    | 'ERROR'\n    | 'ERROR_TOXIC'\n    | 'ERROR_LIMIT'\n    | 'USER_CANCEL'\n    | 'MAX_TOKENS';\n  tool_calls: AxAICohereChatResponseToolCalls;\n};\n\nexport type AxAICohereChatResponseDelta = AxAICohereChatResponse & {\n  event_type:\n    | 'stream-start'\n    | 'text-generation'\n    | 'tool-calls-generation'\n    | 'stream-end';\n};\n\nexport type AxAICohereEmbedRequest = {\n  texts: readonly string[];\n  model: AxAICohereEmbedModel;\n  truncate: string;\n};\n\nexport type AxAICohereEmbedResponse = {\n  id: string;\n  texts: string[];\n  model: AxAICohereEmbedModel;\n  embeddings: number[][];\n};\n","import type { AxModelInfo } from '../types.js';\n\nimport { AxAICohereEmbedModel, AxAICohereModel } from './types.js';\n\nexport const axModelInfoCohere: AxModelInfo[] = [\n  {\n    name: AxAICohereModel.CommandRPlus,\n    currency: 'usd',\n    promptTokenCostPer1M: 3.0,\n    completionTokenCostPer1M: 15,\n  },\n  {\n    name: AxAICohereModel.CommandR,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.5,\n    completionTokenCostPer1M: 1.5,\n  },\n  {\n    name: AxAICohereModel.Command,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.5,\n    completionTokenCostPer1M: 1.5,\n  },\n  {\n    name: AxAICohereModel.CommandLight,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.3,\n    completionTokenCostPer1M: 0.6,\n  },\n  {\n    name: AxAICohereEmbedModel.EmbedEnglishLightV30,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.1,\n  },\n  {\n    name: AxAICohereEmbedModel.EmbedEnglishV30,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.1,\n  },\n  {\n    name: AxAICohereEmbedModel.EmbedMultiLingualV30,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.1,\n  },\n  {\n    name: AxAICohereEmbedModel.EmbedMultiLingualLightV30,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.1,\n  },\n];\n","import type { AxAPI } from '../../util/apicall.js';\nimport {\n  AxBaseAI,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxEmbedResponse,\n  AxInternalChatRequest,\n  AxInternalEmbedRequest,\n  AxModelConfig,\n  AxTokenUsage,\n} from '../types.js';\n\nimport { axModelInfoCohere } from './info.js';\nimport {\n  type AxAICohereChatRequest,\n  type AxAICohereChatResponse,\n  type AxAICohereChatResponseDelta,\n  type AxAICohereConfig,\n  AxAICohereEmbedModel,\n  type AxAICohereEmbedRequest,\n  type AxAICohereEmbedResponse,\n  AxAICohereModel,\n} from './types.js';\n\n/**\n * Creates the default configuration for Cohere AI service\n * @returns A deep clone of the default Cohere configuration with CommandRPlus model and EmbedEnglishV30 embed model\n */\nexport const axAICohereDefaultConfig = (): AxAICohereConfig =>\n  structuredClone({\n    model: AxAICohereModel.CommandRPlus,\n    embedModel: AxAICohereEmbedModel.EmbedEnglishV30,\n    ...axBaseAIDefaultConfig(),\n  });\n\n/**\n * Creates a creative configuration for Cohere AI service with more flexible parameters\n * @returns A deep clone of the creative Cohere configuration with CommandR model and EmbedEnglishV30 embed model\n */\nexport const axAICohereCreativeConfig = (): AxAICohereConfig =>\n  structuredClone({\n    model: AxAICohereModel.CommandR,\n    embedModel: AxAICohereEmbedModel.EmbedEnglishV30,\n    ...axBaseAIDefaultCreativeConfig(),\n  });\n\n/**\n * Configuration arguments for initializing the Cohere AI service\n * @template TModelKey - The type of model keys supported\n */\nexport interface AxAICohereArgs<TModelKey> {\n  name: 'cohere';\n  apiKey: string;\n  config?: Readonly<Partial<AxAICohereConfig>>;\n  options?: Readonly<AxAIServiceOptions>;\n  models?: AxAIInputModelList<AxAICohereModel, AxAICohereEmbedModel, TModelKey>;\n}\n\n/**\n * Implementation class for Cohere AI service that handles API requests and responses\n */\nclass AxAICohereImpl\n  implements\n    AxAIServiceImpl<\n      AxAICohereModel,\n      AxAICohereEmbedModel,\n      AxAICohereChatRequest,\n      AxAICohereEmbedRequest,\n      AxAICohereChatResponse,\n      AxAICohereChatResponseDelta,\n      AxAICohereEmbedResponse\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n\n  /**\n   * Creates a new instance of AxAICohereImpl\n   * @param config - The configuration object for the Cohere AI service\n   */\n  constructor(private config: AxAICohereConfig) {}\n\n  /**\n   * Returns the token usage information from the last API call\n   * @returns Token usage data or undefined if no tokens have been used\n   */\n  getTokenUsage(): AxTokenUsage | undefined {\n    return this.tokensUsed;\n  }\n\n  /**\n   * Extracts and returns the model configuration parameters\n   * @returns Model configuration object with parameters like maxTokens, temperature, etc.\n   */\n  getModelConfig(): AxModelConfig {\n    const { config } = this;\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      topP: config.topP,\n      topK: config.topK,\n      frequencyPenalty: config.frequencyPenalty,\n      presencePenalty: config.presencePenalty,\n      endSequences: config.endSequences,\n      stopSequences: config.stopSequences,\n      stream: config.stream,\n      n: config.n,\n    } as AxModelConfig;\n  }\n\n  /**\n   * Creates a chat request in Cohere API format from internal request format\n   * @param req - The internal chat request object\n   * @returns A tuple containing API configuration and the formatted Cohere chat request\n   */\n  createChatReq(\n    req: Readonly<AxInternalChatRequest<AxAICohereModel>>\n  ): [AxAPI, AxAICohereChatRequest] {\n    const model = req.model;\n\n    const lastChatMsg = req.chatPrompt.at(-1);\n    const restOfChat = req.chatPrompt.slice(0, -1);\n\n    let message: AxAICohereChatRequest['message'] | undefined;\n\n    if (\n      lastChatMsg &&\n      lastChatMsg.role === 'user' &&\n      typeof lastChatMsg.content === 'string'\n    ) {\n      message = lastChatMsg?.content;\n    }\n\n    const chatHistory = createHistory(restOfChat);\n\n    type PropValue = NonNullable<\n      AxAICohereChatRequest['tools']\n    >[0]['parameter_definitions'][0];\n\n    const tools: AxAICohereChatRequest['tools'] = req.functions?.map((v) => {\n      const props: Record<string, PropValue> = {};\n      if (v.parameters?.properties) {\n        for (const [key, value] of Object.entries(v.parameters.properties)) {\n          props[key] = {\n            description: value.description,\n            type: value.type,\n            required: v.parameters.required?.includes(key) ?? false,\n          };\n        }\n      }\n\n      return {\n        name: v.name,\n        description: v.description,\n        parameter_definitions: props,\n      };\n    });\n\n    type FnType = Extract<AxChatRequest['chatPrompt'][0], { role: 'function' }>;\n\n    const toolResults: AxAICohereChatRequest['tool_results'] = (\n      req.chatPrompt as FnType[]\n    )\n      .filter((chat) => chat.role === 'function')\n      .map((chat) => {\n        const fn = tools?.find((t) => t.name === chat.functionId);\n        if (!fn) {\n          throw new Error('Function not found');\n        }\n        return {\n          call: { name: fn.name, parameters: fn.parameter_definitions },\n          outputs: [{ result: chat.result ?? '' }],\n        };\n      });\n\n    const apiConfig = {\n      name: '/chat',\n    };\n\n    const reqValue: AxAICohereChatRequest = {\n      message,\n      model,\n      tools,\n      ...(toolResults && !message ? { tool_results: toolResults } : {}),\n      chat_history: chatHistory,\n      max_tokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,\n      ...(req.modelConfig?.temperature !== undefined\n        ? { temperature: req.modelConfig.temperature }\n        : {}),\n      k: req.modelConfig?.topK ?? this.config.topK,\n      ...(req.modelConfig?.topP !== undefined\n        ? { p: req.modelConfig.topP }\n        : {}),\n      frequency_penalty:\n        req.modelConfig?.frequencyPenalty ?? this.config.frequencyPenalty,\n      presence_penalty:\n        req.modelConfig?.presencePenalty ?? this.config.presencePenalty,\n      end_sequences: this.config.endSequences,\n      stop_sequences:\n        req.modelConfig?.stopSequences ?? this.config.stopSequences,\n    };\n\n    return [apiConfig, reqValue];\n  }\n\n  /**\n   * Creates an embedding request in Cohere API format from internal request format\n   * @param req - The internal embed request object\n   * @returns A tuple containing API configuration and the formatted Cohere embed request\n   */\n  createEmbedReq = (\n    req: Readonly<AxInternalEmbedRequest<AxAICohereEmbedModel>>\n  ): [AxAPI, AxAICohereEmbedRequest] => {\n    const model = req.embedModel;\n\n    if (!model) {\n      throw new Error('Embed model not set');\n    }\n\n    if (!req.texts || req.texts.length === 0) {\n      throw new Error('Embed texts is empty');\n    }\n\n    const apiConfig = {\n      name: '/embed',\n    };\n\n    const reqValue = {\n      model,\n      texts: req.texts ?? [],\n      input_type: 'classification',\n      truncate: '',\n    };\n\n    return [apiConfig, reqValue];\n  };\n\n  /**\n   * Converts Cohere chat response to internal chat response format\n   * @param resp - The Cohere chat response object\n   * @returns Formatted internal chat response\n   */\n  createChatResp = (resp: Readonly<AxAICohereChatResponse>): AxChatResponse => {\n    this.tokensUsed = resp.meta.billed_units\n      ? {\n          promptTokens: resp.meta.billed_units.input_tokens,\n          completionTokens: resp.meta.billed_units.output_tokens,\n          totalTokens:\n            resp.meta.billed_units.input_tokens +\n            resp.meta.billed_units.output_tokens,\n        }\n      : undefined;\n\n    let finishReason: AxChatResponse['results'][0]['finishReason'];\n    if ('finish_reason' in resp) {\n      switch (resp.finish_reason) {\n        case 'COMPLETE':\n          finishReason = 'stop';\n          break;\n        case 'MAX_TOKENS':\n          finishReason = 'length';\n          break;\n        case 'ERROR':\n          throw new Error('Finish reason: ERROR');\n        case 'ERROR_TOXIC':\n          throw new Error('Finish reason: CONTENT_FILTER');\n        default:\n          finishReason = 'stop';\n          break;\n      }\n    }\n\n    let functionCalls: AxChatResponse['results'][0]['functionCalls'];\n\n    if ('tool_calls' in resp) {\n      functionCalls = resp.tool_calls?.map(\n        (v): NonNullable<AxChatResponse['results'][0]['functionCalls']>[0] => {\n          return {\n            id: v.name,\n            type: 'function' as const,\n            function: { name: v.name, params: v.parameters },\n          };\n        }\n      );\n    }\n\n    const results: AxChatResponse['results'] = [\n      {\n        index: 0,\n        id: resp.generation_id,\n        content: resp.text,\n        functionCalls,\n        finishReason,\n      },\n    ];\n\n    return { results, remoteId: resp.response_id };\n  };\n\n  /**\n   * Converts Cohere streaming chat response to internal chat response format\n   * @param resp - The Cohere streaming chat response delta\n   * @param state - State object to maintain across streaming chunks\n   * @returns Formatted internal chat response for streaming\n   */\n  createChatStreamResp = (\n    resp: Readonly<AxAICohereChatResponseDelta>,\n    state: object\n  ): AxChatResponse => {\n    const ss = state as {\n      generation_id?: string;\n    };\n\n    if (resp.event_type === 'stream-start') {\n      ss.generation_id = resp.generation_id;\n    }\n\n    this.tokensUsed = {\n      promptTokens: 0,\n      completionTokens: resp.meta.billed_units?.output_tokens ?? 0,\n      totalTokens: resp.meta.billed_units?.output_tokens ?? 0,\n    };\n\n    const { results } = this.createChatResp(resp);\n    const result = results[0];\n    if (!result) {\n      throw new Error('No result');\n    }\n\n    result.id = ss.generation_id ?? '';\n    return { results };\n  };\n\n  /**\n   * Converts Cohere embedding response to internal embedding response format\n   * @param resp - The Cohere embedding response object\n   * @returns Formatted internal embedding response\n   */\n  createEmbedResp(resp: Readonly<AxAICohereEmbedResponse>): AxEmbedResponse {\n    return {\n      remoteId: resp.id,\n      embeddings: resp.embeddings,\n    };\n  }\n}\n\n/**\n * Main Cohere AI service class that extends the base AI implementation\n * @template TModelKey - The type of model keys supported\n */\nexport class AxAICohere<TModelKey> extends AxBaseAI<\n  AxAICohereModel,\n  AxAICohereEmbedModel,\n  AxAICohereChatRequest,\n  AxAICohereEmbedRequest,\n  AxAICohereChatResponse,\n  AxAICohereChatResponseDelta,\n  AxAICohereEmbedResponse,\n  TModelKey\n> {\n  /**\n   * Creates a new instance of AxAICohere\n   * @param args - Configuration arguments including API key, config, options, and models\n   */\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n  }: Readonly<Omit<AxAICohereArgs<TModelKey>, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Cohere API key not set');\n    }\n    const Config = {\n      ...axAICohereDefaultConfig(),\n      ...config,\n    };\n\n    const aiImpl = new AxAICohereImpl(Config);\n\n    // Normalize per-model presets: allow provider-specific config on each model list item\n    const normalizedModels = models?.map((item) => {\n      const anyItem = item as any;\n      const cfg = anyItem?.config as Partial<AxAICohereConfig> | undefined;\n      if (!cfg) return item;\n\n      const modelConfig: Partial<AxModelConfig> = {};\n      if (cfg.maxTokens !== undefined) modelConfig.maxTokens = cfg.maxTokens;\n      if (cfg.temperature !== undefined)\n        modelConfig.temperature = cfg.temperature;\n      if (cfg.topP !== undefined) modelConfig.topP = cfg.topP;\n      if (cfg.topK !== undefined) modelConfig.topK = cfg.topK as number;\n      if (cfg.presencePenalty !== undefined)\n        modelConfig.presencePenalty = cfg.presencePenalty as number;\n      if (cfg.frequencyPenalty !== undefined)\n        modelConfig.frequencyPenalty = cfg.frequencyPenalty as number;\n      if (cfg.stopSequences !== undefined)\n        modelConfig.stopSequences = cfg.stopSequences as string[];\n      if ((cfg as any).endSequences !== undefined)\n        (modelConfig as any).endSequences = (cfg as any).endSequences;\n      if (cfg.stream !== undefined) modelConfig.stream = cfg.stream as boolean;\n      if (cfg.n !== undefined) modelConfig.n = cfg.n as number;\n\n      const out: any = { ...anyItem };\n      if (Object.keys(modelConfig).length > 0) {\n        out.modelConfig = { ...(anyItem.modelConfig ?? {}), ...modelConfig };\n      }\n      return out as typeof item;\n    });\n\n    super(aiImpl, {\n      name: 'Cohere',\n      apiURL: 'https://api.cohere.ai/v1',\n      headers: async () => ({ Authorization: `Bearer ${apiKey}` }),\n      modelInfo: axModelInfoCohere,\n      defaults: { model: Config.model },\n      supportFor: {\n        functions: true,\n        streaming: true,\n        media: {\n          images: {\n            supported: false,\n            formats: [],\n            maxSize: 0,\n            detailLevels: [] as ('high' | 'low' | 'auto')[],\n          },\n          audio: {\n            supported: false,\n            formats: [],\n            maxDuration: 0,\n          },\n          files: {\n            supported: false,\n            formats: [],\n            maxSize: 0,\n            uploadMethod: 'none' as 'inline' | 'upload' | 'cloud' | 'none',\n          },\n          urls: {\n            supported: false,\n            webSearch: false,\n            contextFetching: false,\n          },\n        },\n        caching: {\n          supported: false,\n          types: [],\n        },\n        thinking: false,\n        multiTurn: true,\n      },\n      options,\n      models: normalizedModels ?? models,\n    });\n  }\n}\n\n/**\n * Converts internal chat prompt format to Cohere chat history format\n * @param chatPrompt - Array of chat messages in internal format\n * @returns Formatted chat history for Cohere API\n */\nfunction createHistory(\n  chatPrompt: Readonly<AxChatRequest['chatPrompt']>\n): AxAICohereChatRequest['chat_history'] {\n  return chatPrompt.map((chat) => {\n    let message = '';\n\n    if (\n      chat.role === 'system' ||\n      chat.role === 'assistant' ||\n      chat.role === 'user'\n    ) {\n      if (typeof chat.content === 'string') {\n        message = chat.content;\n      } else {\n        throw new Error('Multi-modal content not supported');\n      }\n    }\n\n    switch (chat.role) {\n      case 'user':\n        return { role: 'USER' as const, message };\n      case 'system':\n        return { role: 'SYSTEM' as const, message };\n      case 'assistant': {\n        const toolCalls = createToolCall(chat.functionCalls);\n        return {\n          role: 'CHATBOT' as const,\n          message,\n          tool_calls: toolCalls,\n        };\n      }\n      case 'function': {\n        const functionCalls = chatPrompt\n          .map((v) => {\n            if (v.role === 'assistant') {\n              return v.functionCalls?.find((f) => f.id === chat.functionId);\n            }\n            return undefined;\n          })\n          .filter((v) => v !== undefined);\n\n        const call = createToolCall(functionCalls)?.at(0);\n\n        if (!call) {\n          throw new Error('Function call not found');\n        }\n\n        const outputs = [{ result: chat.result }];\n        return {\n          role: 'TOOL' as const,\n          tool_results: [\n            {\n              call,\n              outputs,\n            },\n          ],\n        };\n      }\n      default:\n        throw new Error('Unknown role');\n    }\n  });\n}\n\n/**\n * Converts function calls from internal format to Cohere tool call format\n * @param functionCalls - Array of function calls from assistant messages\n * @returns Formatted tool calls for Cohere API or undefined if no function calls\n */\nfunction createToolCall(\n  functionCalls: Readonly<\n    Extract<\n      AxChatRequest['chatPrompt'][0],\n      { role: 'assistant' }\n    >['functionCalls']\n  >\n) {\n  return functionCalls?.map((v) => {\n    const parameters =\n      typeof v.function.params === 'string'\n        ? JSON.parse(v.function.params)\n        : v.function.params;\n    return { name: v.function.name, parameters };\n  });\n}\n","/**\n * DeepSeek: Models for text generation\n */\nexport enum AxAIDeepSeekModel {\n  DeepSeekChat = 'deepseek-chat',\n  DeepSeekCoder = 'deepseek-coder',\n  DeepSeekReasoner = 'deepseek-reasoner',\n}\n","import type { AxModelInfo } from '../types.js';\n\nimport { AxAIDeepSeekModel } from './types.js';\n\nexport const axModelInfoDeepSeek: AxModelInfo[] = [\n  {\n    name: AxAIDeepSeekModel.DeepSeekChat,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.27,\n    completionTokenCostPer1M: 1.1,\n  },\n  {\n    name: AxAIDeepSeekModel.DeepSeekReasoner,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.55,\n    completionTokenCostPer1M: 2.19,\n  },\n];\n","import {\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport { type AxAIOpenAIArgs, AxAIOpenAIBase } from '../openai/api.js';\nimport type { AxAIOpenAIConfig } from '../openai/chat_types.js';\n\nimport { axModelInfoDeepSeek } from './info.js';\nimport { AxAIDeepSeekModel } from './types.js';\n\n/**\n * Configuration type for DeepSeek AI models\n */\ntype DeepSeekConfig = AxAIOpenAIConfig<AxAIDeepSeekModel, undefined>;\n\n/**\n * Creates the default configuration for DeepSeek AI with the chat model\n * @returns Default DeepSeek configuration with chat model settings\n */\nexport const axAIDeepSeekDefaultConfig = (): DeepSeekConfig =>\n  structuredClone({\n    model: AxAIDeepSeekModel.DeepSeekChat,\n    ...axBaseAIDefaultConfig(),\n  });\n\n/**\n * Creates a configuration optimized for code generation tasks using DeepSeek Coder\n * @returns DeepSeek configuration with creative settings for coding tasks\n */\nexport const axAIDeepSeekCodeConfig = (): DeepSeekConfig =>\n  structuredClone({\n    model: AxAIDeepSeekModel.DeepSeekCoder,\n    ...axBaseAIDefaultCreativeConfig(),\n  });\n\n/**\n * Arguments type for initializing DeepSeek AI instances\n * @template TModelKey - The model key type for type safety\n */\nexport type AxAIDeepSeekArgs<TModelKey> = AxAIOpenAIArgs<\n  'deepseek',\n  AxAIDeepSeekModel,\n  undefined,\n  TModelKey\n>;\n\n/**\n * DeepSeek AI client implementation extending OpenAI base functionality\n * Provides access to DeepSeek's language models through OpenAI-compatible API\n * @template TModelKey - The model key type for type safety\n */\nexport class AxAIDeepSeek<TModelKey> extends AxAIOpenAIBase<\n  AxAIDeepSeekModel,\n  undefined,\n  TModelKey\n> {\n  /**\n   * Creates a new DeepSeek AI client instance\n   * @param args - Configuration arguments for the DeepSeek client\n   * @param args.apiKey - DeepSeek API key for authentication\n   * @param args.config - Optional configuration overrides\n   * @param args.options - Optional client options\n   * @param args.models - Optional model definitions\n   * @param args.modelInfo - Optional additional model information\n   * @throws {Error} When API key is not provided or empty\n   */\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAIDeepSeekArgs<TModelKey>, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('DeepSeek API key not set');\n    }\n    const Config = {\n      ...axAIDeepSeekDefaultConfig(),\n      ...config,\n    };\n\n    modelInfo = [...axModelInfoDeepSeek, ...(modelInfo ?? [])];\n\n    super({\n      apiKey,\n      config: Config,\n      options,\n      apiURL: 'https://api.deepseek.com',\n      modelInfo,\n      supportFor: {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: false,\n        hasShowThoughts: false,\n        media: {\n          images: {\n            supported: false,\n            formats: [],\n          },\n          audio: {\n            supported: false,\n            formats: [],\n          },\n          files: {\n            supported: false,\n            formats: [],\n            uploadMethod: 'none' as const,\n          },\n          urls: {\n            supported: false,\n            webSearch: false,\n            contextFetching: false,\n          },\n        },\n        caching: {\n          supported: false,\n          types: [],\n        },\n        thinking: false,\n        multiTurn: true,\n      },\n      models,\n    });\n\n    super.setName('DeepSeek');\n  }\n}\n","import type { AxModelConfig } from '../types.js';\n\nexport enum AxAIGoogleGeminiModel {\n  Gemini25Pro = 'gemini-2.5-pro',\n  Gemini25Flash = 'gemini-2.5-flash',\n  Gemini25FlashLite = 'gemini-2.5-flash-lite',\n  Gemini20Flash = 'gemini-2.0-flash',\n  Gemini20FlashLite = 'gemini-2.0-flash-lite',\n  Gemini1Pro = 'gemini-1.0-pro',\n  Gemini15Flash = 'gemini-1.5-flash',\n  Gemini15Flash002 = 'gemini-1.5-flash-002',\n  Gemini15Flash8B = 'gemini-1.5-flash-8b',\n  Gemini15Pro = 'gemini-1.5-pro',\n  GeminiFlashLatest = 'gemini-flash-latest',\n  GeminiFlashLiteLatest = 'gemini-flash-lite-latest',\n  GeminiProLatest = 'gemini-pro-latest',\n}\n\nexport enum AxAIGoogleGeminiEmbedModel {\n  GeminiEmbedding = 'gemini-embedding-exp',\n  TextEmbeddingLarge = 'text-embedding-large-exp-03-07',\n  TextEmbedding004 = 'text-embedding-004',\n  TextEmbedding005 = 'text-embedding-005',\n}\n\nexport enum AxAIGoogleGeminiSafetyCategory {\n  HarmCategoryHarassment = 'HARM_CATEGORY_HARASSMENT',\n  HarmCategoryHateSpeech = 'HARM_CATEGORY_HATE_SPEECH',\n  HarmCategorySexuallyExplicit = 'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n  HarmCategoryDangerousContent = 'HARM_CATEGORY_DANGEROUS_CONTENT',\n}\n\nexport enum AxAIGoogleGeminiSafetyThreshold {\n  BlockNone = 'BLOCK_NONE',\n  BlockOnlyHigh = 'BLOCK_ONLY_HIGH',\n  BlockMediumAndAbove = 'BLOCK_MEDIUM_AND_ABOVE',\n  BlockLowAndAbove = 'BLOCK_LOW_AND_ABOVE',\n  BlockDefault = 'HARM_BLOCK_THRESHOLD_UNSPECIFIED',\n}\n\nexport enum AxAIGoogleGeminiEmbedTypes {\n  SemanticSimilarity = 'SEMANTIC_SIMILARITY',\n  Classification = 'CLASSIFICATION',\n  Clustering = 'CLUSTERING',\n  RetrievalDocument = 'RETRIEVAL_DOCUMENT',\n  RetrievalQuery = 'RETRIEVAL_QUERY',\n  QuestionAnswering = 'QUESTION_ANSWERING',\n  FactVerification = 'FACT_VERIFICATION',\n  CodeRetrievalQuery = 'CODE_RETRIEVAL_QUERY',\n}\n\nexport type AxAIGoogleGeminiContent = {\n  role: 'user' | 'model';\n  parts: AxAIGoogleGeminiContentPart[];\n};\n\n// Part type with common fields intersected with a union of data fields\nexport type AxAIGoogleGeminiContentPart = {\n  thought?: boolean;\n  metadata?: { videoMetadata: object };\n} & (\n  | { text: string }\n  | {\n      inlineData: {\n        mimeType: string;\n        data: string;\n      };\n    }\n  | {\n      functionCall: {\n        name: string;\n        args: object;\n      };\n    }\n  | {\n      functionResponse: {\n        name: string;\n        response: object;\n      };\n    }\n  | {\n      fileData: {\n        mimeType: string;\n        fileUri: string;\n      };\n    }\n  | { executableCode: object }\n  | { codeExecutionResult: object }\n);\n\nexport type AxAIGoogleGeminiToolFunctionDeclaration = {\n  name: string;\n  description?: string;\n  parameters?: object;\n};\n\nexport type AxAIGoogleGeminiToolGoogleSearchRetrieval = {\n  dynamic_retrieval_config: {\n    mode?: 'MODE_DYNAMIC';\n    dynamic_threshold?: number;\n  };\n};\n\nexport type AxAIGoogleGeminiToolGoogleMaps = {\n  enableWidget?: boolean;\n};\n\nexport type AxAIGoogleGeminiTool = {\n  function_declarations?: AxAIGoogleGeminiToolFunctionDeclaration[];\n  code_execution?: object;\n  google_search_retrieval?: AxAIGoogleGeminiToolGoogleSearchRetrieval;\n  google_search?: object;\n  url_context?: object;\n  google_maps?: AxAIGoogleGeminiToolGoogleMaps;\n};\n\nexport type AxAIGoogleGeminiToolConfig = {\n  function_calling_config: {\n    mode: 'ANY' | 'NONE' | 'AUTO';\n    allowed_function_names?: string[];\n  };\n  retrievalConfig?: AxAIGoogleGeminiRetrievalConfig;\n};\n\nexport type AxAIGoogleGeminiGenerationConfig = {\n  temperature?: number;\n  topP?: number;\n  topK?: number;\n  frequencyPenalty?: number;\n  candidateCount?: number;\n  maxOutputTokens?: number;\n  stopSequences?: readonly string[];\n  responseMimeType?: string;\n  thinkingConfig?: {\n    thinkingBudget?: number;\n    includeThoughts?: boolean;\n  };\n};\n\nexport type AxAIGoogleGeminiRetrievalConfig = {\n  latLng?: { latitude: number; longitude: number };\n};\n\nexport type AxAIGoogleGeminiSafetySettings = {\n  category: AxAIGoogleGeminiSafetyCategory;\n  threshold: AxAIGoogleGeminiSafetyThreshold;\n}[];\n\nexport type AxAIGoogleGeminiChatRequest = {\n  contents: AxAIGoogleGeminiContent[];\n  tools?: AxAIGoogleGeminiTool[];\n  toolConfig?: AxAIGoogleGeminiToolConfig;\n  systemInstruction?: AxAIGoogleGeminiContent;\n  generationConfig: AxAIGoogleGeminiGenerationConfig;\n  safetySettings?: AxAIGoogleGeminiSafetySettings;\n};\n\nexport type AxAIGoogleGeminiChatResponse = {\n  candidates: {\n    content: AxAIGoogleGeminiContent;\n\n    finishReason:\n      | 'STOP'\n      | 'MAX_TOKENS'\n      | 'SAFETY'\n      | 'RECITATION'\n      | 'OTHER'\n      | 'BLOCKLIST'\n      | 'PROHIBITED_CONTENT'\n      | 'SPII'\n      | 'MALFORMED_FUNCTION_CALL'\n      | 'UNEXPECTED_TOOL_CALL'\n      | 'FINISH_REASON_UNSPECIFIED';\n    citationMetadata: {\n      citations: {\n        startIndex: number;\n        endIndex: number;\n        uri: string;\n        title: string;\n        license: string;\n        publicationDate: {\n          year: number;\n          month: number;\n          day: number;\n        };\n      }[];\n    };\n    groundingMetadata?: {\n      groundingChunks?: {\n        maps?: {\n          title?: string;\n          uri?: string;\n        };\n      }[];\n      googleMapsWidgetContextToken?: string;\n    };\n  }[];\n  usageMetadata: {\n    promptTokenCount: number;\n    candidatesTokenCount: number;\n    totalTokenCount: number;\n    thoughtsTokenCount: number;\n  };\n};\n\nexport type AxAIGoogleGeminiChatResponseDelta = AxAIGoogleGeminiChatResponse;\n\nexport type AxAIGoogleGeminiThinkingConfig = {\n  thinkingTokenBudget?: number;\n  includeThoughts?: boolean;\n};\n\nexport type AxAIGoogleGeminiThinkingTokenBudgetLevels = {\n  minimal?: number;\n  low?: number;\n  medium?: number;\n  high?: number;\n  highest?: number;\n};\n\n/**\n * AxAIGoogleGeminiConfig: Configuration options for Google Gemini API\n */\nexport type AxAIGoogleGeminiConfig = AxModelConfig & {\n  model: AxAIGoogleGeminiModel;\n  embedModel?: AxAIGoogleGeminiEmbedModel;\n  safetySettings?: AxAIGoogleGeminiSafetySettings;\n  embedType?: AxAIGoogleGeminiEmbedTypes;\n  dimensions?: number;\n  autoTruncate?: boolean;\n  thinking?: AxAIGoogleGeminiThinkingConfig;\n  thinkingTokenBudgetLevels?: AxAIGoogleGeminiThinkingTokenBudgetLevels;\n  urlContext?: string;\n};\n\n/**\n * AxAIGoogleGeminiEmbedRequest: Structure for making an embedding request to the Google Gemini API.\n */\nexport type AxAIGoogleGeminiBatchEmbedRequest = {\n  requests: {\n    model: string;\n    content: {\n      parts: { text: string }[];\n    };\n  }[];\n};\n\n/**\n * AxAIGoogleGeminiEmbedResponse: Structure for handling responses from the Google Gemini API embedding requests.\n */\nexport type AxAIGoogleGeminiBatchEmbedResponse = {\n  embeddings: {\n    values: number[];\n  }[];\n};\n\n/**\n * AxAIGoogleVertexBatchEmbedRequest: Structure for making an embedding request to the Google Vertex API.\n */\nexport type AxAIGoogleVertexBatchEmbedRequest = {\n  instances: {\n    content: string;\n    task_type?: AxAIGoogleGeminiEmbedTypes;\n  }[];\n  parameters: {\n    autoTruncate?: boolean;\n    outputDimensionality?: number;\n  };\n};\n\n/**\n * AxAIGoogleVertexBatchEmbedResponse: Structure for handling responses from the Google Vertex API embedding requests.\n */\nexport type AxAIGoogleVertexBatchEmbedResponse = {\n  predictions: {\n    embeddings: {\n      values: number[];\n    };\n  }[];\n};\n","import type { AxModelInfo } from '../types.js';\n\nimport { AxAIGoogleGeminiModel } from './types.js';\n\n/**\n * AxAIGoogleGemini: Model information\n */\nexport const axModelInfoGoogleGemini: AxModelInfo[] = [\n  {\n    name: AxAIGoogleGeminiModel.Gemini25Pro,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 2.5,\n    completionTokenCostPer1M: 15.0,\n    supported: { thinkingBudget: true, showThoughts: true },\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini25Flash,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 15.0,\n    completionTokenCostPer1M: 3.5,\n    supported: { thinkingBudget: true, showThoughts: true },\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini25FlashLite,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.4,\n    supported: { thinkingBudget: true, showThoughts: true },\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini20Flash,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 0.01,\n    completionTokenCostPer1M: 0.4,\n  },\n\n  {\n    name: AxAIGoogleGeminiModel.Gemini20FlashLite,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 0.0,\n    completionTokenCostPer1M: 0.0,\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini15Flash,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 0.075,\n    completionTokenCostPer1M: 0.3,\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini15Flash8B,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 0.0375,\n    completionTokenCostPer1M: 0.15,\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini15Pro,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 1.25,\n    completionTokenCostPer1M: 5.0,\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini1Pro,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 0.5,\n    completionTokenCostPer1M: 1.5,\n  },\n  {\n    name: AxAIGoogleGeminiModel.GeminiFlashLatest,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 0.075,\n    completionTokenCostPer1M: 0.3,\n    supported: { thinkingBudget: true, showThoughts: true },\n  },\n  {\n    name: AxAIGoogleGeminiModel.GeminiFlashLiteLatest,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 0.0,\n    completionTokenCostPer1M: 0.0,\n    supported: { thinkingBudget: true, showThoughts: true },\n  },\n  {\n    name: AxAIGoogleGeminiModel.GeminiProLatest,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 1.25,\n    completionTokenCostPer1M: 5.0,\n    supported: { thinkingBudget: true, showThoughts: true },\n  },\n];\n","import { getModelInfo } from '../../dsp/modelinfo.js';\nimport type { AxAPI } from '../../util/apicall.js';\nimport { AxAIRefusalError } from '../../util/apicall.js';\nimport { randomUUID } from '../../util/crypto.js';\nimport {\n  AxBaseAI,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxEmbedResponse,\n  AxInternalChatRequest,\n  AxInternalEmbedRequest,\n  AxModelConfig,\n  AxModelInfo,\n  AxTokenUsage,\n} from '../types.js';\nimport { axModelInfoGoogleGemini } from './info.js';\nimport {\n  type AxAIGoogleGeminiBatchEmbedRequest,\n  type AxAIGoogleGeminiBatchEmbedResponse,\n  type AxAIGoogleGeminiChatRequest,\n  type AxAIGoogleGeminiChatResponse,\n  type AxAIGoogleGeminiChatResponseDelta,\n  type AxAIGoogleGeminiConfig,\n  type AxAIGoogleGeminiContent,\n  type AxAIGoogleGeminiContentPart,\n  AxAIGoogleGeminiEmbedModel,\n  type AxAIGoogleGeminiGenerationConfig,\n  type AxAIGoogleGeminiToolGoogleMaps,\n  type AxAIGoogleGeminiRetrievalConfig,\n  AxAIGoogleGeminiModel,\n  AxAIGoogleGeminiSafetyCategory,\n  type AxAIGoogleGeminiSafetySettings,\n  AxAIGoogleGeminiSafetyThreshold,\n  type AxAIGoogleVertexBatchEmbedRequest,\n  type AxAIGoogleVertexBatchEmbedResponse,\n} from './types.js';\n\n/**\n * Clean function schema for Gemini API compatibility by removing unsupported fields\n * Gemini doesn't support: additionalProperties, default, optional, maximum, oneOf, anyOf\n */\nconst cleanSchemaForGemini = (schema: any): any => {\n  if (!schema || typeof schema !== 'object') {\n    return schema;\n  }\n\n  const cleaned = { ...schema };\n\n  // Remove unsupported fields\n  delete cleaned.additionalProperties;\n  delete cleaned.default;\n  delete cleaned.optional;\n  delete cleaned.maximum;\n  delete cleaned.oneOf;\n  delete cleaned.anyOf;\n\n  // Recursively clean properties\n  if (cleaned.properties && typeof cleaned.properties === 'object') {\n    cleaned.properties = Object.fromEntries(\n      Object.entries(cleaned.properties).map(([key, value]) => [\n        key,\n        cleanSchemaForGemini(value),\n      ])\n    );\n  }\n\n  // Recursively clean items (for arrays)\n  if (cleaned.items) {\n    cleaned.items = cleanSchemaForGemini(cleaned.items);\n  }\n\n  return cleaned;\n};\n\nconst safetySettings: AxAIGoogleGeminiSafetySettings = [\n  {\n    category: AxAIGoogleGeminiSafetyCategory.HarmCategoryHarassment,\n    threshold: AxAIGoogleGeminiSafetyThreshold.BlockNone,\n  },\n  {\n    category: AxAIGoogleGeminiSafetyCategory.HarmCategoryHateSpeech,\n    threshold: AxAIGoogleGeminiSafetyThreshold.BlockNone,\n  },\n  {\n    category: AxAIGoogleGeminiSafetyCategory.HarmCategorySexuallyExplicit,\n    threshold: AxAIGoogleGeminiSafetyThreshold.BlockNone,\n  },\n  {\n    category: AxAIGoogleGeminiSafetyCategory.HarmCategoryDangerousContent,\n    threshold: AxAIGoogleGeminiSafetyThreshold.BlockNone,\n  },\n];\n\n/**\n * AxAIGoogleGemini: Default Model options for text generation\n */\nexport const axAIGoogleGeminiDefaultConfig = (): AxAIGoogleGeminiConfig =>\n  structuredClone<AxAIGoogleGeminiConfig>({\n    model: AxAIGoogleGeminiModel.Gemini25Flash,\n    embedModel: AxAIGoogleGeminiEmbedModel.TextEmbedding005,\n    safetySettings,\n    thinkingTokenBudgetLevels: {\n      minimal: 200,\n      low: 800,\n      medium: 5000,\n      high: 10000,\n      highest: 24500,\n    },\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAIGoogleGeminiDefaultCreativeConfig =\n  (): AxAIGoogleGeminiConfig =>\n    structuredClone<AxAIGoogleGeminiConfig>({\n      model: AxAIGoogleGeminiModel.Gemini20Flash,\n      embedModel: AxAIGoogleGeminiEmbedModel.TextEmbedding005,\n      safetySettings,\n      thinkingTokenBudgetLevels: {\n        minimal: 200,\n        low: 800,\n        medium: 5000,\n        high: 10000,\n        highest: 24500,\n      },\n      ...axBaseAIDefaultCreativeConfig(),\n    });\n\nexport interface AxAIGoogleGeminiOptionsTools {\n  codeExecution?: boolean;\n  googleSearchRetrieval?: {\n    mode?: 'MODE_DYNAMIC';\n    dynamicThreshold?: number;\n  };\n  googleSearch?: boolean;\n  urlContext?: boolean;\n  googleMaps?: AxAIGoogleGeminiToolGoogleMaps;\n  retrievalConfig?: AxAIGoogleGeminiRetrievalConfig;\n}\n\nexport interface AxAIGoogleGeminiArgs<TModelKey> {\n  name: 'google-gemini';\n  apiKey?: string | (() => Promise<string>);\n  projectId?: string;\n  region?: string;\n  endpointId?: string;\n  config?: Readonly<Partial<AxAIGoogleGeminiConfig>>;\n  options?: Readonly<AxAIServiceOptions & AxAIGoogleGeminiOptionsTools>;\n  models?: AxAIInputModelList<\n    AxAIGoogleGeminiModel,\n    AxAIGoogleGeminiEmbedModel,\n    TModelKey\n  >;\n  modelInfo?: AxModelInfo[];\n}\n\nclass AxAIGoogleGeminiImpl\n  implements\n    AxAIServiceImpl<\n      AxAIGoogleGeminiModel,\n      AxAIGoogleGeminiEmbedModel,\n      AxAIGoogleGeminiChatRequest,\n      AxAIGoogleGeminiBatchEmbedRequest | AxAIGoogleVertexBatchEmbedRequest,\n      AxAIGoogleGeminiChatResponse,\n      AxAIGoogleGeminiChatResponseDelta,\n      AxAIGoogleGeminiBatchEmbedResponse | AxAIGoogleVertexBatchEmbedResponse\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n\n  constructor(\n    private config: AxAIGoogleGeminiConfig,\n    private isVertex: boolean,\n    private endpointId?: string,\n    private apiKey?: string | (() => Promise<string>),\n    private options?: AxAIGoogleGeminiArgs<any>['options']\n  ) {\n    if (!this.isVertex && this.config.autoTruncate) {\n      throw new Error('Auto truncate is not supported for GoogleGemini');\n    }\n  }\n\n  getTokenUsage(): AxTokenUsage | undefined {\n    return this.tokensUsed;\n  }\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this;\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      topP: config.topP,\n      topK: config.topK,\n      presencePenalty: config.presencePenalty,\n      frequencyPenalty: config.frequencyPenalty,\n      stopSequences: config.stopSequences,\n      endSequences: config.endSequences,\n      stream: config.stream,\n      n: config.n,\n    } as AxModelConfig;\n  }\n\n  createChatReq = async (\n    req: Readonly<AxInternalChatRequest<AxAIGoogleGeminiModel>>,\n    config: Readonly<AxAIServiceOptions>\n  ): Promise<[AxAPI, AxAIGoogleGeminiChatRequest]> => {\n    const model = req.model;\n    const stream = req.modelConfig?.stream ?? this.config.stream;\n\n    if (!req.chatPrompt || req.chatPrompt.length === 0) {\n      throw new Error('Chat prompt is empty');\n    }\n\n    let apiConfig: AxAPI;\n    if (this.endpointId) {\n      apiConfig = {\n        name: stream\n          ? `/${this.endpointId}:streamGenerateContent?alt=sse`\n          : `/${this.endpointId}:generateContent`,\n      };\n    } else {\n      apiConfig = {\n        name: stream\n          ? `/models/${model}:streamGenerateContent?alt=sse`\n          : `/models/${model}:generateContent`,\n      };\n    }\n\n    if (!this.isVertex) {\n      const pf = stream ? '&' : '?';\n      const keyValue =\n        typeof this.apiKey === 'function' ? await this.apiKey() : this.apiKey;\n      apiConfig.name += `${pf}key=${keyValue}`;\n    }\n\n    const systemPrompts = req.chatPrompt\n      .filter((p) => p.role === 'system')\n      .map((p) => p.content);\n\n    const systemInstruction =\n      systemPrompts.length > 0\n        ? {\n            role: 'user' as const,\n            parts: [{ text: systemPrompts.join(' ') }],\n          }\n        : undefined;\n\n    const contents: AxAIGoogleGeminiContent[] = req.chatPrompt\n      .filter((p) => p.role !== 'system')\n      .map((msg, i) => {\n        switch (msg.role) {\n          case 'user': {\n            const parts: AxAIGoogleGeminiContentPart[] = Array.isArray(\n              msg.content\n            )\n              ? msg.content.map((c, i) => {\n                  switch (c.type) {\n                    case 'text':\n                      return { text: c.text };\n                    case 'image':\n                      return {\n                        inlineData: { mimeType: c.mimeType, data: c.image },\n                      };\n                    case 'audio':\n                      return {\n                        inlineData: {\n                          mimeType: `audio/${c.format ?? 'mp3'}`,\n                          data: c.data,\n                        },\n                      };\n                    case 'file':\n                      // Support both inline data and fileUri formats\n                      if ('fileUri' in c) {\n                        return {\n                          fileData: {\n                            mimeType: c.mimeType,\n                            fileUri: c.fileUri,\n                          },\n                        };\n                      } else {\n                        return {\n                          inlineData: { mimeType: c.mimeType, data: c.data },\n                        };\n                      }\n                    default:\n                      throw new Error(\n                        `Chat prompt content type not supported (index: ${i})`\n                      );\n                  }\n                })\n              : [{ text: msg.content }];\n            return {\n              role: 'user' as const,\n              parts,\n            };\n          }\n\n          case 'assistant': {\n            let parts: AxAIGoogleGeminiContentPart[] = [];\n\n            if (msg.functionCalls) {\n              parts = msg.functionCalls.map((f) => {\n                const args =\n                  typeof f.function.params === 'string'\n                    ? JSON.parse(f.function.params)\n                    : f.function.params;\n                return {\n                  functionCall: {\n                    name: f.function.name,\n                    args: args,\n                  },\n                };\n              });\n\n              if (!parts) {\n                throw new Error('Function call is empty');\n              }\n\n              return {\n                role: 'model' as const,\n                parts,\n              };\n            }\n\n            if (!msg.content) {\n              throw new Error('Assistant content is empty');\n            }\n\n            parts = [{ text: msg.content }];\n            return {\n              role: 'model' as const,\n              parts,\n            };\n          }\n\n          case 'function': {\n            if (!('functionId' in msg)) {\n              throw new Error(`Chat prompt functionId is empty (index: ${i})`);\n            }\n            const parts: AxAIGoogleGeminiContentPart[] = [\n              {\n                functionResponse: {\n                  name: msg.functionId,\n                  response: { result: msg.result },\n                },\n              },\n            ];\n\n            return {\n              role: 'user' as const,\n              parts,\n            };\n          }\n\n          default:\n            throw new Error(\n              `Invalid role: ${JSON.stringify(msg)} (index: ${i})`\n            );\n        }\n      });\n\n    let tools: AxAIGoogleGeminiChatRequest['tools'] | undefined = [];\n\n    if (req.functions && req.functions.length > 0) {\n      // Clean function schemas for Gemini compatibility\n      const cleanedFunctions = req.functions.map((fn) => ({\n        ...fn,\n        parameters: fn.parameters\n          ? cleanSchemaForGemini(fn.parameters)\n          : undefined,\n      }));\n      tools.push({ function_declarations: cleanedFunctions });\n    }\n\n    if (this.options?.codeExecution) {\n      tools.push({ code_execution: {} });\n    }\n\n    if (this.options?.googleSearchRetrieval) {\n      tools.push({\n        google_search_retrieval: {\n          dynamic_retrieval_config: this.options.googleSearchRetrieval,\n        },\n      });\n    }\n\n    if (this.options?.googleSearch) {\n      tools.push({ google_search: {} });\n    }\n\n    if (this.options?.googleMaps) {\n      const gm = this.options.googleMaps;\n      const mapsToolCfg =\n        gm?.enableWidget !== undefined ? { enableWidget: gm.enableWidget } : {};\n      tools.push({ google_maps: mapsToolCfg } as any);\n    }\n\n    if (this.options?.urlContext) {\n      tools.push({ url_context: {} });\n    }\n\n    if (tools.length === 0) {\n      tools = undefined;\n    }\n\n    let toolConfig:\n      | {\n          function_calling_config: {\n            mode: 'NONE' | 'AUTO' | 'ANY';\n            allowedFunctionNames?: string[];\n          };\n          retrieval_config?: {\n            lat_lng?: { latitude: number; longitude: number };\n            enable_widget?: boolean;\n          };\n        }\n      | undefined;\n\n    // Detect if we declared any functions for Gemini (function_declarations tool)\n    const hasFunctionDeclarations = Array.isArray(tools)\n      ? tools.some(\n          (t: any) =>\n            t &&\n            Array.isArray(t.function_declarations) &&\n            t.function_declarations.length > 0\n        )\n      : false;\n\n    if (req.functionCall) {\n      if (req.functionCall === 'none') {\n        toolConfig = { function_calling_config: { mode: 'NONE' as const } };\n      } else if (req.functionCall === 'auto') {\n        toolConfig = { function_calling_config: { mode: 'AUTO' as const } };\n      } else if (req.functionCall === 'required') {\n        toolConfig = {\n          function_calling_config: { mode: 'ANY' as const },\n        };\n      } else {\n        const allowedFunctionNames = req.functionCall.function?.name\n          ? {\n              allowedFunctionNames: [req.functionCall.function.name],\n            }\n          : {};\n        toolConfig = {\n          function_calling_config: { mode: 'ANY' as const },\n          ...allowedFunctionNames,\n        };\n      }\n    } else if (hasFunctionDeclarations) {\n      // Only set default function_calling_config when we actually provide function_declarations\n      toolConfig = {\n        function_calling_config: { mode: 'AUTO' as const },\n      } as any;\n    }\n\n    // Merge retrievalConfig if provided\n    if (this.options?.retrievalConfig) {\n      toolConfig = {\n        ...(toolConfig ?? {}),\n        retrievalConfig: {\n          ...(this.options.retrievalConfig.latLng\n            ? { latLng: this.options.retrievalConfig.latLng }\n            : {}),\n        },\n      } as any;\n    }\n\n    const thinkingConfig: AxAIGoogleGeminiGenerationConfig['thinkingConfig'] =\n      {};\n\n    if (this.config.thinking?.includeThoughts) {\n      thinkingConfig.includeThoughts = true;\n    }\n\n    if (this.config.thinking?.thinkingTokenBudget) {\n      thinkingConfig.thinkingBudget = this.config.thinking.thinkingTokenBudget;\n    }\n\n    // Then, override based on prompt-specific config\n    if (config?.thinkingTokenBudget) {\n      //The thinkingBudget must be an integer in the range 0 to 24576\n      const levels = this.config.thinkingTokenBudgetLevels;\n\n      switch (config.thinkingTokenBudget) {\n        case 'none':\n          thinkingConfig.thinkingBudget = 0; // Explicitly set to 0\n          thinkingConfig.includeThoughts = false; // When thinkingTokenBudget is 'none', disable showThoughts\n          break;\n        case 'minimal':\n          thinkingConfig.thinkingBudget = levels?.minimal ?? 200;\n          break;\n        case 'low':\n          thinkingConfig.thinkingBudget = levels?.low ?? 800;\n          break;\n        case 'medium':\n          thinkingConfig.thinkingBudget = levels?.medium ?? 5000;\n          break;\n        case 'high':\n          thinkingConfig.thinkingBudget = levels?.high ?? 10000;\n          break;\n        case 'highest':\n          thinkingConfig.thinkingBudget = levels?.highest ?? 24500;\n          break;\n      }\n    }\n\n    if (config?.showThoughts !== undefined) {\n      // Only override includeThoughts if thinkingTokenBudget is not 'none'\n      if (config?.thinkingTokenBudget !== 'none') {\n        thinkingConfig.includeThoughts = config.showThoughts;\n      }\n    }\n\n    const generationConfig: AxAIGoogleGeminiGenerationConfig = {\n      maxOutputTokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,\n      ...(req.modelConfig?.temperature !== undefined\n        ? { temperature: req.modelConfig.temperature }\n        : {}),\n      ...(req.modelConfig?.topP !== undefined\n        ? { topP: req.modelConfig.topP }\n        : {}),\n      topK: req.modelConfig?.topK ?? this.config.topK,\n      frequencyPenalty:\n        req.modelConfig?.frequencyPenalty ?? this.config.frequencyPenalty,\n      candidateCount: 1,\n      stopSequences:\n        req.modelConfig?.stopSequences ?? this.config.stopSequences,\n      responseMimeType: 'text/plain',\n\n      ...(Object.keys(thinkingConfig).length > 0 ? { thinkingConfig } : {}),\n    };\n\n    const safetySettings = this.config.safetySettings;\n\n    const reqValue: AxAIGoogleGeminiChatRequest = {\n      contents,\n      tools,\n      toolConfig,\n      systemInstruction,\n      generationConfig,\n      safetySettings,\n    };\n\n    return [apiConfig, reqValue];\n  };\n\n  createEmbedReq = async (\n    req: Readonly<AxInternalEmbedRequest<AxAIGoogleGeminiEmbedModel>>\n  ): Promise<\n    [\n      AxAPI,\n      AxAIGoogleGeminiBatchEmbedRequest | AxAIGoogleVertexBatchEmbedRequest,\n    ]\n  > => {\n    const model = req.embedModel;\n\n    if (!model) {\n      throw new Error('Embed model not set');\n    }\n\n    if (!req.texts || req.texts.length === 0) {\n      throw new Error('Embed texts is empty');\n    }\n\n    let apiConfig: AxAPI;\n    let reqValue:\n      | AxAIGoogleGeminiBatchEmbedRequest\n      | AxAIGoogleVertexBatchEmbedRequest;\n\n    if (this.isVertex) {\n      if (this.endpointId) {\n        apiConfig = {\n          name: `/${this.endpointId}:predict`,\n        };\n      } else {\n        apiConfig = {\n          name: `/models/${model}:predict`,\n        };\n      }\n\n      reqValue = {\n        instances: req.texts.map((text) => ({\n          content: text,\n          ...(this.config.embedType && { taskType: this.config.embedType }),\n        })),\n        parameters: {\n          autoTruncate: this.config.autoTruncate,\n          outputDimensionality: this.config.dimensions,\n        },\n      };\n    } else {\n      const keyValue =\n        typeof this.apiKey === 'function' ? this.apiKey() : this.apiKey;\n      apiConfig = {\n        name: `/models/${model}:batchEmbedContents?key=${keyValue}`,\n      };\n\n      reqValue = {\n        requests: req.texts.map((text) => ({\n          model: `models/${model}`,\n          content: { parts: [{ text }] },\n          outputDimensionality: this.config.dimensions,\n          ...(this.config.embedType && { taskType: this.config.embedType }),\n        })),\n      };\n    }\n\n    return [apiConfig, reqValue];\n  };\n\n  createChatResp = (\n    resp: Readonly<AxAIGoogleGeminiChatResponse>\n  ): AxChatResponse => {\n    let mapsWidgetToken: string | undefined;\n    const results: AxChatResponseResult[] = resp.candidates?.map(\n      (candidate) => {\n        const result: AxChatResponseResult = { index: 0 };\n\n        switch (candidate.finishReason) {\n          case 'MAX_TOKENS':\n            result.finishReason = 'length';\n            break;\n          case 'STOP':\n            result.finishReason = 'stop';\n            break;\n          case 'SAFETY':\n            throw new AxAIRefusalError(\n              'Content was blocked due to safety settings',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'RECITATION':\n            throw new AxAIRefusalError(\n              'Content was blocked due to recitation policy',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'MALFORMED_FUNCTION_CALL':\n            throw new AxAIRefusalError(\n              'Function call was malformed and blocked',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'UNEXPECTED_TOOL_CALL':\n            throw new AxAIRefusalError(\n              'Unexpected tool call',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'FINISH_REASON_UNSPECIFIED':\n            throw new AxAIRefusalError(\n              'Finish reason unspecified',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'BLOCKLIST':\n            throw new AxAIRefusalError(\n              'Content was blocked due to blocklist',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'PROHIBITED_CONTENT':\n            throw new AxAIRefusalError(\n              'Content was blocked due to prohibited content',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'SPII':\n            throw new AxAIRefusalError(\n              'Content was blocked due to SPII',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'OTHER':\n            throw new AxAIRefusalError(\n              'Other finish reason',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n        }\n\n        if (!candidate.content || !candidate.content.parts) {\n          return result;\n        }\n\n        for (const part of candidate.content.parts) {\n          if ('text' in part) {\n            if ('thought' in part && part.thought) {\n              result.thought = part.text;\n            } else {\n              result.content = part.text;\n            }\n            continue;\n          }\n\n          if ('functionCall' in part) {\n            result.functionCalls = [\n              {\n                id: randomUUID(),\n                type: 'function',\n                function: {\n                  name: part.functionCall.name,\n                  params: part.functionCall.args,\n                },\n              },\n            ];\n          }\n        }\n        // Map citation metadata to normalized citations\n        const cms = candidate.citationMetadata?.citations;\n        if (Array.isArray(cms) && cms.length) {\n          const toIso = (d?: { year: number; month: number; day: number }) =>\n            d\n              ? `${d.year}-${String(d.month).padStart(2, '0')}-${String(d.day).padStart(2, '0')}`\n              : undefined;\n          result.citations = cms\n            .filter((c) => typeof c?.uri === 'string')\n            .map((c) => ({\n              url: c.uri,\n              title: c.title,\n              license: c.license,\n              publicationDate: toIso(c.publicationDate),\n            }));\n        }\n        // Map Google Maps grounding metadata\n        const gm = (candidate as any).groundingMetadata;\n        if (gm) {\n          if (Array.isArray(gm.groundingChunks)) {\n            const mapsCitations = gm.groundingChunks\n              .map((ch: any) => ch?.maps)\n              .filter((m: any) => m && typeof m.uri === 'string')\n              .map((m: any) => ({\n                url: m.uri as string,\n                title: m.title as string | undefined,\n              }));\n            if (mapsCitations.length) {\n              result.citations = [\n                ...(result.citations ?? []),\n                ...mapsCitations,\n              ];\n            }\n          }\n          if (typeof gm.googleMapsWidgetContextToken === 'string') {\n            mapsWidgetToken = gm.googleMapsWidgetContextToken;\n          }\n        }\n        return result;\n      }\n    );\n\n    if (resp.usageMetadata) {\n      this.tokensUsed = {\n        totalTokens: resp.usageMetadata.totalTokenCount,\n        promptTokens: resp.usageMetadata.promptTokenCount,\n        completionTokens: resp.usageMetadata.candidatesTokenCount,\n        thoughtsTokens: resp.usageMetadata.thoughtsTokenCount,\n      };\n    }\n    const response: AxChatResponse = { results };\n    if (mapsWidgetToken) {\n      (response as any).providerMetadata = {\n        ...(response as any).providerMetadata,\n        google: {\n          ...((response as any).providerMetadata?.google ?? {}),\n          mapsWidgetContextToken: mapsWidgetToken,\n        },\n      };\n    }\n    return response;\n  };\n\n  createChatStreamResp = (\n    resp: Readonly<AxAIGoogleGeminiChatResponseDelta>\n  ): AxChatResponse => {\n    return this.createChatResp(resp);\n  };\n\n  createEmbedResp = (\n    resp: Readonly<\n      AxAIGoogleGeminiBatchEmbedResponse | AxAIGoogleVertexBatchEmbedResponse\n    >\n  ): AxEmbedResponse => {\n    let embeddings: number[][];\n    if (this.isVertex) {\n      embeddings = (resp as AxAIGoogleVertexBatchEmbedResponse).predictions.map(\n        (prediction) => prediction.embeddings.values\n      );\n    } else {\n      embeddings = (resp as AxAIGoogleGeminiBatchEmbedResponse).embeddings.map(\n        (embedding) => embedding.values\n      );\n    }\n\n    return {\n      embeddings,\n    };\n  };\n}\n\n// Helper type to extract model keys from the models array\ntype ExtractModelKeys<T> = T extends readonly { key: infer K }[] ? K : never;\n\nexport class AxAIGoogleGemini<TModelKey = string> extends AxBaseAI<\n  AxAIGoogleGeminiModel,\n  AxAIGoogleGeminiEmbedModel,\n  AxAIGoogleGeminiChatRequest,\n  AxAIGoogleGeminiBatchEmbedRequest | AxAIGoogleVertexBatchEmbedRequest,\n  AxAIGoogleGeminiChatResponse,\n  AxAIGoogleGeminiChatResponseDelta,\n  AxAIGoogleGeminiBatchEmbedResponse | AxAIGoogleVertexBatchEmbedResponse,\n  TModelKey\n> {\n  // Static factory method for automatic type inference\n  static create<const T extends AxAIGoogleGeminiArgs<any>>(\n    options: T\n  ): T extends { models: infer M }\n    ? AxAIGoogleGemini<ExtractModelKeys<M>>\n    : AxAIGoogleGemini<string> {\n    return new AxAIGoogleGemini(options) as any;\n  }\n\n  constructor({\n    apiKey,\n    projectId,\n    region,\n    endpointId,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAIGoogleGeminiArgs<TModelKey>, 'name'>>) {\n    const isVertex = projectId !== undefined && region !== undefined;\n\n    let apiURL: string;\n    let headers: () => Promise<Record<string, string>>;\n\n    if (isVertex) {\n      if (!apiKey) {\n        throw new Error('GoogleGemini Vertex API key not set');\n      }\n      if (typeof apiKey !== 'function') {\n        throw new Error(\n          'GoogleGemini Vertex API key must be a function for token-based authentication'\n        );\n      }\n\n      let path: string;\n      if (endpointId) {\n        path = 'endpoints';\n      } else {\n        path = 'publishers/google';\n      }\n\n      const tld = region === 'global' ? 'aiplatform' : `${region}-aiplatform`;\n      apiURL = `https://${tld}.googleapis.com/v1/projects/${projectId}/locations/${region}/${path}`;\n      headers = async () => ({\n        Authorization: `Bearer ${typeof apiKey === 'function' ? await apiKey() : apiKey}`,\n      });\n    } else {\n      if (!apiKey) {\n        throw new Error('GoogleGemini AI API key not set');\n      }\n      apiURL = 'https://generativelanguage.googleapis.com/v1beta';\n      headers = async () => ({});\n    }\n\n    const Config = {\n      ...axAIGoogleGeminiDefaultConfig(),\n      ...config,\n    };\n\n    const aiImpl = new AxAIGoogleGeminiImpl(\n      Config,\n      isVertex,\n      endpointId,\n      apiKey,\n      options\n    );\n\n    modelInfo = [...axModelInfoGoogleGemini, ...(modelInfo ?? [])];\n\n    const supportFor = (model: AxAIGoogleGeminiModel) => {\n      const mi = getModelInfo<\n        AxAIGoogleGeminiModel,\n        AxAIGoogleGeminiEmbedModel,\n        TModelKey\n      >({\n        model,\n        modelInfo,\n        models,\n      });\n      return {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: mi?.supported?.thinkingBudget ?? false,\n        hasShowThoughts: mi?.supported?.showThoughts ?? false,\n        media: {\n          images: {\n            supported: true,\n            formats: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],\n            maxSize: 20 * 1024 * 1024, // 20MB\n            detailLevels: ['high', 'low', 'auto'] as (\n              | 'high'\n              | 'low'\n              | 'auto'\n            )[],\n          },\n          audio: {\n            supported: true,\n            formats: ['wav', 'mp3', 'aac', 'ogg'],\n            maxDuration: 9.5 * 60, // 9.5 minutes for cloud storage\n          },\n          files: {\n            supported: true,\n            formats: [\n              'application/pdf',\n              'text/plain',\n              'text/csv',\n              'text/html',\n              'text/xml',\n            ],\n            maxSize: 2 * 1024 * 1024 * 1024, // 2GB\n            uploadMethod: 'cloud' as 'inline' | 'upload' | 'cloud' | 'none',\n          },\n          urls: {\n            supported: true,\n            webSearch: true,\n            contextFetching: true,\n          },\n        },\n        caching: {\n          supported: false,\n          types: [],\n        },\n        thinking: mi?.supported?.thinkingBudget ?? false,\n        multiTurn: true,\n      };\n    };\n\n    // Normalize per-model presets: allow provider-specific config on each model list item\n    const normalizedModels = models?.map((item) => {\n      const anyItem = item as any;\n      const cfg = anyItem?.config as\n        | Partial<AxAIGoogleGeminiConfig>\n        | undefined;\n      if (!cfg) return item;\n\n      // Extract AxModelConfig-compatible fields and merge into modelConfig\n      const modelConfig: Partial<AxModelConfig> = {};\n      if (cfg.maxTokens !== undefined) modelConfig.maxTokens = cfg.maxTokens;\n      if (cfg.temperature !== undefined)\n        modelConfig.temperature = cfg.temperature;\n      if (cfg.topP !== undefined) modelConfig.topP = cfg.topP;\n      if (cfg.topK !== undefined) modelConfig.topK = cfg.topK as number;\n      if (cfg.presencePenalty !== undefined)\n        modelConfig.presencePenalty = cfg.presencePenalty as number;\n      if (cfg.frequencyPenalty !== undefined)\n        modelConfig.frequencyPenalty = cfg.frequencyPenalty as number;\n      if (cfg.stopSequences !== undefined)\n        modelConfig.stopSequences = cfg.stopSequences as string[];\n      if ((cfg as any).endSequences !== undefined)\n        (modelConfig as any).endSequences = (cfg as any).endSequences;\n      if (cfg.stream !== undefined) modelConfig.stream = cfg.stream as boolean;\n      if (cfg.n !== undefined) modelConfig.n = cfg.n as number;\n\n      const out: any = { ...anyItem };\n      if (Object.keys(modelConfig).length > 0) {\n        out.modelConfig = { ...(anyItem.modelConfig ?? {}), ...modelConfig };\n      }\n\n      // Map exact numeric thinking budget to the closest supported level\n      const numericBudget = cfg.thinking?.thinkingTokenBudget;\n      if (typeof numericBudget === 'number') {\n        const levels = Config.thinkingTokenBudgetLevels;\n        const candidates = [\n          ['minimal', levels?.minimal ?? 200],\n          ['low', levels?.low ?? 800],\n          ['medium', levels?.medium ?? 5000],\n          ['high', levels?.high ?? 10000],\n          ['highest', levels?.highest ?? 24500],\n        ] as const;\n        let bestName: 'minimal' | 'low' | 'medium' | 'high' | 'highest' =\n          'minimal';\n        let bestDiff = Number.POSITIVE_INFINITY;\n        for (const [name, value] of candidates) {\n          const diff = Math.abs(numericBudget - value);\n          if (diff < bestDiff) {\n            bestDiff = diff;\n            bestName = name as typeof bestName;\n          }\n        }\n        out.thinkingTokenBudget = bestName;\n      }\n      // If includeThoughts is provided (with or without numeric budget), map to showThoughts\n      if (cfg.thinking?.includeThoughts !== undefined) {\n        out.showThoughts = !!cfg.thinking.includeThoughts;\n      }\n\n      return out as typeof item;\n    });\n\n    super(aiImpl, {\n      name: 'GoogleGeminiAI',\n      apiURL,\n      headers,\n      modelInfo,\n      defaults: {\n        model: Config.model as AxAIGoogleGeminiModel,\n        embedModel: Config.embedModel as AxAIGoogleGeminiEmbedModel,\n      },\n      options,\n      supportFor,\n      models: normalizedModels ?? models,\n    });\n  }\n}\n","import { ColorLog } from './log.js';\n\nconst colorLog = new ColorLog();\n\nexport interface AxRateLimiterTokenUsageOptions {\n  debug?: boolean;\n}\n\nexport class AxRateLimiterTokenUsage {\n  private options?: Readonly<AxRateLimiterTokenUsageOptions>;\n  private maxTokens: number;\n  private refillRate: number;\n  private currentTokens: number;\n  private lastRefillTime: number;\n\n  constructor(\n    maxTokens: number,\n    refillRate: number,\n    options?: Readonly<AxRateLimiterTokenUsageOptions>\n  ) {\n    this.maxTokens = maxTokens;\n    this.refillRate = refillRate;\n    this.currentTokens = maxTokens;\n    this.lastRefillTime = Date.now();\n    this.options = options;\n  }\n\n  private refillTokens() {\n    const now = Date.now();\n    const timeElapsed = (now - this.lastRefillTime) / 1000; // Convert ms to seconds\n    const tokensToAdd = timeElapsed * this.refillRate;\n    this.currentTokens = Math.min(\n      this.maxTokens,\n      this.currentTokens + tokensToAdd\n    );\n    this.lastRefillTime = now;\n  }\n\n  private async waitUntilTokensAvailable(tokens: number): Promise<void> {\n    this.refillTokens();\n    if (this.currentTokens >= tokens) {\n      this.currentTokens -= tokens;\n      return;\n    }\n    if (this.options?.debug) {\n      console.log(\n        colorLog.red(\n          `Rate limiter: Waiting for ${tokens - this.currentTokens} tokens`\n        )\n      );\n    }\n    await new Promise((resolve) => setTimeout(resolve, 100)); // Wait for 100ms before checking again\n    return this.waitUntilTokensAvailable(tokens); // Recursive call\n  }\n\n  public async acquire(tokens: number): Promise<void> {\n    await this.waitUntilTokensAvailable(tokens);\n  }\n}\n\n/**\n * Example usage of the rate limiter. Limits to 5800 tokens per minute.\nconst rateLimiter = new AxRateLimiterTokenUsage(5800, 5800 / 60);\n\nconst axRateLimiterFunction = async (func, info) => {\n  const totalTokens = info.modelUsage?.totalTokens || 0;\n  await rateLimiter.acquire(totalTokens);\n  return func();\n};\n**/\n","export enum AxAIGroqModel {\n  Llama3_8B = 'llama3-8b-8192',\n  Llama33_70B = 'llama-3.3-70b-versatile',\n  Mixtral_8x7B = 'mixtral-8x7b-32768',\n  Gemma2_9B = 'gemma2-9b-it',\n}\n","import type { AxModelInfo } from '../types.js';\n\nimport { AxAIGroqModel } from './types.js';\n\n/**\n * AxAIGroq: Model information\n */\nexport const axModelInfoGroq: AxModelInfo[] = [\n  {\n    name: AxAIGroqModel.Gemma2_9B,\n    currency: 'usd',\n    characterIsToken: true,\n    promptTokenCostPer1M: 0.2,\n    completionTokenCostPer1M: 0.2,\n  },\n  {\n    name: AxAIGroqModel.Llama33_70B,\n    currency: 'usd',\n    characterIsToken: true,\n    promptTokenCostPer1M: 0.59,\n    completionTokenCostPer1M: 0.79,\n  },\n  {\n    name: AxAIGroqModel.Llama3_8B,\n    currency: 'usd',\n    characterIsToken: true,\n    promptTokenCostPer1M: 0.05,\n    completionTokenCostPer1M: 0.08,\n  },\n  {\n    name: AxAIGroqModel.Mixtral_8x7B,\n    currency: 'usd',\n    characterIsToken: true,\n    promptTokenCostPer1M: 0.24,\n    completionTokenCostPer1M: 0.24,\n  },\n];\n","import { AxRateLimiterTokenUsage } from '../../util/rate-limit.js';\nimport { axBaseAIDefaultConfig } from '../base.js';\nimport { type AxAIOpenAIArgs, AxAIOpenAIBase } from '../openai/api.js';\nimport type { AxAIOpenAIConfig } from '../openai/chat_types.js';\nimport type {\n  AxAIServiceOptions,\n  AxModelInfo,\n  AxRateLimiterFunction,\n} from '../types.js';\n\nimport { axModelInfoGroq } from './info.js';\nimport { AxAIGroqModel } from './types.js';\n\ntype AxAIGroqAIConfig = AxAIOpenAIConfig<AxAIGroqModel, undefined>;\n\nconst axAIGroqDefaultConfig = (): AxAIGroqAIConfig =>\n  structuredClone({\n    model: AxAIGroqModel.Llama33_70B,\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport type AxAIGroqArgs<TModelKey> = AxAIOpenAIArgs<\n  'groq',\n  AxAIGroqModel,\n  undefined,\n  TModelKey\n> & {\n  options?: Readonly<AxAIServiceOptions> & { tokensPerMinute?: number };\n  modelInfo?: AxModelInfo[];\n};\n\nexport class AxAIGroq<TModelKey> extends AxAIOpenAIBase<\n  AxAIGroqModel,\n  undefined,\n  TModelKey\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAIGroqArgs<TModelKey>, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Groq API key not set');\n    }\n    const Config = {\n      ...axAIGroqDefaultConfig(),\n      ...config,\n    };\n\n    const Options = {\n      ...options,\n      streamingUsage: false,\n    };\n\n    modelInfo = [...axModelInfoGroq, ...(modelInfo ?? [])];\n\n    const supportFor = {\n      functions: true,\n      streaming: true,\n      hasThinkingBudget: false,\n      hasShowThoughts: false,\n      media: {\n        images: {\n          supported: false,\n          formats: [],\n        },\n        audio: {\n          supported: false,\n          formats: [],\n        },\n        files: {\n          supported: false,\n          formats: [],\n          uploadMethod: 'none' as const,\n        },\n        urls: {\n          supported: false,\n          webSearch: false,\n          contextFetching: false,\n        },\n      },\n      caching: {\n        supported: false,\n        types: [],\n      },\n      thinking: false,\n      multiTurn: true,\n    };\n\n    super({\n      apiKey,\n      config: Config,\n      options: Options,\n      modelInfo,\n      apiURL: 'https://api.groq.com/openai/v1',\n      models,\n      supportFor,\n    });\n\n    super.setName('Groq');\n    this.setOptions(Options);\n  }\n\n  override setOptions = (options: Readonly<AxAIServiceOptions>) => {\n    const rateLimiter = this.newRateLimiter(options);\n    super.setOptions({ ...options, rateLimiter });\n  };\n\n  private newRateLimiter = (\n    options: Readonly<AxAIGroqArgs<any>['options']>\n  ) => {\n    if (options?.rateLimiter) {\n      return options.rateLimiter;\n    }\n\n    const tokensPerMin = options?.tokensPerMinute ?? 4800;\n    const rt = new AxRateLimiterTokenUsage(tokensPerMin, tokensPerMin / 60, {\n      debug: options?.debug,\n    });\n\n    const rtFunc: AxRateLimiterFunction = async (func, info) => {\n      const totalTokens = info.modelUsage?.tokens?.totalTokens || 0;\n      await rt.acquire(totalTokens);\n      return await func();\n    };\n\n    return rtFunc;\n  };\n}\n","import type { AxModelInfo } from '../types.js';\n\n/**\n * HuggingFace: Model information\n */\nexport const axModelInfoHuggingFace: AxModelInfo[] = [];\n","import type { AxModelConfig } from '../types.js';\n\nexport enum AxAIHuggingFaceModel {\n  MetaLlama270BChatHF = 'meta-llama/Llama-2-70b-chat-hf',\n}\n\nexport type AxAIHuggingFaceConfig = AxModelConfig & {\n  model: AxAIHuggingFaceModel;\n  returnFullText?: boolean;\n  doSample?: boolean;\n  maxTime?: number;\n  useCache?: boolean;\n  waitForModel?: boolean;\n};\n\nexport type AxAIHuggingFaceRequest = {\n  model: AxAIHuggingFaceModel;\n  inputs: string;\n  parameters: {\n    max_new_tokens?: number;\n    repetition_penalty?: number;\n    temperature?: number;\n    top_p?: number;\n    top_k?: number;\n    return_full_text?: boolean;\n    num_return_sequences?: number;\n    do_sample?: boolean;\n    max_time?: number;\n  };\n  options?: {\n    use_cache?: boolean;\n    wait_for_model?: boolean;\n  };\n};\n\nexport type AxAIHuggingFaceResponse = {\n  generated_text: string;\n};\n","import type { AxAPI } from '../../util/apicall.js';\nimport {\n  AxBaseAI,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatResponse,\n  AxInternalChatRequest,\n  AxModelConfig,\n  AxTokenUsage,\n} from '../types.js';\n\nimport { axModelInfoHuggingFace } from './info.js';\nimport {\n  type AxAIHuggingFaceConfig,\n  AxAIHuggingFaceModel,\n  type AxAIHuggingFaceRequest,\n  type AxAIHuggingFaceResponse,\n} from './types.js';\n\nexport const axAIHuggingFaceDefaultConfig = (): AxAIHuggingFaceConfig =>\n  structuredClone({\n    model: AxAIHuggingFaceModel.MetaLlama270BChatHF,\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAIHuggingFaceCreativeConfig = (): AxAIHuggingFaceConfig =>\n  structuredClone({\n    model: AxAIHuggingFaceModel.MetaLlama270BChatHF,\n    ...axBaseAIDefaultCreativeConfig(),\n  });\n\nexport interface AxAIHuggingFaceArgs<TModelKey> {\n  name: 'huggingface';\n  apiKey: string;\n  config?: Readonly<Partial<AxAIHuggingFaceConfig>>;\n  options?: Readonly<AxAIServiceOptions>;\n  models?: AxAIInputModelList<AxAIHuggingFaceModel, undefined, TModelKey>;\n}\n\nclass AxAIHuggingFaceImpl\n  implements\n    AxAIServiceImpl<\n      AxAIHuggingFaceModel,\n      unknown,\n      AxAIHuggingFaceRequest,\n      unknown,\n      AxAIHuggingFaceResponse,\n      unknown,\n      unknown\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n\n  constructor(private config: AxAIHuggingFaceConfig) {}\n\n  getTokenUsage(): AxTokenUsage | undefined {\n    return this.tokensUsed;\n  }\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this;\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      topP: config.topP,\n      topK: config.topK,\n      n: config.n,\n      presencePenalty: config.presencePenalty,\n    } as AxModelConfig;\n  }\n\n  createChatReq = (\n    req: Readonly<AxInternalChatRequest<AxAIHuggingFaceModel>>\n  ): [AxAPI, AxAIHuggingFaceRequest] => {\n    const model = req.model;\n\n    const functionsList = req.functions\n      ? `Functions:\\n${JSON.stringify(req.functions, null, 2)}\\n`\n      : '';\n\n    const prompt = req.chatPrompt\n      ?.map((msg) => {\n        switch (msg.role) {\n          case 'user':\n            return `User: ${msg.content}`;\n          case 'system':\n            return `System: ${msg.content}`;\n          case 'function':\n            return `Function Result: ${msg.result}`;\n          case 'assistant': {\n            const fc = msg.functionCalls\n              ?.map((fc) => {\n                const args =\n                  typeof fc.function.params === 'string'\n                    ? fc.function.params\n                    : JSON.stringify(fc.function.params);\n\n                return `${fc.function.name}(${args})`;\n              })\n              .join('\\n');\n            if (fc) {\n              return `Assistant: ${msg.content}\\n Functions:\\n${fc}`;\n            }\n            return `Assistant: ${msg.content}`;\n          }\n          default:\n            throw new Error('Unknown role');\n        }\n\n        //return `${msg.role}: ${msg.content}`;\n      })\n      .join('\\n');\n\n    const inputs = `${functionsList} ${prompt}`.trim();\n\n    const apiConfig = {\n      name: '/models',\n    };\n\n    const reqValue: AxAIHuggingFaceRequest = {\n      model,\n      inputs,\n      parameters: {\n        max_new_tokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,\n        repetition_penalty:\n          req.modelConfig?.presencePenalty ?? this.config.presencePenalty,\n        ...(req.modelConfig?.temperature !== undefined\n          ? { temperature: req.modelConfig.temperature }\n          : {}),\n        ...(req.modelConfig?.topP !== undefined\n          ? { top_p: req.modelConfig.topP }\n          : {}),\n        top_k: req.modelConfig?.topK ?? this.config.topK,\n        return_full_text: this.config.returnFullText,\n        num_return_sequences: this.config.n,\n        do_sample: this.config.doSample,\n        max_time: this.config.maxTime,\n      },\n      options: {\n        use_cache: this.config.useCache,\n        wait_for_model: this.config.waitForModel,\n      },\n    };\n\n    return [apiConfig, reqValue];\n  };\n\n  createChatResp = (\n    resp: Readonly<AxAIHuggingFaceResponse>\n  ): AxChatResponse => {\n    return {\n      results: [\n        {\n          index: 0,\n          content: resp.generated_text,\n        },\n      ],\n    };\n  };\n}\n\nexport class AxAIHuggingFace<TModelKey> extends AxBaseAI<\n  AxAIHuggingFaceModel,\n  unknown,\n  AxAIHuggingFaceRequest,\n  unknown,\n  AxAIHuggingFaceResponse,\n  unknown,\n  unknown,\n  TModelKey\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n  }: Readonly<Omit<AxAIHuggingFaceArgs<TModelKey>, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('HuggingFace API key not set');\n    }\n    const Config = {\n      ...axAIHuggingFaceDefaultConfig(),\n      ...config,\n    };\n\n    const aiImpl = new AxAIHuggingFaceImpl(Config);\n\n    super(aiImpl, {\n      name: 'HuggingFace',\n      apiURL: 'https://api-inference.huggingface.co',\n      headers: async () => ({ Authorization: `Bearer ${apiKey}` }),\n      modelInfo: axModelInfoHuggingFace,\n      defaults: { model: Config.model },\n      options,\n      supportFor: {\n        functions: false,\n        streaming: false,\n        media: {\n          images: {\n            supported: false,\n            formats: [],\n          },\n          audio: {\n            supported: false,\n            formats: [],\n          },\n          files: {\n            supported: false,\n            formats: [],\n            uploadMethod: 'none' as const,\n          },\n          urls: {\n            supported: false,\n            webSearch: false,\n            contextFetching: false,\n          },\n        },\n        caching: {\n          supported: false,\n          types: [],\n        },\n        thinking: false,\n        multiTurn: true,\n      },\n      models,\n    });\n  }\n}\n","// cspell:ignore mistral, mixtral, codestral, nemo\n\nexport enum AxAIMistralModel {\n  Mistral7B = 'open-mistral-7b',\n  Mistral8x7B = 'open-mixtral-8x7b',\n  MistralSmall = 'mistral-small-latest',\n  MistralNemo = 'mistral-nemo-latest',\n  MistralLarge = 'mistral-large-latest',\n  Codestral = 'codestral-latest',\n  OpenCodestralMamba = 'open-codestral-mamba',\n  OpenMistralNemo = 'open-mistral-nemo-latest',\n}\n\nexport enum AxAIMistralEmbedModels {\n  MistralEmbed = 'mistral-embed',\n}\n","// cspell:ignore mistral, mixtral, codestral, nemo\n\nimport type { AxModelInfo } from '../types.js';\n\nimport { AxAIMistralModel } from './types.js';\n\nexport const axModelInfoMistral: AxModelInfo[] = [\n  {\n    name: AxAIMistralModel.Mistral7B,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.25,\n    completionTokenCostPer1M: 0.25,\n  },\n  {\n    name: AxAIMistralModel.Mistral8x7B,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.7,\n    completionTokenCostPer1M: 0.7,\n  },\n  {\n    name: AxAIMistralModel.MistralNemo,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.15,\n    completionTokenCostPer1M: 0.15,\n  },\n  {\n    name: AxAIMistralModel.MistralSmall,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.2,\n    completionTokenCostPer1M: 0.6,\n  },\n  {\n    name: AxAIMistralModel.MistralLarge,\n    currency: 'USD',\n    promptTokenCostPer1M: 2,\n    completionTokenCostPer1M: 6,\n  },\n  {\n    name: AxAIMistralModel.Codestral,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.2,\n    completionTokenCostPer1M: 0.6,\n  },\n  {\n    name: AxAIMistralModel.OpenCodestralMamba,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.25,\n    completionTokenCostPer1M: 0.25,\n  },\n  {\n    name: AxAIMistralModel.OpenMistralNemo,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.3,\n    completionTokenCostPer1M: 0.3,\n  },\n];\n","import { axBaseAIDefaultConfig } from '../base.js';\nimport { type AxAIOpenAIArgs, AxAIOpenAIBase } from '../openai/api.js';\nimport type {\n  AxAIOpenAIChatRequest,\n  AxAIOpenAIConfig,\n} from '../openai/chat_types.js';\nimport type { AxAIServiceOptions, AxModelInfo } from '../types.js';\n\nimport { axModelInfoMistral } from './info.js';\nimport { type AxAIMistralEmbedModels, AxAIMistralModel } from './types.js';\n\ntype AxAIMistralConfig = AxAIOpenAIConfig<\n  AxAIMistralModel,\n  AxAIMistralEmbedModels\n>;\n\nexport const axAIMistralDefaultConfig = (): AxAIMistralConfig =>\n  structuredClone({\n    model: AxAIMistralModel.MistralSmall,\n    ...axBaseAIDefaultConfig(),\n    topP: 1,\n  });\n\nexport const axAIMistralBestConfig = (): AxAIMistralConfig =>\n  structuredClone({\n    ...axAIMistralDefaultConfig(),\n    model: AxAIMistralModel.MistralLarge,\n  });\n\nexport type AxAIMistralChatRequest = Omit<\n  AxAIOpenAIChatRequest<AxAIMistralModel>,\n  'max_completion_tokens' | 'stream_options' | 'messages'\n> & {\n  max_tokens?: number;\n  messages: (\n    | { role: 'system'; content: string }\n    | {\n        role: 'user';\n        content:\n          | string\n          | (\n              | {\n                  type: 'text';\n                  text: string;\n                }\n              | {\n                  type: 'image_url';\n                  image_url: string;\n                }\n            )[];\n        name?: string;\n      }\n    | {\n        role: 'assistant';\n        content: string;\n        name?: string;\n        tool_calls?: {\n          type: 'function';\n          function: {\n            name: string;\n            // eslint-disable-next-line functional/functional-parameters\n            arguments?: string;\n          };\n        }[];\n      }\n    | { role: 'tool'; content: string; tool_call_id: string }\n  )[];\n};\n\nexport type AxAIMistralArgs<TModelKey> = AxAIOpenAIArgs<\n  'mistral',\n  AxAIMistralModel,\n  AxAIMistralEmbedModels,\n  TModelKey\n> & {\n  options?: Readonly<AxAIServiceOptions> & { tokensPerMinute?: number };\n  modelInfo?: AxModelInfo[];\n};\n\nexport class AxAIMistral<TModelKey> extends AxAIOpenAIBase<\n  AxAIMistralModel,\n  AxAIMistralEmbedModels,\n  TModelKey\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAIMistralArgs<TModelKey>, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Mistral API key not set');\n    }\n    const Config = {\n      ...axAIMistralDefaultConfig(),\n      ...config,\n    };\n\n    modelInfo = [...axModelInfoMistral, ...(modelInfo ?? [])];\n\n    const supportFor = {\n      functions: true,\n      streaming: true,\n      hasThinkingBudget: false,\n      hasShowThoughts: false,\n      media: {\n        images: {\n          supported: false,\n          formats: [],\n        },\n        audio: {\n          supported: false,\n          formats: [],\n        },\n        files: {\n          supported: false,\n          formats: [],\n          uploadMethod: 'none' as const,\n        },\n        urls: {\n          supported: false,\n          webSearch: false,\n          contextFetching: false,\n        },\n      },\n      caching: {\n        supported: false,\n        types: [],\n      },\n      thinking: false,\n      multiTurn: true,\n    };\n\n    // Chat request updater to add Grok's search parameters\n    const chatReqUpdater = (\n      req: Readonly<AxAIOpenAIChatRequest<AxAIMistralModel>>\n    ): AxAIMistralChatRequest => {\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      const { max_completion_tokens, messages, ...result } =\n        req as AxAIOpenAIChatRequest<AxAIMistralModel>;\n\n      return {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ...(result as any),\n        messages: this.updateMessages(messages),\n        max_tokens: max_completion_tokens,\n      };\n    };\n\n    super({\n      apiKey,\n      config: Config,\n      options,\n      apiURL: 'https://api.mistral.ai/v1',\n      modelInfo,\n      models,\n      supportFor,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      chatReqUpdater: chatReqUpdater as any,\n    });\n\n    super.setName('Mistral');\n  }\n\n  private updateMessages(\n    messages: AxAIOpenAIChatRequest<AxAIMistralModel>['messages']\n  ) {\n    const messagesUpdated: AxAIOpenAIChatRequest<AxAIMistralModel>['messages'] =\n      [];\n\n    if (!Array.isArray(messages)) {\n      return messages;\n    }\n\n    for (const message of messages) {\n      if (message.role === 'user' && Array.isArray(message.content)) {\n        const contentUpdated = message.content.map((item) => {\n          if (\n            typeof item === 'object' &&\n            item !== null &&\n            'image_url' in item\n          ) {\n            return {\n              type: 'image_url' as const,\n              image_url: { url: item.image_url?.url },\n            };\n          }\n          return item;\n        });\n        messagesUpdated.push({ ...message, content: contentUpdated });\n      } else {\n        messagesUpdated.push(message);\n      }\n    }\n\n    return messagesUpdated;\n  }\n}\n","// ReadableStream is available globally in modern browsers and Node.js 16+\nimport { randomUUID } from '../../util/crypto.js';\n\nimport type {\n  AxAIModelList,\n  AxAIService,\n  AxAIServiceMetrics,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxEmbedRequest,\n  AxEmbedResponse,\n  AxLoggerData,\n  AxLoggerFunction,\n  AxModelConfig,\n  AxModelInfoWithProvider,\n} from '../types.js';\nimport type { AxAIFeatures } from '../base.js';\n\nexport type AxMockAIServiceConfig<TModelKey> = {\n  name?: string;\n  id?: string;\n  modelInfo?: Partial<AxModelInfoWithProvider>;\n  embedModelInfo?: AxModelInfoWithProvider;\n  features?: { functions?: boolean; streaming?: boolean };\n  models?: AxAIModelList<TModelKey>;\n  options?: AxAIServiceOptions;\n  chatResponse?:\n    | AxChatResponse\n    | ReadableStream<AxChatResponse>\n    | (() => Promise<AxChatResponse | ReadableStream<AxChatResponse>>)\n    | ((\n        req: Readonly<AxChatRequest<unknown>>,\n        options?: Readonly<AxAIServiceOptions>\n      ) => Promise<AxChatResponse | ReadableStream<AxChatResponse>>);\n\n  embedResponse?:\n    | AxEmbedResponse\n    | ((\n        req: Readonly<AxEmbedRequest>\n      ) => AxEmbedResponse | Promise<AxEmbedResponse>);\n  shouldError?: boolean;\n  errorMessage?: string;\n  latencyMs?: number;\n};\n\nexport class AxMockAIService<TModelKey>\n  implements AxAIService<unknown, unknown, TModelKey>\n{\n  private metrics: AxAIServiceMetrics = {\n    latency: {\n      chat: { mean: 0, p95: 0, p99: 0, samples: [] },\n      embed: { mean: 0, p95: 0, p99: 0, samples: [] },\n    },\n    errors: {\n      chat: { count: 0, rate: 0, total: 0 },\n      embed: { count: 0, rate: 0, total: 0 },\n    },\n  };\n\n  constructor(private readonly config: AxMockAIServiceConfig<TModelKey> = {}) {\n    this.config.id = this.config.id ?? randomUUID();\n  }\n  getLastUsedChatModel(): unknown {\n    return this.config.modelInfo?.name ?? 'mock-model';\n  }\n  getLastUsedEmbedModel(): unknown {\n    return this.config.embedModelInfo?.name ?? 'mock-embed-model';\n  }\n  getLastUsedModelConfig(): AxModelConfig | undefined {\n    return this.config.modelInfo\n      ? {\n          maxTokens: this.config.modelInfo.maxTokens,\n          temperature: 0.7, // Default temperature\n          stream: this.config.features?.streaming ?? false,\n        }\n      : undefined;\n  }\n\n  getName(): string {\n    return this.config.name ?? 'mock-ai-service';\n  }\n\n  getId(): string {\n    return this.config.id ?? 'mock-ai-service-id';\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getFeatures(_model?: string): AxAIFeatures {\n    return {\n      functions: this.config.features?.functions ?? false,\n      streaming: this.config.features?.streaming ?? false,\n      media: {\n        images: {\n          supported: false,\n          formats: [],\n        },\n        audio: {\n          supported: false,\n          formats: [],\n        },\n        files: {\n          supported: false,\n          formats: [],\n          uploadMethod: 'none' as const,\n        },\n        urls: {\n          supported: false,\n          webSearch: false,\n          contextFetching: false,\n        },\n      },\n      caching: {\n        supported: false,\n        types: [],\n      },\n      thinking: false,\n      multiTurn: true,\n    };\n  }\n\n  getModelList(): AxAIModelList<TModelKey> | undefined {\n    return this.config.models;\n  }\n\n  getMetrics(): AxAIServiceMetrics {\n    return this.metrics;\n  }\n\n  async chat(\n    req: Readonly<AxChatRequest<unknown>>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options?: Readonly<AxAIServiceOptions>\n  ) {\n    if (this.config.latencyMs) {\n      await new Promise((resolve) =>\n        setTimeout(resolve, this.config.latencyMs)\n      );\n    }\n\n    if (this.config.shouldError) {\n      throw new Error(this.config.errorMessage ?? 'Mock chat error');\n    }\n\n    this.updateMetrics('chat');\n\n    if (typeof this.config.chatResponse === 'function') {\n      return await this.config.chatResponse(req);\n    }\n\n    return (\n      this.config.chatResponse ?? {\n        results: [\n          {\n            index: 0,\n            content: 'Mock response',\n            finishReason: 'stop',\n          },\n        ],\n        modelUsage: {\n          ai: this.getName(),\n          model: 'mock-model',\n          tokens: {\n            promptTokens: 10,\n            completionTokens: 5,\n            totalTokens: 15,\n          },\n        },\n      }\n    );\n  }\n\n  async embed(\n    req: Readonly<AxEmbedRequest>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options?: Readonly<AxAIServiceOptions>\n  ): Promise<AxEmbedResponse> {\n    if (this.config.latencyMs) {\n      await new Promise((resolve) =>\n        setTimeout(resolve, this.config.latencyMs)\n      );\n    }\n\n    if (this.config.shouldError) {\n      throw new Error(this.config.errorMessage ?? 'Mock embed error');\n    }\n\n    this.updateMetrics('embed');\n\n    if (typeof this.config.embedResponse === 'function') {\n      return this.config.embedResponse(req);\n    }\n\n    return (\n      this.config.embedResponse ?? {\n        embeddings: [[0.1, 0.2, 0.3]],\n        modelUsage: {\n          ai: this.getName(),\n          model: 'mock-model',\n          tokens: {\n            promptTokens: 5,\n            completionTokens: 0,\n            totalTokens: 5,\n          },\n        },\n      }\n    );\n  }\n\n  setOptions(options: Readonly<AxAIServiceOptions>): void {\n    this.config.options = options;\n  }\n\n  getOptions(): Readonly<AxAIServiceOptions> {\n    return this.config.options ?? {};\n  }\n\n  getLogger(): AxLoggerFunction {\n    return (\n      this.config.options?.logger ??\n      ((message: string | AxLoggerData) => {\n        console.log(message);\n      })\n    );\n  }\n\n  private updateMetrics(type: 'chat' | 'embed'): void {\n    const latency = this.config.latencyMs ?? 0;\n    this.metrics.latency[type].samples.push(latency);\n    const samples = this.metrics.latency[type].samples;\n\n    // Update mean\n    this.metrics.latency[type].mean =\n      samples.reduce((a, b) => a + b, 0) / samples.length;\n\n    // Calculate percentiles only if we have enough samples\n    if (samples.length > 0) {\n      const sortedSamples = [...samples].sort((a, b) => a - b);\n\n      // For p95, we need at least 20 samples for meaningful calculation (1/0.05)\n      const p95Index = Math.max(0, Math.floor(sortedSamples.length * 0.95) - 1);\n      this.metrics.latency[type].p95 = sortedSamples[p95Index] ?? latency;\n\n      // For p99, we need at least 100 samples for meaningful calculation (1/0.01)\n      const p99Index = Math.max(0, Math.floor(sortedSamples.length * 0.99) - 1);\n      this.metrics.latency[type].p99 = sortedSamples[p99Index] ?? latency;\n    }\n\n    if (this.config.shouldError) {\n      this.metrics.errors[type].count++;\n      this.metrics.errors[type].total++;\n\n      // Calculate error rate against total requests, not just samples\n      const totalRequests = this.metrics.latency[type].samples.length;\n      this.metrics.errors[type].rate =\n        totalRequests > 0 ? this.metrics.errors[type].count / totalRequests : 0;\n    }\n  }\n}\n\n// Example usage:\n/*\nconst mockService = new MockAIService({\n  name: 'test-service',\n  modelInfo: {\n    name: 'test-model',\n    provider: 'test-provider',\n    promptTokenCostPer1M: 200,\n    completionTokenCostPer1M: 150,\n  },\n  features: {\n    functions: true,\n    streaming: true,\n  },\n  chatResponse: async (req) => ({\n    results: [\n      {\n        content: `Processed request with ${req.chatPrompt.length} messages`,\n        finishReason: 'stop',\n      },\n    ],\n    modelUsage: {\n      promptTokens: 20,\n      completionTokens: 10,\n      totalTokens: 30,\n    },\n  }),\n  latencyMs: 100,\n})\n*/\n","// ReadableStream is available globally in modern browsers and Node.js 16+\n\nimport type {\n  AxAIModelList,\n  AxAIService,\n  AxAIServiceMetrics,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxEmbedRequest,\n  AxEmbedResponse,\n  AxLoggerFunction,\n  AxModelConfig,\n} from './types.js';\nimport type { AxAIFeatures } from './base.js';\n\ntype AxAIServiceListItem<\n  TModel = unknown,\n  TEmbedModel = unknown,\n  TModelKey = string,\n> = {\n  key: TModelKey;\n  service: AxAIService<TModel, TEmbedModel, TModelKey>;\n  description: string;\n  isInternal?: boolean;\n};\n\n// Helper type to extract model keys from a service\ntype ExtractServiceModelKeys<T> = T extends AxAIService<any, any, infer K>\n  ? K\n  : T extends AxAIServiceListItem<any, any, infer K>\n    ? K\n    : never;\n\n// Helper type to extract model keys from an array of services\ntype ExtractAllModelKeys<T extends readonly any[]> = T extends readonly [\n  infer First,\n  ...infer Rest,\n]\n  ? ExtractServiceModelKeys<First> | ExtractAllModelKeys<Rest>\n  : never;\n\nexport class AxMultiServiceRouter<\n  TServices extends readonly (\n    | AxAIService\n    | AxAIServiceListItem<any, any, any>\n  )[] = readonly AxAIService[],\n  TModelKey = ExtractAllModelKeys<TServices>,\n> implements AxAIService<unknown, unknown, TModelKey>\n{\n  private options?: AxAIServiceOptions;\n  private lastUsedService?: AxAIService<unknown, unknown, TModelKey>;\n\n  private services: Map<\n    TModelKey,\n    {\n      isInternal?: boolean;\n      description: string;\n      model?: string;\n      embedModel?: string;\n      service: AxAIService<unknown, unknown, TModelKey>;\n    }\n  > = new Map();\n  /**\n   * Constructs a new multi-service router.\n   * It validates that each service provides a unique set of model keys,\n   * then builds a lookup (map) for routing the chat/embed requests.\n   */\n  constructor(services: TServices) {\n    if (services.length === 0) {\n      throw new Error('No AI services provided.');\n    }\n\n    // Determine input type based on first element (assuming homogeneous array)\n\n    for (const [index, item] of services.entries()) {\n      const isKeyBased = 'key' in item;\n\n      if (isKeyBased) {\n        if (this.services.has(item.key as TModelKey)) {\n          throw new Error(`Duplicate model key: ${item.key}`);\n        }\n\n        const { service, description, isInternal } = item;\n\n        this.services.set(item.key as TModelKey, {\n          service: service as AxAIService<unknown, unknown, TModelKey>,\n          description,\n          isInternal,\n        });\n      } else {\n        const modelList = item.getModelList() as\n          | AxAIModelList<TModelKey>\n          | undefined;\n\n        if (!modelList) {\n          throw new Error(\n            `Service ${index} \\`${item.getName()}\\` has no model list.`\n          );\n        }\n\n        for (const v of modelList) {\n          if (this.services.has(v.key)) {\n            const otherService = this.services.get(v.key)?.service;\n            throw new Error(\n              `Service ${index} \\`${item.getName()}\\` has duplicate model key: ${v.key} as service ${otherService?.getName()}`\n            );\n          }\n          if ('model' in v && typeof v.model) {\n            this.services.set(v.key, {\n              description: v.description,\n              service: item as AxAIService<unknown, unknown, TModelKey>,\n              model: v.model,\n            });\n          } else if ('embedModel' in v && v.embedModel) {\n            this.services.set(v.key, {\n              description: v.description,\n              service: item as AxAIService<unknown, unknown, TModelKey>,\n              embedModel: v.embedModel,\n            });\n          } else {\n            throw new Error(\n              `Key ${v.key} in model list for service ${index} \\`${item.getName()}\\` is missing a model or embedModel property.`\n            );\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Static factory method for type-safe multi-service router creation with automatic model key inference.\n   */\n  static create<\n    const TServices extends readonly (\n      | AxAIService\n      | AxAIServiceListItem<any, any, any>\n    )[],\n  >(\n    services: TServices\n  ): AxMultiServiceRouter<TServices, ExtractAllModelKeys<TServices>> {\n    return new AxMultiServiceRouter(services);\n  }\n  getLastUsedChatModel(): unknown | undefined {\n    return this.lastUsedService?.getLastUsedChatModel();\n  }\n  getLastUsedEmbedModel(): unknown | undefined {\n    return this.lastUsedService?.getLastUsedEmbedModel();\n  }\n  getLastUsedModelConfig(): AxModelConfig | undefined {\n    return this.lastUsedService?.getLastUsedModelConfig();\n  }\n\n  /**\n   * Delegates the chat call to the service matching the provided model key.\n   */\n  async chat(\n    req: Readonly<AxChatRequest<TModelKey>>,\n    options?: Readonly<AxAIServiceOptions>\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    const modelKey = req.model as TModelKey;\n    if (!modelKey) {\n      throw new Error('Model key must be specified for multi-service');\n    }\n\n    const item = this.services.get(modelKey);\n    if (!item) {\n      throw new Error(`No service found for model key: ${modelKey}`);\n    }\n\n    this.lastUsedService = item.service;\n\n    if (!item.model) {\n      const { model: _, ...reqWithoutModel } = req;\n      return await item.service.chat(reqWithoutModel, options);\n    }\n\n    return await item.service.chat({ model: modelKey, ...req }, options);\n  }\n\n  /**\n   * Delegates the embed call to the service matching the provided embed model key.\n   */\n  async embed(\n    req: Readonly<AxEmbedRequest<TModelKey>>,\n    options?: Readonly<AxAIServiceOptions>\n  ): Promise<AxEmbedResponse> {\n    const embedModelKey = req.embedModel as TModelKey;\n    if (!embedModelKey) {\n      throw new Error('Embed model key must be specified for multi-service');\n    }\n\n    const item = this.services.get(embedModelKey);\n    if (!item) {\n      throw new Error(`No service found for embed model key: ${embedModelKey}`);\n    }\n\n    this.lastUsedService = item.service;\n\n    if (!item.model) {\n      const { embedModel: _, ...reqWithoutEmbedModel } = req;\n      return await item.service.embed(reqWithoutEmbedModel, options);\n    }\n\n    return await item.service.embed(\n      { embedModel: embedModelKey, ...req },\n      options\n    );\n  }\n\n  /**\n   * Returns a composite ID built from the IDs of the underlying services.\n   */\n  getId(): string {\n    return `MultiServiceRouter:${Array.from(this.services.values())\n      .map((s) => s.service.getId())\n      .join(',')}`;\n  }\n\n  /**\n   * Returns the name of this router.\n   */\n  getName(): string {\n    return 'MultiServiceRouter';\n  }\n\n  /**\n   * Aggregates all available models across the underlying services.\n   */\n  getModelList(): AxAIModelList<TModelKey> {\n    return Array.from(this.services)\n      .filter(([, value]) => !value.isInternal)\n      .map(([key, v]) => {\n        if (v.model) {\n          return { key, description: v.description, model: v.model };\n        }\n        if (v.embedModel) {\n          return { key, description: v.description, embedModel: v.embedModel };\n        }\n        throw new Error(`Service ${key} has no model or embedModel`);\n      });\n  }\n\n  /**\n   * If a model key is provided, delegate to the corresponding service's features.\n   * Otherwise, returns a default feature set.\n   */\n  getFeatures(model?: TModelKey): AxAIFeatures {\n    if (model) {\n      const service = this.services.get(model);\n      if (service) {\n        return service.service.getFeatures(model);\n      }\n    }\n    return {\n      functions: false,\n      streaming: false,\n      media: {\n        images: {\n          supported: false,\n          formats: [],\n        },\n        audio: {\n          supported: false,\n          formats: [],\n        },\n        files: {\n          supported: false,\n          formats: [],\n          uploadMethod: 'none' as const,\n        },\n        urls: {\n          supported: false,\n          webSearch: false,\n          contextFetching: false,\n        },\n      },\n      caching: {\n        supported: false,\n        types: [],\n      },\n      thinking: false,\n      multiTurn: true,\n    };\n  }\n\n  /**\n   * Returns aggregated metrics from the underlying service.\n   * Uses the metrics from the last service that was used,\n   * or falls back to the first service if none has been used.\n   */\n  getMetrics(): AxAIServiceMetrics {\n    let serviceInstance = this.lastUsedService;\n    if (!serviceInstance) {\n      const firstServiceEntry = this.services.values().next().value;\n      if (firstServiceEntry) {\n        // Check if it's the service directly or the wrapped object\n        serviceInstance =\n          'service' in firstServiceEntry\n            ? firstServiceEntry.service\n            : firstServiceEntry;\n      }\n    }\n\n    if (!serviceInstance) {\n      throw new Error('No service available to get metrics.');\n    }\n    return serviceInstance.getMetrics();\n  }\n\n  /**\n   * Sets options on all underlying services.\n   */\n  setOptions(options: Readonly<AxAIServiceOptions>): void {\n    for (const service of this.services.values()) {\n      service.service.setOptions(options);\n    }\n    this.options = options;\n  }\n\n  /**\n   * Returns the options from the last used service,\n   * or falls back to the first service if none has been used.\n   */\n  getOptions(): Readonly<AxAIServiceOptions> {\n    return this.options ?? {};\n  }\n\n  /**\n   * Returns the logger from the last used service,\n   * or falls back to the first service if none has been used.\n   */\n  getLogger(): AxLoggerFunction {\n    let serviceInstance = this.lastUsedService;\n    if (!serviceInstance) {\n      const firstServiceEntry = this.services.values().next().value;\n      if (firstServiceEntry) {\n        serviceInstance = firstServiceEntry.service;\n      }\n    }\n\n    if (!serviceInstance) {\n      throw new Error('No service available to get logger.');\n    }\n    return serviceInstance.getLogger();\n  }\n\n  /**\n   * Sets a service entry for a given key. This method is intended for testing purposes.\n   * @param key - The model key\n   * @param entry - The service entry to set\n   */\n  setServiceEntry(\n    key: TModelKey,\n    entry: {\n      isInternal?: boolean;\n      description: string;\n      model?: string;\n      embedModel?: string;\n      service: AxAIService<unknown, unknown, TModelKey>;\n    }\n  ): void {\n    this.services.set(key, entry);\n  }\n}\n","import {\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport { type AxAIOpenAIArgs, AxAIOpenAIBase } from '../openai/api.js';\nimport type { AxAIOpenAIConfig } from '../openai/chat_types.js';\n\n/**\n * Configuration type for Ollama AI service\n */\nexport type AxAIOllamaAIConfig = AxAIOpenAIConfig<string, string>;\n\n/**\n * Creates default configuration for Ollama AI service\n * @returns Default configuration object with nous-hermes2 model and all-minilm embed model\n */\nexport const axAIOllamaDefaultConfig = (): AxAIOllamaAIConfig =>\n  structuredClone({\n    ...axBaseAIDefaultConfig(),\n    model: 'nous-hermes2',\n    embedModel: 'all-minilm',\n  });\n\n/**\n * Creates default creative configuration for Ollama AI service\n * @returns Creative configuration object with nous-hermes2 model and all-minilm embed model\n */\nexport const axAIOllamaDefaultCreativeConfig = (): AxAIOllamaAIConfig =>\n  structuredClone({\n    ...axBaseAIDefaultCreativeConfig(),\n    model: 'nous-hermes2',\n    embedModel: 'all-minilm',\n  });\n\n/**\n * Arguments type for initializing Ollama AI service\n * @template TModelKey - Type for model key\n */\nexport type AxAIOllamaArgs<TModelKey> = AxAIOpenAIArgs<\n  'ollama',\n  string,\n  string,\n  TModelKey\n> & {\n  model?: string;\n  embedModel?: string;\n  url?: string;\n};\n\n/**\n * Ollama AI service implementation that extends OpenAI base functionality\n * Provides access to locally hosted Ollama models with OpenAI-compatible API\n * @template TModelKey - Type for model key\n */\nexport class AxAIOllama<TModelKey> extends AxAIOpenAIBase<\n  string,\n  string,\n  TModelKey\n> {\n  /**\n   * Creates a new Ollama AI service instance\n   * @param args - Configuration arguments for the Ollama service\n   * @param args.apiKey - API key for authentication (defaults to 'not-set')\n   * @param args.url - Base URL for the Ollama API (defaults to 'http://localhost:11434/v1')\n   * @param args.config - Additional configuration options\n   * @param args.options - Service options\n   * @param args.models - Available models configuration\n   */\n  constructor({\n    apiKey = 'not-set',\n    url = 'http://localhost:11434/v1',\n    config,\n    options,\n    models,\n  }: Readonly<Omit<AxAIOllamaArgs<TModelKey>, 'name'>>) {\n    const Config = {\n      ...axAIOllamaDefaultConfig(),\n      ...config,\n    };\n    super({\n      apiKey,\n      options,\n      config: Config,\n      apiURL: url,\n      models,\n      modelInfo: [],\n      supportFor: {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: false,\n        hasShowThoughts: false,\n        media: {\n          images: {\n            supported: false,\n            formats: [],\n          },\n          audio: {\n            supported: false,\n            formats: [],\n          },\n          files: {\n            supported: false,\n            formats: [],\n            uploadMethod: 'none' as const,\n          },\n          urls: {\n            supported: false,\n            webSearch: false,\n            contextFetching: false,\n          },\n        },\n        caching: {\n          supported: false,\n          types: [],\n        },\n        thinking: false,\n        multiTurn: true,\n      },\n    });\n\n    super.setName('Ollama');\n  }\n}\n","import type {\n  AxAIOpenAIEmbedRequest,\n  AxAIOpenAIEmbedResponse,\n  AxAPI,\n} from '@ax-llm/ax/index.js';\nimport { AxAIRefusalError } from '../../util/apicall.js';\nimport type {\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxInternalChatRequest,\n  AxInternalEmbedRequest,\n  AxModelConfig,\n  AxTokenUsage,\n} from '../types.js';\nimport type {\n  AxAIOpenAIResponsesCodeInterpreterToolCall,\n  AxAIOpenAIResponsesComputerToolCall,\n  AxAIOpenAIResponsesConfig,\n  AxAIOpenAIResponsesDefineFunctionTool,\n  AxAIOpenAIResponsesFileSearchToolCall,\n  AxAIOpenAIResponsesImageGenerationToolCall,\n  AxAIOpenAIResponsesInputContentPart,\n  AxAIOpenAIResponsesInputItem,\n  AxAIOpenAIResponsesInputMessageItem,\n  AxAIOpenAIResponsesLocalShellToolCall,\n  AxAIOpenAIResponsesMCPToolCall,\n  AxAIOpenAIResponsesOutputRefusalContentPart,\n  AxAIOpenAIResponsesOutputTextContentPart,\n  AxAIOpenAIResponsesRequest,\n  AxAIOpenAIResponsesResponse,\n  AxAIOpenAIResponsesResponseDelta,\n  AxAIOpenAIResponsesStreamEvent,\n  AxAIOpenAIResponsesToolDefinition,\n  AxAIOpenAIResponsesWebSearchToolCall,\n  Mutable,\n  RequestFunctionDefinition,\n  ResponsesReqUpdater,\n  UserMessageContentItem,\n} from './responses_types.js';\nimport { AxAIOpenAIResponsesModel } from './responses_types.js';\n\n/**\n * Checks if the given OpenAI Responses model is a thinking/reasoning model.\n * Thinking models (o1, o3, o4 series) have different parameter restrictions.\n */\nexport const isOpenAIResponsesThinkingModel = (model: string): boolean => {\n  const thinkingModels = [\n    AxAIOpenAIResponsesModel.O1,\n    AxAIOpenAIResponsesModel.O1Mini,\n    AxAIOpenAIResponsesModel.O1Pro,\n    AxAIOpenAIResponsesModel.O3,\n    AxAIOpenAIResponsesModel.O3Mini,\n    AxAIOpenAIResponsesModel.O3Pro,\n    AxAIOpenAIResponsesModel.O4Mini,\n  ];\n  return thinkingModels.includes(model as AxAIOpenAIResponsesModel);\n};\n\nexport class AxAIOpenAIResponsesImpl<\n  TModel,\n  TEmbedModel, // Kept for interface compatibility, but not used by this impl.\n  TResponsesReq extends AxAIOpenAIResponsesRequest<TModel>,\n> implements\n    AxAIServiceImpl<\n      TModel,\n      TEmbedModel,\n      Readonly<AxAIOpenAIResponsesRequest<TModel>>, // ChatReq (now ResponsesReq)\n      Readonly<AxAIOpenAIEmbedRequest<TEmbedModel>>, // EmbedReq\n      Readonly<AxAIOpenAIResponsesResponse>, // ChatResp (now ResponsesResp)\n      Readonly<AxAIOpenAIResponsesResponseDelta>, // ChatRespDelta (now ResponsesRespDelta)\n      Readonly<AxAIOpenAIEmbedResponse> // EmbedResp\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n\n  constructor(\n    private readonly config: Readonly<\n      AxAIOpenAIResponsesConfig<TModel, TEmbedModel>\n    >,\n    private readonly streamingUsage: boolean, // If /v1/responses supports include_usage for streams\n    private readonly responsesReqUpdater?: ResponsesReqUpdater<\n      TModel,\n      TResponsesReq\n    >\n  ) {}\n\n  getTokenUsage(): Readonly<AxTokenUsage> | undefined {\n    return this.tokensUsed;\n  }\n\n  getModelConfig(): Readonly<AxModelConfig> {\n    const { config } = this;\n    return {\n      maxTokens: config.maxTokens, // maps to max_output_tokens\n      temperature: config.temperature,\n      // presencePenalty, frequencyPenalty are not direct params in /v1/responses\n      stopSequences: config.stopSequences, // /v1/responses uses 'truncation' or relies on item structure\n      topP: config.topP,\n      // n: config.n, // Not a direct parameter in /v1/responses\n      stream: config.stream,\n    };\n  }\n\n  private mapInternalContentToResponsesInput(\n    content: ReadonlyArray<UserMessageContentItem>, // Expects an array of content items, string case handled by caller\n    role: 'user' | 'assistant'\n  ): ReadonlyArray<AxAIOpenAIResponsesInputContentPart> {\n    const mappedParts: Mutable<AxAIOpenAIResponsesInputContentPart>[] = [];\n\n    for (const part of content) {\n      if (part.type === 'text') {\n        if (role === 'assistant') {\n          mappedParts.push({\n            type: 'output_text',\n            text: part.text,\n          } as unknown as AxAIOpenAIResponsesInputContentPart);\n        } else {\n          mappedParts.push({ type: 'input_text', text: part.text });\n        }\n        continue;\n      }\n\n      if (role === 'assistant') {\n        // Assistant message content in input must be output types only. Skip non-text parts.\n        continue;\n      }\n\n      if (part.type === 'image') {\n        const url = `data:${part.mimeType};base64,${part.image}`;\n        mappedParts.push({\n          type: 'input_image',\n          image_url: { url, details: part.details ?? 'auto' },\n        } as const);\n        continue;\n      }\n      if (part.type === 'audio') {\n        mappedParts.push({\n          type: 'input_audio',\n          input_audio: {\n            data: part.data,\n            format: part.format === 'wav' ? 'wav' : undefined,\n          },\n        } as const);\n        continue;\n      }\n\n      const ExhaustiveCheck: never = part;\n      throw new Error(\n        `Unsupported content part: ${JSON.stringify(ExhaustiveCheck)}`\n      );\n    }\n\n    return mappedParts as ReadonlyArray<AxAIOpenAIResponsesInputContentPart>;\n  }\n\n  private createResponsesReqInternalInput(\n    chatPrompt: ReadonlyArray<AxChatRequest<TModel>['chatPrompt'][number]>,\n    excludeSystemMessages = false // New parameter\n  ): ReadonlyArray<AxAIOpenAIResponsesInputItem> {\n    // Map from AxChatPromptItemType roles to AxAIOpenAI /v1/responses API roles:\n    // - 'system' -> 'system' (may be skipped if excludeSystemMessages is true)\n    // - 'user' -> 'user'\n    // - 'assistant' -> 'assistant'\n    // - 'function' -> Special handling for function call outputs (different structure)\n    //\n    // Note: AxAIOpenAI's /v1/responses API also supports a 'developer' role that isn't\n    // currently mapped from our AxChatPromptItemType structure.\n\n    const items: Mutable<AxAIOpenAIResponsesInputItem>[] = [];\n    for (const msg of chatPrompt) {\n      if (excludeSystemMessages && msg.role === 'system') {\n        continue; // Skip system messages if they are handled by top-level 'instructions'\n      }\n\n      let mappedContent:\n        | string\n        | ReadonlyArray<AxAIOpenAIResponsesInputContentPart>;\n      // Type guard for content based on role\n      if (\n        msg.role === 'system' ||\n        msg.role === 'user' ||\n        (msg.role === 'assistant' && msg.content)\n      ) {\n        if (typeof msg.content === 'string') {\n          if (msg.role === 'system') {\n            mappedContent = msg.content;\n          } else if (msg.role === 'assistant') {\n            mappedContent = [\n              { type: 'output_text', text: msg.content },\n            ] as ReadonlyArray<AxAIOpenAIResponsesInputContentPart>;\n          } else {\n            mappedContent = [\n              { type: 'input_text', text: msg.content },\n            ] as ReadonlyArray<AxAIOpenAIResponsesInputContentPart>;\n          }\n        } else if (Array.isArray(msg.content)) {\n          mappedContent = this.mapInternalContentToResponsesInput(\n            msg.content as ReadonlyArray<UserMessageContentItem>,\n            msg.role === 'assistant' ? 'assistant' : 'user'\n          );\n        } else {\n          // Handle cases where content might be undefined for assistant, or unexpected type\n          if (msg.role === 'assistant' && !msg.content && msg.functionCalls) {\n            // This is fine, assistant message can be just functionCalls\n          } else {\n            throw new Error(`Invalid content type for role ${msg.role}`);\n          }\n          mappedContent = ''; // Default or skip\n        }\n      } else if (msg.role === 'function') {\n        // Function role does not have 'content' in the same way, it has 'result'\n        mappedContent = ''; // Placeholder, not directly used for content field in function_call_output\n      } else {\n        mappedContent = ''; // Default for roles that might not have content or are handled differently\n      }\n\n      switch (msg.role) {\n        case 'system': // Will be skipped if excludeSystemMessages is true\n          items.push({\n            type: 'message',\n            role: 'system',\n            content: mappedContent as string,\n          });\n          break;\n        case 'user':\n          items.push({\n            type: 'message',\n            role: 'user',\n            content: mappedContent,\n            name: msg.name,\n          });\n          break;\n        case 'assistant':\n          if (msg.content || msg.functionCalls) {\n            // Assistant can have content, functionCalls, or both\n            const assistantMessage: Mutable<AxAIOpenAIResponsesInputMessageItem> =\n              {\n                type: 'message',\n                role: 'assistant',\n                content: '',\n              }; // Start with empty content\n            if (msg.content) {\n              assistantMessage.content = mappedContent;\n            }\n            if (msg.name) {\n              assistantMessage.name = msg.name;\n            }\n            // If only function calls, content might remain empty or not be applicable in the same way for AxAIOpenAI item\n            // AxAIOpenAI /v1/responses expects assistant messages with tool calls to be structured carefully.\n            // For now, pushing the textual content if present. Tool calls are separate items.\n            if (msg.content)\n              items.push(\n                assistantMessage as AxAIOpenAIResponsesInputMessageItem\n              );\n\n            if (msg.functionCalls) {\n              for (const call of msg.functionCalls) {\n                items.push({\n                  type: 'function_call',\n                  call_id: call.id,\n                  name: call.function.name,\n                  arguments:\n                    typeof call.function.params === 'object'\n                      ? JSON.stringify(call.function.params)\n                      : call.function.params || '',\n                });\n              }\n            }\n          }\n          break;\n        case 'function': // This is a tool result\n          items.push({\n            type: 'function_call_output',\n            call_id: msg.functionId!,\n            output: msg.result!,\n          });\n          break;\n        default: {\n          // Fix for any type\n          const invalidRole = (msg as { role: string }).role;\n          throw new Error(`Invalid role in chat prompt: ${invalidRole}`);\n        }\n      }\n    }\n    return items as ReadonlyArray<AxAIOpenAIResponsesInputItem>;\n  }\n\n  createChatReq(\n    req: Readonly<AxInternalChatRequest<TModel>>,\n    config: Readonly<AxAIServiceOptions>\n  ): [Readonly<AxAPI>, Readonly<AxAIOpenAIResponsesRequest<TModel>>] {\n    const model = req.model;\n    const apiConfig: Readonly<AxAPI> = { name: '/responses' };\n\n    let instructionsFromPrompt: string | null = null;\n    let systemMessageFoundAndUsed = false;\n    if (req.chatPrompt) {\n      for (const item of req.chatPrompt) {\n        if (item.role === 'system' && typeof item.content === 'string') {\n          instructionsFromPrompt = item.content;\n          systemMessageFoundAndUsed = true;\n          break;\n        }\n      }\n    }\n\n    const finalInstructions =\n      instructionsFromPrompt ?? this.config.systemPrompt ?? null;\n\n    const tools: ReadonlyArray<AxAIOpenAIResponsesToolDefinition> | undefined =\n      req.functions?.map(\n        (\n          v: Readonly<RequestFunctionDefinition>\n        ): AxAIOpenAIResponsesDefineFunctionTool => ({\n          type: 'function' as const,\n          name: v.name,\n          description: v.description,\n          parameters: v.parameters ?? {},\n        })\n      );\n\n    // Set include field based on showThoughts option, but override if thinkingTokenBudget is 'none'\n    const includeFields: // | 'file_search_call.results'\n    'message.input_image.image_url'[] =\n      // | 'computer_call_output.output.image_url'\n      // | 'reasoning.encrypted_content'\n      // | 'code_interpreter_call.outputs'\n      [];\n\n    const isThinkingModel = isOpenAIResponsesThinkingModel(model as string);\n\n    let reasoningSummary = this.config.reasoningSummary;\n\n    if (!config?.showThoughts) {\n      reasoningSummary = undefined;\n    } else if (!reasoningSummary) {\n      reasoningSummary = 'auto';\n    }\n\n    let reasoningEffort = this.config.reasoningEffort;\n\n    // Handle thinkingTokenBudget config parameter\n    if (config?.thinkingTokenBudget) {\n      switch (config.thinkingTokenBudget) {\n        case 'none':\n          reasoningEffort = undefined;\n          break;\n        case 'minimal':\n          reasoningEffort = 'minimal';\n          break;\n        case 'low':\n          reasoningEffort = 'medium';\n          break;\n        case 'medium':\n        case 'high':\n        case 'highest':\n          reasoningEffort = 'high';\n          break;\n      }\n    }\n\n    const mutableReq: Mutable<AxAIOpenAIResponsesRequest<TModel>> = {\n      model,\n      input: '', // Will be set below\n      instructions: finalInstructions,\n      tools: tools?.length ? tools : undefined,\n      tool_choice:\n        req.functionCall === 'none' ||\n        req.functionCall === 'auto' ||\n        req.functionCall === 'required'\n          ? req.functionCall\n          : typeof req.functionCall === 'object' && req.functionCall.function\n            ? { type: 'function', name: req.functionCall.function.name }\n            : undefined,\n      // For thinking models, don't set these parameters as they're not supported\n      ...(isThinkingModel\n        ? {\n            max_output_tokens:\n              req.modelConfig?.maxTokens ?? this.config.maxTokens ?? undefined,\n          }\n        : {\n            ...(req.modelConfig?.temperature !== undefined\n              ? { temperature: req.modelConfig.temperature }\n              : {}),\n            ...(req.modelConfig?.topP !== undefined\n              ? { top_p: req.modelConfig.topP }\n              : {}),\n            presence_penalty:\n              req.modelConfig?.presencePenalty ??\n              this.config.presencePenalty ??\n              undefined,\n            frequency_penalty:\n              req.modelConfig?.frequencyPenalty ??\n              this.config.frequencyPenalty ??\n              undefined,\n            max_output_tokens:\n              req.modelConfig?.maxTokens ?? this.config.maxTokens ?? undefined,\n          }),\n      stream: req.modelConfig?.stream ?? this.config.stream ?? false, // Sourced from modelConfig or global config\n      // Optional fields from AxAIOpenAIResponsesRequest that need to be in Mutable for initialization\n      background: undefined,\n      include: includeFields.length > 0 ? includeFields : undefined,\n      metadata: undefined,\n      parallel_tool_calls: this.config.parallelToolCalls,\n      previous_response_id: undefined,\n      ...(reasoningEffort\n        ? {\n            reasoning: {\n              effort: reasoningEffort,\n              summary: reasoningSummary,\n            },\n          }\n        : {}),\n      service_tier: this.config.serviceTier,\n      store: this.config.store,\n      text: undefined,\n      truncation: undefined,\n      user: this.config.user,\n      seed: this.config.seed,\n    };\n\n    // Populate from this.config if properties exist on AxAIOpenAIConfig\n    if (this.config.user) mutableReq.user = this.config.user;\n    if (this.config.parallelToolCalls !== undefined)\n      mutableReq.parallel_tool_calls = this.config.parallelToolCalls;\n    if (this.config.responseFormat)\n      mutableReq.text = {\n        format: {\n          type: this.config.responseFormat as\n            | 'text'\n            | 'json_object'\n            | 'json_schema',\n        },\n      };\n    if (this.config.seed) mutableReq.seed = this.config.seed;\n    // TODO: Check AxAIOpenAIConfig for other fields like store, background, include, metadata, service_tier, truncation\n\n    const inputItems = req.chatPrompt\n      ? this.createResponsesReqInternalInput(\n          req.chatPrompt,\n          systemMessageFoundAndUsed\n        )\n      : [];\n\n    if (inputItems.length > 0) {\n      mutableReq.input = inputItems;\n    } else if (\n      req.chatPrompt &&\n      req.chatPrompt.length === 1 &&\n      req.chatPrompt[0]?.role === 'user' &&\n      req.chatPrompt[0]?.content &&\n      typeof req.chatPrompt[0].content === 'string' &&\n      !finalInstructions\n    ) {\n      // Fallback to simple string input if only one user message and no instructions\n      mutableReq.input = req.chatPrompt[0].content;\n    } else if (inputItems.length === 0 && !finalInstructions) {\n      throw new Error('Responses API request must have input or instructions.');\n    }\n\n    let currentReasoning = mutableReq.reasoning ?? {};\n    if (this.config.reasoningEffort) {\n      currentReasoning = {\n        ...currentReasoning,\n        effort: this.config.reasoningEffort,\n      };\n    }\n\n    // Handle thinkingTokenBudget config parameter\n    if (config?.thinkingTokenBudget) {\n      switch (config.thinkingTokenBudget) {\n        case 'none':\n          // When thinkingTokenBudget is 'none', remove reasoning entirely\n          currentReasoning = {};\n          break;\n        case 'minimal':\n          currentReasoning = {\n            ...currentReasoning,\n            effort: 'minimal',\n          };\n          break;\n        case 'low':\n          currentReasoning = {\n            ...currentReasoning,\n            effort: 'medium',\n          };\n          break;\n        case 'medium':\n        case 'high':\n        case 'highest':\n          currentReasoning = {\n            ...currentReasoning,\n            effort: 'high',\n          };\n          break;\n      }\n    }\n\n    if (Object.keys(currentReasoning).length > 0 && currentReasoning.effort) {\n      mutableReq.reasoning = currentReasoning;\n    } else {\n      mutableReq.reasoning = undefined; // Ensure reasoning is not sent if empty or only has non-effort keys by mistake\n    }\n\n    let finalReqToProcess: Readonly<AxAIOpenAIResponsesRequest<TModel>> =\n      mutableReq as Readonly<AxAIOpenAIResponsesRequest<TModel>>;\n\n    if (this.responsesReqUpdater) {\n      finalReqToProcess = this.responsesReqUpdater(\n        finalReqToProcess as Readonly<TResponsesReq>\n      );\n    }\n\n    return [apiConfig, finalReqToProcess];\n  }\n\n  // Create Chat Response from /v1/responses (non-streaming)\n  createChatResp(\n    resp: Readonly<AxAIOpenAIResponsesResponse>\n  ): Readonly<AxChatResponse> {\n    const { id, output, usage } = resp;\n\n    if (usage) {\n      this.tokensUsed = {\n        promptTokens: usage.prompt_tokens,\n        completionTokens: usage.completion_tokens ?? usage.output_tokens ?? 0,\n        totalTokens: usage.total_tokens,\n      };\n    }\n\n    const currentResult: Partial<AxChatResponseResult> = {};\n\n    for (const item of output ?? []) {\n      switch (item.type) {\n        case 'message':\n          currentResult.id = item.id;\n          currentResult.content = contentToText(item.content, id);\n          currentResult.finishReason =\n            item.status === 'completed' ? 'stop' : 'content_filter';\n          // Extract annotations from output_text parts\n          currentResult.citations = extractAnnotationsFromContent(item.content);\n          break;\n\n        case 'reasoning':\n          currentResult.id = item.id;\n          // Use encrypted_content if available (when showThoughts is enabled), otherwise use summary\n          if (item.encrypted_content) {\n            currentResult.thought = item.encrypted_content;\n          } else {\n            currentResult.thought = item.summary\n              .map((s: string | object) =>\n                typeof s === 'object' ? JSON.stringify(s) : s\n              )\n              .join('\\n');\n          }\n          break;\n\n        case 'file_search_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: 'file_search',\n                params: {\n                  queries: item.queries,\n                  results: item.results,\n                },\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n        case 'web_search_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: 'web_search',\n                params: {\n                  queries: item.queries,\n                },\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n        case 'computer_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: 'computer_use',\n                params: {\n                  action: item.action,\n                },\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n        case 'code_interpreter_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: 'code_interpreter',\n                params: {\n                  code: item.code,\n                  results: item.results,\n                },\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n        case 'image_generation_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: 'image_generation',\n                params: {\n                  result: item.result,\n                },\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n        case 'local_shell_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: 'local_shell',\n                params: {\n                  action: item.action,\n                },\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n        case 'mcp_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: 'mcp',\n                params: {\n                  name: item.name,\n                  args: item.args,\n                  serverLabel: item.server_label,\n                  output: item.output,\n                  error: item.error,\n                },\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n        case 'function_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: item.name,\n                params: item.arguments,\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n      }\n    }\n\n    return {\n      results: [{ ...currentResult, index: 0 }],\n      remoteId: id,\n    };\n  }\n\n  // Create Chat Stream Response from /v1/responses stream events\n  createChatStreamResp(\n    streamEvent: Readonly<AxAIOpenAIResponsesResponseDelta>\n  ): Readonly<AxChatResponse> {\n    // Handle new streaming event format\n    const event = streamEvent as AxAIOpenAIResponsesStreamEvent;\n\n    // Create a basic result structure\n    const baseResult: AxChatResponseResult = {\n      index: 0,\n      id: '',\n      content: '',\n      finishReason: 'stop',\n    };\n\n    let remoteId: string | undefined;\n\n    switch (event.type) {\n      case 'response.created':\n      case 'response.in_progress':\n      case 'response.queued':\n        // Response lifecycle events - return empty content with metadata\n        remoteId = event.response.id;\n        baseResult.id = `${event.response.id}_res_0`;\n        break;\n\n      case 'response.output_item.added':\n        // New output item added\n        switch (event.item.type) {\n          case 'message':\n            baseResult.id = event.item.id;\n            baseResult.content = contentToText(\n              event.item.content,\n              event.item.id\n            );\n            baseResult.citations = extractAnnotationsFromContent(\n              event.item.content\n            );\n            break;\n          case 'function_call':\n            baseResult.id = event.item.id;\n            baseResult.functionCalls = [\n              {\n                id: event.item.id,\n                type: 'function' as const,\n                function: {\n                  name: event.item.name,\n                  params: event.item.arguments,\n                },\n              },\n            ];\n            break;\n          case 'file_search_call':\n            {\n              const fileSearchItem =\n                event.item as AxAIOpenAIResponsesFileSearchToolCall;\n              baseResult.id = event.item.id;\n              baseResult.functionCalls = [\n                {\n                  id: fileSearchItem.id,\n                  type: 'function' as const,\n                  function: {\n                    name: 'file_search',\n                    params: {\n                      queries: fileSearchItem.queries || [],\n                      results: fileSearchItem.results?.map((r) => ({\n                        fileId: r.file_id,\n                        filename: r.filename,\n                        score: r.score,\n                        text: r.text,\n                        attributes: r.attributes,\n                      })),\n                    },\n                  },\n                },\n              ];\n            }\n            break;\n          case 'web_search_call':\n            {\n              const webSearchItem =\n                event.item as AxAIOpenAIResponsesWebSearchToolCall;\n              baseResult.id = event.item.id;\n              baseResult.functionCalls = [\n                {\n                  id: webSearchItem.id,\n                  type: 'function' as const,\n                  function: {\n                    name: 'web_search',\n                    params: {\n                      queries: webSearchItem.queries || [],\n                    },\n                  },\n                },\n              ];\n            }\n            break;\n          case 'computer_call':\n            {\n              const computerItem =\n                event.item as AxAIOpenAIResponsesComputerToolCall;\n              baseResult.id = event.item.id;\n              baseResult.functionCalls = [\n                {\n                  id: computerItem.id,\n                  type: 'function' as const,\n                  function: {\n                    name: 'computer_use',\n                    params: {\n                      action: computerItem.action || {},\n                    },\n                  },\n                },\n              ];\n            }\n            break;\n          case 'code_interpreter_call':\n            {\n              const codeItem =\n                event.item as AxAIOpenAIResponsesCodeInterpreterToolCall;\n              baseResult.id = event.item.id;\n              baseResult.functionCalls = [\n                {\n                  id: codeItem.id,\n                  type: 'function' as const,\n                  function: {\n                    name: 'code_interpreter',\n                    params: {\n                      code: codeItem.code || '',\n                      results: codeItem.results,\n                    },\n                  },\n                },\n              ];\n            }\n            break;\n          case 'image_generation_call':\n            {\n              const imageItem =\n                event.item as AxAIOpenAIResponsesImageGenerationToolCall;\n              baseResult.id = event.item.id;\n              baseResult.functionCalls = [\n                {\n                  id: imageItem.id,\n                  type: 'function' as const,\n                  function: {\n                    name: 'image_generation',\n                    params: {\n                      result: imageItem.result,\n                    },\n                  },\n                },\n              ];\n            }\n            break;\n          case 'local_shell_call':\n            {\n              const shellItem =\n                event.item as AxAIOpenAIResponsesLocalShellToolCall;\n              baseResult.id = event.item.id;\n              baseResult.functionCalls = [\n                {\n                  id: shellItem.id,\n                  type: 'function' as const,\n                  function: {\n                    name: 'local_shell',\n                    params: {\n                      action: shellItem.action || {},\n                    },\n                  },\n                },\n              ];\n            }\n            break;\n          case 'mcp_call':\n            {\n              const mcpItem = event.item as AxAIOpenAIResponsesMCPToolCall;\n              baseResult.id = event.item.id;\n              baseResult.functionCalls = [\n                {\n                  id: mcpItem.id,\n                  type: 'function' as const,\n                  function: {\n                    name: 'mcp',\n                    params: {\n                      name: mcpItem.name || '',\n                      args: mcpItem.args || '',\n                      serverLabel: mcpItem.server_label || '',\n                      output: mcpItem.output,\n                      error: mcpItem.error,\n                    },\n                  },\n                },\n              ];\n            }\n            break;\n          // case 'reasoning':\n          //     {\n          //         const reasoningItem =\n          //             event.item as AxAIOpenAIResponsesReasoningItem\n          //         baseResult.id = event.item.id\n          //         // Use encrypted_content if available (when showThoughts is enabled), otherwise use summary\n          //         if (reasoningItem.encrypted_content) {\n          //             baseResult.thought = reasoningItem.encrypted_content\n          //         } else if (reasoningItem.summary) {\n          //             baseResult.thought = reasoningItem.summary\n          //                 .map((s: string | object) =>\n          //                     typeof s === 'object' ? JSON.stringify(s) : s\n          //                 )\n          //                 .join('\\n')\n          //         }\n          //     }\n          //     break\n        }\n        break;\n\n      case 'response.content_part.added':\n        // Content part added - return the initial text if any\n        baseResult.id = event.item_id;\n        baseResult.content = contentToText([event.part], event.item_id);\n        baseResult.citations = extractAnnotationsFromContent([\n          event.part as any,\n        ]);\n        break;\n\n      case 'response.output_text.delta':\n        // Text delta - return just the delta content\n        baseResult.id = event.item_id;\n        baseResult.content = event.delta;\n        break;\n\n      case 'response.output_text.done':\n        break;\n\n      case 'response.function_call_arguments.delta':\n        // Function call arguments delta - return delta with empty name\n        baseResult.id = event.item_id;\n        baseResult.functionCalls = [\n          {\n            id: event.item_id,\n            type: 'function' as const,\n            function: {\n              name: '',\n              params: event.delta,\n            },\n          },\n        ];\n        break;\n\n      // case 'response.function_call_arguments.done':\n      //     // Function call arguments done - don't return function calls here\n      //     // The mergeFunctionCalls will handle combining name and arguments\n      //     baseResult.id = event.item_id\n      //     baseResult.finishReason = 'function_call'\n      //     break\n\n      case 'response.reasoning_summary_text.delta':\n        // Reasoning summary delta\n        baseResult.id = event.item_id;\n        baseResult.thought = event.delta;\n        break;\n\n      // case 'response.reasoning_summary_text.done':\n      //     // Reasoning summary done\n      //     baseResult.id = event.item_id\n      //     baseResult.thought = event.text\n      //     break\n\n      // File search tool events\n      case 'response.file_search_call.in_progress':\n      case 'response.file_search_call.searching':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        break;\n\n      case 'response.file_search_call.completed':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        break;\n\n      // Web search tool events\n      case 'response.web_search_call.in_progress':\n      case 'response.web_search_call.searching':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        break;\n\n      case 'response.web_search_call.completed':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        break;\n\n      // Image generation tool events\n      case 'response.image_generation_call.in_progress':\n      case 'response.image_generation_call.generating':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        break;\n\n      case 'response.image_generation_call.completed':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        break;\n\n      case 'response.image_generation_call.partial_image':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        // Could potentially add partial image data to content or a special field\n        break;\n\n      // MCP tool events\n      case 'response.mcp_call.in_progress':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        break;\n\n      case 'response.mcp_call.arguments.delta':\n        baseResult.id = event.item_id;\n        baseResult.functionCalls = [\n          {\n            id: event.item_id,\n            type: 'function' as const,\n            function: {\n              name: '',\n              params: event.delta,\n            },\n          },\n        ];\n        break;\n\n      case 'response.mcp_call.arguments.done':\n        baseResult.id = event.item_id;\n        baseResult.functionCalls = [\n          {\n            id: event.item_id,\n            type: 'function' as const,\n            function: {\n              name: '',\n              params: event.arguments,\n            },\n          },\n        ];\n        break;\n\n      case 'response.mcp_call.completed':\n      case 'response.mcp_call.failed':\n        // These events don't have item_id, use a generic ID\n        baseResult.id = 'mcp_call_event';\n        baseResult.finishReason = 'function_call';\n        break;\n\n      case 'response.mcp_list_tools.in_progress':\n      case 'response.mcp_list_tools.completed':\n      case 'response.mcp_list_tools.failed':\n        // MCP list tools events don't have item_id\n        baseResult.id = 'mcp_list_tools_event';\n        baseResult.finishReason = 'function_call';\n        break;\n\n      case 'response.output_item.done':\n        // Item completion\n\n        switch (event.item.type) {\n          case 'message':\n            baseResult.id = event.item.id;\n            baseResult.finishReason =\n              event.item.status === 'completed' ? 'stop' : 'error';\n            if (!baseResult.citations || baseResult.citations.length === 0) {\n              const anns = extractAnnotationsFromContent(\n                event.item.content || []\n              );\n              if (anns) baseResult.citations = anns;\n            }\n            break;\n          case 'function_call':\n          case 'file_search_call':\n          case 'web_search_call':\n          case 'computer_call':\n          case 'code_interpreter_call':\n          case 'image_generation_call':\n          case 'local_shell_call':\n          case 'mcp_call':\n            // Tool calls completed - finishReason indicates function execution needed\n            baseResult.id = event.item.id;\n            baseResult.finishReason = 'function_call';\n            break;\n          // case 'reasoning':\n          //     // Reasoning completed\n          //     baseResult.id = event.item.id\n          //     break\n        }\n        break;\n\n      case 'response.completed':\n        // Response completion - handle usage\n        if (event.response.usage) {\n          this.tokensUsed = {\n            promptTokens: event.response.usage.prompt_tokens,\n            completionTokens:\n              event.response.usage.completion_tokens ??\n              event.response.usage.output_tokens ??\n              0,\n            totalTokens: event.response.usage.total_tokens,\n          };\n        }\n        remoteId = event.response.id;\n        baseResult.id = `${event.response.id}_completed`;\n        baseResult.finishReason = 'stop';\n        break;\n\n      case 'response.failed':\n        // Response failure\n        remoteId = event.response.id;\n        baseResult.id = `${event.response.id}_failed`;\n        baseResult.finishReason = 'error';\n        break;\n\n      case 'response.incomplete':\n        // Response incomplete\n        remoteId = event.response.id;\n        baseResult.id = `${event.response.id}_incomplete`;\n        baseResult.finishReason = 'length';\n        break;\n\n      case 'error':\n        // Error event\n        baseResult.id = 'error';\n        baseResult.content = `Error: ${event.message}`;\n        baseResult.finishReason = 'error';\n        break;\n\n      default:\n        // For unhandled events, return empty result\n        baseResult.id = 'unknown';\n        break;\n    }\n\n    return {\n      results: [baseResult],\n      remoteId,\n    } as Readonly<AxChatResponse>;\n  }\n\n  createEmbedReq(\n    req: Readonly<AxInternalEmbedRequest<TEmbedModel>>\n  ): [AxAPI, AxAIOpenAIEmbedRequest<TEmbedModel>] {\n    const model = req.embedModel;\n\n    if (!model) {\n      throw new Error('Embed model not set');\n    }\n\n    if (!req.texts || req.texts.length === 0) {\n      throw new Error('Embed texts is empty');\n    }\n\n    const apiConfig = {\n      name: '/embeddings',\n    };\n\n    const reqValue = {\n      model: model,\n      input: req.texts,\n      dimensions: this.config.dimensions,\n    };\n\n    return [apiConfig, reqValue];\n  }\n}\n\n// const getThought = (item: AxAIOpenAIResponsesReasoningItem): string => {\n//     if (item.encrypted_content) {\n//         return item.encrypted_content\n//     }\n//     return item.summary.map((s) => s.text).join('\\n')\n// }\n\nconst contentToText = (\n  content: ReadonlyArray<\n    | AxAIOpenAIResponsesOutputTextContentPart\n    | AxAIOpenAIResponsesOutputRefusalContentPart\n  >,\n  responseId?: string\n): string => {\n  // Check for refusal content and throw exception\n  const refusalContent = content.filter((c) => c.type === 'refusal');\n  if (refusalContent.length > 0) {\n    const refusalMessage = refusalContent.map((c) => c.refusal).join('\\n');\n    throw new AxAIRefusalError(refusalMessage, undefined, responseId);\n  }\n\n  // Return only text content\n  return content\n    .filter((c) => c.type === 'output_text')\n    .map((c) => c.text)\n    .join('\\n');\n};\n\n// Extract URL citations from output_text annotations into normalized citations\nfunction extractAnnotationsFromContent(\n  content: ReadonlyArray<\n    | AxAIOpenAIResponsesOutputTextContentPart\n    | AxAIOpenAIResponsesOutputRefusalContentPart\n  >\n): AxChatResponseResult['citations'] | undefined {\n  const annos: NonNullable<AxChatResponseResult['citations']> = [];\n  for (const p of content ?? []) {\n    if (\n      (p as any)?.type === 'output_text' &&\n      Array.isArray((p as any).annotations)\n    ) {\n      for (const a of (p as any).annotations) {\n        if (a && a.type === 'url_citation' && typeof a.url === 'string') {\n          annos.push({\n            url: a.url,\n            title: a.title,\n            description: a.description,\n          });\n        }\n      }\n    }\n  }\n  return annos.length ? annos : undefined;\n}\n","import type { AxAIOpenAIResponsesConfig } from '@ax-llm/ax/index.js';\nimport { getModelInfo } from '../../dsp/modelinfo.js';\nimport type { AxAIFeatures } from '../base.js';\nimport { AxBaseAI } from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIServiceOptions,\n  AxModelConfig,\n  AxModelInfo,\n} from '../types.js';\nimport type {\n  AxAIOpenAIEmbedRequest,\n  AxAIOpenAIEmbedResponse,\n} from './chat_types.js';\nimport { AxAIOpenAIEmbedModel } from './chat_types.js';\nimport { axModelInfoOpenAIResponses } from './info.js';\nimport { AxAIOpenAIResponsesImpl } from './responses_api.js';\nimport type {\n  AxAIOpenAIResponsesRequest,\n  AxAIOpenAIResponsesResponse,\n  AxAIOpenAIResponsesResponseDelta,\n} from './responses_types.js';\nimport { AxAIOpenAIResponsesModel } from './responses_types.js';\n\n// Helper functions to create default configurations\nexport const axAIOpenAIResponsesDefaultConfig = (): AxAIOpenAIResponsesConfig<\n  AxAIOpenAIResponsesModel,\n  AxAIOpenAIEmbedModel\n> => ({\n  model: AxAIOpenAIResponsesModel.GPT4O,\n  embedModel: AxAIOpenAIEmbedModel.TextEmbeddingAda002,\n  temperature: 0.7,\n  topP: 1,\n  stream: true,\n  //   reasoningEffort: 'medium',\n});\n\nexport const axAIOpenAIResponsesBestConfig = (): AxAIOpenAIResponsesConfig<\n  AxAIOpenAIResponsesModel,\n  AxAIOpenAIEmbedModel\n> => ({\n  ...axAIOpenAIResponsesDefaultConfig(),\n  model: AxAIOpenAIResponsesModel.GPT4O,\n  temperature: 0.5,\n});\n\nexport const axAIOpenAIResponsesCreativeConfig = (): AxAIOpenAIResponsesConfig<\n  AxAIOpenAIResponsesModel,\n  AxAIOpenAIEmbedModel\n> => ({\n  ...axAIOpenAIResponsesDefaultConfig(),\n  model: AxAIOpenAIResponsesModel.GPT4O,\n  temperature: 0.9,\n});\n\n// Arguments for AxAIOpenAIResponsesBase constructor\ninterface AxAIOpenAIResponsesBaseArgs<\n  TModel,\n  TEmbedModel,\n  TModelKey,\n  TResponsesReq extends AxAIOpenAIResponsesRequest<TModel>,\n> {\n  apiKey: string;\n  config: AxAIOpenAIResponsesConfig<TModel, TEmbedModel>;\n  options?: {\n    streamingUsage?: boolean;\n  } & AxAIServiceOptions;\n  apiURL?: string;\n  modelInfo?: ReadonlyArray<AxModelInfo>;\n  models?: AxAIInputModelList<TModel, TEmbedModel, TModelKey>;\n  responsesReqUpdater?: (\n    req: Readonly<TResponsesReq>\n  ) => Readonly<TResponsesReq>;\n  supportFor?: AxAIFeatures | ((model: TModel) => AxAIFeatures);\n}\n\n/**\n * Base class for OpenAI AI services using the /v1/responses API endpoint\n */\nexport class AxAIOpenAIResponsesBase<\n  TModel,\n  TEmbedModel,\n  TModelKey,\n  TResponsesReq extends AxAIOpenAIResponsesRequest<TModel>,\n> extends AxBaseAI<\n  TModel,\n  TEmbedModel,\n  AxAIOpenAIResponsesRequest<TModel>,\n  AxAIOpenAIEmbedRequest<TEmbedModel>,\n  AxAIOpenAIResponsesResponse,\n  AxAIOpenAIResponsesResponseDelta,\n  AxAIOpenAIEmbedResponse,\n  TModelKey\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    apiURL,\n    modelInfo = [],\n    models,\n    responsesReqUpdater,\n    supportFor = {\n      functions: true,\n      streaming: true,\n      media: {\n        images: {\n          supported: false,\n          formats: [],\n        },\n        audio: {\n          supported: false,\n          formats: [],\n        },\n        files: {\n          supported: false,\n          formats: [],\n          uploadMethod: 'none' as const,\n        },\n        urls: {\n          supported: false,\n          webSearch: false,\n          contextFetching: false,\n        },\n      },\n      caching: {\n        supported: false,\n        types: [],\n      },\n      thinking: false,\n      multiTurn: true,\n    },\n  }: Readonly<\n    AxAIOpenAIResponsesBaseArgs<TModel, TEmbedModel, TModelKey, TResponsesReq>\n  >) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('OpenAI API key not set');\n    }\n\n    const aiImpl = new AxAIOpenAIResponsesImpl<\n      TModel,\n      TEmbedModel,\n      TResponsesReq\n    >(config, options?.streamingUsage ?? true, responsesReqUpdater);\n\n    // Normalize per-model presets: allow provider-specific config on each model list item\n    const normalizedModels = (\n      models as AxAIInputModelList<TModel, TEmbedModel, TModelKey> | undefined\n    )?.map((item) => {\n      const anyItem = item as any;\n      const cfg = anyItem?.config as\n        | Partial<\n            AxAIOpenAIResponsesConfig<AxAIOpenAIResponsesModel, TEmbedModel>\n          >\n        | undefined;\n      if (!cfg) return item;\n\n      const modelConfig: Partial<AxModelConfig> = {};\n      if ((cfg as any).maxTokens !== undefined)\n        modelConfig.maxTokens = (cfg as any).maxTokens;\n      if ((cfg as any).temperature !== undefined)\n        modelConfig.temperature = (cfg as any).temperature;\n      if ((cfg as any).topP !== undefined) modelConfig.topP = (cfg as any).topP;\n      if ((cfg as any).presencePenalty !== undefined)\n        modelConfig.presencePenalty = (cfg as any).presencePenalty as number;\n      if ((cfg as any).frequencyPenalty !== undefined)\n        modelConfig.frequencyPenalty = (cfg as any).frequencyPenalty as number;\n      const stopSeq = (cfg as any).stopSequences ?? (cfg as any).stop;\n      if (stopSeq !== undefined)\n        modelConfig.stopSequences = stopSeq as string[];\n      if ((cfg as any).n !== undefined)\n        modelConfig.n = (cfg as any).n as number;\n      if ((cfg as any).stream !== undefined)\n        modelConfig.stream = (cfg as any).stream as boolean;\n\n      const out: any = { ...anyItem };\n      if (Object.keys(modelConfig).length > 0) {\n        out.modelConfig = { ...(anyItem.modelConfig ?? {}), ...modelConfig };\n      }\n\n      // Map optional numeric thinking budget to closest Ax level for convenience\n      const numericBudget = (cfg as any)?.thinking?.thinkingTokenBudget;\n      if (typeof numericBudget === 'number') {\n        const candidates = [\n          ['minimal', 200],\n          ['low', 800],\n          ['medium', 5000],\n          ['high', 10000],\n          ['highest', 24500],\n        ] as const;\n        let bestName: 'minimal' | 'low' | 'medium' | 'high' | 'highest' =\n          'minimal';\n        let bestDiff = Number.POSITIVE_INFINITY;\n        for (const [name, value] of candidates) {\n          const diff = Math.abs(numericBudget - value);\n          if (diff < bestDiff) {\n            bestDiff = diff;\n            bestName = name as typeof bestName;\n          }\n        }\n        out.thinkingTokenBudget = bestName;\n      }\n      if ((cfg as any)?.thinking?.includeThoughts !== undefined) {\n        out.showThoughts = !!(cfg as any).thinking.includeThoughts;\n      }\n\n      return out as typeof item;\n    });\n\n    super(aiImpl, {\n      name: 'OpenAI',\n      apiURL: apiURL ? apiURL : 'https://api.openai.com/v1',\n      headers: async () => ({ Authorization: `Bearer ${apiKey}` }),\n      modelInfo,\n      defaults: {\n        model: (config.model ?? AxAIOpenAIResponsesModel.GPT4O) as any,\n        embedModel: (config.embedModel ??\n          AxAIOpenAIEmbedModel.TextEmbeddingAda002) as any,\n      },\n      options,\n      supportFor,\n      models: normalizedModels ?? models,\n    });\n  }\n}\n\n/**\n * Ready-to-use implementation of the OpenAI Responses API client\n * This class uses OpenAI's /v1/responses API endpoint which supports text, image, and audio inputs\n */\n\nexport interface AxAIOpenAIResponsesArgs<\n  TName = 'openai-responses',\n  TModel = AxAIOpenAIResponsesModel,\n  TEmbedModel = AxAIOpenAIEmbedModel,\n  TModelKey = string,\n  TChatReq extends\n    AxAIOpenAIResponsesRequest<TModel> = AxAIOpenAIResponsesRequest<TModel>,\n> extends Omit<\n    AxAIOpenAIResponsesBaseArgs<TModel, TEmbedModel, TModelKey, TChatReq>,\n    'config' | 'supportFor' | 'modelInfo'\n  > {\n  name: TName;\n  modelInfo?: AxModelInfo[];\n  config?: Partial<\n    AxAIOpenAIResponsesBaseArgs<\n      TModel,\n      TEmbedModel,\n      TModelKey,\n      TChatReq\n    >['config']\n  >;\n}\n\nexport class AxAIOpenAIResponses<\n  TModelKey = string,\n> extends AxAIOpenAIResponsesBase<\n  AxAIOpenAIResponsesModel,\n  AxAIOpenAIEmbedModel,\n  TModelKey,\n  AxAIOpenAIResponsesRequest<AxAIOpenAIResponsesModel>\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<\n    Omit<\n      AxAIOpenAIResponsesArgs<\n        'openai-responses',\n        AxAIOpenAIResponsesModel,\n        AxAIOpenAIEmbedModel,\n        TModelKey\n      >,\n      'name'\n    >\n  >) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('OpenAI API key not set');\n    }\n\n    // Use the original OpenAI model info since it contains both chat and embed models\n    modelInfo = [...axModelInfoOpenAIResponses, ...(modelInfo ?? [])];\n\n    const supportFor = (model: AxAIOpenAIResponsesModel) => {\n      const mi = getModelInfo<\n        AxAIOpenAIResponsesModel,\n        AxAIOpenAIEmbedModel,\n        TModelKey\n      >({\n        model,\n        modelInfo,\n        models,\n      });\n      return {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: mi?.supported?.thinkingBudget ?? false,\n        hasShowThoughts: mi?.supported?.showThoughts ?? false,\n        media: {\n          images: {\n            supported: false,\n            formats: [],\n          },\n          audio: {\n            supported: false,\n            formats: [],\n          },\n          files: {\n            supported: false,\n            formats: [],\n            uploadMethod: 'none' as const,\n          },\n          urls: {\n            supported: false,\n            webSearch: false,\n            contextFetching: false,\n          },\n        },\n        caching: {\n          supported: false,\n          types: [],\n        },\n        thinking: false,\n        multiTurn: true,\n      };\n    };\n\n    super({\n      apiKey,\n      config: {\n        ...axAIOpenAIResponsesDefaultConfig(),\n        ...config,\n      },\n      options,\n      modelInfo,\n      models,\n      supportFor,\n    });\n  }\n}\n","import { axBaseAIDefaultConfig } from '../base.js';\nimport { type AxAIOpenAIArgs, AxAIOpenAIBase } from '../openai/api.js';\nimport type { AxAIOpenAIConfig } from '../openai/chat_types.js';\nimport type { AxAIServiceOptions } from '../types.js';\n\ntype OpenRouterConfig = AxAIOpenAIConfig<string, unknown>;\n\nexport const axAIOpenRouterDefaultConfig = (): OpenRouterConfig =>\n  structuredClone({\n    model: 'openrouter/auto',\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport type AxAIOpenRouterArgs<TModelKey> = AxAIOpenAIArgs<\n  'openrouter',\n  string,\n  unknown,\n  TModelKey\n> & {\n  referer?: string;\n  title?: string;\n  options?: Readonly<AxAIServiceOptions>;\n};\n\nexport class AxAIOpenRouter<TModelKey> extends AxAIOpenAIBase<\n  string,\n  unknown,\n  TModelKey\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n    modelInfo,\n    referer,\n    title,\n  }: Readonly<Omit<AxAIOpenRouterArgs<TModelKey>, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('OpenRouter API key not set');\n    }\n\n    const Config: OpenRouterConfig = {\n      ...axAIOpenRouterDefaultConfig(),\n      ...config,\n    };\n\n    const supportFor = {\n      functions: true,\n      streaming: true,\n      hasThinkingBudget: false,\n      hasShowThoughts: false,\n      media: {\n        images: { supported: false, formats: [] },\n        audio: { supported: false, formats: [] },\n        files: { supported: false, formats: [], uploadMethod: 'none' as const },\n        urls: { supported: false, webSearch: false, contextFetching: false },\n      },\n      caching: { supported: false, types: [] },\n      thinking: false,\n      multiTurn: true,\n    };\n\n    const ModelInfo = modelInfo ?? [];\n\n    super({\n      apiKey,\n      config: Config,\n      options,\n      apiURL: 'https://openrouter.ai/api/v1',\n      modelInfo: ModelInfo,\n      models,\n      supportFor,\n    });\n\n    super.setName('OpenRouter');\n    super.setHeaders(async () => {\n      const headers: Record<string, string> = {\n        Authorization: `Bearer ${apiKey}`,\n      };\n      if (referer) headers['HTTP-Referer'] = referer;\n      if (title) headers['X-Title'] = title;\n      return headers;\n    });\n  }\n}\n","import {\n  AxContentProcessingError,\n  AxMediaNotSupportedError,\n} from '../util/apicall.js';\nimport type { AxAIService } from './types.js';\n\n/**\n * Configuration options for content processing and fallback behavior\n */\nexport interface ProcessingOptions {\n  /** How to handle unsupported content types: 'error' throws, 'degrade' converts to text, 'skip' omits */\n  fallbackBehavior?: 'error' | 'degrade' | 'skip';\n  /** Service to convert images to text descriptions */\n  imageToText?: (imageData: string) => Promise<string>;\n  /** Service to convert audio to text transcriptions */\n  audioToText?: (audioData: string, format?: string) => Promise<string>;\n  /** Service to extract text from files */\n  fileToText?: (fileData: string, mimeType: string) => Promise<string>;\n  /** Service to fetch and extract text from URLs */\n  urlToText?: (url: string) => Promise<string>;\n}\n\n/**\n * Represents processed content that has been converted to text format\n */\nexport interface ProcessedContent {\n  /** Content type after processing (always 'text') */\n  type: 'text';\n  /** The processed text content */\n  text: string;\n}\n\n/**\n * Indicates what types of media content are present in a request\n */\nexport interface MediaRequirements {\n  /** Whether the content includes images */\n  hasImages: boolean;\n  /** Whether the content includes audio */\n  hasAudio: boolean;\n  /** Whether the content includes files */\n  hasFiles: boolean;\n  /** Whether the content includes URLs */\n  hasUrls: boolean;\n}\n\n/**\n * Processes content for a specific AI provider, handling unsupported media types.\n *\n * This function takes mixed content (text, images, audio, files, URLs) and transforms\n * it to formats supported by the target provider. Unsupported content types are\n * handled according to the fallback behavior:\n * - 'error': Throws AxMediaNotSupportedError\n * - 'degrade': Converts to text using fallback services or alt text\n * - 'skip': Omits the unsupported content\n *\n * @param content - The content to process (string, object, or array of content items)\n * @param provider - The target AI service provider\n * @param options - Processing options including fallback behavior and conversion services\n * @returns Promise resolving to array of processed content items (all converted to text)\n * @throws AxMediaNotSupportedError when fallbackBehavior is 'error' and content is unsupported\n * @throws AxContentProcessingError when a conversion service fails\n *\n * @example\n * ```typescript\n * const processed = await axProcessContentForProvider(\n *   [\n *     { type: 'text', text: 'Analyze this:' },\n *     { type: 'image', image: 'base64...', altText: 'Chart showing sales data' }\n *   ],\n *   textOnlyProvider,\n *   {\n *     fallbackBehavior: 'degrade',\n *     imageToText: async (data) => await visionService.describe(data)\n *   }\n * );\n * // Result: [{ type: 'text', text: 'Analyze this:' }, { type: 'text', text: 'Chart showing sales data' }]\n * ```\n */\nexport async function axProcessContentForProvider(\n  content: any,\n  provider: AxAIService,\n  options: ProcessingOptions = {}\n): Promise<ProcessedContent[]> {\n  if (typeof content === 'string') {\n    return [{ type: 'text', text: content }];\n  }\n\n  if (!Array.isArray(content)) {\n    return [{ type: 'text', text: String(content) }];\n  }\n\n  const features = provider.getFeatures();\n  const processedContent: ProcessedContent[] = [];\n\n  for (const item of content) {\n    try {\n      switch (item.type) {\n        case 'text':\n          processedContent.push({ type: 'text', text: item.text });\n          break;\n\n        case 'image':\n          if (features.media.images.supported) {\n            // Provider supports images - validate and pass through as text description\n            if (item.altText) {\n              processedContent.push({\n                type: 'text',\n                text: `[Image: ${item.altText}]`,\n              });\n            } else {\n              processedContent.push({\n                type: 'text',\n                text: '[Image content]',\n              });\n            }\n          } else if (item.altText) {\n            // Fallback to alt text\n            processedContent.push({ type: 'text', text: item.altText });\n          } else if (options.imageToText) {\n            // Use AI vision service to describe image\n            try {\n              const description = await options.imageToText(item.image);\n              processedContent.push({ type: 'text', text: description });\n            } catch (error) {\n              throw new AxContentProcessingError(\n                error as Error,\n                'image',\n                'vision analysis'\n              );\n            }\n          } else {\n            // Handle based on fallback behavior\n            switch (options.fallbackBehavior) {\n              case 'error':\n                throw new AxMediaNotSupportedError(\n                  'Images',\n                  provider.getName(),\n                  false\n                );\n              case 'skip':\n                continue; // Skip this content item\n              default:\n                processedContent.push({\n                  type: 'text',\n                  text: '[Image content not supported by this provider]',\n                });\n            }\n          }\n          break;\n\n        case 'audio':\n          if (features.media.audio.supported) {\n            // Provider supports audio - use transcription if available\n            if (item.transcription) {\n              processedContent.push({\n                type: 'text',\n                text: item.transcription,\n              });\n            } else {\n              processedContent.push({\n                type: 'text',\n                text: '[Audio content]',\n              });\n            }\n          } else if (item.transcription) {\n            // Use provided transcription\n            processedContent.push({ type: 'text', text: item.transcription });\n          } else if (options.audioToText) {\n            // Use speech-to-text service\n            try {\n              const transcription = await options.audioToText(\n                item.data,\n                item.format\n              );\n              processedContent.push({ type: 'text', text: transcription });\n            } catch (error) {\n              throw new AxContentProcessingError(\n                error as Error,\n                'audio',\n                'transcription'\n              );\n            }\n          } else {\n            // Fallback behavior\n            switch (options.fallbackBehavior) {\n              case 'error':\n                throw new AxMediaNotSupportedError(\n                  'Audio',\n                  provider.getName(),\n                  false\n                );\n              case 'skip':\n                continue;\n              case 'degrade':\n                processedContent.push({\n                  type: 'text',\n                  text: '[Audio content not supported by this provider]',\n                });\n            }\n          }\n          break;\n\n        case 'file':\n          if (features.media.files.supported) {\n            // Provider supports files - use extracted text if available\n            if (item.extractedText) {\n              processedContent.push({\n                type: 'text',\n                text: item.extractedText,\n              });\n            } else {\n              processedContent.push({\n                type: 'text',\n                text: `[File: ${item.filename}]`,\n              });\n            }\n          } else if (item.extractedText) {\n            processedContent.push({ type: 'text', text: item.extractedText });\n          } else if (options.fileToText) {\n            try {\n              const extractedText = await options.fileToText(\n                item.data,\n                item.mimeType\n              );\n              processedContent.push({ type: 'text', text: extractedText });\n            } catch (error) {\n              throw new AxContentProcessingError(\n                error as Error,\n                'file',\n                'text extraction'\n              );\n            }\n          } else {\n            // Fallback behavior\n            switch (options.fallbackBehavior) {\n              case 'error':\n                throw new AxMediaNotSupportedError(\n                  'Files',\n                  provider.getName(),\n                  false\n                );\n              case 'skip':\n                continue;\n              default:\n                processedContent.push({\n                  type: 'text',\n                  text: `[File: ${item.filename} - content not accessible by this provider]`,\n                });\n            }\n          }\n          break;\n\n        case 'url':\n          if (features.media.urls.supported) {\n            // Provider supports URLs - use cached content if available\n            if (item.cachedContent) {\n              processedContent.push({\n                type: 'text',\n                text: item.cachedContent,\n              });\n            } else {\n              processedContent.push({\n                type: 'text',\n                text: `[Link: ${item.url}${item.title ? ` - ${item.title}` : ''}]`,\n              });\n            }\n          } else if (item.cachedContent) {\n            processedContent.push({ type: 'text', text: item.cachedContent });\n          } else if (options.urlToText) {\n            try {\n              const fetchedContent = await options.urlToText(item.url);\n              processedContent.push({ type: 'text', text: fetchedContent });\n            } catch (error) {\n              throw new AxContentProcessingError(\n                error as Error,\n                'url',\n                'content fetching'\n              );\n            }\n          } else {\n            // Fallback behavior\n            switch (options.fallbackBehavior) {\n              case 'error':\n                throw new AxMediaNotSupportedError(\n                  'URLs',\n                  provider.getName(),\n                  false\n                );\n              case 'skip':\n                continue;\n              case 'degrade':\n                processedContent.push({\n                  type: 'text',\n                  text: `[Link: ${item.url}${item.title ? ` - ${item.title}` : ''}]`,\n                });\n            }\n          }\n          break;\n\n        default:\n          // Pass through any unrecognized content types as text\n          if (typeof item === 'object' && item.text) {\n            processedContent.push({ type: 'text', text: item.text });\n          } else {\n            processedContent.push({ type: 'text', text: String(item) });\n          }\n      }\n    } catch (error) {\n      if (\n        error instanceof AxMediaNotSupportedError ||\n        error instanceof AxContentProcessingError\n      ) {\n        throw error;\n      }\n      throw new AxContentProcessingError(\n        error as Error,\n        item.type || 'unknown',\n        'content processing'\n      );\n    }\n  }\n\n  return processedContent;\n}\n\n/**\n * Analyzes a chat prompt to determine what media types it contains.\n *\n * Scans through chat messages to identify the types of media content present,\n * which can be used for provider capability matching and routing decisions.\n *\n * @param chatPrompt - Array of chat messages to analyze\n * @returns Object indicating which media types are present in the chat prompt\n *\n * @example\n * ```typescript\n * const requirements = axAnalyzeChatPromptRequirements([\n *   {\n *     role: 'user',\n *     content: [\n *       { type: 'text', text: 'Analyze this:' },\n *       { type: 'image', image: 'base64...' },\n *       { type: 'file', filename: 'report.pdf' }\n *     ]\n *   }\n * ]);\n * // Result: { hasImages: true, hasAudio: false, hasFiles: true, hasUrls: false }\n * ```\n */\nexport function axAnalyzeChatPromptRequirements(\n  chatPrompt: any[]\n): MediaRequirements {\n  let hasImages = false;\n  let hasAudio = false;\n  let hasFiles = false;\n  let hasUrls = false;\n\n  for (const message of chatPrompt) {\n    if (message.role === 'user' && Array.isArray(message.content)) {\n      for (const part of message.content) {\n        switch (part.type) {\n          case 'image':\n            hasImages = true;\n            break;\n          case 'audio':\n            hasAudio = true;\n            break;\n          case 'file':\n            hasFiles = true;\n            break;\n          case 'url':\n            hasUrls = true;\n            break;\n        }\n      }\n    }\n  }\n\n  return { hasImages, hasAudio, hasFiles, hasUrls };\n}\n\n// Note: axSelectOptimalProvider is now available in capabilities.ts for more advanced provider selection\n","import type { AxModelConfig } from '../types.js';\n\nexport enum AxAIRekaModel {\n  RekaCore = 'reka-core',\n  RekaFlash = 'reka-flash',\n  RekaEdge = 'reka-edge',\n}\n\nexport type AxAIRekaConfig = Omit<AxModelConfig, 'topK'> & {\n  model: AxAIRekaModel;\n  stop?: readonly string[];\n  useSearchEngine?: boolean;\n};\n\nexport type AxAIRekaUsage = {\n  input_tokens: number;\n  output_tokens: number;\n};\n\nexport type AxAIRekaChatRequest = {\n  model: string;\n  messages: (\n    | {\n        role: 'user';\n        content:\n          | string\n          | {\n              type: 'text';\n              text: string;\n            }[];\n      }\n    | {\n        role: 'assistant';\n        content:\n          | string\n          | {\n              type: 'text';\n              text: string;\n            }[];\n      }\n  )[];\n  usage?: AxAIRekaUsage;\n  response_format?: { type: string };\n  max_tokens?: number;\n  temperature?: number;\n  top_p?: number;\n  top_k?: number;\n  stream?: boolean;\n  stop?: readonly string[];\n  presence_penalty?: number;\n  frequency_penalty?: number;\n  use_search_engine?: boolean;\n};\n\nexport type AxAIRekaChatResponse = {\n  id: string;\n  model: string;\n  responses: {\n    message: {\n      content:\n        | string\n        | {\n            type: 'text';\n            text: string;\n          };\n    };\n    finish_reason: 'stop' | 'length' | 'context';\n  }[];\n  usage?: AxAIRekaUsage;\n};\n\nexport type AxAIRekaChatResponseDelta = {\n  id: string;\n  model: string;\n  responses: {\n    chunk: AxAIRekaChatResponse['responses'][0]['message'];\n    finish_reason: AxAIRekaChatResponse['responses'][0]['finish_reason'];\n  }[];\n  usage?: AxAIRekaUsage;\n};\n","import type { AxModelInfo } from '../types.js';\n\nimport { AxAIRekaModel } from './types.js';\n/**\n * OpenAI: Model information\n */\nexport const axModelInfoReka: AxModelInfo[] = [\n  {\n    name: AxAIRekaModel.RekaCore,\n    currency: 'usd',\n    promptTokenCostPer1M: 3,\n    completionTokenCostPer1M: 15,\n  },\n  {\n    name: AxAIRekaModel.RekaFlash,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.8,\n    completionTokenCostPer1M: 2,\n  },\n  {\n    name: AxAIRekaModel.RekaEdge,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.4,\n    completionTokenCostPer1M: 1,\n  },\n];\n","import type { AxAPI } from '../../util/apicall.js';\nimport {\n  AxBaseAI,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxInternalChatRequest,\n  AxModelConfig,\n  AxModelInfo,\n  AxTokenUsage,\n} from '../types.js';\n\nimport { axModelInfoReka } from './info.js';\nimport {\n  type AxAIRekaChatRequest,\n  type AxAIRekaChatResponse,\n  type AxAIRekaChatResponseDelta,\n  type AxAIRekaConfig,\n  AxAIRekaModel,\n} from './types.js';\n\nexport const axAIRekaDefaultConfig = (): AxAIRekaConfig =>\n  structuredClone({\n    model: AxAIRekaModel.RekaCore,\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAIRekaBestConfig = (): AxAIRekaConfig =>\n  structuredClone({\n    ...axAIRekaDefaultConfig(),\n    model: AxAIRekaModel.RekaCore,\n  });\n\nexport const axAIRekaCreativeConfig = (): AxAIRekaConfig =>\n  structuredClone({\n    model: AxAIRekaModel.RekaCore,\n    ...axBaseAIDefaultCreativeConfig(),\n  });\n\nexport const axAIRekaFastConfig = (): AxAIRekaConfig => ({\n  ...axAIRekaDefaultConfig(),\n  model: AxAIRekaModel.RekaFlash,\n});\n\nexport interface AxAIRekaArgs<TModelKey> {\n  name: 'reka';\n  apiKey: string;\n  apiURL?: string;\n  config?: Readonly<Partial<AxAIRekaConfig>>;\n  options?: Readonly<AxAIServiceOptions & { streamingUsage?: boolean }>;\n  modelInfo?: Readonly<AxModelInfo[]>;\n  models?: AxAIInputModelList<AxAIRekaModel, undefined, TModelKey>;\n}\n\nclass AxAIRekaImpl\n  implements\n    AxAIServiceImpl<\n      AxAIRekaModel,\n      undefined,\n      AxAIRekaChatRequest,\n      unknown,\n      AxAIRekaChatResponse,\n      AxAIRekaChatResponseDelta,\n      unknown\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n\n  constructor(private config: AxAIRekaConfig) {}\n\n  getTokenUsage(): AxTokenUsage | undefined {\n    return this.tokensUsed;\n  }\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this;\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      presencePenalty: config.presencePenalty,\n      frequencyPenalty: config.frequencyPenalty,\n      stopSequences: config.stopSequences,\n      topP: config.topP,\n      n: config.n,\n      stream: config.stream,\n    };\n  }\n\n  createChatReq = (\n    req: Readonly<AxInternalChatRequest<AxAIRekaModel>>\n  ): [AxAPI, AxAIRekaChatRequest] => {\n    const model = req.model;\n\n    if (!req.chatPrompt || req.chatPrompt.length === 0) {\n      throw new Error('Chat prompt is empty');\n    }\n\n    const apiConfig = {\n      name: '/chat/completions',\n    };\n\n    const messages = createMessages(req);\n\n    const frequencyPenalty =\n      req.modelConfig?.frequencyPenalty ?? this.config.frequencyPenalty;\n\n    const stream = req.modelConfig?.stream ?? this.config.stream;\n\n    const reqValue: AxAIRekaChatRequest = {\n      model,\n      messages,\n      max_tokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,\n      ...(req.modelConfig?.temperature !== undefined\n        ? { temperature: req.modelConfig.temperature }\n        : {}),\n      top_k: req.modelConfig?.n ?? this.config.n,\n      ...(req.modelConfig?.topP !== undefined\n        ? { top_p: req.modelConfig.topP }\n        : {}),\n      stop: req.modelConfig?.stopSequences ?? this.config.stop,\n      presence_penalty:\n        req.modelConfig?.presencePenalty ?? this.config.presencePenalty,\n      ...(frequencyPenalty ? { frequency_penalty: frequencyPenalty } : {}),\n      ...(stream ? { stream: true } : {}),\n    };\n\n    return [apiConfig, reqValue];\n  };\n\n  createChatResp = (resp: Readonly<AxAIRekaChatResponse>): AxChatResponse => {\n    const { id, usage, responses } = resp;\n\n    this.tokensUsed = usage\n      ? {\n          promptTokens: usage.input_tokens,\n          completionTokens: usage.output_tokens,\n          totalTokens: usage.input_tokens + usage.output_tokens,\n        }\n      : undefined;\n\n    const results = responses.map((res, index) => {\n      const finishReason = mapFinishReason(res.finish_reason);\n      let content: string;\n      if (typeof res.message.content === 'string') {\n        content = res.message.content;\n      } else {\n        content = res.message.content.text;\n      }\n\n      return {\n        index,\n        id: `${id}`,\n        content,\n        finishReason,\n      };\n    });\n\n    return { results, remoteId: id };\n  };\n\n  createChatStreamResp = (\n    resp: Readonly<AxAIRekaChatResponseDelta>\n  ): AxChatResponse => {\n    const { id, usage, responses } = resp;\n\n    this.tokensUsed = usage\n      ? {\n          promptTokens: usage.input_tokens,\n          completionTokens: usage.output_tokens,\n          totalTokens: usage.input_tokens + usage.output_tokens,\n        }\n      : undefined;\n\n    const results = responses.map((res, index) => {\n      const finishReason = mapFinishReason(res.finish_reason);\n      let content: string;\n      if (typeof res.chunk.content === 'string') {\n        content = res.chunk.content;\n      } else {\n        content = res.chunk.content.text;\n      }\n\n      return {\n        index,\n        id: `${id}`,\n        content,\n        finishReason,\n      };\n    });\n\n    return { results };\n  };\n}\n\nconst mapFinishReason = (\n  finishReason: AxAIRekaChatResponse['responses'][0]['finish_reason']\n): AxChatResponseResult['finishReason'] => {\n  switch (finishReason) {\n    case 'stop':\n      return 'stop' as const;\n    case 'context':\n      return 'length' as const;\n    case 'length':\n      return 'length' as const;\n  }\n};\n\nfunction createMessages(\n  req: Readonly<AxChatRequest>\n): AxAIRekaChatRequest['messages'] {\n  return req.chatPrompt.map((msg) => {\n    switch (msg.role) {\n      case 'system':\n        return { role: 'user' as const, content: msg.content };\n\n      case 'user':\n        if (Array.isArray(msg.content)) {\n          return {\n            role: 'user' as const,\n            content: msg.content.map((c) => {\n              switch (c.type) {\n                case 'text':\n                  return { type: 'text' as const, text: c.text };\n                case 'image': {\n                  throw new Error('Image type not supported');\n                }\n                default:\n                  throw new Error('Invalid content type');\n              }\n            }),\n          };\n        }\n        return { role: 'user' as const, content: msg.content };\n\n      case 'assistant':\n        if (Array.isArray(msg.content)) {\n          return {\n            role: 'assistant' as const,\n            content: msg.content.map((c) => {\n              switch (c.type) {\n                case 'text':\n                  return { type: 'text' as const, text: c.text };\n                case 'image': {\n                  throw new Error('Image type not supported');\n                }\n                default:\n                  throw new Error('Invalid content type');\n              }\n            }),\n          };\n        }\n        if (!msg.content) {\n          throw new Error('Assistant content is empty');\n        }\n        return { role: 'user' as const, content: msg.content };\n      default:\n        throw new Error('Invalid role');\n    }\n  });\n}\n\nexport class AxAIReka<TModelKey> extends AxBaseAI<\n  AxAIRekaModel,\n  undefined,\n  AxAIRekaChatRequest,\n  unknown,\n  AxAIRekaChatResponse,\n  AxAIRekaChatResponseDelta,\n  unknown,\n  TModelKey\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    apiURL,\n    modelInfo = axModelInfoReka,\n    models,\n  }: Readonly<Omit<AxAIRekaArgs<TModelKey>, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Reka API key not set');\n    }\n    const Config = {\n      ...axAIRekaDefaultConfig(),\n      ...config,\n    };\n\n    const aiImpl = new AxAIRekaImpl(Config);\n\n    super(aiImpl, {\n      name: 'Reka',\n      apiURL: apiURL ? apiURL : 'https://api.reka.ai/v1/chat',\n      headers: async () => ({ 'X-Api-Key': apiKey }),\n      modelInfo,\n      defaults: {\n        model: Config.model,\n      },\n      options,\n      supportFor: {\n        functions: true,\n        streaming: true,\n        media: {\n          images: {\n            supported: false,\n            formats: [],\n          },\n          audio: {\n            supported: false,\n            formats: [],\n          },\n          files: {\n            supported: false,\n            formats: [],\n            uploadMethod: 'none' as const,\n          },\n          urls: {\n            supported: false,\n            webSearch: false,\n            contextFetching: false,\n          },\n        },\n        caching: {\n          supported: false,\n          types: [],\n        },\n        thinking: false,\n        multiTurn: true,\n      },\n      models,\n    });\n  }\n}\n","import type {\n  AxAIService,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n} from './types.js';\nimport {\n  axProcessContentForProvider,\n  type ProcessingOptions,\n} from './processor.js';\nimport {\n  axSelectOptimalProvider,\n  axAnalyzeRequestRequirements,\n} from './capabilities.js';\nimport { AxMediaNotSupportedError } from '../util/apicall.js';\n\n/**\n * Services for converting unsupported content types to text or optimized formats\n */\nexport interface AxContentProcessingServices {\n  /** Service to convert images to text descriptions */\n  imageToText?: (imageData: string) => Promise<string>;\n  /** Service to convert audio to text transcriptions */\n  audioToText?: (audioData: string, format?: string) => Promise<string>;\n  /** Service to extract text from files */\n  fileToText?: (fileData: string, mimeType: string) => Promise<string>;\n  /** Service to fetch and extract text from URLs */\n  urlToText?: (url: string) => Promise<string>;\n  /** Service to optimize images for size/quality */\n  imageOptimization?: (\n    imageData: string,\n    options: OptimizationOptions\n  ) => Promise<string>;\n}\n\n/**\n * Options for image optimization processing\n */\nexport interface OptimizationOptions {\n  /** Image quality (0-100) */\n  quality?: number;\n  /** Maximum file size in bytes */\n  maxSize?: number;\n  /** Target image format */\n  format?: 'jpeg' | 'png' | 'webp';\n}\n\n/**\n * Configuration for multi-provider routing with fallback capabilities\n */\nexport interface AxMultiProviderConfig {\n  /** Provider hierarchy for routing */\n  providers: {\n    /** Primary provider to try first */\n    primary: AxAIService;\n    /** Alternative providers for fallback */\n    alternatives: AxAIService[];\n  };\n  /** Routing behavior configuration */\n  routing: {\n    /** Order of preferences when selecting providers */\n    preferenceOrder: ('capability' | 'cost' | 'speed' | 'quality')[];\n    /** Capability matching requirements */\n    capability: {\n      /** Only use providers with full capability support */\n      requireExactMatch: boolean;\n      /** Allow providers that require content processing fallbacks */\n      allowDegradation: boolean;\n    };\n  };\n  /** Content processing services for unsupported media types */\n  processing: AxContentProcessingServices;\n}\n\n/**\n * Result of the routing process including provider selection and processing information\n */\nexport interface AxRoutingResult {\n  /** The selected AI service provider */\n  provider: AxAIService;\n  /** List of content processing steps that were applied */\n  processingApplied: string[];\n  /** List of capability degradations that occurred */\n  degradations: string[];\n  /** Non-critical warnings about the routing decision */\n  warnings: string[];\n}\n\n/**\n * Multi-provider router that automatically selects optimal AI providers and handles content processing.\n *\n * The router analyzes requests to determine capability requirements, scores available providers,\n * and automatically handles content transformation for unsupported media types. It provides\n * graceful degradation and fallback mechanisms for robust multi-modal AI applications.\n *\n * @example\n * ```typescript\n * const router = new AxProviderRouter({\n *   providers: {\n *     primary: openaiProvider,\n *     alternatives: [geminiProvider, cohereProvider]\n *   },\n *   routing: {\n *     preferenceOrder: ['capability', 'quality'],\n *     capability: {\n *       requireExactMatch: false,\n *       allowDegradation: true\n *     }\n *   },\n *   processing: {\n *     imageToText: async (data) => await visionService.describe(data),\n *     audioToText: async (data) => await speechService.transcribe(data)\n *   }\n * });\n *\n * const result = await router.chat(multiModalRequest);\n * console.log(`Used: ${result.routing.provider.getName()}`);\n * ```\n */\nexport class AxProviderRouter {\n  private providers: AxAIService[];\n  private processingServices: AxContentProcessingServices;\n  private config: AxMultiProviderConfig['routing'];\n\n  /**\n   * Creates a new provider router with the specified configuration.\n   *\n   * @param config - Router configuration including providers, routing preferences, and processing services\n   */\n  constructor(config: AxMultiProviderConfig) {\n    this.providers = [\n      config.providers.primary,\n      ...config.providers.alternatives,\n    ];\n    this.processingServices = config.processing;\n    this.config = config.routing;\n  }\n\n  /**\n   * Routes a chat request to the most appropriate provider with automatic content processing.\n   *\n   * This method analyzes the request, selects the optimal provider, preprocesses content\n   * for compatibility, and executes the request with fallback support.\n   *\n   * @param request - The chat request to process\n   * @param options - Extended options including fallback providers and routing preferences\n   * @param options.fallbackProviders - Additional providers to try if primary selection fails\n   * @param options.processingOptions - Content processing options and conversion services\n   * @param options.routingOptions - Provider selection and routing behavior options\n   * @param options.routingOptions.requireExactMatch - Only use providers with full capability support\n   * @param options.routingOptions.allowDegradation - Allow content processing for unsupported types\n   * @param options.routingOptions.maxRetries - Maximum number of fallback providers to try\n   * @returns Promise resolving to the AI response and routing information\n   * @throws AxMediaNotSupportedError when no suitable provider can handle the request\n   *\n   * @example\n   * ```typescript\n   * const result = await router.chat(\n   *   { chatPrompt: [{ role: 'user', content: [{ type: 'image', image: '...' }] }] },\n   *   {\n   *     processingOptions: { fallbackBehavior: 'degrade' },\n   *     routingOptions: { allowDegradation: true }\n   *   }\n   * );\n   *\n   * console.log(`Provider: ${result.routing.provider.getName()}`);\n   * console.log(`Processing applied: ${result.routing.processingApplied}`);\n   * ```\n   */\n  async chat(\n    request: AxChatRequest,\n    options: AxAIServiceOptions & {\n      fallbackProviders?: AxAIService[];\n      processingOptions?: ProcessingOptions;\n      routingOptions?: {\n        requireExactMatch?: boolean;\n        allowDegradation?: boolean;\n        maxRetries?: number;\n      };\n    } = {}\n  ): Promise<{\n    response: AxChatResponse | ReadableStream<AxChatResponse>;\n    routing: AxRoutingResult;\n  }> {\n    const routingResult = await this.selectProviderWithDegradation(\n      request,\n      options.routingOptions || {}\n    );\n\n    const processedRequest = await this.preprocessRequest(\n      request,\n      routingResult.provider,\n      options.processingOptions\n    );\n\n    try {\n      const response = await routingResult.provider.chat(\n        processedRequest,\n        options\n      );\n\n      return {\n        response,\n        routing: routingResult,\n      };\n    } catch (error) {\n      if (\n        error instanceof AxMediaNotSupportedError &&\n        options.fallbackProviders?.length\n      ) {\n        // Try fallback providers\n        return await this.tryFallbackProviders(\n          request,\n          options.fallbackProviders,\n          options\n        );\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Preprocesses request content for the target provider\n   */\n  private async preprocessRequest(\n    request: AxChatRequest,\n    provider: AxAIService,\n    processingOptions?: ProcessingOptions\n  ): Promise<AxChatRequest> {\n    const enhancedOptions: ProcessingOptions = {\n      ...processingOptions,\n      fallbackBehavior: processingOptions?.fallbackBehavior || 'degrade',\n      imageToText:\n        processingOptions?.imageToText || this.processingServices.imageToText,\n      audioToText:\n        processingOptions?.audioToText || this.processingServices.audioToText,\n      fileToText:\n        processingOptions?.fileToText || this.processingServices.fileToText,\n      urlToText:\n        processingOptions?.urlToText || this.processingServices.urlToText,\n    };\n\n    const processedChatPrompt = [];\n\n    for (const message of request.chatPrompt) {\n      if (message.role === 'user' && Array.isArray(message.content)) {\n        const processedContent = await axProcessContentForProvider(\n          message.content,\n          provider,\n          enhancedOptions\n        );\n\n        // Convert processed content back to string format if it's all text\n        const allText = processedContent.every((item) => item.type === 'text');\n        if (allText && processedContent.length === 1) {\n          processedChatPrompt.push({\n            ...message,\n            content: processedContent[0].text,\n          });\n        } else {\n          // Keep as array format\n          processedChatPrompt.push({\n            ...message,\n            content: processedContent.map((item) => ({\n              type: 'text' as const,\n              text: item.text,\n            })),\n          });\n        }\n      } else {\n        processedChatPrompt.push(message);\n      }\n    }\n\n    return {\n      ...request,\n      chatPrompt: processedChatPrompt,\n    };\n  }\n\n  /**\n   * Selects provider with graceful degradation\n   */\n  private async selectProviderWithDegradation(\n    request: AxChatRequest,\n    options: {\n      requireExactMatch?: boolean;\n      allowDegradation?: boolean;\n      maxRetries?: number;\n    }\n  ): Promise<AxRoutingResult> {\n    const requirements = axAnalyzeRequestRequirements(request);\n    const processingApplied: string[] = [];\n    const degradations: string[] = [];\n    const warnings: string[] = [];\n\n    try {\n      const provider = axSelectOptimalProvider(request, this.providers, {\n        requireExactMatch:\n          options.requireExactMatch ?? this.config.capability.requireExactMatch,\n        allowDegradation:\n          options.allowDegradation ?? this.config.capability.allowDegradation,\n      });\n\n      const features = provider.getFeatures();\n\n      // Check what degradations will be applied\n      if (requirements.hasImages && !features.media.images.supported) {\n        degradations.push('Images will be converted to text descriptions');\n        processingApplied.push('Image-to-text conversion');\n      }\n\n      if (requirements.hasAudio && !features.media.audio.supported) {\n        degradations.push('Audio will be transcribed to text');\n        processingApplied.push('Audio-to-text transcription');\n      }\n\n      if (requirements.hasFiles && !features.media.files.supported) {\n        degradations.push('File content will be extracted to text');\n        processingApplied.push('File-to-text extraction');\n      }\n\n      if (requirements.hasUrls && !features.media.urls.supported) {\n        degradations.push('URL content will be pre-fetched');\n        processingApplied.push('URL content fetching');\n      }\n\n      if (requirements.requiresStreaming && !features.streaming) {\n        warnings.push('Streaming not supported - will use non-streaming mode');\n      }\n\n      if (requirements.requiresCaching && !features.caching.supported) {\n        warnings.push('Content caching not supported');\n      }\n\n      return {\n        provider,\n        processingApplied,\n        degradations,\n        warnings,\n      };\n    } catch (error) {\n      throw new Error(\n        `Provider selection failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Tries fallback providers when primary provider fails\n   */\n  private async tryFallbackProviders(\n    request: AxChatRequest,\n    fallbackProviders: AxAIService[],\n    options: AxAIServiceOptions\n  ): Promise<{\n    response: AxChatResponse | ReadableStream<AxChatResponse>;\n    routing: AxRoutingResult;\n  }> {\n    for (const fallbackProvider of fallbackProviders) {\n      try {\n        const routingResult: AxRoutingResult = {\n          provider: fallbackProvider,\n          processingApplied: ['Fallback provider selection'],\n          degradations: [\n            'Using fallback provider due to primary provider failure',\n          ],\n          warnings: [],\n        };\n\n        const processedRequest = await this.preprocessRequest(\n          request,\n          fallbackProvider,\n          { fallbackBehavior: 'degrade' }\n        );\n\n        const response = await fallbackProvider.chat(processedRequest, options);\n\n        return {\n          response,\n          routing: routingResult,\n        };\n      } catch (_fallbackError) {}\n    }\n\n    throw new Error('All fallback providers failed');\n  }\n\n  /**\n   * Gets routing recommendation without executing the request.\n   *\n   * Analyzes the request and returns routing information including which provider\n   * would be selected, what processing would be applied, and any degradations or warnings.\n   *\n   * @param request - The chat request to analyze\n   * @returns Promise resolving to routing result with provider selection and processing info\n   *\n   * @example\n   * ```typescript\n   * const recommendation = await router.getRoutingRecommendation(request);\n   * console.log(`Would use: ${recommendation.provider.getName()}`);\n   * console.log(`Degradations: ${recommendation.degradations.join(', ')}`);\n   * ```\n   */\n  async getRoutingRecommendation(\n    request: AxChatRequest\n  ): Promise<AxRoutingResult> {\n    return await this.selectProviderWithDegradation(request, {});\n  }\n\n  /**\n   * Validates whether the configured providers can handle a specific request.\n   *\n   * Performs pre-flight validation to check if the request can be successfully\n   * processed by available providers, identifies potential issues, and provides\n   * recommendations for improving compatibility.\n   *\n   * @param request - The chat request to validate\n   * @returns Promise resolving to validation result with handling capability and recommendations\n   *\n   * @example\n   * ```typescript\n   * const validation = await router.validateRequest(request);\n   * if (!validation.canHandle) {\n   *   console.log('Issues:', validation.issues);\n   *   console.log('Recommendations:', validation.recommendations);\n   * }\n   * ```\n   */\n  async validateRequest(request: AxChatRequest): Promise<{\n    canHandle: boolean;\n    issues: string[];\n    recommendations: string[];\n  }> {\n    const requirements = axAnalyzeRequestRequirements(request);\n    const issues: string[] = [];\n    const recommendations: string[] = [];\n\n    try {\n      const routingResult = await this.selectProviderWithDegradation(\n        request,\n        {}\n      );\n\n      if (routingResult.degradations.length > 0) {\n        issues.push(...routingResult.degradations);\n        recommendations.push(\n          'Consider using a provider that natively supports all media types'\n        );\n      }\n\n      if (routingResult.warnings.length > 0) {\n        issues.push(...routingResult.warnings);\n      }\n\n      // Check if we have processing services for required degradations\n      if (\n        requirements.hasImages &&\n        this.processingServices.imageToText === undefined\n      ) {\n        const hasImageProvider = this.providers.some(\n          (p) => p.getFeatures().media.images.supported\n        );\n        if (!hasImageProvider) {\n          issues.push(\n            'No image processing service available and no providers support images'\n          );\n          recommendations.push(\n            'Add imageToText processing service or use image-capable provider'\n          );\n        }\n      }\n\n      if (\n        requirements.hasAudio &&\n        this.processingServices.audioToText === undefined\n      ) {\n        const hasAudioProvider = this.providers.some(\n          (p) => p.getFeatures().media.audio.supported\n        );\n        if (!hasAudioProvider) {\n          issues.push(\n            'No audio processing service available and no providers support audio'\n          );\n          recommendations.push(\n            'Add audioToText processing service or use audio-capable provider'\n          );\n        }\n      }\n\n      return {\n        canHandle: issues.length === 0 || routingResult.degradations.length > 0,\n        issues,\n        recommendations,\n      };\n    } catch (error) {\n      return {\n        canHandle: false,\n        issues: [\n          `Cannot route request: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        ],\n        recommendations: [\n          'Add more providers or processing services to handle this request',\n        ],\n      };\n    }\n  }\n\n  /**\n   * Gets detailed statistics about the router's provider capabilities.\n   *\n   * Returns information about available providers, their supported capabilities,\n   * and routing recommendations for analysis and debugging purposes.\n   *\n   * @returns Object containing provider statistics and capability matrix\n   *\n   * @example\n   * ```typescript\n   * const stats = router.getRoutingStats();\n   * console.log(`Total providers: ${stats.totalProviders}`);\n   * console.log('Capabilities:');\n   * for (const [capability, providers] of Object.entries(stats.capabilityMatrix)) {\n   *   console.log(`  ${capability}: ${providers.join(', ')}`);\n   * }\n   * ```\n   */\n  getRoutingStats(): {\n    totalProviders: number;\n    capabilityMatrix: {\n      [capability: string]: string[];\n    };\n    recommendedProvider: string;\n  } {\n    const capabilityMatrix: { [capability: string]: string[] } = {};\n\n    // Build capability matrix\n    for (const provider of this.providers) {\n      const features = provider.getFeatures();\n      const name = provider.getName();\n\n      if (features.functions) {\n        capabilityMatrix.Functions = capabilityMatrix.Functions || [];\n        capabilityMatrix.Functions.push(name);\n      }\n\n      if (features.streaming) {\n        capabilityMatrix.Streaming = capabilityMatrix.Streaming || [];\n        capabilityMatrix.Streaming.push(name);\n      }\n\n      if (features.media.images.supported) {\n        capabilityMatrix.Images = capabilityMatrix.Images || [];\n        capabilityMatrix.Images.push(name);\n      }\n\n      if (features.media.audio.supported) {\n        capabilityMatrix.Audio = capabilityMatrix.Audio || [];\n        capabilityMatrix.Audio.push(name);\n      }\n\n      if (features.media.files.supported) {\n        capabilityMatrix.Files = capabilityMatrix.Files || [];\n        capabilityMatrix.Files.push(name);\n      }\n\n      if (features.media.urls.supported) {\n        capabilityMatrix.URLs = capabilityMatrix.URLs || [];\n        capabilityMatrix.URLs.push(name);\n      }\n\n      if (features.caching.supported) {\n        capabilityMatrix.Caching = capabilityMatrix.Caching || [];\n        capabilityMatrix.Caching.push(name);\n      }\n    }\n\n    return {\n      totalProviders: this.providers.length,\n      capabilityMatrix,\n      recommendedProvider: this.providers[0]?.getName() || 'None',\n    };\n  }\n}\n","import type { AxModelInfo } from '../types.js';\n\nexport const axModelInfoTogether: AxModelInfo[] = [];\n","import { axBaseAIDefaultConfig } from '../base.js';\nimport { type AxAIOpenAIArgs, AxAIOpenAIBase } from '../openai/api.js';\nimport type { AxAIOpenAIConfig } from '../openai/chat_types.js';\n\nimport { axModelInfoTogether } from './info.js';\n\ntype TogetherAIConfig = AxAIOpenAIConfig<string, unknown>;\n\nexport const axAITogetherDefaultConfig = (): TogetherAIConfig =>\n  structuredClone({\n    // cspell:disable-next-line\n    model: 'mistralai/Mixtral-8x7B-Instruct-v0.1',\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport type AxAITogetherArgs<TModelKey> = AxAIOpenAIArgs<\n  'together',\n  string,\n  unknown,\n  TModelKey\n>;\n\nexport class AxAITogether<TModelKey> extends AxAIOpenAIBase<\n  string,\n  unknown,\n  TModelKey\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAITogetherArgs<TModelKey>, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Together API key not set');\n    }\n    const Config = {\n      ...axAITogetherDefaultConfig(),\n      ...config,\n    };\n\n    modelInfo = [...axModelInfoTogether, ...(modelInfo ?? [])];\n\n    const supportFor = {\n      functions: true,\n      streaming: true,\n      hasThinkingBudget: false,\n      hasShowThoughts: false,\n      media: {\n        images: {\n          supported: false,\n          formats: [],\n        },\n        audio: {\n          supported: false,\n          formats: [],\n        },\n        files: {\n          supported: false,\n          formats: [],\n          uploadMethod: 'none' as const,\n        },\n        urls: {\n          supported: false,\n          webSearch: false,\n          contextFetching: false,\n        },\n      },\n      caching: {\n        supported: false,\n        types: [],\n      },\n      thinking: false,\n      multiTurn: true,\n    };\n\n    super({\n      apiKey,\n      config: Config,\n      options,\n      apiURL: 'https://api.together.xyz/v1',\n      modelInfo,\n      models,\n      supportFor,\n    });\n\n    super.setName('Together');\n  }\n}\n","import type { AxModelConfig } from '../types.js';\n\n/**\n * WebLLM: Models for text generation\n * Based on WebLLM's supported models\n */\nexport enum AxAIWebLLMModel {\n  // Llama 3.1 series\n  Llama31_8B_Instruct = 'Llama-3.1-8B-Instruct-q4f32_1-MLC',\n  Llama31_70B_Instruct = 'Llama-3.1-70B-Instruct-q4f16_1-MLC',\n\n  // Llama 3.2 series\n  Llama32_1B_Instruct = 'Llama-3.2-1B-Instruct-q4f32_1-MLC',\n  Llama32_3B_Instruct = 'Llama-3.2-3B-Instruct-q4f32_1-MLC',\n\n  // Mistral series\n  Mistral7B_Instruct = 'Mistral-7B-Instruct-v0.3-q4f32_1-MLC',\n\n  // Phi series\n  Phi35_Mini_Instruct = 'Phi-3.5-mini-instruct-q4f32_1-MLC',\n\n  // Gemma series\n  Gemma2_2B_Instruct = 'gemma-2-2b-it-q4f32_1-MLC',\n  Gemma2_9B_Instruct = 'gemma-2-9b-it-q4f32_1-MLC',\n\n  // Qwen series\n  Qwen2_5_0_5B_Instruct = 'Qwen2.5-0.5B-Instruct-q4f32_1-MLC',\n  Qwen2_5_1_5B_Instruct = 'Qwen2.5-1.5B-Instruct-q4f32_1-MLC',\n  Qwen2_5_3B_Instruct = 'Qwen2.5-3B-Instruct-q4f32_1-MLC',\n  Qwen2_5_7B_Instruct = 'Qwen2.5-7B-Instruct-q4f32_1-MLC',\n}\n\n/**\n * WebLLM: Model options for text generation\n */\nexport type AxAIWebLLMConfig = AxModelConfig & {\n  model: AxAIWebLLMModel;\n  logitBias?: Record<number, number>;\n  logProbs?: boolean;\n  topLogprobs?: number;\n};\n\n/**\n * WebLLM: Chat request structure\n * Based on OpenAI-compatible API from WebLLM\n */\nexport type AxAIWebLLMChatRequest = {\n  model: AxAIWebLLMModel;\n  messages: Array<{\n    role: 'system' | 'user' | 'assistant' | 'function';\n    content?: string;\n    name?: string;\n    function_call?: {\n      name: string;\n      arguments: string;\n    };\n  }>;\n  temperature?: number;\n  top_p?: number;\n  max_tokens?: number;\n  stream?: boolean;\n  stop?: string | string[];\n  presence_penalty?: number;\n  frequency_penalty?: number;\n  logit_bias?: Record<number, number>;\n  logprobs?: boolean;\n  top_logprobs?: number;\n  n?: number;\n  tools?: Array<{\n    type: 'function';\n    function: {\n      name: string;\n      description: string;\n      parameters: object;\n    };\n  }>;\n  tool_choice?:\n    | 'none'\n    | 'auto'\n    | { type: 'function'; function: { name: string } };\n};\n\n/**\n * WebLLM: Chat response structure\n */\nexport type AxAIWebLLMChatResponse = {\n  id: string;\n  object: 'chat.completion';\n  created: number;\n  model: AxAIWebLLMModel;\n  choices: Array<{\n    index: number;\n    message: {\n      role: 'assistant';\n      content?: string;\n      tool_calls?: Array<{\n        id: string;\n        type: 'function';\n        function: {\n          name: string;\n          arguments: string;\n        };\n      }>;\n    };\n    finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter';\n    logprobs?: {\n      content: Array<{\n        token: string;\n        logprob: number;\n        bytes: number[];\n        top_logprobs: Array<{\n          token: string;\n          logprob: number;\n          bytes: number[];\n        }>;\n      }>;\n    };\n  }>;\n  usage: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n};\n\n/**\n * WebLLM: Streaming chat response structure\n */\nexport type AxAIWebLLMChatResponseDelta = {\n  id: string;\n  object: 'chat.completion.chunk';\n  created: number;\n  model: AxAIWebLLMModel;\n  choices: Array<{\n    index: number;\n    delta: {\n      role?: 'assistant';\n      content?: string;\n      tool_calls?: Array<{\n        index: number;\n        id?: string;\n        type?: 'function';\n        function?: {\n          name?: string;\n          arguments?: string;\n        };\n      }>;\n    };\n    finish_reason?: 'stop' | 'length' | 'tool_calls' | 'content_filter';\n    logprobs?: {\n      content: Array<{\n        token: string;\n        logprob: number;\n        bytes: number[];\n        top_logprobs: Array<{\n          token: string;\n          logprob: number;\n          bytes: number[];\n        }>;\n      }>;\n    };\n  }>;\n  usage?: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n};\n\n/**\n * WebLLM doesn't support embeddings natively\n * This is a placeholder for consistency with the framework\n */\nexport type AxAIWebLLMEmbedModel = never;\nexport type AxAIWebLLMEmbedRequest = never;\nexport type AxAIWebLLMEmbedResponse = never;\n","import type { AxModelInfo } from '../types.js';\n\nimport { AxAIWebLLMModel } from './types.js';\n\n/**\n * WebLLM model information\n * Note: WebLLM runs models locally in the browser, so there are no API costs\n * However, we include context window and capability information\n */\nexport const axModelInfoWebLLM: AxModelInfo[] = [\n  // Llama 3.1 series\n  {\n    name: AxAIWebLLMModel.Llama31_8B_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0, // Local inference - no cost\n    completionTokenCostPer1M: 0, // Local inference - no cost\n    contextWindow: 128000,\n    maxTokens: 4096,\n  },\n  {\n    name: AxAIWebLLMModel.Llama31_70B_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n    contextWindow: 128000,\n    maxTokens: 4096,\n    isExpensive: true, // Large model - requires significant compute\n  },\n\n  // Llama 3.2 series\n  {\n    name: AxAIWebLLMModel.Llama32_1B_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n    contextWindow: 128000,\n    maxTokens: 2048,\n  },\n  {\n    name: AxAIWebLLMModel.Llama32_3B_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n    contextWindow: 128000,\n    maxTokens: 2048,\n  },\n\n  // Mistral series\n  {\n    name: AxAIWebLLMModel.Mistral7B_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n    contextWindow: 32768,\n    maxTokens: 4096,\n  },\n\n  // Phi series\n  {\n    name: AxAIWebLLMModel.Phi35_Mini_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n    contextWindow: 128000,\n    maxTokens: 4096,\n  },\n\n  // Gemma series\n  {\n    name: AxAIWebLLMModel.Gemma2_2B_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n    contextWindow: 8192,\n    maxTokens: 2048,\n  },\n  {\n    name: AxAIWebLLMModel.Gemma2_9B_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n    contextWindow: 8192,\n    maxTokens: 2048,\n  },\n\n  // Qwen series\n  {\n    name: AxAIWebLLMModel.Qwen2_5_0_5B_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n    contextWindow: 32768,\n    maxTokens: 2048,\n  },\n  {\n    name: AxAIWebLLMModel.Qwen2_5_1_5B_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n    contextWindow: 32768,\n    maxTokens: 2048,\n  },\n  {\n    name: AxAIWebLLMModel.Qwen2_5_3B_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n    contextWindow: 32768,\n    maxTokens: 2048,\n  },\n  {\n    name: AxAIWebLLMModel.Qwen2_5_7B_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n    contextWindow: 32768,\n    maxTokens: 4096,\n  },\n];\n","import type { AxAPI } from '../../util/apicall.js';\nimport {\n  AxBaseAI,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatResponse,\n  AxEmbedResponse,\n  AxInternalChatRequest,\n  AxInternalEmbedRequest,\n  AxModelConfig,\n  AxTokenUsage,\n} from '../types.js';\n\nimport { axModelInfoWebLLM } from './info.js';\nimport {\n  type AxAIWebLLMChatRequest,\n  type AxAIWebLLMChatResponse,\n  type AxAIWebLLMChatResponseDelta,\n  type AxAIWebLLMConfig,\n  type AxAIWebLLMEmbedModel,\n  type AxAIWebLLMEmbedRequest,\n  type AxAIWebLLMEmbedResponse,\n  AxAIWebLLMModel,\n} from './types.js';\n\nexport const axAIWebLLMDefaultConfig = (): AxAIWebLLMConfig =>\n  structuredClone({\n    model: AxAIWebLLMModel.Llama32_3B_Instruct,\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAIWebLLMCreativeConfig = (): AxAIWebLLMConfig =>\n  structuredClone({\n    model: AxAIWebLLMModel.Llama32_3B_Instruct,\n    ...axBaseAIDefaultCreativeConfig(),\n  });\n\nexport interface AxAIWebLLMArgs<TModelKey> {\n  name: 'webllm';\n  engine: any; // WebLLM MLCEngine instance\n  config?: Readonly<Partial<AxAIWebLLMConfig>>;\n  options?: Readonly<AxAIServiceOptions>;\n  models?: AxAIInputModelList<AxAIWebLLMModel, AxAIWebLLMEmbedModel, TModelKey>;\n}\n\nclass AxAIWebLLMImpl\n  implements\n    AxAIServiceImpl<\n      AxAIWebLLMModel,\n      AxAIWebLLMEmbedModel,\n      AxAIWebLLMChatRequest,\n      AxAIWebLLMEmbedRequest,\n      AxAIWebLLMChatResponse,\n      AxAIWebLLMChatResponseDelta,\n      AxAIWebLLMEmbedResponse\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n  public engine: any; // Make engine public so we can access it in localCall\n\n  constructor(\n    private config: AxAIWebLLMConfig,\n    engine: any // WebLLM MLCEngine instance\n  ) {\n    this.engine = engine;\n  }\n\n  getTokenUsage(): AxTokenUsage | undefined {\n    return this.tokensUsed;\n  }\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this;\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      topP: config.topP,\n      topK: config.topK,\n      presencePenalty: config.presencePenalty,\n      frequencyPenalty: config.frequencyPenalty,\n      stopSequences: config.stopSequences,\n      endSequences: config.endSequences,\n      stream: config.stream,\n      n: config.n,\n    } as AxModelConfig;\n  }\n\n  createChatReq(\n    req: Readonly<AxInternalChatRequest<AxAIWebLLMModel>>\n  ): [AxAPI, AxAIWebLLMChatRequest] {\n    const model = req.model;\n\n    // Convert Ax chat format to WebLLM format\n    const messages = req.chatPrompt.map((msg) => {\n      if (msg.role === 'function') {\n        return {\n          role: 'function' as const,\n          name: msg.functionId,\n          content:\n            typeof msg.result === 'string'\n              ? msg.result\n              : JSON.stringify(msg.result),\n        };\n      }\n\n      let content = '';\n      if (typeof msg.content === 'string') {\n        content = msg.content;\n      } else if (Array.isArray(msg.content)) {\n        // Handle multi-modal content by extracting text\n        content = msg.content\n          .filter((item) => item.type === 'text')\n          .map((item) => item.text)\n          .join('\\n');\n      }\n\n      const baseMsg = {\n        role: msg.role,\n        content,\n      };\n\n      // Add function calls for assistant messages\n      if (msg.role === 'assistant' && msg.functionCalls?.length) {\n        return {\n          ...baseMsg,\n          tool_calls: msg.functionCalls.map((fc) => ({\n            id: fc.id,\n            type: 'function' as const,\n            function: {\n              name: fc.function.name,\n              arguments:\n                typeof fc.function.params === 'string'\n                  ? fc.function.params\n                  : JSON.stringify(fc.function.params || {}),\n            },\n          })),\n        };\n      }\n\n      return baseMsg;\n    });\n\n    // Convert functions to tools\n    const tools = req.functions?.map((fn) => ({\n      type: 'function' as const,\n      function: {\n        name: fn.name,\n        description: fn.description,\n        parameters: fn.parameters || { type: 'object', properties: {} },\n      },\n    }));\n\n    const apiConfig = {\n      name: '/chat/completions', // WebLLM uses OpenAI-compatible endpoint\n      localCall: async <TRequest, TResponse>(\n        data: TRequest,\n        stream?: boolean\n      ): Promise<TResponse | ReadableStream<TResponse>> => {\n        try {\n          // Use WebLLM engine's chat.completions.create method\n          const response = await this.engine.chat.completions.create({\n            ...data,\n            stream: stream || false,\n          });\n\n          if (stream) {\n            // Return a ReadableStream for streaming responses\n            return new ReadableStream({\n              async start(controller) {\n                try {\n                  for await (const chunk of response) {\n                    controller.enqueue(chunk);\n                  }\n                  controller.close();\n                } catch (error) {\n                  controller.error(error);\n                }\n              },\n            }) as TResponse | ReadableStream<TResponse>;\n          }\n          return response as TResponse | ReadableStream<TResponse>;\n        } catch (error) {\n          throw new Error(`WebLLM API error: ${error}`);\n        }\n      },\n    };\n\n    const reqValue: AxAIWebLLMChatRequest = {\n      model,\n      messages,\n      ...(tools?.length ? { tools } : {}),\n      max_tokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,\n      ...(req.modelConfig?.temperature !== undefined\n        ? { temperature: req.modelConfig.temperature }\n        : {}),\n      ...(req.modelConfig?.topP !== undefined\n        ? { top_p: req.modelConfig.topP }\n        : {}),\n      presence_penalty:\n        req.modelConfig?.presencePenalty ?? this.config.presencePenalty,\n      frequency_penalty:\n        req.modelConfig?.frequencyPenalty ?? this.config.frequencyPenalty,\n      stop: req.modelConfig?.stopSequences ?? this.config.stopSequences,\n      stream: req.modelConfig?.stream ?? this.config.stream,\n      n: req.modelConfig?.n ?? this.config.n,\n    };\n\n    return [apiConfig, reqValue];\n  }\n\n  createEmbedReq = (\n    _req: Readonly<AxInternalEmbedRequest<AxAIWebLLMEmbedModel>>\n  ): [AxAPI, AxAIWebLLMEmbedRequest] => {\n    throw new Error('WebLLM does not support embeddings');\n  };\n\n  createChatResp = (resp: Readonly<AxAIWebLLMChatResponse>): AxChatResponse => {\n    this.tokensUsed = {\n      promptTokens: resp.usage?.prompt_tokens ?? 0,\n      completionTokens: resp.usage?.completion_tokens ?? 0,\n      totalTokens: resp.usage?.total_tokens ?? 0,\n    };\n\n    const results = resp.choices.map((choice, index) => {\n      let finishReason: AxChatResponse['results'][0]['finishReason'] = 'stop';\n      switch (choice.finish_reason) {\n        case 'stop':\n          finishReason = 'stop';\n          break;\n        case 'length':\n          finishReason = 'length';\n          break;\n        case 'tool_calls':\n          finishReason = 'function_call';\n          break;\n        case 'content_filter':\n          finishReason = 'content_filter';\n          break;\n        default:\n          finishReason = 'stop';\n          break;\n      }\n\n      const functionCalls = choice.message.tool_calls?.map((toolCall) => ({\n        id: toolCall.id,\n        type: 'function' as const,\n        function: {\n          name: toolCall.function.name,\n          params: toolCall.function.arguments,\n        },\n      }));\n\n      return {\n        index,\n        id: resp.id,\n        content: choice.message.content || '',\n        functionCalls,\n        finishReason,\n      };\n    });\n\n    return { results, remoteId: resp.id };\n  };\n\n  createChatStreamResp = (\n    resp: Readonly<AxAIWebLLMChatResponseDelta>,\n    state: object\n  ): AxChatResponse => {\n    const ss = state as {\n      content?: string;\n      toolCalls?: Array<{\n        id?: string;\n        type?: 'function';\n        function?: { name?: string; arguments?: string };\n      }>;\n    };\n\n    // Accumulate streaming content\n    const choice = resp.choices[0];\n    if (!choice) {\n      throw new Error('No choice in WebLLM stream response');\n    }\n\n    if (choice.delta.content) {\n      ss.content = (ss.content || '') + choice.delta.content;\n    }\n\n    // Handle tool calls in streaming\n    if (choice.delta.tool_calls) {\n      if (!ss.toolCalls) {\n        ss.toolCalls = [];\n      }\n\n      for (const deltaToolCall of choice.delta.tool_calls) {\n        const existingCall = ss.toolCalls[deltaToolCall.index];\n        if (existingCall) {\n          if (deltaToolCall.function?.arguments) {\n            existingCall.function!.arguments =\n              (existingCall.function?.arguments || '') +\n              deltaToolCall.function.arguments;\n          }\n        } else {\n          ss.toolCalls[deltaToolCall.index] = {\n            id: deltaToolCall.id,\n            type: deltaToolCall.type,\n            function: {\n              name: deltaToolCall.function?.name,\n              arguments: deltaToolCall.function?.arguments || '',\n            },\n          };\n        }\n      }\n    }\n\n    // Update token usage if available\n    if (resp.usage) {\n      this.tokensUsed = {\n        promptTokens: resp.usage.prompt_tokens,\n        completionTokens: resp.usage.completion_tokens,\n        totalTokens: resp.usage.total_tokens,\n      };\n    }\n\n    let finishReason: AxChatResponse['results'][0]['finishReason'] | undefined;\n    if (choice.finish_reason) {\n      switch (choice.finish_reason) {\n        case 'stop':\n          finishReason = 'stop';\n          break;\n        case 'length':\n          finishReason = 'length';\n          break;\n        case 'tool_calls':\n          finishReason = 'function_call';\n          break;\n        case 'content_filter':\n          finishReason = 'content_filter';\n          break;\n        default:\n          finishReason = 'stop';\n          break;\n      }\n    }\n\n    const functionCalls = ss.toolCalls?.map((toolCall) => ({\n      id: toolCall.id || '',\n      type: 'function' as const,\n      function: {\n        name: toolCall.function?.name || '',\n        params: toolCall.function?.arguments || '',\n      },\n    }));\n\n    const results = [\n      {\n        index: 0,\n        id: resp.id,\n        content: ss.content || '',\n        functionCalls,\n        finishReason,\n      },\n    ];\n\n    return { results, remoteId: resp.id };\n  };\n\n  createEmbedResp(_resp: Readonly<AxAIWebLLMEmbedResponse>): AxEmbedResponse {\n    throw new Error('WebLLM does not support embeddings');\n  }\n}\n\nexport class AxAIWebLLM<TModelKey> extends AxBaseAI<\n  AxAIWebLLMModel,\n  AxAIWebLLMEmbedModel,\n  AxAIWebLLMChatRequest,\n  AxAIWebLLMEmbedRequest,\n  AxAIWebLLMChatResponse,\n  AxAIWebLLMChatResponseDelta,\n  AxAIWebLLMEmbedResponse,\n  TModelKey\n> {\n  constructor({\n    engine,\n    config,\n    options,\n    models,\n  }: Readonly<Omit<AxAIWebLLMArgs<TModelKey>, 'name'>>) {\n    if (!engine) {\n      throw new Error('WebLLM engine instance is required');\n    }\n\n    const Config = {\n      ...axAIWebLLMDefaultConfig(),\n      ...config,\n    };\n\n    const aiImpl = new AxAIWebLLMImpl(Config, engine);\n\n    super(aiImpl, {\n      name: 'WebLLM',\n      apiURL: undefined, // No URL needed for local inference\n      headers: async () => ({}), // No headers needed\n      modelInfo: axModelInfoWebLLM,\n      defaults: { model: Config.model },\n      supportFor: (_model: AxAIWebLLMModel) => ({\n        functions: true, // WebLLM supports function calling\n        streaming: true, // WebLLM supports streaming\n        media: {\n          images: {\n            supported: false,\n            formats: [],\n          },\n          audio: {\n            supported: false,\n            formats: [],\n          },\n          files: {\n            supported: false,\n            formats: [],\n            uploadMethod: 'none' as const,\n          },\n          urls: {\n            supported: false,\n            webSearch: false,\n            contextFetching: false,\n          },\n        },\n        caching: {\n          supported: false,\n          types: [],\n        },\n        thinking: false,\n        multiTurn: true,\n      }),\n      options,\n      models,\n    });\n  }\n}\n","// cspell:ignore grok\n\nexport enum AxAIGrokModel {\n  Grok3 = 'grok-3',\n  Grok3Mini = 'grok-3-mini',\n  Grok3Fast = 'grok-3-fast',\n  Grok3MiniFast = 'grok-3-mini-fast',\n}\n\nexport enum AxAIGrokEmbedModels {\n  GrokEmbedSmall = 'grok-embed-small', // Placeholder, update if actual models are known\n}\n","// cspell:ignore grok\n\nimport type { AxModelInfo } from '../types.js';\n\nimport { AxAIGrokModel } from './types.js';\n\nexport const axModelInfoGrok: AxModelInfo[] = [\n  {\n    name: AxAIGrokModel.Grok3,\n    currency: 'USD',\n    promptTokenCostPer1M: 3.0,\n    completionTokenCostPer1M: 15.0,\n  },\n  {\n    name: AxAIGrokModel.Grok3Mini,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.3,\n    completionTokenCostPer1M: 0.5,\n    supported: { thinkingBudget: true },\n  },\n  {\n    name: AxAIGrokModel.Grok3Fast,\n    currency: 'USD',\n    promptTokenCostPer1M: 5.0,\n    completionTokenCostPer1M: 25.0,\n  },\n  {\n    name: AxAIGrokModel.Grok3MiniFast,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.6,\n    completionTokenCostPer1M: 4.0,\n    supported: { thinkingBudget: true },\n  },\n];\n","import { getModelInfo } from '../../dsp/modelinfo.js';\nimport { axBaseAIDefaultConfig } from '../base.js';\nimport { type AxAIOpenAIArgs, AxAIOpenAIBase } from '../openai/api.js';\nimport type {\n  AxAIOpenAIChatRequest,\n  AxAIOpenAIConfig,\n} from '../openai/chat_types.js';\nimport type { AxAIServiceOptions, AxModelInfo } from '../types.js';\nimport { axModelInfoGrok } from './info.js';\nimport { type AxAIGrokEmbedModels, AxAIGrokModel } from './types.js';\n\nexport const axAIGrokDefaultConfig = (): AxAIOpenAIConfig<\n  AxAIGrokModel,\n  AxAIGrokEmbedModels\n> =>\n  structuredClone({\n    model: AxAIGrokModel.Grok3Mini,\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAIGrokBestConfig = (): AxAIOpenAIConfig<\n  AxAIGrokModel,\n  AxAIGrokEmbedModels\n> =>\n  structuredClone({\n    ...axAIGrokDefaultConfig(),\n    model: AxAIGrokModel.Grok3,\n  });\n\nexport interface AxAIGrokSearchSource {\n  type: 'web' | 'x' | 'news' | 'rss';\n  country?: string; // ISO alpha-2 code for web and news\n  excludedWebsites?: string[]; // Max 5 websites for web and news\n  allowedWebsites?: string[]; // Max 5 websites for web only\n  safeSearch?: boolean; // For web and news, default true\n  xHandles?: string[]; // For X source\n  links?: string[]; // For RSS source, max 1 link\n}\n\nexport interface AxAIGrokOptionsTools {\n  searchParameters?: {\n    mode?: 'auto' | 'on' | 'off';\n    returnCitations?: boolean;\n    fromDate?: string; // ISO8601 format YYYY-MM-DD\n    toDate?: string; // ISO8601 format YYYY-MM-DD\n    maxSearchResults?: number; // Default 20\n    sources?: AxAIGrokSearchSource[];\n  };\n}\n\nexport type AxAIGrokChatRequest = AxAIOpenAIChatRequest<AxAIGrokModel> & {\n  search_parameters?: {\n    mode?: 'auto' | 'on' | 'off';\n    return_citations?: boolean;\n    from_date?: string;\n    to_date?: string;\n    max_search_results?: number;\n    sources?: AxAIGrokSearchSource[];\n  };\n};\n\nexport type AxAIGrokArgs<TModelKey> = AxAIOpenAIArgs<\n  'grok',\n  AxAIGrokModel,\n  AxAIGrokEmbedModels,\n  TModelKey,\n  AxAIGrokChatRequest\n> & {\n  options?: Readonly<AxAIServiceOptions & AxAIGrokOptionsTools> & {\n    tokensPerMinute?: number;\n  };\n  modelInfo?: AxModelInfo[];\n};\n\nexport class AxAIGrok<TModelKey> extends AxAIOpenAIBase<\n  AxAIGrokModel,\n  AxAIGrokEmbedModels,\n  TModelKey,\n  AxAIGrokChatRequest\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAIGrokArgs<TModelKey>, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Grok API key not set');\n    }\n\n    const Config = {\n      ...axAIGrokDefaultConfig(),\n      ...config,\n    };\n\n    modelInfo = [...axModelInfoGrok, ...(modelInfo ?? [])];\n\n    const supportFor = (model: AxAIGrokModel) => {\n      const mi = getModelInfo<AxAIGrokModel, AxAIGrokEmbedModels, TModelKey>({\n        model,\n        modelInfo,\n        models,\n      });\n      return {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: mi?.supported?.thinkingBudget ?? false,\n        hasShowThoughts: mi?.supported?.showThoughts ?? false,\n        media: {\n          images: {\n            supported: false,\n            formats: [],\n          },\n          audio: {\n            supported: false,\n            formats: [],\n          },\n          files: {\n            supported: false,\n            formats: [],\n            uploadMethod: 'none' as const,\n          },\n          urls: {\n            supported: false,\n            webSearch: false,\n            contextFetching: false,\n          },\n        },\n        caching: {\n          supported: false,\n          types: [],\n        },\n        thinking: false,\n        multiTurn: true,\n      };\n    };\n\n    // Chat request updater to add Grok's search parameters\n    const chatReqUpdater = (req: AxAIGrokChatRequest): AxAIGrokChatRequest => {\n      if (options?.searchParameters) {\n        const searchParams = options.searchParameters;\n        return {\n          ...req,\n          search_parameters: {\n            mode: searchParams.mode,\n            return_citations: searchParams.returnCitations,\n            from_date: searchParams.fromDate,\n            to_date: searchParams.toDate,\n            max_search_results: searchParams.maxSearchResults,\n            sources: searchParams.sources?.map((source) => ({\n              type: source.type,\n              country: source.country,\n              excluded_websites: source.excludedWebsites,\n              allowed_websites: source.allowedWebsites,\n              safe_search: source.safeSearch,\n              x_handles: source.xHandles,\n              links: source.links,\n            })),\n          },\n        };\n      }\n      return req;\n    };\n\n    super({\n      apiKey,\n      config: Config,\n      options,\n      apiURL: 'https://api.x.ai/v1',\n      modelInfo,\n      models,\n      supportFor,\n      chatReqUpdater,\n    });\n\n    super.setName('Grok');\n  }\n}\n","// ReadableStream is available globally in modern browsers and Node.js 16+\n\nimport { AxAIAnthropic, type AxAIAnthropicArgs } from './anthropic/api.js';\nimport type { AxAIAnthropicModel } from './anthropic/types.js';\nimport {\n  AxAIAzureOpenAI,\n  type AxAIAzureOpenAIArgs,\n} from './azure-openai/api.js';\nimport type { AxAIFeatures } from './base.js';\nimport { AxAICohere, type AxAICohereArgs } from './cohere/api.js';\nimport type { AxAICohereEmbedModel, AxAICohereModel } from './cohere/types.js';\nimport { AxAIDeepSeek, type AxAIDeepSeekArgs } from './deepseek/api.js';\nimport type { AxAIDeepSeekModel } from './deepseek/types.js';\nimport {\n  AxAIGoogleGemini,\n  type AxAIGoogleGeminiArgs,\n} from './google-gemini/api.js';\nimport type {\n  AxAIGoogleGeminiEmbedModel,\n  AxAIGoogleGeminiModel,\n} from './google-gemini/types.js';\nimport { AxAIGroq, type AxAIGroqArgs } from './groq/api.js';\nimport type { AxAIGroqModel } from './groq/types.js';\nimport {\n  AxAIHuggingFace,\n  type AxAIHuggingFaceArgs,\n} from './huggingface/api.js';\nimport type { AxAIHuggingFaceModel } from './huggingface/types.js';\nimport { AxAIMistral, type AxAIMistralArgs } from './mistral/api.js';\nimport type { AxAIMistralModel } from './mistral/types.js';\nimport { AxAIOllama, type AxAIOllamaArgs } from './ollama/api.js';\nimport { AxAIOpenAI, type AxAIOpenAIArgs } from './openai/api.js';\nimport type {\n  AxAIOpenAIEmbedModel,\n  AxAIOpenAIModel,\n} from './openai/chat_types.js';\nimport {\n  AxAIOpenAIResponses,\n  type AxAIOpenAIResponsesArgs,\n} from './openai/responses_api_base.js';\nimport type { AxAIOpenAIResponsesModel } from './openai/responses_types.js';\nimport { AxAIOpenRouter, type AxAIOpenRouterArgs } from './openrouter/api.js';\nimport { AxAIReka, type AxAIRekaArgs } from './reka/api.js';\nimport { AxAITogether, type AxAITogetherArgs } from './together/api.js';\nimport type {\n  AxAIModelList,\n  AxAIService,\n  AxAIServiceMetrics,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxEmbedRequest,\n  AxEmbedResponse,\n  AxLoggerFunction,\n} from './types.js';\nimport { AxAIWebLLM, type AxAIWebLLMArgs } from './webllm/api.js';\nimport type { AxAIWebLLMModel } from './webllm/types.js';\nimport { AxAIGrok, type AxAIGrokArgs } from './x-grok/api.js';\nimport type { AxAIGrokModel } from './x-grok/types.js';\n\nexport type AxAIArgs<TModelKey> =\n  | AxAIOpenAIArgs<'openai', AxAIOpenAIModel, AxAIOpenAIEmbedModel, TModelKey>\n  | AxAIOpenAIResponsesArgs<\n      'openai-responses',\n      AxAIOpenAIResponsesModel,\n      AxAIOpenAIEmbedModel,\n      TModelKey\n    >\n  | AxAIAzureOpenAIArgs<TModelKey>\n  | AxAITogetherArgs<TModelKey>\n  | AxAIOpenRouterArgs<TModelKey>\n  | AxAIAnthropicArgs<TModelKey>\n  | AxAIGroqArgs<TModelKey>\n  | AxAIGoogleGeminiArgs<TModelKey>\n  | AxAICohereArgs<TModelKey>\n  | AxAIHuggingFaceArgs<TModelKey>\n  | AxAIMistralArgs<TModelKey>\n  | AxAIDeepSeekArgs<TModelKey>\n  | AxAIOllamaArgs<TModelKey>\n  | AxAIRekaArgs<TModelKey>\n  | AxAIGrokArgs<TModelKey>\n  | AxAIWebLLMArgs<TModelKey>;\n\nexport type AxAIModels =\n  | AxAIOpenAIModel\n  | AxAIAnthropicModel\n  | AxAIGroqModel\n  | AxAIGoogleGeminiModel\n  | AxAICohereModel\n  | AxAIHuggingFaceModel\n  | AxAIMistralModel\n  | AxAIDeepSeekModel\n  | AxAIGrokModel\n  | AxAIWebLLMModel;\n\nexport type AxAIEmbedModels =\n  | AxAIOpenAIEmbedModel\n  | AxAIGoogleGeminiEmbedModel\n  | AxAICohereEmbedModel;\n\n// Helper to extract both model keys and enum values from model configurations\ntype ExtractModelKeysAndValues<T> = T extends readonly {\n  key: infer K;\n  model: infer M;\n}[]\n  ? K | M\n  : never;\n\n// Helper to infer TModelKey from args - now includes both keys and enum values\ntype InferTModelKey<T> = T extends { models: infer M }\n  ? ExtractModelKeysAndValues<M>\n  : string;\n\n/**\n * Factory function for creating AxAI instances with type safety.\n * This is the recommended way to create AxAI instances instead of using the constructor.\n *\n * @param options - Configuration options for the AI service\n * @returns A properly typed AxAI instance\n *\n * @example\n * ```typescript\n * const ai = ai({\n *   name: 'openai',\n *   apiKey: process.env.OPENAI_APIKEY!\n * });\n * ```\n */\nexport function ai<const T extends AxAIArgs<any>>(\n  options: T\n): AxAI<InferTModelKey<T>> {\n  return AxAI.create(options);\n}\n\nexport class AxAI<TModelKey = string>\n  implements AxAIService<any, any, TModelKey>\n{\n  private ai: AxAIService<any, any, TModelKey>;\n\n  // Static factory method for automatic type inference\n  static create<const T extends AxAIArgs<any>>(\n    options: T\n  ): AxAI<InferTModelKey<T>> {\n    return new AxAI(options) as any;\n  }\n\n  /**\n   * @deprecated Use `AxAI.create()` or `ai()` function instead for better type safety.\n   * This constructor will be removed in v15.0.0.\n   *\n   * Migration timeline:\n   * - v13.0.24+: Deprecation warnings (current)\n   * - v14.0.0: Runtime console warnings\n   * - v15.0.0: Complete removal\n   *\n   * @example\n   * ```typescript\n   * // Instead of: new AxAI({ name: 'openai', apiKey: '...' })\n   * // Use: AxAI.create({ name: 'openai', apiKey: '...' })\n   * // Or: ai({ name: 'openai', apiKey: '...' })\n   * ```\n   */\n  constructor(options: Readonly<AxAIArgs<TModelKey>>) {\n    switch (options.name) {\n      case 'openai':\n        this.ai = new AxAIOpenAI<TModelKey>(options);\n        break;\n      case 'openai-responses':\n        this.ai = new AxAIOpenAIResponses<TModelKey>(options);\n        break;\n      case 'azure-openai':\n        this.ai = new AxAIAzureOpenAI<TModelKey>(options);\n        break;\n      case 'grok':\n        this.ai = new AxAIGrok<TModelKey>(options);\n        break;\n      case 'huggingface':\n        this.ai = new AxAIHuggingFace<TModelKey>(options);\n        break;\n      case 'groq':\n        this.ai = new AxAIGroq<TModelKey>(options);\n        break;\n      case 'together':\n        this.ai = new AxAITogether<TModelKey>(options);\n        break;\n      case 'openrouter':\n        this.ai = new AxAIOpenRouter<TModelKey>(options);\n        break;\n      case 'cohere':\n        this.ai = new AxAICohere<TModelKey>(options);\n        break;\n      case 'google-gemini':\n        this.ai = new AxAIGoogleGemini<TModelKey>(options);\n        break;\n      case 'anthropic':\n        this.ai = new AxAIAnthropic<TModelKey>(options);\n        break;\n      case 'mistral':\n        this.ai = new AxAIMistral<TModelKey>(options);\n        break;\n      case 'deepseek':\n        this.ai = new AxAIDeepSeek<TModelKey>(options);\n        break;\n      case 'ollama':\n        this.ai = new AxAIOllama<TModelKey>(options);\n        break;\n      case 'reka':\n        this.ai = new AxAIReka<TModelKey>(options);\n        break;\n      case 'webllm':\n        this.ai = new AxAIWebLLM<TModelKey>(options);\n        break;\n      default:\n        throw new Error('Unknown AI');\n    }\n  }\n\n  getName(): string {\n    return this.ai.getName();\n  }\n\n  getId(): string {\n    return this.ai.getId();\n  }\n\n  getFeatures(model?: string): AxAIFeatures {\n    return this.ai.getFeatures(model);\n  }\n\n  getModelList() {\n    return this.ai.getModelList() as AxAIModelList<TModelKey> | undefined;\n  }\n\n  getLastUsedChatModel() {\n    return this.ai.getLastUsedChatModel();\n  }\n\n  getLastUsedEmbedModel() {\n    return this.ai.getLastUsedEmbedModel();\n  }\n\n  getLastUsedModelConfig() {\n    return this.ai.getLastUsedModelConfig();\n  }\n\n  getMetrics(): AxAIServiceMetrics {\n    return this.ai.getMetrics();\n  }\n\n  async chat(\n    req: Readonly<AxChatRequest<TModelKey>>,\n    options?: Readonly<AxAIServiceOptions>\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    return await this.ai.chat(req, options);\n  }\n\n  async embed(\n    req: Readonly<AxEmbedRequest<TModelKey>>,\n    options?: Readonly<AxAIServiceOptions>\n  ): Promise<AxEmbedResponse> {\n    return await this.ai.embed(req, options);\n  }\n\n  setOptions(options: Readonly<AxAIServiceOptions>): void {\n    this.ai.setOptions(options);\n  }\n\n  getOptions(): Readonly<AxAIServiceOptions> {\n    return this.ai.getOptions();\n  }\n\n  getLogger(): AxLoggerFunction {\n    return this.ai.getLogger();\n  }\n}\n","import { type Span, SpanKind, type Tracer } from '@opentelemetry/api';\n\nimport { axSpanAttributes } from '../trace/trace.js';\n\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBService,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js';\n\nexport interface AxDBBaseArgs {\n  fetch?: typeof fetch;\n  tracer?: Tracer;\n}\n\nexport interface AxDBBaseOpOptions {\n  span?: Span;\n}\n\nexport class AxDBBase implements AxDBService {\n  protected name: string;\n  protected fetch?: typeof fetch;\n  private tracer?: Tracer;\n\n  _upsert?: (\n    req: Readonly<AxDBUpsertRequest>,\n    update?: boolean,\n    options?: Readonly<AxDBBaseOpOptions>\n  ) => Promise<AxDBUpsertResponse>;\n\n  _batchUpsert?: (\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean,\n    options?: Readonly<AxDBBaseOpOptions>\n  ) => Promise<AxDBUpsertResponse>;\n\n  _query?: (\n    req: Readonly<AxDBQueryRequest>,\n    options?: Readonly<AxDBBaseOpOptions>\n  ) => Promise<AxDBQueryResponse>;\n\n  constructor({\n    name,\n    fetch,\n    tracer,\n  }: Readonly<AxDBBaseArgs & { name: string }>) {\n    this.name = name;\n    this.fetch = fetch;\n    this.tracer = tracer;\n  }\n\n  async upsert(\n    req: Readonly<AxDBUpsertRequest>,\n    update?: boolean\n  ): Promise<AxDBUpsertResponse> {\n    if (!this._upsert) {\n      throw new Error('upsert() not implemented');\n    }\n\n    if (!this.tracer) {\n      return await this._upsert(req, update);\n    }\n\n    return await this.tracer.startActiveSpan(\n      'DB Upsert Request',\n      {\n        kind: SpanKind.SERVER,\n        attributes: {\n          [axSpanAttributes.DB_SYSTEM]: this.name,\n          [axSpanAttributes.DB_OPERATION_NAME]: 'upsert',\n          [axSpanAttributes.DB_TABLE]: req.table,\n          [axSpanAttributes.DB_NAMESPACE]: req.namespace,\n          [axSpanAttributes.DB_OPERATION_NAME]: update ? 'update' : 'insert',\n        },\n      },\n      async (span) => {\n        try {\n          return await this._upsert!(req, update, { span });\n        } finally {\n          span.end();\n        }\n      }\n    );\n  }\n\n  async batchUpsert(\n    req: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean\n  ): Promise<AxDBUpsertResponse> {\n    if (!this._batchUpsert) {\n      throw new Error('batchUpsert() not implemented');\n    }\n    if (req.length === 0) {\n      throw new Error('Batch request is empty');\n    }\n    if (!req[0]) {\n      throw new Error('Batch request is invalid first element is undefined');\n    }\n\n    if (!this.tracer) {\n      return await this._batchUpsert(req, update);\n    }\n\n    return await this.tracer.startActiveSpan(\n      'DB Batch Upsert Request',\n      {\n        kind: SpanKind.SERVER,\n        attributes: {\n          [axSpanAttributes.DB_SYSTEM]: this.name,\n          [axSpanAttributes.DB_OPERATION_NAME]: 'upsert',\n          [axSpanAttributes.DB_TABLE]: req[0].table,\n          [axSpanAttributes.DB_NAMESPACE]: req[0].namespace,\n          [axSpanAttributes.DB_OPERATION_NAME]: update ? 'update' : 'insert',\n        },\n      },\n      async (span) => {\n        try {\n          return await this._batchUpsert!(req, update, { span });\n        } finally {\n          span.end();\n        }\n      }\n    );\n  }\n\n  async query(req: Readonly<AxDBQueryRequest>): Promise<AxDBQueryResponse> {\n    if (!this._query) {\n      throw new Error('query() not implemented');\n    }\n    if (!this.tracer) {\n      return await this._query(req);\n    }\n\n    return await this.tracer.startActiveSpan(\n      'DB Query Request',\n      {\n        kind: SpanKind.SERVER,\n        attributes: {\n          [axSpanAttributes.DB_SYSTEM]: this.name,\n          [axSpanAttributes.DB_OPERATION_NAME]: 'upsert',\n          [axSpanAttributes.DB_TABLE]: req.table,\n          [axSpanAttributes.DB_NAMESPACE]: req.namespace,\n          [axSpanAttributes.DB_OPERATION_NAME]: 'query',\n        },\n      },\n      async (span) => {\n        try {\n          return await this._query!(req, { span });\n        } finally {\n          span.end();\n        }\n      }\n    );\n  }\n}\n","import { apiCall } from '../util/apicall.js';\n\nimport { AxDBBase, type AxDBBaseArgs, type AxDBBaseOpOptions } from './base.js';\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js';\n\nconst baseURL = 'https://api.cloudflare.com/client/v4/accounts/';\n\nexport type AxDBCloudflareOpOptions = AxDBBaseOpOptions;\n\ntype AxCloudflareUpsertResponse = {\n  success: boolean;\n  errors?: { message: string }[];\n  result: { ids: string[] };\n};\n\ntype AxCloudflareQueryResponse = {\n  success: boolean;\n  errors?: { message: string }[];\n  result: {\n    matches: {\n      id: string;\n      score: number;\n      values: number[];\n      metadata: object;\n    }[];\n  };\n};\n\nexport interface AxDBCloudflareArgs extends AxDBBaseArgs {\n  name: 'cloudflare';\n  apiKey: string;\n  accountId: string;\n  fetch?: typeof fetch;\n}\n\n/**\n * Cloudflare: DB Service\n */\nexport class AxDBCloudflare extends AxDBBase {\n  private apiKey: string;\n  private accountId: string;\n\n  constructor({\n    apiKey,\n    accountId,\n    fetch,\n    tracer,\n  }: Readonly<Omit<AxDBCloudflareArgs, 'name'>>) {\n    if (!apiKey || !accountId) {\n      throw new Error('Cloudflare credentials not set');\n    }\n    super({ name: 'Cloudflare', fetch, tracer });\n    this.apiKey = apiKey;\n    this.accountId = accountId;\n  }\n\n  override _upsert = async (\n    req: Readonly<AxDBUpsertRequest>,\n    _update?: boolean,\n    options?: Readonly<AxDBCloudflareOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    const res = (await apiCall(\n      {\n        url: new URL(\n          `${this.accountId}/vectorize/indexes/${req.table}/upsert`,\n          baseURL\n        ),\n        headers: {\n          'X-Auth-Key': this.apiKey,\n        },\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      {\n        id: req.id,\n        values: req.values,\n        namespace: req.namespace,\n        metadata: req.metadata,\n      }\n    )) as AxCloudflareUpsertResponse;\n\n    if (res.errors) {\n      throw new Error(\n        `Cloudflare upsert failed: ${res.errors.map(({ message }) => message).join(', ')}`\n      );\n    }\n\n    return {\n      ids: res.result.ids,\n    };\n  };\n\n  override batchUpsert = async (\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean,\n    options?: Readonly<AxDBCloudflareOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    if (update) {\n      throw new Error('Weaviate does not support batch update');\n    }\n    if (batchReq.length < 1) {\n      throw new Error('Batch request is empty');\n    }\n    if (!batchReq[0] || !batchReq[0].table) {\n      throw new Error('Table name is empty');\n    }\n    const table = batchReq[0].table;\n\n    const res = (await apiCall(\n      {\n        url: new URL(\n          `${this.accountId}/vectorize/indexes/${table}/upsert`,\n          baseURL\n        ),\n        headers: {\n          'X-Auth-Key': this.apiKey,\n        },\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      batchReq.map((req) => ({\n        id: req.id,\n        values: req.values,\n        namespace: req.namespace,\n        metadata: req.metadata,\n      }))\n    )) as AxCloudflareUpsertResponse;\n\n    if (res.errors) {\n      throw new Error(\n        `Cloudflare batch upsert failed: ${res.errors\n          .map(({ message }) => message)\n          .join(', ')}`\n      );\n    }\n\n    return {\n      ids: res.result.ids,\n    };\n  };\n\n  override query = async (\n    req: Readonly<AxDBQueryRequest>,\n    options?: Readonly<AxDBCloudflareOpOptions>\n  ): Promise<AxDBQueryResponse> => {\n    const res = (await apiCall(\n      {\n        url: new URL(\n          `${this.accountId}/vectorize/indexes/${req.table}/query`,\n          baseURL\n        ),\n        headers: {\n          'X-Auth-Key': this.apiKey,\n        },\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      {\n        vector: req.values,\n        topK: req.limit || 10,\n        returnValues: true,\n      }\n    )) as AxCloudflareQueryResponse;\n\n    if (res.errors) {\n      throw new Error(\n        `Cloudflare query failed: ${res.errors.map(({ message }) => message).join(', ')}`\n      );\n    }\n\n    const matches = res.result.matches.map(\n      ({ id, score, values, metadata }) => ({\n        id,\n        score,\n        values,\n        metadata,\n      })\n    );\n    return { matches } as AxDBQueryResponse;\n  };\n}\n","import { AxDBBase, type AxDBBaseArgs, type AxDBBaseOpOptions } from './base.js';\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js';\n\nexport type AxDBMemoryOpOptions = AxDBBaseOpOptions;\n\nexport interface AxDBMemoryArgs extends AxDBBaseArgs {\n  name: 'memory';\n}\n\nexport type AxDBState = Record<string, Record<string, AxDBUpsertRequest>>;\n\n/**\n * MemoryDB: DB Service\n */\nexport class AxDBMemory extends AxDBBase {\n  private state: AxDBState;\n\n  constructor({ tracer }: Readonly<Omit<AxDBMemoryArgs, 'name'>> = {}) {\n    super({ name: 'Memory', tracer });\n    this.state = {};\n  }\n\n  override _upsert = async (\n    req: Readonly<AxDBUpsertRequest>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _update?: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options?: Readonly<AxDBMemoryOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    if (!this.state[req.table]) {\n      this.state[req.table] = {\n        [req.id]: req,\n      };\n    } else {\n      const obj = this.state[req.table];\n      if (!obj) {\n        throw new Error(`Table not found: ${req.table}`);\n      }\n      obj[req.id] = req;\n    }\n\n    return { ids: [req.id] };\n  };\n\n  override _batchUpsert = async (\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options?: Readonly<AxDBMemoryOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    const ids: string[] = [];\n    for (const req of batchReq) {\n      const res = await this.upsert(req, update);\n      ids.push(...res.ids);\n    }\n\n    return { ids };\n  };\n\n  override _query = async (\n    req: Readonly<AxDBQueryRequest>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options?: Readonly<AxDBMemoryOpOptions>\n  ): Promise<AxDBQueryResponse> => {\n    const table = this.state[req.table];\n    if (!table) {\n      return { matches: [] };\n    }\n\n    const matches: AxDBQueryResponse['matches'] = [];\n\n    Object.entries(table).forEach(([id, data]) => {\n      if (req.values && data.values) {\n        const score = distance(req.values, data.values);\n        matches.push({ id: id, score: score, metadata: data.metadata });\n      }\n    });\n\n    matches.sort((a, b) => a.score - b.score);\n    if (req.limit) {\n      matches.length = req.limit;\n    }\n\n    return { matches };\n  };\n\n  public getDB = () => {\n    return structuredClone(this.state);\n  };\n\n  public setDB = (state: AxDBState) => {\n    this.state = structuredClone(state);\n  };\n\n  public clearDB = () => {\n    this.state = {};\n  };\n}\n\nconst distance = (a: readonly number[], b: readonly number[]): number => {\n  if (a.length !== b.length) {\n    throw new Error('Vectors must be of the same length.');\n  }\n\n  let dotProduct = 0;\n  let normA = 0;\n  let normB = 0;\n  let zeroVectorA = true;\n  let zeroVectorB = true;\n\n  const vectorA = new Float64Array(a);\n  const vectorB = new Float64Array(b);\n\n  for (let i = 0; i < vectorA.length; i++) {\n    dotProduct += vectorA[i]! * vectorB[i]!;\n    normA += vectorA[i]! * vectorA[i]!;\n    normB += vectorB[i]! * vectorB[i]!;\n    if (vectorA[i] !== 0) zeroVectorA = false;\n    if (vectorB[i] !== 0) zeroVectorB = false;\n  }\n\n  if (zeroVectorA || zeroVectorB) {\n    return 1; // Return maximum distance if one vector is zero\n  }\n\n  const sqrtNormA = Math.sqrt(normA);\n  const sqrtNormB = Math.sqrt(normB);\n  const similarity = dotProduct / (sqrtNormA * sqrtNormB);\n  return 1 - similarity; // Returning distance as 1 - cosine similarity.\n};\n","import { apiCall } from '../util/apicall.js';\n\nimport { AxDBBase, type AxDBBaseArgs, type AxDBBaseOpOptions } from './base.js';\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js';\n\nexport type AxDBPineconeOpOptions = AxDBBaseOpOptions;\n\ntype AxPineconeQueryRequest = {\n  namespace?: string;\n  topK: number;\n  filter?: Record<string, string>;\n  includeValues: boolean;\n  includeMetadata: boolean;\n  vector: readonly number[];\n  id?: string;\n};\n\ntype AxPineconeQueryResponse = {\n  matches: {\n    id: string;\n    score: number;\n    values: number[];\n    metadata?: Record<string, string>;\n  }[];\n};\n\nconst createPineconeQueryRequest = (\n  req: Readonly<AxDBQueryRequest>\n): AxPineconeQueryRequest => {\n  const pineconeQueryRequest: AxPineconeQueryRequest = {\n    namespace: req.namespace,\n    topK: req.limit || 10,\n    filter: {},\n    includeValues: true,\n    includeMetadata: true,\n    vector: req.values ?? [],\n    id: req.id,\n  };\n\n  return pineconeQueryRequest;\n};\n\nexport interface AxDBPineconeArgs extends AxDBBaseArgs {\n  name: 'pinecone';\n  apiKey: string;\n  host: string;\n  fetch?: typeof fetch;\n}\n\n/**\n * Pinecone: DB Service\n */\nexport class AxDBPinecone extends AxDBBase {\n  private apiKey: string;\n  private apiURL: string;\n\n  constructor({\n    apiKey,\n    host,\n    fetch,\n    tracer,\n  }: Readonly<Omit<AxDBPineconeArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Pinecone API key not set');\n    }\n    super({ name: 'Pinecone', fetch, tracer });\n    this.apiKey = apiKey;\n    this.apiURL = host;\n  }\n\n  override _upsert = async (\n    req: Readonly<AxDBUpsertRequest>,\n    update?: boolean,\n    options?: Readonly<AxDBPineconeOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    await this._batchUpsert([req], update, options);\n    return { ids: [req.id] };\n  };\n\n  override _batchUpsert = async (\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    _update?: boolean,\n    options?: Readonly<AxDBPineconeOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    if (batchReq.length === 0) {\n      throw new Error('Batch request is empty');\n    }\n    await apiCall(\n      {\n        url: this.apiURL,\n        headers: { Authorization: `Bearer ${this.apiKey}` },\n        name: '/vectors/upsert',\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      batchReq.map(({ id, values = [], metadata }) => ({\n        id,\n        values,\n        metadata,\n      }))\n    );\n\n    return { ids: batchReq.map(({ id }) => id) };\n  };\n\n  override query = async (\n    req: Readonly<AxDBQueryRequest>,\n    options?: Readonly<AxDBPineconeOpOptions>\n  ): Promise<AxDBQueryResponse> => {\n    if (req.text) {\n      throw new Error('Pinecone does not support text');\n    }\n\n    const res = (await apiCall(\n      {\n        url: this.apiURL,\n        headers: { Authorization: `Bearer ${this.apiKey}` },\n        name: '/query',\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      createPineconeQueryRequest(req)\n    )) as AxPineconeQueryResponse;\n\n    const matches = res.matches.map(({ id, score, values, metadata }) => ({\n      id,\n      score,\n      metadata,\n      values,\n    }));\n\n    return { matches };\n  };\n}\n","import { apiCall } from '../util/apicall.js';\n\nimport { AxDBBase, type AxDBBaseArgs, type AxDBBaseOpOptions } from './base.js';\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js';\n\nexport type AxDBWeaviateOpOptions = AxDBBaseOpOptions;\n\ntype AxWeaviateUpsertResponse = {\n  id: string;\n  result?: { errors?: { error: { message: string }[] } };\n};\n\ntype AxWeaviateQueryResponse = {\n  errors?: { location: string; message: string; path: string }[];\n  data: {\n    Get: {\n      [key: string]: {\n        [key: string]: unknown;\n      }[];\n    };\n  };\n};\n\nexport interface AxDBWeaviateArgs extends AxDBBaseArgs {\n  name: 'weaviate';\n  apiKey: string;\n  host: string;\n  fetch?: typeof fetch;\n}\n\n/**\n * Weaviate: DB Service\n */\nexport class AxDBWeaviate extends AxDBBase {\n  private apiKey: string;\n  private apiURL: string;\n\n  constructor({\n    apiKey,\n    host,\n    fetch,\n    tracer,\n  }: Readonly<Omit<AxDBWeaviateArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Weaviate API key not set');\n    }\n    super({ name: 'Weaviate', fetch, tracer });\n    this.apiKey = apiKey;\n    this.apiURL = host;\n  }\n\n  override _upsert = async (\n    req: Readonly<AxDBUpsertRequest>,\n    update?: boolean,\n    options?: Readonly<AxDBWeaviateOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    const res = (await apiCall(\n      {\n        url: this.apiURL,\n        headers: { Authorization: `Bearer ${this.apiKey}` },\n        name: `/v1/objects/${req.table}/${req.id}`,\n        put: !!update,\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      {\n        id: req.id,\n        class: req.table,\n        tenant: req.namespace,\n        vector: req.values,\n        properties: req.metadata ?? {},\n      }\n    )) as AxWeaviateUpsertResponse;\n\n    if (res?.result?.errors) {\n      throw new Error(\n        `Weaviate upsert failed: ${res.result.errors.error\n          .map(({ message }) => message)\n          .join(', ')}`\n      );\n    }\n\n    return {\n      ids: [res.id],\n    };\n  };\n\n  override _batchUpsert = async (\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean,\n    options?: Readonly<AxDBWeaviateOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    if (update) {\n      throw new Error('Weaviate does not support batch update');\n    }\n    if (batchReq.length === 0) {\n      throw new Error('Batch request is empty');\n    }\n    const objects = batchReq.map((req) => ({\n      id: req.id,\n      class: req.table,\n      tenant: req.namespace,\n      vector: req.values,\n      properties: req.metadata ?? {},\n    }));\n\n    const res = (await apiCall(\n      {\n        url: this.apiURL,\n        headers: { Authorization: `Bearer ${this.apiKey}` },\n        name: '/v1/batch/objects',\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      { objects }\n    )) as AxWeaviateUpsertResponse[];\n\n    if (res?.some(({ result }) => result?.errors)) {\n      throw new Error(\n        `Weaviate batch upsert failed: ${res\n          .map(({ result }) =>\n            result?.errors?.error.map(({ message }) => message).join(', ')\n          )\n          .join(', ')}`\n      );\n    }\n\n    return {\n      ids: res.map(({ id }) => id),\n    };\n  };\n\n  override _query = async (\n    req: Readonly<AxDBQueryRequest>,\n    options?: Readonly<AxDBWeaviateOpOptions>\n  ): Promise<AxDBQueryResponse> => {\n    let filter = '';\n\n    if (req.columns && req.columns.length === 0) {\n      throw new Error('Weaviate requires at least one column');\n    }\n\n    if (req.values) {\n      filter = `nearVector: {\n            vector: [${req.values.join(',')}],\n        }`;\n    } else if (req.text) {\n      filter = `nearText: {\n            concepts: ['${req.text}'],\n        }`;\n    } else {\n      throw new Error('Weaviate requires either text or values');\n    }\n\n    const res = (await apiCall(\n      {\n        url: this.apiURL,\n        headers: { Authorization: `Bearer ${this.apiKey}` },\n        name: '/v1/graphql',\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      {\n        query: `{\n          Get {\n            ${req.table} (\n              limit: ${req.limit || 10},\n              ${filter}\n            ) {\n                ${req.columns?.join('\\n')}\n            }\n          }\n        }`,\n      }\n    )) as AxWeaviateQueryResponse;\n\n    if (res.errors) {\n      throw new Error(\n        `Weaviate query failed: ${res.errors\n          .map(({ message }) => message)\n          .join(', ')}`\n      );\n    }\n\n    const resMatches = res.data.Get[req.table];\n\n    if (!resMatches) {\n      return { matches: [] };\n    }\n\n    const matches = resMatches.map((match) => {\n      return {\n        id: match.id as string,\n        score: 1,\n        metadata: match,\n      };\n    });\n    return { matches } as AxDBQueryResponse;\n  };\n}\n","import { AxDBCloudflare, type AxDBCloudflareArgs } from './cloudflare.js';\nimport { AxDBMemory, type AxDBMemoryArgs } from './memory.js';\nimport { AxDBPinecone, type AxDBPineconeArgs } from './pinecone.js';\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBService,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js';\nimport { AxDBWeaviate, type AxDBWeaviateArgs } from './weaviate.js';\n\nexport type AxDBArgs =\n  | AxDBCloudflareArgs\n  | AxDBPineconeArgs\n  | AxDBWeaviateArgs\n  | AxDBMemoryArgs;\n\nexport class AxDB implements AxDBService {\n  private db: AxDBService;\n  constructor(args: Readonly<AxDBArgs>) {\n    switch (args.name) {\n      case 'weaviate':\n        this.db = new AxDBWeaviate(args);\n        break;\n      case 'pinecone':\n        this.db = new AxDBPinecone(args);\n        break;\n      case 'cloudflare':\n        this.db = new AxDBCloudflare(args);\n        break;\n      case 'memory':\n        this.db = new AxDBMemory(args);\n        break;\n      default:\n        throw new Error('Unknown DB');\n    }\n  }\n  async upsert(\n    req: Readonly<AxDBUpsertRequest>,\n    update?: boolean\n  ): Promise<AxDBUpsertResponse> {\n    return await this.db.upsert(req, update);\n  }\n\n  async batchUpsert(\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean\n  ): Promise<AxDBUpsertResponse> {\n    return await this.db.batchUpsert(batchReq, update);\n  }\n\n  async query(req: Readonly<AxDBQueryRequest>): Promise<AxDBQueryResponse> {\n    return await this.db.query(req);\n  }\n}\n","import type { AxAIService } from '../ai/types.js';\nimport type { AxDBQueryResponse, AxDBService } from '../db/types.js';\nimport type { AxGen } from '../dsp/generate.js';\n\nexport type AxRewriteIn = { query: string };\nexport type AxRewriteOut = { rewrittenQuery: string };\n\nexport type AxRerankerIn = { query: string; items: string[] };\nexport type AxRerankerOut = { rankedItems: string[] };\n\nexport interface AxDBLoaderOptions {\n  chunker?: (text: string) => string[];\n  rewriter?: AxGen<AxRewriteIn, AxRewriteOut>;\n  reranker?: AxGen<AxRerankerIn, AxRerankerOut>;\n}\n\nexport interface AxDBManagerArgs {\n  ai: AxAIService;\n  db: AxDBService;\n  config?: AxDBLoaderOptions;\n}\n\nexport interface AxDBMatch {\n  score: number;\n  text: string;\n}\n\nconst table = '_internal';\n\nexport class AxDBManager {\n  private ai: AxAIService;\n  private db: AxDBService;\n  private chunker: (text: string) => string[];\n  private rewriter?: AxGen<AxRewriteIn, AxRewriteOut>;\n  private reranker?: AxGen<AxRerankerIn, AxRerankerOut>;\n\n  constructor({ ai, db, config }: Readonly<AxDBManagerArgs>) {\n    this.ai = ai;\n    this.db = db;\n    this.chunker = config?.chunker ?? this.defaultChunker;\n    this.reranker = config?.reranker;\n    this.rewriter = config?.rewriter;\n  }\n\n  private defaultChunker = (text: string): string[] => {\n    // Default chunking by paragraphs\n    return text.split(/\\n\\n+/);\n  };\n\n  insert = async (\n    text: Readonly<string | string[]>,\n    options?: Readonly<{\n      batchSize?: number;\n      maxWordsPerChunk?: number;\n      minWordsPerChunk?: number;\n      abortSignal?: AbortSignal;\n    }>\n  ): Promise<void> => {\n    try {\n      const chunkerInput = Array.isArray(text)\n        ? text.join('\\n\\n')\n        : (text as string);\n\n      // Chunk the text using the specified or default chunking function\n      const initialChunks = this.chunker(chunkerInput).filter(\n        (chunk) => chunk.length > 0\n      );\n\n      const maxWordsPerChunk = options?.maxWordsPerChunk;\n      const minWordsPerChunk = options?.minWordsPerChunk;\n\n      const chunks = processChunks({\n        initialChunks,\n        minWordsPerChunk,\n        maxWordsPerChunk,\n      });\n\n      const bs = options?.batchSize ?? 10;\n\n      // Process chunks in batches of 10\n      for (let i = 0; i < chunks.length; i += bs) {\n        const batch = chunks.slice(i, i + bs);\n\n        // Get embeddings for the whole batch from the AI service in one call\n        const ret = await this.ai.embed(\n          { texts: batch },\n          {\n            abortSignal: options?.abortSignal,\n          }\n        );\n\n        // Prepare batch for bulk upsert\n        const embeddings = ret.embeddings\n          .map((embedding, index) => ({\n            id: `chunk_${Date.now() + index}`, // Unique ID for each chunk, adjusted by index\n            table,\n            values: embedding,\n            metadata: { text: batch[index] ?? '' },\n          }))\n          .filter((v) => v.metadata?.text && v.metadata?.text.length > 0);\n\n        // Batch upsert embeddings\n        await this.db.batchUpsert(embeddings);\n      }\n    } catch (error) {\n      throw new Error(`Error processing text: ${error}`);\n    }\n  };\n\n  query = async (\n    query: Readonly<string | string[] | number | number[]>,\n    {\n      topPercent,\n      abortSignal,\n    }:\n      | Readonly<{ topPercent?: number; abortSignal?: AbortSignal }>\n      | undefined = {}\n  ): Promise<AxDBMatch[][]> => {\n    const texts = Array.isArray(query) ? query : [query];\n\n    if (typeof texts[0] === 'string' && this.rewriter) {\n      for (const [i, text] of texts.entries()) {\n        const { rewrittenQuery } = await this.rewriter.forward(this.ai, {\n          query: text,\n        });\n        texts[i] = rewrittenQuery;\n      }\n    }\n\n    let queries: Promise<AxDBQueryResponse>[];\n\n    if (typeof texts[0] === 'string') {\n      const embedResults = await this.ai.embed(\n        { texts },\n        {\n          abortSignal,\n        }\n      );\n      queries = embedResults.embeddings.map((values) =>\n        this.db.query({ table, values })\n      );\n    } else {\n      queries = texts.map((values) => this.db.query({ table, values }));\n    }\n\n    const queryResults = await Promise.all(queries);\n    const res: AxDBMatch[][] = [];\n\n    for (const { matches } of queryResults) {\n      const m = matches\n        .filter((v) => v.metadata?.text && v.metadata?.text.length > 0)\n        .map(({ score, metadata }) => ({\n          score,\n          text: metadata?.text ?? '',\n        }));\n\n      const tp = topPercent && topPercent > 1 ? topPercent / 100 : topPercent;\n      const resultItems = tp ? getTopInPercent(m, tp) : m;\n\n      if (this.reranker) {\n        const { rankedItems } = await this.reranker.forward(this.ai, {\n          query: texts[0] as string,\n          items: resultItems.map((item) => item.text),\n        });\n\n        const items = rankedItems\n          .map((item) => resultItems.find((r) => r.text === item))\n          .filter((v) => v !== undefined) as AxDBMatch[];\n\n        res.push(items);\n      } else {\n        res.push(resultItems);\n      }\n    }\n\n    return res;\n  };\n}\n\nconst processChunks = ({\n  initialChunks,\n  maxWordsPerChunk = 350,\n  minWordsPerChunk = 250,\n}: Readonly<{\n  initialChunks: readonly string[];\n  maxWordsPerChunk?: number;\n  minWordsPerChunk?: number;\n}>): string[] => {\n  const chunks: string[] = [];\n\n  let currentChunk = '';\n  let currentWordCount = 0;\n\n  initialChunks.forEach((chunk) => {\n    const words = chunk.split(/\\s+/); // Split the chunk into words\n    const wordCount = words.length; // Count words in the current chunk\n\n    if (currentWordCount + wordCount <= maxWordsPerChunk) {\n      // Add to the current chunk if within the max size limit\n      currentChunk += `${chunk}\\n\\n`;\n      currentWordCount += wordCount;\n    } else if (\n      currentWordCount > 0 &&\n      currentWordCount + wordCount <= maxWordsPerChunk * 1.5\n    ) {\n      // If the total word count exceeds the limit but is less than 150% of the maxWordsPerChunk\n      currentChunk += `${chunk}\\n\\n`;\n      currentWordCount += wordCount;\n    } else {\n      // If the current chunk is not empty and adding the new chunk exceeds the adjusted limit\n      if (currentWordCount > minWordsPerChunk) {\n        chunks.push(currentChunk.trim());\n        currentChunk = '';\n        currentWordCount = 0;\n      }\n      // Handle the case where the chunk itself is larger than the limit\n      if (wordCount > maxWordsPerChunk) {\n        const remainingWords = words;\n        while (remainingWords.length > maxWordsPerChunk * 1.5) {\n          const slice = remainingWords.splice(0, maxWordsPerChunk);\n          chunks.push(slice.join(' '));\n        }\n        // Add the last portion if it fits the condition of being within 150% of maxWordsPerChunk\n        if (remainingWords.length > 0) {\n          currentChunk += `${remainingWords.join(' ')}\\n\\n`;\n          currentWordCount += remainingWords.length;\n        }\n      } else {\n        // If the new chunk is smaller than the maximum words per chunk\n        currentChunk = `${chunk}\\n\\n`;\n        currentWordCount = wordCount;\n      }\n    }\n  });\n\n  // Push the last chunk if it exists and meets the minimum words condition\n  if (currentWordCount > minWordsPerChunk || chunks.length === 0) {\n    chunks.push(currentChunk.trim());\n  }\n  return chunks;\n};\n\nconst getTopInPercent = (\n  entries: readonly AxDBMatch[],\n  percent = 0.1\n): AxDBMatch[] => {\n  // Sort entries by score in ascending order\n  const sortedEntries = [...entries].sort((a, b) => a.score - b.score);\n\n  // Calculate the number of entries to take (top 10%)\n  const topTenPercentCount = Math.ceil(sortedEntries.length * percent);\n\n  // Return the top 10% of entries\n  return sortedEntries.slice(0, topTenPercentCount);\n};\n","// ReadableStream is available globally in modern browsers and Node.js 16+\n\nimport {\n  type Context,\n  context,\n  type Meter,\n  type Span,\n  SpanKind,\n  trace,\n} from '@opentelemetry/api';\n\nimport { validateAxMessageArray } from '../ai/base.js';\nimport { logResultPickerUsed } from '../ai/debug.js';\nimport type {\n  AxAIService,\n  AxChatRequest,\n  AxChatResponseResult,\n  AxFunction,\n  AxLoggerFunction,\n} from '../ai/types.js';\nimport { AxMemory } from '../mem/memory.js';\nimport type { AxAIMemory } from '../mem/types.js';\nimport {\n  AxAIRefusalError,\n  AxAIServiceStreamTerminatedError,\n} from '../util/apicall.js';\nimport {\n  type AxAssertion,\n  AxAssertionError,\n  type AxStreamingAssertion,\n} from './asserts.js';\nimport {\n  type HandleErrorForGenerateArgs,\n  handleAssertionErrorForGenerate,\n  handleRefusalErrorForGenerate,\n  handleValidationErrorForGenerate,\n  ValidationError,\n} from './errors.js';\nimport type { extractionState } from './extract.js';\nimport type { AxFieldProcessor } from './fieldProcessor.js';\nimport {\n  type AxChatResponseFunctionCall,\n  AxStopFunctionCallException,\n  createFunctionConfig,\n  parseFunctions,\n} from './functions.js';\nimport { axGlobals } from './globals.js';\n// helper no longer used since memory removal is non-throwing\nimport {\n  type AxGenMetricsInstruments,\n  getOrCreateGenMetricsInstruments,\n  recordErrorCorrectionMetric,\n  recordFieldProcessingMetric,\n  recordFunctionCallingMetric,\n  recordGenerationMetric,\n  recordMultiStepMetric,\n  recordPerformanceMetric,\n  recordSamplesMetric,\n  recordSignatureComplexityMetrics,\n  recordStreamingMetric,\n} from './metrics.js';\nimport {\n  processResponse,\n  processStreamingResponse,\n  shouldContinueSteps,\n} from './processResponse.js';\nimport { AxProgram } from './program.js';\nimport { AxPromptTemplate } from './prompt.js';\nimport { selectFromSamples, selectFromSamplesInMemory } from './samples.js';\nimport type { AxIField, AxSignature } from './sig.js';\nimport { SignatureToolCallingManager } from './signatureToolCalling.js';\nimport type {\n  AsyncGenDeltaOut,\n  AxGenDeltaOut,\n  AxGenOut,\n  AxGenStreamingOut,\n  AxMessage,\n  AxProgramExamples,\n  AxProgramForwardOptions,\n  AxProgramForwardOptionsWithModels,\n  AxProgrammable,\n  AxProgramStreamingForwardOptionsWithModels,\n  AxResultPickerFunction,\n  AxSetExamplesOptions,\n} from './types.js';\nimport { mergeDeltas } from './util.js';\n\nexport type AxGenerateResult<OUT> = OUT & {\n  thought?: string;\n};\n\nexport interface AxResponseHandlerArgs<T> {\n  ai: Readonly<AxAIService>;\n  model?: string;\n  res: T;\n  mem: AxAIMemory;\n  sessionId?: string;\n  traceId?: string;\n  functions: Readonly<AxFunction[]>;\n  strictMode?: boolean;\n  span?: Span;\n  logger: AxLoggerFunction;\n}\n\nexport interface AxStreamingEvent<T> {\n  event: 'delta' | 'done' | 'error';\n  data: {\n    contentDelta?: string;\n    partialValues?: Partial<T>;\n    error?: string;\n    functions?: AxChatResponseFunctionCall[];\n  };\n}\n\nexport type InternalAxGenState = {\n  index: number;\n  values: Record<string, any>;\n  content: string;\n  functionsExecuted: Set<string>;\n  functionCalls: NonNullable<AxChatResponseResult['functionCalls']>;\n  xstate: extractionState;\n};\n\nexport class AxGen<IN = any, OUT extends AxGenOut = any>\n  extends AxProgram<IN, OUT>\n  implements AxProgrammable<IN, OUT>\n{\n  private promptTemplate: AxPromptTemplate;\n  private asserts: AxAssertion<OUT>[];\n  private streamingAsserts: AxStreamingAssertion[];\n  private options?: Omit<AxProgramForwardOptions<any>, 'functions'>;\n  private functions: AxFunction[];\n  private fieldProcessors: AxFieldProcessor[] = [];\n  private streamingFieldProcessors: AxFieldProcessor[] = [];\n  private excludeContentFromTrace = false;\n  private thoughtFieldName: string;\n  private signatureToolCallingManager?: SignatureToolCallingManager;\n\n  constructor(\n    signature:\n      | NonNullable<ConstructorParameters<typeof AxSignature>[0]>\n      | AxSignature<any, any>,\n    options?: Readonly<AxProgramForwardOptions<any>>\n  ) {\n    super(signature, {\n      description: options?.description,\n      traceLabel: options?.traceLabel,\n    });\n\n    this.options = options;\n    this.thoughtFieldName = options?.thoughtFieldName ?? 'thought';\n    const promptTemplateOptions = {\n      functions: options?.functions,\n      thoughtFieldName: this.thoughtFieldName,\n      cacheSystemPrompt: options?.cacheSystemPrompt,\n    };\n    this.promptTemplate = new (options?.promptTemplate ?? AxPromptTemplate)(\n      this.signature,\n      promptTemplateOptions\n    );\n    this.asserts = this.options?.asserts ?? [];\n    this.streamingAsserts = this.options?.streamingAsserts ?? [];\n    this.excludeContentFromTrace = options?.excludeContentFromTrace ?? false;\n    this.functions = options?.functions\n      ? parseFunctions(options.functions)\n      : [];\n    this.usage = [];\n  }\n\n  private getSignatureName(): string {\n    return this.signature.getDescription() || 'unknown_signature';\n  }\n\n  private getMetricsInstruments(): AxGenMetricsInstruments | undefined {\n    return getOrCreateGenMetricsInstruments();\n  }\n\n  public updateMeter(meter?: Meter): void {\n    // This now just updates the global singleton, no need to store locally\n    getOrCreateGenMetricsInstruments(meter);\n  }\n\n  private createStates(n: number) {\n    return Array.from({ length: n }, (_, index) => ({\n      index,\n      functionCalls: [],\n      values: {},\n      content: '',\n      functionsExecuted: new Set<string>(),\n      xstate: {\n        extractedFields: [],\n        streamedIndex: {},\n        s: -1,\n      },\n    }));\n  }\n\n  public addAssert = (fn: AxAssertion<OUT>['fn'], message?: string) => {\n    this.asserts.push({ fn, message });\n  };\n\n  public addStreamingAssert = (\n    fieldName: keyof OUT,\n    fn: AxStreamingAssertion['fn'],\n    message?: string\n  ) => {\n    // Validate that the field name exists in the output signature\n    const outputField = this.signature\n      .getOutputFields()\n      .find((f) => f.name === fieldName);\n\n    if (!outputField) {\n      throw new Error(\n        `addStreamingAssert: field ${String(fieldName)} not found in output signature`\n      );\n    }\n\n    // Ensure the field is a string field for streaming assertions\n    const ft = outputField.type?.name;\n    const isStringField = !ft || ft === 'string' || ft === 'code';\n\n    if (!isStringField) {\n      throw new Error(\n        `addStreamingAssert: field ${String(fieldName)} must be a string field for streaming assertions`\n      );\n    }\n\n    this.streamingAsserts.push({ fieldName: String(fieldName), fn, message });\n  };\n\n  private addFieldProcessorInternal = (\n    fieldName: string,\n    fn: AxFieldProcessor['process'],\n    streaming = false\n  ) => {\n    const field = this.signature\n      .getOutputFields()\n      .find((f) => f.name === fieldName);\n\n    if (!field) {\n      throw new Error(`addFieldProcessor: field ${fieldName} not found`);\n    }\n\n    if (streaming) {\n      const ft = field.type?.name;\n      const isText = !ft || ft === 'string' || ft === 'code';\n\n      if (!isText) {\n        throw new Error(\n          `addFieldProcessor: field ${fieldName} is must be a text field`\n        );\n      }\n      this.streamingFieldProcessors.push({ field, process: fn });\n    } else {\n      this.fieldProcessors.push({ field, process: fn });\n    }\n  };\n\n  public addStreamingFieldProcessor = (\n    fieldName: keyof OUT,\n    fn: (\n      value: string,\n      context?: { values?: OUT; sessionId?: string; done?: boolean }\n    ) => unknown | Promise<unknown>\n  ) => {\n    this.addFieldProcessorInternal(\n      String(fieldName),\n      fn as AxFieldProcessor['process'],\n      true\n    );\n  };\n\n  public addFieldProcessor = (\n    fieldName: keyof OUT,\n    fn: (\n      value: OUT[keyof OUT],\n      context?: { values?: OUT; sessionId?: string; done?: boolean }\n    ) => unknown | Promise<unknown>\n  ) => {\n    this.addFieldProcessorInternal(\n      String(fieldName),\n      fn as AxFieldProcessor['process'],\n      false\n    );\n  };\n\n  private async forwardSendRequest({\n    ai,\n    mem,\n    options,\n    traceContext,\n    functions,\n    functionCall,\n    stepIndex,\n  }: Readonly<{\n    ai: Readonly<AxAIService>;\n    mem: AxAIMemory;\n    options?: Omit<AxProgramForwardOptions<any>, 'ai' | 'mem'>;\n    traceContext?: Context;\n    functions: AxFunction[];\n    functionCall: AxChatRequest['functionCall'] | undefined;\n    stepIndex?: number;\n  }>) {\n    const {\n      sessionId,\n      model,\n      rateLimiter,\n      stream,\n      thinkingTokenBudget,\n      showThoughts,\n    } = options ?? {};\n\n    // Use selectFromSamplesInMemory to choose the best sample before getting history\n    const selectedIndex = await selectFromSamplesInMemory(mem, sessionId, {\n      resultPicker: options?.resultPicker as\n        | AxResultPickerFunction<OUT>\n        | undefined,\n    });\n\n    const chatPrompt = mem?.history(selectedIndex, sessionId) ?? [];\n\n    // History transformation for prompt-mode is handled centrally in base.ts\n\n    if (chatPrompt.length === 0) {\n      throw new Error('No chat prompt found');\n    }\n    const modelConfig = {\n      ...options?.modelConfig,\n      ...(options?.sampleCount ? { n: options.sampleCount } : {}),\n      ...(options?.sampleCount && options?.modelConfig?.temperature === 1\n        ? { temperature: 0.8 }\n        : {}),\n    };\n\n    const debug = this.isDebug(ai, options);\n    const firstStep = stepIndex === 0;\n    const logger = this.getLogger(ai, options);\n\n    // Do not send native functions to the provider when emulating via prompt mode\n    functions = this.signatureToolCallingManager ? [] : functions;\n\n    const res = await ai.chat(\n      {\n        chatPrompt,\n        // Do not send native functions to the provider when emulating via prompt mode\n        functions,\n        functionCall,\n        modelConfig,\n        model,\n      },\n      {\n        sessionId,\n        rateLimiter,\n        stream,\n        debug,\n        // Hide system prompt in debug logging for steps > 0 to reduce noise in multi-step workflows\n        debugHideSystemPrompt: !firstStep,\n        thinkingTokenBudget,\n        showThoughts,\n        traceContext,\n        abortSignal: options?.abortSignal,\n        stepIndex,\n        logger,\n        functionCallMode:\n          options?.functionCallMode ?? this.options?.functionCallMode ?? 'auto',\n      }\n    );\n\n    return res;\n  }\n\n  private async *forwardCore({\n    ai,\n    mem,\n    options,\n    stepIndex,\n    span,\n    traceContext,\n    states,\n    stopFunctionNames,\n  }: Readonly<{\n    ai: Readonly<AxAIService>;\n    mem: AxAIMemory;\n    options: Omit<AxProgramForwardOptions<any>, 'ai' | 'mem'>;\n    stepIndex?: number;\n    span?: Span;\n    traceContext?: Context;\n    states: InternalAxGenState[];\n    stopFunctionNames?: readonly string[];\n  }>): AsyncGenDeltaOut<OUT> {\n    const { sessionId, functions: functionList } = options ?? {};\n\n    const functionResultFormatter =\n      options?.functionResultFormatter ?? this.options?.functionResultFormatter;\n\n    const definedFunctionCall =\n      options?.functionCall ?? this.options?.functionCall;\n\n    const signatureToolCallingManager = this.signatureToolCallingManager;\n\n    const strictMode = options?.strictMode ?? false;\n    const model = options.model;\n    const usage = this.usage;\n    const firstStep = stepIndex === 0;\n\n    const debug = this.isDebug(ai, options);\n    const logger = this.getLogger(ai, options);\n\n    // Pass the function call mode directly to createFunctionConfig\n    const { functions, functionCall } = createFunctionConfig(\n      functionList,\n      definedFunctionCall,\n      firstStep,\n      options\n    );\n\n    const res = await this.forwardSendRequest({\n      ai,\n      mem,\n      options,\n      traceContext,\n      functions,\n      functionCall,\n      stepIndex,\n    });\n\n    if (res instanceof ReadableStream) {\n      yield* processStreamingResponse<OUT>({\n        ai,\n        model,\n        res,\n        mem,\n        sessionId,\n        traceId: span ? (span as any).spanContext?.().traceId : undefined,\n        functions,\n        strictMode,\n        span,\n        states,\n        usage,\n        asserts: this.asserts,\n        streamingAsserts: this.streamingAsserts,\n        fieldProcessors: this.fieldProcessors,\n        streamingFieldProcessors: this.streamingFieldProcessors,\n        thoughtFieldName: this.thoughtFieldName,\n        excludeContentFromTrace: this.excludeContentFromTrace,\n        signature: this.signature,\n        logger,\n        debug,\n        functionResultFormatter,\n        signatureToolCallingManager,\n        stopFunctionNames,\n        disableMemoryCleanup: options.disableMemoryCleanup,\n      });\n    } else {\n      yield* processResponse<OUT>({\n        ai,\n        model,\n        res,\n        mem,\n        sessionId,\n        traceId: span ? (span as any).spanContext?.().traceId : undefined,\n        functions,\n        span,\n        strictMode,\n        states,\n        usage,\n        asserts: this.asserts,\n        fieldProcessors: this.fieldProcessors,\n        thoughtFieldName: this.thoughtFieldName,\n        excludeContentFromTrace: this.excludeContentFromTrace,\n        signature: this.signature,\n        logger,\n        debug,\n        functionResultFormatter,\n        signatureToolCallingManager,\n        stopFunctionNames,\n        disableMemoryCleanup: options.disableMemoryCleanup,\n      });\n    }\n  }\n\n  private async *_forward2(\n    ai: Readonly<AxAIService>,\n    values: IN | AxMessage<IN>[],\n    states: InternalAxGenState[],\n    options: Readonly<AxProgramForwardOptions<any>>,\n    span?: Span,\n    traceContext?: Context\n  ): AxGenStreamingOut<OUT> {\n    const rawStop = options?.stopFunction ?? this.options?.stopFunction;\n    const stopFunctionNames = Array.isArray(rawStop)\n      ? rawStop.map((s) => s.toLowerCase())\n      : rawStop\n        ? [rawStop.toLowerCase()]\n        : undefined;\n\n    const maxRetries = options.maxRetries ?? this.options?.maxRetries ?? 10;\n    const maxSteps = options.maxSteps ?? this.options?.maxSteps ?? 10;\n\n    const mem = options.mem ?? this.options?.mem ?? new AxMemory();\n\n    const functions = [\n      ...this.functions,\n      ...(options.functions ? parseFunctions(options.functions) : []),\n    ];\n\n    const hasFunctions = functions && functions.length > 0;\n\n    const functionCallMode =\n      options.functionCallMode ?? this.options?.functionCallMode ?? 'auto';\n\n    const cacheSystemPrompt =\n      options.cacheSystemPrompt ?? this.options?.cacheSystemPrompt;\n\n    // Handle prompt mode\n    if (hasFunctions && functionCallMode === 'prompt') {\n      this.signatureToolCallingManager = new SignatureToolCallingManager(\n        functions\n      );\n    }\n\n    // Handle auto mode\n    if (\n      hasFunctions &&\n      functionCallMode === 'auto' &&\n      !ai.getFeatures(options.model).functions\n    )\n      this.signatureToolCallingManager = new SignatureToolCallingManager(\n        functions\n      );\n\n    let err: ValidationError | AxAssertionError | undefined;\n    let lastError: Error | undefined;\n\n    const promptTemplateClass =\n      this.options?.promptTemplate ?? AxPromptTemplate;\n\n    // Use SignatureToolCallingManager to process signature if in prompt mode\n    if (this.signatureToolCallingManager) {\n      this.signature = this.signatureToolCallingManager.processSignature(\n        this.signature\n      );\n      this.setSignature(this.signature);\n    }\n\n    const currentPromptTemplateOptions = {\n      // Prefer per-call functions; fall back to parsed functions from constructor\n      functions: this.signatureToolCallingManager ? [] : functions,\n      thoughtFieldName: this.thoughtFieldName,\n      cacheSystemPrompt,\n    };\n\n    this.promptTemplate = new promptTemplateClass(\n      this.signature,\n      currentPromptTemplateOptions\n    );\n\n    // New logic:\n    let prompt: AxChatRequest['chatPrompt'];\n\n    // Track prompt rendering performance\n    const promptRenderStart = performance.now();\n\n    if (Array.isArray(values)) {\n      // Validate AxMessage array items\n      validateAxMessageArray<IN>(values as AxMessage<IN>[]);\n\n      // We'll need to decide how to get the 'individual' IN for demos/examples if needed by render.\n      // For now, assume render will handle the array directly.\n      // The generic type for render might need to be T (from render<T extends ...>)\n      // and T will be inferred as ReadonlyArray<AxMessage>\n      prompt = this.promptTemplate.render(values as any, {\n        examples: this.examples as any,\n        demos: this.demos as any,\n      });\n    } else {\n      // Ensure `values` here is correctly inferred as IN\n      prompt = this.promptTemplate.render(values as any, {\n        // Cast if necessary\n        examples: this.examples as any,\n        demos: this.demos as any,\n      });\n    }\n\n    const promptRenderDuration = performance.now() - promptRenderStart;\n\n    // Record prompt render performance metric\n    const metricsInstruments = this.getMetricsInstruments();\n    if (metricsInstruments) {\n      recordPerformanceMetric(\n        metricsInstruments,\n        'prompt_render',\n        promptRenderDuration,\n        this.getSignatureName()\n      );\n    }\n\n    // Track memory update performance\n    const memoryUpdateStart = performance.now();\n    mem.addRequest(prompt, options.sessionId);\n    const memoryUpdateDuration = performance.now() - memoryUpdateStart;\n\n    // Record memory update performance metric\n    if (metricsInstruments) {\n      recordPerformanceMetric(\n        metricsInstruments,\n        'memory_update',\n        memoryUpdateDuration,\n        this.getSignatureName()\n      );\n    }\n\n    multiStepLoop: for (let n = 0; n < maxSteps; n++) {\n      for (let errCount = 0; errCount < maxRetries; errCount++) {\n        try {\n          const generator = this.forwardCore({\n            options,\n            ai,\n            mem,\n            stepIndex: n,\n            span,\n            traceContext,\n            states,\n            stopFunctionNames,\n          });\n\n          let stopFunctionTriggered = false;\n          try {\n            for await (const result of generator) {\n              if (result !== undefined) {\n                yield {\n                  version: errCount,\n                  index: result.index,\n                  delta: result.delta,\n                };\n              }\n            }\n          } catch (e) {\n            if (e instanceof AxStopFunctionCallException) {\n              stopFunctionTriggered = true;\n            } else {\n              throw e;\n            }\n          }\n\n          const shouldContinue = stopFunctionTriggered\n            ? false\n            : shouldContinueSteps(\n                mem,\n                stopFunctionNames,\n                states,\n                options?.sessionId\n              );\n\n          if (shouldContinue) {\n            // Record multi-step generation metric\n            const metricsInstruments = this.getMetricsInstruments();\n            if (metricsInstruments) {\n              recordMultiStepMetric(\n                metricsInstruments,\n                n + 1,\n                maxSteps,\n                this.getSignatureName()\n              );\n            }\n            continue multiStepLoop;\n          }\n\n          // On success, clean up any error-related tags from memory to keep context clean\n          if (!options?.disableMemoryCleanup) {\n            mem.removeByTag('invalid-assistant', options.sessionId);\n            mem.removeByTag('correction', options.sessionId);\n            mem.removeByTag('error', options.sessionId);\n          }\n\n          // Record successful completion metrics\n          const metricsInstruments = this.getMetricsInstruments();\n          if (metricsInstruments) {\n            recordMultiStepMetric(\n              metricsInstruments,\n              n + 1,\n              maxSteps,\n              this.getSignatureName()\n            );\n\n            // Count unique functions executed across all states\n            const allFunctionsExecuted = new Set<string>();\n            states.forEach((state) => {\n              state.functionsExecuted.forEach((func) =>\n                allFunctionsExecuted.add(func)\n              );\n            });\n\n            // Record function metrics if functions were used\n            if (allFunctionsExecuted.size > 0) {\n              recordFunctionCallingMetric(\n                metricsInstruments,\n                true,\n                allFunctionsExecuted.size,\n                true,\n                false,\n                this.getSignatureName()\n              );\n            }\n\n            // Record field processing metrics\n            recordFieldProcessingMetric(\n              metricsInstruments,\n              this.fieldProcessors.length,\n              this.streamingFieldProcessors.length,\n              this.getSignatureName()\n            );\n          }\n\n          return;\n        } catch (e) {\n          lastError = e as Error;\n          let errorFields: AxIField[] | undefined;\n          const debug = this.isDebug(ai, options);\n          const logger = this.getLogger(ai, options);\n          const metricsInstruments = this.getMetricsInstruments();\n          const signatureName = this.getSignatureName();\n\n          const args: HandleErrorForGenerateArgs<Error> = {\n            error: e as Error,\n            errCount,\n            logger,\n            metricsInstruments,\n            signatureName,\n            span,\n            debug,\n          };\n\n          span?.recordException(e as Error);\n\n          if (e instanceof ValidationError) {\n            errorFields = handleValidationErrorForGenerate(\n              args as HandleErrorForGenerateArgs<ValidationError>\n            );\n            err = e;\n          } else if (e instanceof AxAssertionError) {\n            errorFields = handleAssertionErrorForGenerate(\n              args as HandleErrorForGenerateArgs<AxAssertionError>\n            );\n            err = e;\n          } else if (e instanceof AxAIRefusalError) {\n            handleRefusalErrorForGenerate(\n              args as HandleErrorForGenerateArgs<AxAIRefusalError>\n            );\n          } else if (e instanceof AxAIServiceStreamTerminatedError) {\n            // Do nothing allow error correction to happen\n          } else {\n            throw enhanceError(e, ai, this.signature);\n          }\n\n          if (errorFields) {\n            mem.addTag('error', options.sessionId);\n            mem.addRequest(\n              [\n                {\n                  role: 'user' as const,\n                  content: this.promptTemplate.renderExtraFields(errorFields),\n                },\n              ],\n              options.sessionId\n            );\n            mem.addTag('correction', options.sessionId);\n          }\n        }\n      }\n\n      // Record max retries reached\n      const metricsInstruments = this.getMetricsInstruments();\n      if (metricsInstruments) {\n        recordErrorCorrectionMetric(\n          metricsInstruments,\n          maxRetries,\n          false, // failed\n          maxRetries,\n          this.getSignatureName()\n        );\n      }\n\n      throw enhanceError(\n        new Error(\n          `Unable to fix validation error: ${\n            (err ?? lastError)?.message ??\n            (err ?? lastError)?.toString() ??\n            'unknown error'\n          }`\n        ),\n        ai,\n        this.signature\n      );\n    }\n\n    // Record max steps reached\n    if (metricsInstruments) {\n      recordMultiStepMetric(\n        metricsInstruments,\n        maxSteps,\n        maxSteps,\n        this.getSignatureName()\n      );\n    }\n\n    throw enhanceError(\n      new Error(`Max steps reached: ${maxSteps}`),\n      ai,\n      this.signature\n    );\n  }\n\n  public async *_forward1(\n    ai: Readonly<AxAIService>,\n    values: IN | AxMessage<IN>[],\n    options: Readonly<AxProgramForwardOptions<any>>\n  ): AxGenStreamingOut<OUT> {\n    // Track state creation performance\n    const stateCreationStart = performance.now();\n    const states = this.createStates(options.sampleCount ?? 1);\n    const stateCreationDuration = performance.now() - stateCreationStart;\n\n    // Record state creation performance metric\n    const metricsInstruments = this.getMetricsInstruments();\n    if (metricsInstruments) {\n      recordPerformanceMetric(\n        metricsInstruments,\n        'state_creation',\n        stateCreationDuration,\n        this.getSignatureName()\n      );\n    }\n\n    const tracer =\n      options?.tracer ?? this.options?.tracer ?? ai.getOptions().tracer;\n\n    let functions: AxFunction[] | undefined = this.functions;\n\n    if (options?.functions) {\n      functions = parseFunctions(options.functions, this.functions);\n    }\n\n    if (!tracer) {\n      yield* this._forward2(ai, values, states, {\n        ...options,\n        functions,\n      });\n      return;\n    }\n\n    const funcNames = functions?.map((f) => f.name).join(',');\n\n    const attributes = {\n      signature: JSON.stringify(this.signature.toJSON(), null, 2),\n      ...(this.examples\n        ? { examples: JSON.stringify(this.examples, null, 2) }\n        : {}),\n      ...(funcNames ? { provided_functions: funcNames } : {}),\n      ...(options?.model ? { model: options.model } : {}),\n      ...(options?.thinkingTokenBudget\n        ? { thinking_token_budget: options.thinkingTokenBudget }\n        : {}),\n      ...(options?.showThoughts ? { show_thoughts: options.showThoughts } : {}),\n      ...(options?.maxSteps ? { max_steps: options.maxSteps } : {}),\n      ...(options?.maxRetries ? { max_retries: options.maxRetries } : {}),\n    };\n\n    const traceLabel =\n      this.traceLabel && options.traceLabel\n        ? `${this.traceLabel} > ${options.traceLabel}`\n        : (options.traceLabel ?? this.traceLabel);\n    const spanName = traceLabel ? `AxGen > ${traceLabel}` : 'AxGen';\n\n    const span = tracer.startSpan(spanName, {\n      kind: SpanKind.SERVER,\n      attributes,\n    });\n\n    const currentContext = context.active();\n    const traceContext = trace.setSpan(currentContext, span);\n\n    try {\n      if (!this.excludeContentFromTrace) {\n        span.addEvent('input', { content: JSON.stringify(values, null, 2) });\n      }\n\n      yield* this._forward2(\n        ai,\n        values,\n        states,\n        {\n          ...options,\n          functions,\n        },\n        span,\n        traceContext\n      );\n\n      if (!this.excludeContentFromTrace) {\n        const valuesList = states.map((s) => s.values);\n        const values = valuesList.length === 1 ? valuesList[0] : valuesList;\n        span.addEvent('output', {\n          content: JSON.stringify(values, null, 2),\n        });\n      }\n    } finally {\n      span.end();\n    }\n  }\n\n  public async forward<T extends Readonly<AxAIService>>(\n    ai: T,\n    values: IN | AxMessage<IN>[],\n    options?: Readonly<AxProgramForwardOptionsWithModels<T>>\n  ): Promise<OUT> {\n    const startTime = performance.now();\n    const signatureName = this.getSignatureName();\n    const isStreaming = options?.stream ?? false;\n    let success = false;\n    let errorCorrectionAttempts = 0;\n    let resultPickerUsed = false;\n\n    try {\n      // Record signature complexity metrics\n      const metricsInstruments = this.getMetricsInstruments();\n      if (metricsInstruments) {\n        recordSignatureComplexityMetrics(\n          metricsInstruments,\n          this.signature.getInputFields().length,\n          this.signature.getOutputFields().length,\n          this.examples?.length ?? 0,\n          this.demos?.length ?? 0,\n          signatureName\n        );\n      }\n\n      const generator = this._forward1(ai, values, options ?? {});\n\n      let buffer: AxGenDeltaOut<OUT>[] = [];\n      let currentVersion = 0;\n      let deltasEmitted = 0;\n\n      for await (const delta of generator) {\n        if (delta.version !== currentVersion) {\n          buffer = [];\n        }\n        currentVersion = delta.version;\n        buffer = mergeDeltas<OUT>(buffer, delta);\n        deltasEmitted++;\n      }\n\n      // Track error correction attempts from the version count\n      errorCorrectionAttempts = currentVersion;\n\n      // Use result picker to select from multiple samples\n      const resultPickerStart = performance.now();\n      resultPickerUsed = !!options?.resultPicker;\n\n      const selectedIndex = await selectFromSamples(\n        buffer,\n        {\n          resultPicker: options?.resultPicker as\n            | AxResultPickerFunction<OUT>\n            | undefined,\n        },\n        // Pass memory to enable function result selection\n        options?.mem,\n        options?.sessionId\n      );\n\n      const resultPickerLatency = performance.now() - resultPickerStart;\n\n      const selectedResult = buffer[selectedIndex];\n      const result = selectedResult?.delta ?? {};\n\n      // When values is an AxMessage array, do not spread it into trace; only include result\n      const baseTrace = Array.isArray(values)\n        ? ({} as Record<string, unknown>)\n        : ((values as unknown as Record<string, unknown>) ?? {});\n      this.trace = { ...baseTrace, ...result } as unknown as OUT;\n      // Log result picker usage if it was used and debug is enabled\n      if (resultPickerUsed && this.isDebug(ai, options)) {\n        const logger = this.getLogger(ai, options);\n        logResultPickerUsed(\n          buffer.length,\n          selectedIndex,\n          resultPickerLatency,\n          logger\n        );\n      }\n\n      success = true;\n\n      // Record samples metrics\n      if (metricsInstruments) {\n        recordSamplesMetric(\n          metricsInstruments,\n          buffer.length,\n          resultPickerUsed,\n          resultPickerUsed ? resultPickerLatency : undefined,\n          signatureName\n        );\n\n        // Record streaming metrics\n        recordStreamingMetric(\n          metricsInstruments,\n          isStreaming,\n          deltasEmitted,\n          undefined, // finalization latency not applicable here\n          signatureName\n        );\n      }\n\n      return result as unknown as OUT;\n    } catch (error) {\n      success = false;\n      throw error;\n    } finally {\n      const duration = performance.now() - startTime;\n\n      // Record generation metrics\n      const finalMetricsInstruments = this.getMetricsInstruments();\n      if (finalMetricsInstruments) {\n        recordGenerationMetric(\n          finalMetricsInstruments,\n          duration,\n          success,\n          signatureName,\n          ai.getName(),\n          options?.model ? String(options.model) : undefined\n        );\n\n        // Skip per-call function execution metric here; detailed metrics are recorded during processing\n\n        // Record error correction metrics\n        if (errorCorrectionAttempts > 0) {\n          recordErrorCorrectionMetric(\n            finalMetricsInstruments,\n            errorCorrectionAttempts,\n            success,\n            options?.maxRetries ?? 10,\n            signatureName\n          );\n        }\n      }\n    }\n  }\n\n  async *streamingForward<T extends Readonly<AxAIService>>(\n    ai: T,\n    values: IN | AxMessage<IN>[],\n    options?: Readonly<AxProgramStreamingForwardOptionsWithModels<T>>\n  ): AxGenStreamingOut<OUT> {\n    // If no result picker, use normal streaming\n    if (!options?.resultPicker) {\n      yield* this._forward1(ai, values, {\n        ...options,\n        stream: true,\n      });\n      return;\n    }\n\n    // For result picker, we need to buffer all results first\n    const generator = this._forward1(ai, values, {\n      ...options,\n      stream: true,\n    });\n\n    let buffer: AxGenDeltaOut<OUT>[] = [];\n    let currentVersion = 0;\n\n    for await (const delta of generator) {\n      if (delta.version !== currentVersion) {\n        buffer = [];\n      }\n      currentVersion = delta.version;\n      buffer = mergeDeltas<OUT>(buffer, delta);\n    }\n\n    // Use result picker to select from samples\n    const selectedIndex = await selectFromSamples(\n      buffer,\n      {\n        resultPicker: options?.resultPicker as\n          | AxResultPickerFunction<OUT>\n          | undefined,\n      },\n      // Pass memory to enable function result selection\n      options?.mem,\n      options?.sessionId\n    );\n\n    // Yield the selected result\n    const selectedResult = buffer[selectedIndex];\n    if (selectedResult) {\n      yield {\n        version: currentVersion,\n        index: selectedIndex,\n        delta: selectedResult.delta,\n      };\n    }\n  }\n\n  public override setExamples(\n    examples: Readonly<AxProgramExamples<IN, OUT>>,\n    options?: Readonly<AxSetExamplesOptions>\n  ) {\n    super.setExamples(examples, options);\n    // No need to update prompt template - all fields can be missing in examples\n  }\n\n  private isDebug(\n    ai: Readonly<AxAIService>,\n    options?: Readonly<AxProgramForwardOptions<any>>\n  ) {\n    return (\n      options?.debug ?? this.options?.debug ?? ai.getOptions().debug ?? false\n    );\n  }\n\n  private getLogger(\n    ai: Readonly<AxAIService>,\n    options?: Readonly<AxProgramForwardOptions<any>>\n  ) {\n    return (\n      options?.logger ??\n      this.options?.logger ??\n      axGlobals.logger ??\n      ai.getLogger()\n    );\n  }\n}\n\nexport type AxGenerateErrorDetails = {\n  model?: string;\n  maxTokens?: number;\n  streaming: boolean;\n  signature: {\n    input: Readonly<AxIField[]>;\n    output: Readonly<AxIField[]>;\n    description?: string;\n  };\n};\n\ntype ErrorOptions = { cause?: Error };\n\nexport class AxGenerateError extends Error {\n  public readonly details: AxGenerateErrorDetails;\n\n  constructor(\n    message: string,\n    details: Readonly<AxGenerateErrorDetails>,\n    options?: ErrorOptions\n  ) {\n    super(message);\n    this.name = 'AxGenerateError';\n    this.details = details;\n    // Set cause property dynamically to avoid TypeScript issues\n    if (options?.cause) {\n      (this as ErrorOptions).cause = options.cause;\n    }\n  }\n}\n\nfunction enhanceError(\n  e: unknown,\n  ai: Readonly<AxAIService>,\n  signature: Readonly<AxSignature>\n): Error {\n  const originalError = e instanceof Error ? e : new Error(String(e));\n  const model = ai.getLastUsedChatModel() as string | undefined;\n  const modelConfig = ai.getLastUsedModelConfig();\n\n  const details = {\n    model: model,\n    maxTokens: modelConfig?.maxTokens,\n    streaming: modelConfig?.stream ?? false,\n    signature: {\n      input: signature.getInputFields(),\n      output: signature.getOutputFields(),\n      description: signature.getDescription(),\n    },\n  };\n\n  // Return custom error with short message and details as object property\n  return new AxGenerateError('Generate failed', details, {\n    cause: originalError,\n  });\n}\n","// Removed debug imports - logging now handled in base.ts\nimport type {\n  AxChatRequest,\n  AxChatResponseResult,\n  AxFunctionResult,\n} from '../ai/types.js';\nimport {\n  axValidateChatRequestMessage,\n  axValidateChatResponseResult,\n} from '../ai/validate.js';\n\nimport type { AxAIMemory, AxMemoryData } from './types.js';\n\nexport class MemoryImpl {\n  private data: AxMemoryData = [];\n  private seenTags = new Set<string>();\n\n  addRequest(items: AxChatRequest['chatPrompt'], index: number): void {\n    this.data.push(\n      ...items.map((item) => {\n        const value = structuredClone(item);\n        return {\n          role: item.role,\n          chat: [{ index, value }],\n        };\n      })\n    );\n  }\n\n  addFunctionResults(results: Readonly<AxFunctionResult[]>): void {\n    const chat = results.map(({ index, ...value }) => ({\n      index,\n      value: structuredClone(value),\n    }));\n\n    const lastItem = this.getLast();\n    if (lastItem?.role === 'function') {\n      lastItem.chat.push(...chat);\n    } else {\n      this.data.push({ role: 'function', chat });\n    }\n  }\n\n  addResponse(results: Readonly<AxChatResponseResult[]>): void {\n    const chat = results.map(({ index, ...value }) => ({\n      index,\n      value: structuredClone(value),\n    }));\n\n    this.data.push({ role: 'assistant', chat });\n  }\n\n  updateResult({\n    content,\n    name,\n    functionCalls,\n    thought,\n    thoughtBlock,\n    index,\n  }: Readonly<AxChatResponseResult & { index: number }>): void {\n    const lastItem = this.data.at(-1);\n\n    if (\n      !lastItem ||\n      lastItem.role !== 'assistant' ||\n      (lastItem.role === 'assistant' && !lastItem.updatable)\n    ) {\n      this.data.push({\n        role: 'assistant',\n        updatable: true,\n        chat: [\n          {\n            index,\n            value: structuredClone({\n              content,\n              name,\n              functionCalls,\n              thought,\n              thoughtBlock,\n            }),\n          },\n        ],\n      });\n      return;\n    }\n\n    const chat = lastItem.chat.find((v) => v.index === index);\n\n    if (!chat) {\n      lastItem.chat.push({\n        index,\n        value: structuredClone({\n          content,\n          name,\n          functionCalls,\n          thought,\n          thoughtBlock,\n        }),\n      });\n      return;\n    }\n\n    if (typeof content === 'string' && content.trim() !== '') {\n      (chat.value as { content: string }).content = content;\n    }\n\n    if (typeof name === 'string' && name.trim() !== '') {\n      (chat.value as { name: string }).name = name;\n    }\n\n    if (Array.isArray(functionCalls) && functionCalls.length > 0) {\n      (chat.value as { functionCalls: typeof functionCalls }).functionCalls =\n        functionCalls;\n    }\n\n    if (typeof thought === 'string' && thought.trim() !== '') {\n      const existing = (chat.value as any).thought;\n      (chat.value as any).thought =\n        typeof existing === 'string' ? existing + thought : thought;\n    }\n\n    if (thoughtBlock && typeof thoughtBlock === 'object') {\n      const cur = ((chat.value as any).thoughtBlock ?? {}) as {\n        data?: string;\n        encrypted?: boolean;\n        signature?: string;\n      };\n      const merged = {\n        data: (cur.data ?? '') + (thoughtBlock.data ?? ''),\n        encrypted: Boolean(cur.encrypted) || Boolean(thoughtBlock.encrypted),\n        ...(thoughtBlock.signature\n          ? { signature: thoughtBlock.signature }\n          : {}),\n      } as { data: string; encrypted: boolean; signature?: string };\n      (chat.value as any).thoughtBlock = merged;\n    }\n  }\n\n  addTag(name: string): void {\n    const lastItem = this.data.at(-1);\n    if (!lastItem) {\n      return;\n    }\n\n    if (!lastItem.tags) {\n      lastItem.tags = [];\n    }\n\n    if (!lastItem.tags.includes(name)) {\n      lastItem.tags.push(name);\n    }\n    this.seenTags.add(name);\n  }\n\n  rewindToTag(name: string): AxMemoryData {\n    const tagIndex = this.data.findIndex((item) => item.tags?.includes(name));\n    if (tagIndex === -1) {\n      // If tag was never seen in this memory, throw; otherwise return []\n      if (!this.seenTags.has(name)) {\n        throw new Error(`Tag \"${name}\" not found`);\n      }\n      return [];\n    }\n\n    // Remove and return the tagged item and everything after it\n    return this.data.splice(tagIndex);\n  }\n\n  removeByTag(name: string): AxMemoryData {\n    const indices = this.data.reduce<number[]>((acc, item, index) => {\n      if (item.tags?.includes(name)) {\n        acc.push(index);\n      }\n      return acc;\n    }, []);\n\n    if (indices.length === 0) {\n      return [];\n    }\n\n    return indices\n      .reverse()\n      .map((index) => this.data.splice(index, 1).at(0))\n      .filter((item) => item !== undefined)\n      .reverse();\n  }\n\n  history(index: number): AxChatRequest['chatPrompt'] {\n    const result: AxChatRequest['chatPrompt'] = [];\n\n    for (const { role, chat } of this.data) {\n      let values: unknown;\n\n      if (role === 'function') {\n        values = chat.filter((v) => v.index === index).map((v) => v.value);\n      } else {\n        values = chat.find((v) => v.index === index)?.value;\n      }\n\n      if (Array.isArray(values) && values.length > 0) {\n        result.push(\n          ...values.map(\n            (v) => ({ ...v, role }) as AxChatRequest['chatPrompt'][number]\n          )\n        );\n      } else if (typeof values === 'object' && values !== null) {\n        result.push({ ...values, role } as AxChatRequest['chatPrompt'][number]);\n      }\n      // Skip when values is undefined (no matching index found)\n    }\n    return result;\n  }\n\n  getLast(): AxMemoryData[number] | undefined {\n    return this.data.at(-1);\n  }\n\n  reset(): void {\n    this.data = [];\n    this.seenTags = new Set<string>();\n  }\n}\n\nexport class AxMemory implements AxAIMemory {\n  private memories = new Map<string, MemoryImpl>();\n  private defaultMemory: MemoryImpl;\n\n  constructor() {\n    this.defaultMemory = new MemoryImpl();\n  }\n\n  private getMemory(sessionId?: string): MemoryImpl {\n    if (!sessionId) {\n      return this.defaultMemory;\n    }\n\n    if (!this.memories.has(sessionId)) {\n      this.memories.set(sessionId, new MemoryImpl());\n    }\n\n    return this.memories.get(sessionId) as MemoryImpl;\n  }\n\n  addRequest(value: AxChatRequest['chatPrompt'], sessionId?: string): void {\n    for (const item of value) {\n      axValidateChatRequestMessage(item);\n    }\n    this.getMemory(sessionId).addRequest(value, 0);\n  }\n\n  addResponse(\n    results: Readonly<AxChatResponseResult[]>,\n    sessionId?: string\n  ): void {\n    axValidateChatResponseResult(results);\n    this.getMemory(sessionId).addResponse(results);\n  }\n\n  addFunctionResults(\n    results: Readonly<AxFunctionResult[]>,\n    sessionId?: string\n  ): void {\n    this.getMemory(sessionId).addFunctionResults(results);\n  }\n\n  updateResult(\n    result: Readonly<AxChatResponseResult & { delta?: string }>,\n    sessionId?: string\n  ): void {\n    this.getMemory(sessionId).updateResult(result);\n  }\n\n  addTag(name: string, sessionId?: string) {\n    this.getMemory(sessionId).addTag(name);\n  }\n\n  rewindToTag(name: string, sessionId?: string) {\n    return this.getMemory(sessionId).rewindToTag(name);\n  }\n\n  removeByTag(name: string, sessionId?: string) {\n    return this.getMemory(sessionId).removeByTag(name);\n  }\n\n  history(index: number, sessionId?: string) {\n    return this.getMemory(sessionId).history(index);\n  }\n\n  getLast(sessionId?: string) {\n    return this.getMemory(sessionId).getLast();\n  }\n\n  reset(sessionId?: string): void {\n    if (!sessionId) {\n      this.defaultMemory.reset();\n    } else {\n      this.memories.set(sessionId, new MemoryImpl());\n    }\n  }\n}\n\n// Debug functions removed - logging now handled in base.ts\n","import type { extractionState } from './extract.js';\n\nexport interface AxAssertion<T = Record<string, unknown>> {\n  fn(\n    values: T\n  ): Promise<boolean | string | undefined> | boolean | string | undefined;\n  message?: string;\n}\n\nexport interface AxStreamingAssertion {\n  fieldName: string;\n  fn(content: string, done?: boolean): boolean | string | undefined;\n  message?: string;\n}\n\nexport class AxAssertionError extends Error {\n  constructor({\n    message,\n  }: Readonly<{\n    message: string;\n  }>) {\n    super(message);\n    this.name = this.constructor.name;\n  }\n\n  public getFixingInstructions = () => {\n    const extraFields = [];\n    const message = this.message.trim();\n\n    extraFields.push({\n      name: 'error',\n      title: 'Follow these instructions',\n      description: message + (message.endsWith('.') ? '' : '.'),\n    });\n\n    return extraFields;\n  };\n\n  override toString(): string {\n    return `${this.name}: ${this.message}`;\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')](\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _depth: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options: Record<string, unknown>\n  ) {\n    return this.toString();\n  }\n}\n\nexport const assertAssertions = async <T = Record<string, unknown>>(\n  asserts: readonly AxAssertion<T>[],\n  values: T\n) => {\n  for (const assert of asserts) {\n    const { fn, message } = assert;\n\n    const res = await fn(values);\n    if (res === undefined) {\n      continue;\n    }\n\n    // Handle string returns as failures with custom message\n    if (typeof res === 'string') {\n      throw new AxAssertionError({ message: res });\n    }\n\n    // Handle boolean returns\n    if (!res) {\n      if (!message) {\n        throw new Error('Assertion Failed: No message provided for assertion');\n      }\n      throw new AxAssertionError({ message });\n    }\n  }\n};\n\nexport const assertStreamingAssertions = async (\n  asserts: readonly AxStreamingAssertion[],\n  xstate: Readonly<extractionState>,\n  content: string,\n  final = false\n) => {\n  if (\n    !xstate.currField ||\n    xstate.s === -1 ||\n    !asserts ||\n    asserts.length === 0\n  ) {\n    return;\n  }\n\n  const fieldAsserts = asserts.filter(\n    (a) => a.fieldName === xstate.currField?.name\n  );\n\n  if (fieldAsserts.length === 0) {\n    return;\n  }\n\n  const currValue = content.substring(xstate.s);\n\n  for (const assert of fieldAsserts) {\n    const { message, fn } = assert;\n\n    const res = await fn(currValue, final);\n    if (res === undefined) {\n      continue;\n    }\n\n    // Handle string returns as failures with custom message\n    if (typeof res === 'string') {\n      throw new AxAssertionError({ message: res });\n    }\n\n    // Handle boolean returns\n    if (!res && message) {\n      throw new AxAssertionError({ message });\n    }\n  }\n};\n","import type { Counter, Gauge, Histogram, Meter } from '@opentelemetry/api';\n\nimport { axGlobals } from './globals.js';\n\n// Metrics configuration interface\nexport interface AxMetricsConfig {\n  enabled: boolean;\n  enabledCategories: (\n    | 'generation'\n    | 'streaming'\n    | 'functions'\n    | 'errors'\n    | 'performance'\n  )[];\n  maxLabelLength: number;\n  samplingRate: number;\n}\n\n// Default metrics configuration\nexport const axDefaultMetricsConfig: AxMetricsConfig = {\n  enabled: true,\n  enabledCategories: [\n    'generation',\n    'streaming',\n    'functions',\n    'errors',\n    'performance',\n  ],\n  maxLabelLength: 100,\n  samplingRate: 1.0,\n};\n\n// Standardized error categories for consistent error classification\nexport type AxErrorCategory =\n  | 'validation_error'\n  | 'assertion_error'\n  | 'timeout_error'\n  | 'abort_error'\n  | 'network_error'\n  | 'auth_error'\n  | 'rate_limit_error'\n  | 'function_error'\n  | 'parsing_error'\n  | 'unknown_error';\n\nexport interface AxGenMetricsInstruments {\n  // Generation flow metrics\n  generationLatencyHistogram?: Histogram;\n  generationRequestsCounter?: Counter;\n  generationErrorsCounter?: Counter;\n\n  // Multi-step flow metrics\n  multiStepGenerationsCounter?: Counter;\n  stepsPerGenerationHistogram?: Histogram;\n  maxStepsReachedCounter?: Counter;\n\n  // Error correction metrics\n  validationErrorsCounter?: Counter;\n  assertionErrorsCounter?: Counter;\n  errorCorrectionAttemptsHistogram?: Histogram;\n  errorCorrectionSuccessCounter?: Counter;\n  errorCorrectionFailureCounter?: Counter;\n  maxRetriesReachedCounter?: Counter;\n\n  // Function calling metrics\n  functionsEnabledGenerationsCounter?: Counter;\n  functionCallStepsCounter?: Counter;\n  functionsExecutedPerGenerationHistogram?: Histogram;\n  functionErrorCorrectionCounter?: Counter;\n\n  // Field processing metrics\n  fieldProcessorsExecutedCounter?: Counter;\n  streamingFieldProcessorsExecutedCounter?: Counter;\n\n  // Streaming specific metrics\n  streamingGenerationsCounter?: Counter;\n  streamingDeltasEmittedCounter?: Counter;\n  streamingFinalizationLatencyHistogram?: Histogram;\n\n  // Memory and samples metrics\n  samplesGeneratedHistogram?: Histogram;\n  resultPickerUsageCounter?: Counter;\n  resultPickerLatencyHistogram?: Histogram;\n\n  // Signature complexity metrics\n  inputFieldsGauge?: Gauge;\n  outputFieldsGauge?: Gauge;\n  examplesUsedGauge?: Gauge;\n  demosUsedGauge?: Gauge;\n\n  // Performance metrics\n  promptRenderLatencyHistogram?: Histogram;\n  extractionLatencyHistogram?: Histogram;\n  assertionLatencyHistogram?: Histogram;\n\n  // State management\n  stateCreationLatencyHistogram?: Histogram;\n  memoryUpdateLatencyHistogram?: Histogram;\n}\n\n// Singleton instance for metrics instruments\nlet globalGenMetricsInstruments: AxGenMetricsInstruments | undefined;\n\n// Function to get or create metrics instruments (singleton pattern)\nexport const getOrCreateGenMetricsInstruments = (\n  meter?: Meter\n): AxGenMetricsInstruments | undefined => {\n  // Return existing instance if available\n  if (globalGenMetricsInstruments) {\n    return globalGenMetricsInstruments;\n  }\n\n  // Try to use provided meter or fall back to global\n  const activeMeter = meter ?? axGlobals.meter;\n  if (activeMeter) {\n    globalGenMetricsInstruments = createGenMetricsInstruments(activeMeter);\n    return globalGenMetricsInstruments;\n  }\n\n  return undefined;\n};\n\n// Function to reset the singleton (useful for testing)\nexport const resetGenMetricsInstruments = (): void => {\n  globalGenMetricsInstruments = undefined;\n};\n\n// Health check for metrics system\nexport const axCheckMetricsHealth = (): {\n  healthy: boolean;\n  issues: string[];\n} => {\n  const issues: string[] = [];\n\n  if (!axGlobals.meter) {\n    issues.push('Global meter not initialized');\n  }\n\n  if (!globalGenMetricsInstruments && axGlobals.meter) {\n    issues.push('Metrics instruments not created despite available meter');\n  }\n\n  return {\n    healthy: issues.length === 0,\n    issues,\n  };\n};\n\nexport const createGenMetricsInstruments = (\n  meter: Meter\n): AxGenMetricsInstruments => {\n  return {\n    // Generation flow metrics\n    // Note: Histogram buckets should be configured at the exporter level\n    // Recommended buckets: [1, 5, 10, 25, 50, 100, 250, 500, 1000, 2500, 5000, 10000] ms\n    generationLatencyHistogram: meter.createHistogram(\n      'ax_gen_generation_duration_ms',\n      {\n        description: 'End-to-end duration of AxGen generation requests',\n        unit: 'ms',\n      }\n    ),\n\n    generationRequestsCounter: meter.createCounter(\n      'ax_gen_generation_requests_total',\n      {\n        description: 'Total number of AxGen generation requests',\n      }\n    ),\n\n    generationErrorsCounter: meter.createCounter(\n      'ax_gen_generation_errors_total',\n      {\n        description: 'Total number of failed AxGen generations',\n      }\n    ),\n\n    // Multi-step flow metrics\n    multiStepGenerationsCounter: meter.createCounter(\n      'ax_gen_multistep_generations_total',\n      {\n        description: 'Total number of generations that required multiple steps',\n      }\n    ),\n\n    stepsPerGenerationHistogram: meter.createHistogram(\n      'ax_gen_steps_per_generation',\n      {\n        description: 'Number of steps taken per generation',\n      }\n    ),\n\n    maxStepsReachedCounter: meter.createCounter(\n      'ax_gen_max_steps_reached_total',\n      {\n        description: 'Total number of generations that hit max steps limit',\n      }\n    ),\n\n    // Error correction metrics\n    validationErrorsCounter: meter.createCounter(\n      'ax_gen_validation_errors_total',\n      {\n        description: 'Total number of validation errors encountered',\n      }\n    ),\n\n    assertionErrorsCounter: meter.createCounter(\n      'ax_gen_assertion_errors_total',\n      {\n        description: 'Total number of assertion errors encountered',\n      }\n    ),\n\n    errorCorrectionAttemptsHistogram: meter.createHistogram(\n      'ax_gen_error_correction_attempts',\n      {\n        description: 'Number of error correction attempts per generation',\n      }\n    ),\n\n    errorCorrectionSuccessCounter: meter.createCounter(\n      'ax_gen_error_correction_success_total',\n      {\n        description: 'Total number of successful error corrections',\n      }\n    ),\n\n    errorCorrectionFailureCounter: meter.createCounter(\n      'ax_gen_error_correction_failure_total',\n      {\n        description: 'Total number of failed error corrections',\n      }\n    ),\n\n    maxRetriesReachedCounter: meter.createCounter(\n      'ax_gen_max_retries_reached_total',\n      {\n        description: 'Total number of generations that hit max retries limit',\n      }\n    ),\n\n    // Function calling metrics\n    functionsEnabledGenerationsCounter: meter.createCounter(\n      'ax_gen_functions_enabled_generations_total',\n      {\n        description: 'Total number of generations with functions enabled',\n      }\n    ),\n\n    functionCallStepsCounter: meter.createCounter(\n      'ax_gen_function_call_steps_total',\n      {\n        description: 'Total number of steps that included function calls',\n      }\n    ),\n\n    functionsExecutedPerGenerationHistogram: meter.createHistogram(\n      'ax_gen_functions_executed_per_generation',\n      {\n        description: 'Number of unique functions executed per generation',\n      }\n    ),\n\n    functionErrorCorrectionCounter: meter.createCounter(\n      'ax_gen_function_error_correction_total',\n      {\n        description: 'Total number of function-related error corrections',\n      }\n    ),\n\n    // Field processing metrics\n    fieldProcessorsExecutedCounter: meter.createCounter(\n      'ax_gen_field_processors_executed_total',\n      {\n        description: 'Total number of field processors executed',\n      }\n    ),\n\n    streamingFieldProcessorsExecutedCounter: meter.createCounter(\n      'ax_gen_streaming_field_processors_executed_total',\n      {\n        description: 'Total number of streaming field processors executed',\n      }\n    ),\n\n    // Streaming specific metrics\n    streamingGenerationsCounter: meter.createCounter(\n      'ax_gen_streaming_generations_total',\n      {\n        description: 'Total number of streaming generations',\n      }\n    ),\n\n    streamingDeltasEmittedCounter: meter.createCounter(\n      'ax_gen_streaming_deltas_emitted_total',\n      {\n        description: 'Total number of streaming deltas emitted',\n      }\n    ),\n\n    streamingFinalizationLatencyHistogram: meter.createHistogram(\n      'ax_gen_streaming_finalization_duration_ms',\n      {\n        description: 'Duration of streaming response finalization',\n        unit: 'ms',\n      }\n    ),\n\n    // Memory and samples metrics\n    samplesGeneratedHistogram: meter.createHistogram(\n      'ax_gen_samples_generated',\n      {\n        description: 'Number of samples generated per request',\n      }\n    ),\n\n    resultPickerUsageCounter: meter.createCounter(\n      'ax_gen_result_picker_usage_total',\n      {\n        description: 'Total number of times result picker was used',\n      }\n    ),\n\n    resultPickerLatencyHistogram: meter.createHistogram(\n      'ax_gen_result_picker_duration_ms',\n      {\n        description: 'Duration of result picker execution',\n        unit: 'ms',\n      }\n    ),\n\n    // Signature complexity metrics\n    inputFieldsGauge: meter.createGauge('ax_gen_input_fields', {\n      description: 'Number of input fields in signature',\n    }),\n\n    outputFieldsGauge: meter.createGauge('ax_gen_output_fields', {\n      description: 'Number of output fields in signature',\n    }),\n\n    examplesUsedGauge: meter.createGauge('ax_gen_examples_used', {\n      description: 'Number of examples used in generation',\n    }),\n\n    demosUsedGauge: meter.createGauge('ax_gen_demos_used', {\n      description: 'Number of demos used in generation',\n    }),\n\n    // Performance metrics\n    promptRenderLatencyHistogram: meter.createHistogram(\n      'ax_gen_prompt_render_duration_ms',\n      {\n        description: 'Duration of prompt template rendering',\n        unit: 'ms',\n      }\n    ),\n\n    extractionLatencyHistogram: meter.createHistogram(\n      'ax_gen_extraction_duration_ms',\n      {\n        description: 'Duration of value extraction from responses',\n        unit: 'ms',\n      }\n    ),\n\n    assertionLatencyHistogram: meter.createHistogram(\n      'ax_gen_assertion_duration_ms',\n      {\n        description: 'Duration of assertion checking',\n        unit: 'ms',\n      }\n    ),\n\n    // State management\n    stateCreationLatencyHistogram: meter.createHistogram(\n      'ax_gen_state_creation_duration_ms',\n      {\n        description: 'Duration of state creation for multiple samples',\n        unit: 'ms',\n      }\n    ),\n\n    memoryUpdateLatencyHistogram: meter.createHistogram(\n      'ax_gen_memory_update_duration_ms',\n      {\n        description: 'Duration of memory updates during generation',\n        unit: 'ms',\n      }\n    ),\n  };\n};\n\n// Global metrics configuration\nlet currentMetricsConfig: AxMetricsConfig = axDefaultMetricsConfig;\n\n// Function to update metrics configuration\nexport const axUpdateMetricsConfig = (\n  config: Readonly<Partial<AxMetricsConfig>>\n): void => {\n  currentMetricsConfig = { ...currentMetricsConfig, ...config };\n};\n\n// Function to get current metrics configuration\nexport const axGetMetricsConfig = (): AxMetricsConfig => {\n  return { ...currentMetricsConfig };\n};\n\n// Utility function to sanitize metric labels\nconst sanitizeLabels = (\n  labels: Record<string, unknown>\n): Record<string, string> => {\n  const sanitized: Record<string, string> = {};\n  for (const [key, value] of Object.entries(labels)) {\n    if (value !== undefined && value !== null) {\n      const stringValue = String(value);\n      // Limit label length based on configuration\n      const maxLength = currentMetricsConfig.maxLabelLength;\n      sanitized[key] =\n        stringValue.length > maxLength\n          ? stringValue.substring(0, maxLength)\n          : stringValue;\n    }\n  }\n  return sanitized;\n};\n\n// Recording functions for generation flow metrics\nexport const recordGenerationMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  duration: number,\n  success: boolean,\n  signatureName?: string,\n  aiService?: string,\n  model?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      success: success.toString(),\n      ...(signatureName ? { signature: signatureName } : {}),\n      ...(aiService ? { ai_service: aiService } : {}),\n      ...(model ? { model } : {}),\n    });\n\n    if (instruments.generationLatencyHistogram) {\n      instruments.generationLatencyHistogram.record(duration, labels);\n    }\n\n    if (instruments.generationRequestsCounter) {\n      instruments.generationRequestsCounter.add(1, labels);\n    }\n\n    if (!success && instruments.generationErrorsCounter) {\n      instruments.generationErrorsCounter.add(1, labels);\n    }\n  } catch (error) {\n    // Log error but don't propagate to avoid breaking the main flow\n    console.warn('Failed to record generation metric:', error);\n  }\n};\n\n// Recording functions for multi-step metrics\nexport const recordMultiStepMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  stepsUsed: number,\n  maxSteps: number,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (stepsUsed > 1 && instruments.multiStepGenerationsCounter) {\n      instruments.multiStepGenerationsCounter.add(1, labels);\n    }\n\n    if (instruments.stepsPerGenerationHistogram) {\n      instruments.stepsPerGenerationHistogram.record(stepsUsed, labels);\n    }\n\n    if (stepsUsed >= maxSteps && instruments.maxStepsReachedCounter) {\n      instruments.maxStepsReachedCounter.add(1, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record multi-step metric:', error);\n  }\n};\n\n// Recording functions for error correction metrics\nexport const recordValidationErrorMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  errorType: 'validation' | 'assertion',\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      error_type: errorType,\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (errorType === 'validation' && instruments.validationErrorsCounter) {\n      instruments.validationErrorsCounter.add(1, labels);\n    }\n\n    if (errorType === 'assertion' && instruments.assertionErrorsCounter) {\n      instruments.assertionErrorsCounter.add(1, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record validation error metric:', error);\n  }\n};\n\nexport const recordRefusalErrorMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      error_type: 'refusal',\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    // For now, we'll count refusal errors as validation errors since they trigger retry loops\n    if (instruments.validationErrorsCounter) {\n      instruments.validationErrorsCounter.add(1, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record refusal error metric:', error);\n  }\n};\n\nexport const recordErrorCorrectionMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  attempts: number,\n  success: boolean,\n  maxRetries: number,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      success: success.toString(),\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (instruments.errorCorrectionAttemptsHistogram) {\n      instruments.errorCorrectionAttemptsHistogram.record(attempts, labels);\n    }\n\n    if (success && instruments.errorCorrectionSuccessCounter) {\n      instruments.errorCorrectionSuccessCounter.add(1, labels);\n    }\n\n    if (!success) {\n      if (instruments.errorCorrectionFailureCounter) {\n        instruments.errorCorrectionFailureCounter.add(1, labels);\n      }\n      if (attempts >= maxRetries && instruments.maxRetriesReachedCounter) {\n        instruments.maxRetriesReachedCounter.add(1, labels);\n      }\n    }\n  } catch (error) {\n    console.warn('Failed to record error correction metric:', error);\n  }\n};\n\n// Recording functions for function calling metrics\nexport const recordFunctionCallingMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  functionsEnabled: boolean,\n  functionsExecuted: number,\n  hadFunctionCalls: boolean,\n  functionErrorCorrection = false,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      functions_enabled: functionsEnabled.toString(),\n      had_function_calls: hadFunctionCalls.toString(),\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (functionsEnabled && instruments.functionsEnabledGenerationsCounter) {\n      instruments.functionsEnabledGenerationsCounter.add(1, labels);\n    }\n\n    if (hadFunctionCalls && instruments.functionCallStepsCounter) {\n      instruments.functionCallStepsCounter.add(1, labels);\n    }\n\n    if (\n      functionsExecuted > 0 &&\n      instruments.functionsExecutedPerGenerationHistogram\n    ) {\n      instruments.functionsExecutedPerGenerationHistogram.record(\n        functionsExecuted,\n        labels\n      );\n    }\n\n    if (functionErrorCorrection && instruments.functionErrorCorrectionCounter) {\n      instruments.functionErrorCorrectionCounter.add(1, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record function calling metric:', error);\n  }\n};\n\n// Recording functions for field processing metrics\nexport const recordFieldProcessingMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  fieldProcessorsExecuted: number,\n  streamingFieldProcessorsExecuted: number,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (\n      fieldProcessorsExecuted > 0 &&\n      instruments.fieldProcessorsExecutedCounter\n    ) {\n      instruments.fieldProcessorsExecutedCounter.add(\n        fieldProcessorsExecuted,\n        labels\n      );\n    }\n\n    if (\n      streamingFieldProcessorsExecuted > 0 &&\n      instruments.streamingFieldProcessorsExecutedCounter\n    ) {\n      instruments.streamingFieldProcessorsExecutedCounter.add(\n        streamingFieldProcessorsExecuted,\n        labels\n      );\n    }\n  } catch (error) {\n    console.warn('Failed to record field processing metric:', error);\n  }\n};\n\n// Recording functions for streaming metrics\nexport const recordStreamingMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  isStreaming: boolean,\n  deltasEmitted: number,\n  finalizationDuration?: number,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      is_streaming: isStreaming.toString(),\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (isStreaming && instruments.streamingGenerationsCounter) {\n      instruments.streamingGenerationsCounter.add(1, labels);\n    }\n\n    if (deltasEmitted > 0 && instruments.streamingDeltasEmittedCounter) {\n      instruments.streamingDeltasEmittedCounter.add(deltasEmitted, labels);\n    }\n\n    if (\n      finalizationDuration &&\n      instruments.streamingFinalizationLatencyHistogram\n    ) {\n      instruments.streamingFinalizationLatencyHistogram.record(\n        finalizationDuration,\n        labels\n      );\n    }\n  } catch (error) {\n    console.warn('Failed to record streaming metric:', error);\n  }\n};\n\n// Recording functions for samples metrics\nexport const recordSamplesMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  samplesCount: number,\n  resultPickerUsed: boolean,\n  resultPickerLatency?: number,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      result_picker_used: resultPickerUsed.toString(),\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (instruments.samplesGeneratedHistogram) {\n      instruments.samplesGeneratedHistogram.record(samplesCount, labels);\n    }\n\n    if (resultPickerUsed && instruments.resultPickerUsageCounter) {\n      instruments.resultPickerUsageCounter.add(1, labels);\n    }\n\n    if (resultPickerLatency && instruments.resultPickerLatencyHistogram) {\n      instruments.resultPickerLatencyHistogram.record(\n        resultPickerLatency,\n        labels\n      );\n    }\n  } catch (error) {\n    console.warn('Failed to record samples metric:', error);\n  }\n};\n\n// Recording functions for signature complexity metrics\nexport const recordSignatureComplexityMetrics = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  inputFields: number,\n  outputFields: number,\n  examplesCount: number,\n  demosCount: number,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (instruments.inputFieldsGauge) {\n      instruments.inputFieldsGauge.record(inputFields, labels);\n    }\n\n    if (instruments.outputFieldsGauge) {\n      instruments.outputFieldsGauge.record(outputFields, labels);\n    }\n\n    if (instruments.examplesUsedGauge) {\n      instruments.examplesUsedGauge.record(examplesCount, labels);\n    }\n\n    if (instruments.demosUsedGauge) {\n      instruments.demosUsedGauge.record(demosCount, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record signature complexity metrics:', error);\n  }\n};\n\n// Recording functions for performance metrics\nexport const recordPerformanceMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  metricType:\n    | 'prompt_render'\n    | 'extraction'\n    | 'assertion'\n    | 'state_creation'\n    | 'memory_update',\n  duration: number,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      metric_type: metricType,\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    switch (metricType) {\n      case 'prompt_render':\n        if (instruments.promptRenderLatencyHistogram) {\n          instruments.promptRenderLatencyHistogram.record(duration, labels);\n        }\n        break;\n      case 'extraction':\n        if (instruments.extractionLatencyHistogram) {\n          instruments.extractionLatencyHistogram.record(duration, labels);\n        }\n        break;\n      case 'assertion':\n        if (instruments.assertionLatencyHistogram) {\n          instruments.assertionLatencyHistogram.record(duration, labels);\n        }\n        break;\n      case 'state_creation':\n        if (instruments.stateCreationLatencyHistogram) {\n          instruments.stateCreationLatencyHistogram.record(duration, labels);\n        }\n        break;\n      case 'memory_update':\n        if (instruments.memoryUpdateLatencyHistogram) {\n          instruments.memoryUpdateLatencyHistogram.record(duration, labels);\n        }\n        break;\n    }\n  } catch (error) {\n    console.warn('Failed to record performance metric:', error);\n  }\n};\n","import type { Span } from '@opentelemetry/api';\nimport {\n  logAssertionError,\n  logRefusalError,\n  logValidationError,\n} from '../ai/debug.js';\nimport type { AxLoggerFunction } from '../ai/types.js';\nimport type { AxAIRefusalError } from '../util/apicall.js';\nimport type { AxAssertionError } from './asserts.js';\nimport type { AxGenMetricsInstruments } from './metrics.js';\nimport {\n  recordRefusalErrorMetric,\n  recordValidationErrorMetric,\n} from './metrics.js';\nimport type { AxField } from './sig.js';\n\nconst toFieldType = (type: Readonly<AxField['type']>) => {\n  const baseType = (() => {\n    switch (type?.name) {\n      case 'string':\n        return 'string';\n      case 'number':\n        return 'number';\n      case 'boolean':\n        return 'boolean';\n      case 'date':\n        return 'date (\"YYYY-MM-DD\" format)';\n      case 'datetime':\n        return 'date time (\"YYYY-MM-DD HH:mm Timezone\" format)';\n      case 'json':\n        return 'JSON object';\n      case 'class':\n        return 'classification class';\n      case 'code':\n        return 'code';\n      default:\n        return 'string';\n    }\n  })();\n\n  return type?.isArray ? `json array of ${baseType} items` : baseType;\n};\n\nexport class ValidationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = this.constructor.name;\n  }\n\n  public getFixingInstructions = () => {\n    return [\n      {\n        name: 'outputError',\n        title: 'Invalid Field **Only return the invalid, remaining fields**',\n        description: this.message,\n      },\n    ];\n  };\n\n  override toString(): string {\n    return `${this.name}: ${this.message}`;\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')](\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _depth: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options: Record<string, unknown>\n  ) {\n    return this.toString();\n  }\n}\n\n// Helper factories to create targeted ValidationErrors with actionable guidance\nexport const createMissingRequiredFieldsError = (\n  fields: Readonly<AxField[]>\n) => {\n  const parts = fields.map((f) => `'${f.title}' (${toFieldType(f.type)})`);\n  const list = parts.join(', ');\n  return new ValidationError(\n    `Required field not found: ${list}. Add a line starting with the exact label followed by a colon (e.g., \"${fields[0]?.title}:\") and then provide a valid ${toFieldType(fields[0]?.type)} value. Keep the output concise and avoid unrelated text.`\n  );\n};\n\nexport const createExpectedRequiredFieldNotFoundError = (\n  field: Readonly<AxField>\n) =>\n  new ValidationError(\n    `Expected (Required) field not found: '${field.title}'. Begin a new section with \"${field.title}:\" and then provide a valid ${toFieldType(field.type)} value directly after.`\n  );\n\nexport const createExpectedFieldNotFoundError = (field: Readonly<AxField>) =>\n  new ValidationError(\n    `Expected field not found: '${field.title}'. Add the exact label \"${field.title}:\" and then provide a valid ${toFieldType(field.type)} value.`\n  );\n\nexport const createRequiredFieldMissingError = (field: Readonly<AxField>) =>\n  new ValidationError(\n    `Required field is missing: '${field.title}'. After the \"${field.title}:\" label, provide a non-empty ${toFieldType(field.type)}. Do not use null, undefined, or leave it blank.`\n  );\n\nexport const createInvalidJsonError = (\n  field: Readonly<AxField>,\n  detail: string\n) =>\n  new ValidationError(\n    `Invalid JSON: ${detail} in field '${field.title}'. Return only valid JSON. Prefer a fenced code block containing a single JSON object or array with no trailing text.`\n  );\n\nexport const createInvalidArrayError = (\n  field: Readonly<AxField>,\n  detail: string\n) =>\n  new ValidationError(\n    `Invalid Array: ${detail} for '${field.title}'. Provide a JSON array of ${toFieldType(field.type)} items (e.g., [ ... ]). Markdown lists are also accepted if each item is on its own line starting with a hyphen.`\n  );\n\nexport const createTypeValidationError = (\n  field: Readonly<AxField>,\n  fieldValue: string,\n  detail: string\n) =>\n  new ValidationError(\n    `Field '${field.title}' has an invalid value '${fieldValue}': ${detail}. Provide a ${toFieldType(field.type)}. Ensure formatting exactly matches the expected type.`\n  );\n\nexport const createInvalidDateError = (\n  field: Readonly<AxField>,\n  dateStr: string,\n  detail: string\n) =>\n  new ValidationError(\n    `Invalid date for '${field.title}': ${detail}. Use the exact format YYYY-MM-DD (e.g., 2024-05-09). You provided: ${dateStr}.`\n  );\n\nexport const createInvalidDateTimeError = (\n  field: Readonly<AxField>,\n  dateStr: string,\n  detail: string\n) =>\n  new ValidationError(\n    `Invalid date/time for '${field.title}': ${detail}. Use the format YYYY-MM-DD HH:mm or YYYY-MM-DD HH:mm:ss followed by a valid timezone (e.g., America/New_York). You provided: ${dateStr}.`\n  );\n\nexport const createMissingToolArgumentsError = (\n  toolName: string,\n  missingFields: readonly AxField[]\n) => {\n  const fieldTitles = missingFields.map((field) => field.title);\n  const fieldExamples = missingFields.map(\n    (field) => `${field.name}: <${toFieldType(field.type)}>`\n  );\n  return new ValidationError(\n    `Missing required fields for tool '${toolName}': ${fieldTitles.join(', ')}. Add lines with the exact labels followed by colons (e.g., \"${fieldTitles[0]}:\") and then provide valid values. Required fields: ${fieldExamples.join(', ')}.`\n  );\n};\n\nexport type HandleErrorForGenerateArgs<TError extends Error> = {\n  error: TError;\n  errCount: number;\n  logger: AxLoggerFunction | undefined;\n  metricsInstruments: AxGenMetricsInstruments | undefined;\n  signatureName: string;\n  span: Span | undefined;\n  debug: boolean;\n};\n\n/**\n * Handles validation errors with logging, metrics, and telemetry\n */\nexport const handleValidationErrorForGenerate = ({\n  error,\n  errCount,\n  debug,\n  logger,\n  metricsInstruments,\n  signatureName,\n  span,\n}: HandleErrorForGenerateArgs<ValidationError>) => {\n  const errorFields = error.getFixingInstructions();\n\n  // Log validation error with proper structured logging\n  if (debug && logger) {\n    const fixingInstructions =\n      errorFields?.map((f) => f.title).join(', ') ?? '';\n    logValidationError(error, errCount, fixingInstructions, logger);\n  }\n\n  // Record validation error metric\n  if (metricsInstruments) {\n    recordValidationErrorMetric(\n      metricsInstruments,\n      'validation',\n      signatureName\n    );\n  }\n\n  // Add telemetry event for validation error\n  if (span) {\n    span.addEvent('validation.error', {\n      message: error.toString(),\n      fixing_instructions: errorFields?.map((f) => f.title).join(', ') ?? '',\n    });\n  }\n\n  return errorFields;\n};\n\n/**\n * Handles assertion errors with logging, metrics, and telemetry\n */\nexport const handleAssertionErrorForGenerate = ({\n  error,\n  errCount,\n  debug,\n  logger,\n  metricsInstruments,\n  signatureName,\n  span,\n}: HandleErrorForGenerateArgs<AxAssertionError>) => {\n  const errorFields = error.getFixingInstructions();\n\n  // Log assertion error with proper structured logging\n  if (debug && logger) {\n    const fixingInstructions =\n      errorFields?.map((f) => f.title).join(', ') ?? '';\n    logAssertionError(error, errCount, fixingInstructions, logger);\n  }\n\n  // Record assertion error metric\n  if (metricsInstruments) {\n    recordValidationErrorMetric(metricsInstruments, 'assertion', signatureName);\n  }\n\n  // Add telemetry event for assertion error\n  if (span) {\n    span.addEvent('assertion.error', {\n      message: error.toString(),\n      fixing_instructions: errorFields?.map((f) => f.title).join(', ') ?? '',\n    });\n  }\n\n  return errorFields;\n};\n\n/**\n * Handles refusal errors with logging, metrics, and telemetry\n */\nexport const handleRefusalErrorForGenerate = ({\n  error,\n  errCount,\n  debug,\n  logger,\n  metricsInstruments,\n  signatureName,\n  span,\n}: HandleErrorForGenerateArgs<AxAIRefusalError>) => {\n  // Log refusal error with proper structured logging\n  if (debug && logger) {\n    logRefusalError(error, errCount, logger);\n  }\n\n  // Record refusal error metric\n  if (metricsInstruments) {\n    recordRefusalErrorMetric(metricsInstruments, signatureName);\n  }\n\n  // Add telemetry event for refusal error\n  if (span) {\n    span.addEvent('refusal.error', {\n      message: error.toString(),\n    });\n  }\n};\n","import type { AxFunctionJSONSchema } from '../ai/types.js';\n\n// Extended type to handle flexible JSON schemas with union types\ntype FlexibleJSONSchema = AxFunctionJSONSchema & {\n  anyOf?: FlexibleJSONSchema[];\n  oneOf?: FlexibleJSONSchema[];\n  allOf?: FlexibleJSONSchema[];\n  properties?: Record<string, FlexibleJSONSchema | undefined>;\n};\n\ninterface ValidationError {\n  path: string;\n  issue: string;\n  fix: string;\n  example?: string;\n}\n\nexport const validateJSONSchema = (\n  schema: Readonly<AxFunctionJSONSchema>\n): void => {\n  const errors: ValidationError[] = [];\n\n  const validateSchemaObject = (\n    schema: Readonly<FlexibleJSONSchema | undefined>,\n    path = ''\n  ): void => {\n    // Skip validation if schema is undefined or null\n    if (!schema || typeof schema !== 'object') {\n      return;\n    }\n\n    const validTypes = [\n      'array',\n      'integer',\n      'number',\n      'string',\n      'boolean',\n      'null',\n      'object',\n    ];\n\n    // Handle schemas with anyOf (union types)\n    if (schema.anyOf && Array.isArray(schema.anyOf)) {\n      if (schema.anyOf.length === 0) {\n        errors.push({\n          path: path || 'root',\n          issue: 'anyOf array is empty',\n          fix: 'Add at least one schema to the anyOf array',\n          example: 'anyOf: [{ type: \"string\" }, { type: \"null\" }]',\n        });\n      }\n      // Validate each schema in anyOf\n      schema.anyOf.forEach((subSchema: FlexibleJSONSchema, index: number) => {\n        validateSchemaObject(subSchema, `${path}anyOf[${index}].`);\n      });\n      return;\n    }\n\n    // Handle schemas with oneOf\n    if (schema.oneOf && Array.isArray(schema.oneOf)) {\n      if (schema.oneOf.length === 0) {\n        errors.push({\n          path: path || 'root',\n          issue: 'oneOf array is empty',\n          fix: 'Add at least one schema to the oneOf array',\n          example: 'oneOf: [{ type: \"string\" }, { type: \"number\" }]',\n        });\n      }\n      schema.oneOf.forEach((subSchema: FlexibleJSONSchema, index: number) => {\n        validateSchemaObject(subSchema, `${path}oneOf[${index}].`);\n      });\n      return;\n    }\n\n    // Handle schemas with allOf\n    if (schema.allOf && Array.isArray(schema.allOf)) {\n      if (schema.allOf.length === 0) {\n        errors.push({\n          path: path || 'root',\n          issue: 'allOf array is empty',\n          fix: 'Add at least one schema to the allOf array',\n          example:\n            'allOf: [{ type: \"object\" }, { properties: { name: { type: \"string\" } } }]',\n        });\n      }\n      schema.allOf.forEach((subSchema: FlexibleJSONSchema, index: number) => {\n        validateSchemaObject(subSchema, `${path}allOf[${index}].`);\n      });\n      return;\n    }\n\n    // Skip validation if no type is specified (might be a reference or other valid schema)\n    if (!schema.type) {\n      return;\n    }\n\n    if (!validTypes.includes(schema.type)) {\n      errors.push({\n        path: path || 'root',\n        issue: `Invalid type '${schema.type}'`,\n        fix: `Change type to one of: ${validTypes.join(', ')}`,\n        example: `{ type: \"string\" } or { type: \"object\" }`,\n      });\n      return;\n    }\n\n    if (schema.type === 'object') {\n      if (schema.properties) {\n        if (\n          typeof schema.properties !== 'object' ||\n          Array.isArray(schema.properties)\n        ) {\n          errors.push({\n            path: path || 'root',\n            issue: 'properties must be an object, not an array or primitive',\n            fix: 'Change properties to be an object with property names as keys',\n            example:\n              'properties: { name: { type: \"string\" }, age: { type: \"number\" } }',\n          });\n        } else {\n          for (const key in schema.properties) {\n            const value = schema.properties[key];\n            // Skip undefined or null properties\n            if (value === undefined || value === null) {\n              continue;\n            }\n            if (typeof value !== 'object') {\n              errors.push({\n                path: `${path}${key}`,\n                issue: `Property schema must be an object, got ${typeof value}`,\n                fix: 'Define the property as a proper schema object',\n                example: `${key}: { type: \"string\", description: \"...\" }`,\n              });\n              continue;\n            }\n            validateSchemaObject(value, `${path}${key}.`);\n          }\n        }\n      }\n\n      if (schema.required) {\n        if (!Array.isArray(schema.required)) {\n          errors.push({\n            path: path || 'root',\n            issue: `'required' must be an array, got ${typeof schema.required}`,\n            fix: 'Change required to be an array of property names',\n            example:\n              'required: [\"name\", \"email\"] instead of required: \"name,email\"',\n          });\n        } else if (schema.required.length === 0) {\n          // This is valid but might be worth noting\n        } else {\n          // Validate that required properties exist in properties\n          if (schema.properties) {\n            for (const requiredProp of schema.required) {\n              if (typeof requiredProp !== 'string') {\n                errors.push({\n                  path: `${path}required`,\n                  issue: `Required property names must be strings, got ${typeof requiredProp}`,\n                  fix: 'Ensure all items in required array are strings',\n                  example:\n                    'required: [\"name\", \"email\"] not required: [123, \"email\"]',\n                });\n              } else if (!(requiredProp in schema.properties)) {\n                errors.push({\n                  path: `${path}required`,\n                  issue: `Required property '${requiredProp}' is not defined in properties`,\n                  fix: `Either add '${requiredProp}' to properties or remove it from required`,\n                  example: `properties: { ${requiredProp}: { type: \"string\" } }`,\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (schema.type === 'array') {\n      if (schema.items) {\n        if (typeof schema.items !== 'object') {\n          errors.push({\n            path: `${path}items`,\n            issue: `Array items schema must be an object, got ${typeof schema.items}`,\n            fix: 'Define items as a proper schema object',\n            example:\n              'items: { type: \"string\" } or items: { type: \"object\", properties: {...} }',\n          });\n        } else {\n          validateSchemaObject(schema.items, `${path}items.`);\n        }\n      } else {\n        // Enforce JSON Schema requirement that arrays specify an items schema\n        errors.push({\n          path: path || 'root',\n          issue:\n            'Array schema is missing an \"items\" definition (required by JSON Schema and all LLM providers for function tools)',\n          fix: 'Add an \"items\" schema describing the array element type, e.g., items: { type: \"string\" } or items: { type: \"object\", properties: { ... } }',\n          example: [\n            'type: \"array\",',\n            'description: \"List of step strings\"',\n            'items: { type: \"string\" }',\n          ].join('\\n'),\n        });\n      }\n    }\n  };\n\n  validateSchemaObject(schema);\n\n  if (errors.length > 0) {\n    const errorMessage = [\n      'JSON Schema validation failed:',\n      '',\n      ...errors.map((error, index) => {\n        const parts = [\n          `${index + 1}. Path: ${error.path}`,\n          `   Issue: ${error.issue}`,\n          `   Fix: ${error.fix}`,\n        ];\n        if (error.example) {\n          parts.push(`   Example: ${error.example}`);\n        }\n        return parts.join('\\n');\n      }),\n      '',\n      'Please fix these issues and try again.',\n    ].join('\\n');\n\n    throw new Error(errorMessage);\n  }\n};\n\n// Example Usage:\n\n/*\nconst validSchema: AxFunctionJSONSchema = {\n  type: 'object',\n  properties: {\n    id: { type: 'integer' },\n    name: { type: 'string' },\n    email: { type: 'string' },\n    isActive: { type: 'boolean' },\n    tags: {\n      type: 'array',\n      items: { type: 'string' }\n    },\n    optionalField: {\n      anyOf: [\n        { type: 'string' },\n        { type: 'null' }\n      ]\n    }\n  },\n  required: ['id', 'name', 'email']\n};\n\nconst invalidSchema: any = {\n  type: 'object',\n  properties: {\n    id: { type: 'integer' },\n    name: { type: 'string' },\n    email: { type: 'unknownType' }, // Invalid type\n    isActive: { type: 'boolean' },\n    tags: {\n      type: 'array',\n      items: { type: 'string' }\n    }\n  },\n  required: 'id,name,email' // Invalid 'required' field\n};\n\ntry {\n  validateJSONSchema(validSchema);\n} catch (error) {\n  console.error('Schema validation failed:', error.message);\n}\n\ntry {\n  validateJSONSchema(invalidSchema);\n} catch (error) {\n  console.error('Schema validation failed:', error.message);\n}\n*/\n","import { logFunctionError, logFunctionResults } from '../ai/debug.js';\n// Note: We intentionally avoid importing OpenTelemetry types directly here to\n// keep this module portable across environments that may not resolve OTel types.\nimport type {\n  AxAIService,\n  AxChatRequest,\n  AxChatResponseResult,\n  AxFunction,\n  AxFunctionResult,\n  AxLoggerFunction,\n} from '../ai/types.js';\nimport type { AxMemory } from '../mem/memory.js';\nimport { axGlobals } from './globals.js';\nimport { validateJSONSchema } from './jsonschema.js';\nimport type { AxProgramForwardOptions } from './types.js';\n\nexport class AxStopFunctionCallException extends Error {\n  public readonly calls: ReadonlyArray<{\n    func: Readonly<AxFunction>;\n    args: unknown;\n    result: unknown;\n  }>;\n\n  constructor(\n    calls: ReadonlyArray<{\n      func: Readonly<AxFunction>;\n      args: unknown;\n      result: unknown;\n    }>\n  ) {\n    super(\n      `Stop function executed: ${calls.map((c) => c.func.name).join(', ')}`\n    );\n    this.name = 'AxStopFunctionCallException';\n    this.calls = calls;\n  }\n}\n\nexport class AxFunctionError extends Error {\n  constructor(\n    private fields: {\n      field: string;\n      message: string;\n    }[]\n  ) {\n    super();\n    this.name = this.constructor.name;\n  }\n\n  getFields = () => this.fields;\n\n  override toString(): string {\n    return [\n      `${this.name}: Function validation error`,\n      ...this.fields.map((field) => `  - ${field.field}: ${field.message}`),\n    ].join('\\n');\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')](\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _depth: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options: Record<string, unknown>\n  ) {\n    return this.toString();\n  }\n}\n\ntype FunctionFieldErrors = ConstructorParameters<typeof AxFunctionError>[0];\n\nexport class FunctionError extends Error {\n  constructor(\n    private readonly fields: FunctionFieldErrors,\n    private readonly func: Readonly<AxFunction>,\n    private readonly funcId?: string\n  ) {\n    super();\n  }\n\n  getFunctionId = () => this.funcId;\n\n  private getFieldDescription(fieldName: string): string {\n    if (!this.func.parameters?.properties?.[fieldName]) {\n      return '';\n    }\n\n    const fieldSchema = this.func.parameters.properties[fieldName];\n    let description = fieldSchema.description;\n\n    if (fieldSchema.enum?.length) {\n      description += ` Allowed values are: ${fieldSchema.enum.join(', ')}`;\n    }\n\n    return description;\n  }\n\n  public getFixingInstructions = () => {\n    const bulletPoints = this.fields.map((fieldError) => {\n      const schemaDescription =\n        this.getFieldDescription(fieldError.field) || '';\n      return `- \\`${fieldError.field}\\` - ${fieldError.message} (${schemaDescription}).`;\n    });\n\n    return `Errors In Function Arguments: Fix the following invalid arguments to '${this.func.name}'\\n${bulletPoints.join('\\n')}`;\n  };\n\n  override toString(): string {\n    return [\n      `${this.name}: Function execution error in '${this.func.name}'`,\n      ...this.fields.map((field) => {\n        const description = this.getFieldDescription(field.field);\n        return `  - ${field.field}: ${field.message}${description ? ` (${description})` : ''}`;\n      }),\n      this.funcId ? `  Function ID: ${this.funcId}` : '',\n    ].join('\\n');\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')](\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _depth: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options: Record<string, unknown>\n  ) {\n    return this.toString();\n  }\n}\n\nexport type AxChatResponseFunctionCall = {\n  id: string;\n  name: string;\n  args: string;\n};\n\nexport class AxFunctionProcessor {\n  private funcList: Readonly<AxFunction[]> = [];\n\n  constructor(funcList: Readonly<AxFunction[]>) {\n    this.funcList = funcList;\n  }\n\n  private executeFunction = async <MODEL>(\n    fnSpec: Readonly<AxFunction>,\n    func: Readonly<AxChatResponseFunctionCall>,\n    options?: Readonly<\n      AxProgramForwardOptions<MODEL> & {\n        traceId?: string;\n        stopFunctionNames?: readonly string[];\n      }\n    >\n  ) => {\n    let args: unknown;\n\n    if (typeof func.args === 'string' && func.args.length > 0) {\n      try {\n        args = JSON.parse(func.args);\n      } catch (e) {\n        throw new Error(`Invalid function arguments: ${func.args}`, {\n          cause: e,\n        });\n      }\n    } else {\n      args = func.args;\n    }\n\n    const opt = options\n      ? {\n          sessionId: options.sessionId,\n          traceId: options.traceId,\n          ai: options.ai,\n        }\n      : undefined;\n\n    let res: unknown;\n    if (!fnSpec.parameters) {\n      res =\n        fnSpec.func.length === 1 ? await fnSpec.func(opt) : await fnSpec.func();\n    } else {\n      res =\n        fnSpec.func.length === 2\n          ? await fnSpec.func(args, opt)\n          : await fnSpec.func(args);\n    }\n\n    const formatter =\n      options?.functionResultFormatter ?? axGlobals.functionResultFormatter;\n    const formatted = formatter(res);\n    return {\n      formatted: String(formatted),\n      rawResult: res,\n      parsedArgs: args,\n    } as const;\n  };\n\n  public executeWithDetails = async <MODEL>(\n    func: Readonly<AxChatResponseFunctionCall>,\n    options?: Readonly<\n      AxProgramForwardOptions<MODEL> & {\n        traceId?: string;\n        stopFunctionNames?: readonly string[];\n      }\n    >\n  ): Promise<{\n    formatted: string;\n    rawResult: unknown;\n    parsedArgs: unknown;\n  }> => {\n    const normalize = (s: string) =>\n      s.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();\n    const target = normalize(func.name);\n\n    let fnSpec = this.funcList.find((v) => v.name === func.name);\n    if (!fnSpec) {\n      fnSpec = this.funcList.find((v) => normalize(v.name) === target);\n    }\n    if (!fnSpec) {\n      throw new Error(`Function not found: ${func.name}`);\n    }\n    if (!fnSpec.func) {\n      throw new Error(`No handler for function: ${func.name}`);\n    }\n\n    try {\n      return await this.executeFunction<MODEL>(fnSpec, func, options);\n    } catch (e) {\n      if (e instanceof AxFunctionError) {\n        throw new FunctionError(e.getFields(), fnSpec, func.id);\n      }\n      throw e;\n    }\n  };\n\n  public execute = async <MODEL>(\n    func: Readonly<AxChatResponseFunctionCall>,\n    options?: Readonly<\n      AxProgramForwardOptions<MODEL> & {\n        traceId?: string;\n        stopFunctionNames?: readonly string[];\n      }\n    >\n  ): Promise<string> => {\n    const result = await this.executeWithDetails<MODEL>(func, options);\n    return result.formatted;\n  };\n}\n\nexport type AxInputFunctionType = (\n  | AxFunction\n  | {\n      toFunction: () => AxFunction | AxFunction[];\n    }\n)[];\n\nexport const parseFunctions = (\n  newFuncs: Readonly<AxInputFunctionType>,\n  existingFuncs?: readonly AxFunction[]\n): AxFunction[] => {\n  if (newFuncs.length === 0) {\n    return [...(existingFuncs ?? [])];\n  }\n\n  // biome-ignore lint/complexity/useFlatMap: cannot use flatMap here\n  const functions = newFuncs\n    .map((f) => {\n      if ('toFunction' in f) {\n        return f.toFunction();\n      }\n      return f;\n    })\n    .flat();\n\n  for (const fn of functions.filter((v) => v.parameters)) {\n    if (fn.parameters) {\n      try {\n        validateJSONSchema(fn.parameters);\n      } catch (e) {\n        if (e instanceof Error) {\n          throw new Error(\n            `Function '${fn.name}' parameters schema is invalid.\\n` +\n              `${e.message}\\n` +\n              'Tip: Arrays must include an \"items\" schema (e.g., { items: { type: \"string\" } } or items: { type: \"object\", properties: { ... } }).',\n            { cause: e }\n          );\n        }\n        throw e;\n      }\n    }\n  }\n\n  return [...(existingFuncs ?? []), ...functions];\n};\n\ntype ProcessFunctionsArgs = {\n  ai: Readonly<AxAIService>;\n  functionList: Readonly<AxFunction[]>;\n  functionCalls: readonly AxChatResponseFunctionCall[];\n  mem: Readonly<AxMemory>;\n  sessionId?: string;\n  traceId?: string;\n  span?: any;\n  excludeContentFromTrace?: boolean;\n  index: number;\n  functionResultFormatter?: (result: unknown) => string;\n  logger: AxLoggerFunction;\n  debug: boolean;\n  stopFunctionNames?: readonly string[];\n};\n\nexport const processFunctions = async ({\n  ai,\n  functionList,\n  functionCalls,\n  mem,\n  sessionId,\n  traceId,\n  span,\n  excludeContentFromTrace,\n  index,\n  functionResultFormatter,\n  logger,\n  debug,\n  stopFunctionNames,\n}: Readonly<ProcessFunctionsArgs>) => {\n  const funcProc = new AxFunctionProcessor(functionList);\n  const functionsExecuted = new Set<string>();\n  const stopMatches: Array<{\n    func: Readonly<AxFunction>;\n    args: unknown;\n    result: unknown;\n  }> = [];\n\n  const findFunctionSpec = (name: string): Readonly<AxFunction> | undefined => {\n    const normalize = (s: string) =>\n      s.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();\n    const target = normalize(name);\n    let spec = functionList.find((v) => v.name === name);\n    if (!spec) spec = functionList.find((v) => normalize(v.name) === target);\n    return spec;\n  };\n\n  // Map each function call to a promise that resolves to the function result or null\n  const promises = functionCalls.map((func) => {\n    if (!func.id) {\n      throw new Error(`Function ${func.name} did not return an ID`);\n    }\n\n    const tracer = ai.getOptions().tracer ?? axGlobals.tracer;\n\n    if (!tracer) {\n      return funcProc\n        .executeWithDetails(func, {\n          sessionId,\n          ai,\n          functionResultFormatter,\n          traceId,\n          stopFunctionNames,\n        })\n        .then(\n          ({\n            formatted,\n            rawResult,\n            parsedArgs,\n          }: {\n            formatted: string;\n            rawResult: unknown;\n            parsedArgs: unknown;\n          }) => {\n            functionsExecuted.add(func.name.toLowerCase());\n            if (stopFunctionNames?.includes(func.name.toLowerCase())) {\n              const spec = findFunctionSpec(func.name);\n              if (spec) {\n                stopMatches.push({\n                  func: spec,\n                  args: parsedArgs as any,\n                  result: rawResult,\n                });\n              }\n            }\n            if (span) {\n              const eventData: {\n                name: string;\n                args?: string;\n                result?: string;\n              } = {\n                name: func.name,\n              };\n              if (!excludeContentFromTrace) {\n                eventData.args = func.args;\n                eventData.result = formatted ?? '';\n              }\n              span.addEvent('function.call', eventData);\n            }\n            return {\n              result: formatted ?? '',\n              role: 'function' as const,\n              functionId: func.id,\n              index,\n            };\n          }\n        )\n        .catch((e) => {\n          if (!(e instanceof FunctionError)) {\n            throw e;\n          }\n          const result = e.getFixingInstructions();\n          if (span) {\n            const errorEventData: {\n              name: string;\n              args?: string;\n              message: string;\n              fixing_instructions?: string;\n            } = {\n              name: func.name,\n              message: e.toString(),\n            };\n            if (!excludeContentFromTrace) {\n              errorEventData.args = func.args;\n              errorEventData.fixing_instructions = result;\n            }\n            span.addEvent('function.error', errorEventData);\n          }\n          if (debug) {\n            logFunctionError(e, index, result, logger);\n          }\n          return {\n            functionId: func.id,\n            isError: true,\n            index,\n            result,\n            role: 'function' as const,\n          };\n        });\n    }\n\n    return tracer.startActiveSpan(\n      `Tool: ${func.name}`,\n      async (toolSpan: any) => {\n        try {\n          toolSpan?.setAttributes?.({\n            'tool.name': func.name,\n            'tool.mode': 'native',\n            'function.id': func.id,\n            'session.id': sessionId ?? '',\n          });\n          const {\n            formatted,\n            rawResult,\n            parsedArgs,\n          }: { formatted: string; rawResult: unknown; parsedArgs: unknown } =\n            await funcProc.executeWithDetails(func, {\n              sessionId,\n              ai,\n              functionResultFormatter,\n              traceId: toolSpan?.spanContext?.().traceId ?? traceId,\n              stopFunctionNames,\n            });\n\n          functionsExecuted.add(func.name.toLowerCase());\n          if (stopFunctionNames?.includes(func.name.toLowerCase())) {\n            const spec = findFunctionSpec(func.name);\n            if (spec) {\n              stopMatches.push({\n                func: spec,\n                args: parsedArgs as any,\n                result: rawResult,\n              });\n            }\n          }\n\n          if (!excludeContentFromTrace) {\n            toolSpan.addEvent('gen_ai.tool.message', {\n              name: func.name,\n              args: func.args,\n              result: formatted ?? '',\n            });\n          } else {\n            toolSpan.addEvent('gen_ai.tool.message', { name: func.name });\n          }\n\n          if (span) {\n            const eventData: { name: string; args?: string; result?: string } =\n              {\n                name: func.name,\n              };\n            if (!excludeContentFromTrace) {\n              eventData.args = func.args;\n              eventData.result = formatted ?? '';\n            }\n            span.addEvent('function.call', eventData);\n          }\n\n          return {\n            result: formatted ?? '',\n            role: 'function' as const,\n            functionId: func.id,\n            index,\n          };\n        } catch (e) {\n          toolSpan?.recordException?.(e as Error);\n          if (e instanceof FunctionError) {\n            const result = e.getFixingInstructions();\n            const errorEventData: {\n              name: string;\n              args?: string;\n              message: string;\n              fixing_instructions?: string;\n            } = {\n              name: func.name,\n              message: e.toString(),\n            };\n            if (!excludeContentFromTrace) {\n              errorEventData.args = func.args;\n              errorEventData.fixing_instructions = result;\n            }\n            toolSpan?.addEvent?.('function.error', errorEventData);\n\n            if (debug) {\n              logFunctionError(e, index, result, logger);\n            }\n\n            return {\n              functionId: func.id,\n              isError: true,\n              index,\n              result,\n              role: 'function' as const,\n            };\n          }\n          throw e;\n        } finally {\n          toolSpan?.end?.();\n        }\n      }\n    );\n  });\n\n  // Wait for all promises to resolve\n  const results = await Promise.all(promises);\n  const functionResults: AxFunctionResult[] = results.map((r) =>\n    r.result === undefined || r.result === '' ? { ...r, result: 'done' } : r\n  );\n\n  mem.addFunctionResults(functionResults, sessionId);\n\n  // Log successful function results if debug is enabled\n  if (debug) {\n    const successfulResults = functionResults.filter(\n      (result: AxFunctionResult) => !result.isError\n    );\n    if (successfulResults.length > 0) {\n      logFunctionResults(successfulResults, logger);\n    }\n  }\n\n  if (stopMatches.length > 0) {\n    throw new AxStopFunctionCallException(stopMatches);\n  }\n\n  return functionsExecuted;\n};\n\nexport function parseFunctionCalls(\n  ai: Readonly<AxAIService>,\n  functionCalls: Readonly<AxChatResponseResult['functionCalls']>,\n  _values: Record<string, unknown>,\n  model?: string\n): AxChatResponseFunctionCall[] | undefined {\n  if (!functionCalls || functionCalls.length === 0) {\n    return;\n  }\n  if (!ai.getFeatures(model).functions) {\n    throw new Error('Functions are not supported by the AI service');\n  }\n\n  const funcs: AxChatResponseFunctionCall[] = functionCalls.map((f) => ({\n    id: f.id,\n    name: f.function.name,\n    args: f.function.params as string,\n  }));\n\n  // for (const [i, f] of funcs.entries()) {\n  //   values['functionName' + i] = f.name;\n  //   values['functionArguments' + i] =\n  //     typeof f.args === 'object' ? JSON.stringify(f.args) : f.args;\n  // }\n  return funcs;\n}\n\ntype FunctionCall = AxChatRequest['functionCall'] | undefined;\n\n/**\n * Utility function to parse a list of functions into AxFunction array\n */\nexport function createFunctionConfig(\n  functionList?: AxInputFunctionType,\n  definedFunctionCall?: FunctionCall,\n  firstStep?: boolean,\n  _options?: Readonly<AxProgramForwardOptions<any>>\n): { functions: AxFunction[]; functionCall: FunctionCall } {\n  const functionCall = definedFunctionCall;\n\n  if (\n    !firstStep &&\n    (functionCall === 'required' || typeof functionCall === 'function')\n  ) {\n    return { functions: [], functionCall: undefined };\n  }\n\n  if (!functionList) {\n    return { functions: [], functionCall: functionCall };\n  }\n\n  // biome-ignore lint/complexity/useFlatMap: you cannot use flatMap here\n  const functions = functionList\n    .map((f) => {\n      if ('toFunction' in f) {\n        return f.toFunction();\n      }\n      return f;\n    })\n    .flat();\n\n  return { functions, functionCall };\n}\n","import dayjs from 'dayjs';\nimport customParseFormat from 'dayjs/plugin/customParseFormat.js';\nimport timezone from 'dayjs/plugin/timezone.js';\nimport utc from 'dayjs/plugin/utc.js';\n\nimport {\n  createInvalidDateError,\n  createInvalidDateTimeError,\n} from './errors.js';\nimport type { AxField } from './sig.js';\n\n// Extend Day.js with required plugins\ndayjs.extend(utc);\ndayjs.extend(timezone);\ndayjs.extend(customParseFormat);\n\nexport function parseLLMFriendlyDate(\n  field: Readonly<AxField>,\n  dateStr: string,\n  required = false\n) {\n  try {\n    return ParseLlmFriendlyDate(dateStr);\n  } catch (err) {\n    if (field.isOptional && !required) {\n      return;\n    }\n    const message = (err as Error).message;\n    throw createInvalidDateError(field, dateStr, message);\n  }\n}\n\nfunction ParseLlmFriendlyDate(dateStr: string) {\n  // Validate the date string format\n  if (!dayjs(dateStr, 'YYYY-MM-DD', true).isValid()) {\n    throw new Error(\n      'Invalid date format. Please provide the date in \"YYYY-MM-DD\" format.'\n    );\n  }\n\n  // Parse the date and create a UTC dayjs object at midnight\n  // @ts-ignore - utc method exists after plugin extension\n  const date = dayjs.utc(dateStr, 'YYYY-MM-DD').startOf('day');\n\n  return date.toDate();\n}\n\nexport function parseLLMFriendlyDateTime(\n  field: Readonly<AxField>,\n  dateStr: string,\n  required = false\n) {\n  try {\n    return ParseLlmFriendlyDateTime(dateStr);\n  } catch (err) {\n    if (field.isOptional && !required) {\n      return;\n    }\n    const message = (err as Error).message;\n    throw createInvalidDateTimeError(field, dateStr, message);\n  }\n}\n\nfunction ParseLlmFriendlyDateTime(dateTimeStr: string) {\n  // Validate the date and time string format\n  const dateTimeRegex = /^(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}(?::\\d{2})?) (.+)$/;\n  const match = dateTimeStr.match(dateTimeRegex);\n  if (!match) {\n    throw new Error(\n      'Invalid date and time format. Please provide the date and time in \"YYYY-MM-DD HH:mm\" or \"YYYY-MM-DD HH:mm:ss\" format, followed by the timezone.'\n    );\n  }\n\n  const [, dateTime, timeZone] = match;\n\n  if (!dateTime || !timeZone) {\n    throw new Error(\n      'Invalid date and time format. Please provide the date and time in \"YYYY-MM-DD HH:mm\" or \"YYYY-MM-DD HH:mm:ss\" format, followed by the timezone.'\n    );\n  }\n\n  // Day.js doesn't have a direct equivalent to moment.tz.zone, so we attempt to parse and validate the timezone\n  try {\n    // Determine the format based on whether seconds are included\n    const format =\n      dateTime.includes(':') && dateTime.split(':').length === 3\n        ? 'YYYY-MM-DD HH:mm:ss'\n        : 'YYYY-MM-DD HH:mm';\n\n    // Parse the date and time in the specified time zone\n    // @ts-ignore - tz method exists after plugin extension\n    const date = dayjs.tz(dateTime, format, timeZone);\n\n    // Check if the date and time are valid\n    if (!date.isValid()) {\n      throw new Error(\n        'Invalid date and time values. Please ensure all components are correct.'\n      );\n    }\n\n    // Convert to UTC\n    // @ts-ignore - utc method exists after plugin extension\n    return date.utc().toDate();\n  } catch (_err) {\n    throw new Error(\n      `Unrecognized time zone ${timeZone}. Please provide a valid time zone name, abbreviation, or offset. For example, \"America/New_York\", or \"EST\".`\n    );\n  }\n}\n\nexport const formatDateWithTimezone = (date: Readonly<Date>) => {\n  // @ts-ignore - utc method exists after plugin extension\n  const dayjsDate = dayjs(date).utc();\n  return dayjsDate.format('YYYY-MM-DD HH:mm:ss [UTC]');\n};\n","/* eslint-disable functional/prefer-immutable-types */\nimport { ColorLog } from '../util/log.js';\n\nimport type { AxField } from './sig.js';\nimport type { AxFieldValue, AxGenDeltaOut, AxProgramUsage } from './types.js';\n\nconst _colorLog = new ColorLog();\n\nexport const validateValue = (\n  field: Readonly<AxField>,\n  value: Readonly<AxFieldValue>\n): void => {\n  const ft = field.type ?? { name: 'string', isArray: false };\n\n  const validateSingleValue = (\n    expectedType: string,\n    val: Readonly<AxFieldValue>\n  ): boolean => {\n    switch (expectedType) {\n      case 'class':\n        return typeof val === 'string';\n      case 'code':\n        return typeof val === 'string';\n      case 'string':\n        return typeof val === 'string';\n      case 'number':\n        return typeof val === 'number';\n      case 'boolean':\n        return typeof val === 'boolean';\n      case 'date':\n        return val instanceof Date || typeof val === 'string';\n      case 'datetime':\n        return val instanceof Date || typeof val === 'string';\n      case 'json':\n        return typeof val === 'object' || typeof val === 'string';\n      default:\n        return false; // Unknown or unsupported type\n    }\n  };\n\n  const validImage = (val: Readonly<AxFieldValue>): boolean => {\n    if (\n      !val ||\n      typeof val !== 'object' ||\n      !('mimeType' in val) ||\n      !('data' in val)\n    ) {\n      return false;\n    }\n    return true;\n  };\n\n  if (field.type?.name === 'image') {\n    let msg: string | undefined;\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        if (!validImage(item)) {\n          msg = 'object ({ mimeType: string; data: string })';\n          break;\n        }\n      }\n    } else if (!validImage(value)) {\n      msg = 'object ({ mimeType: string; data: string })';\n    }\n\n    if (msg) {\n      throw new Error(\n        `Validation failed: Expected '${field.name}' to be type '${msg}' instead got '${value}'`\n      );\n    }\n    return;\n  }\n\n  const validAudio = (val: Readonly<AxFieldValue>): boolean => {\n    if (!val || typeof val !== 'object' || !('data' in val)) {\n      return false;\n    }\n    return true;\n  };\n\n  if (field.type?.name === 'audio') {\n    let msg: string | undefined;\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        if (!validAudio(item)) {\n          msg = 'object ({ data: string; format?: string })';\n          break;\n        }\n      }\n    } else if (!validAudio(value)) {\n      msg = 'object ({ data: string; format?: string })';\n    }\n\n    if (msg) {\n      throw new Error(\n        `Validation failed: Expected '${field.name}' to be type '${msg}' instead got '${value}'`\n      );\n    }\n    return;\n  }\n\n  const validFile = (val: Readonly<AxFieldValue>): boolean => {\n    if (!val || typeof val !== 'object' || !('mimeType' in val)) {\n      return false;\n    }\n\n    // Support both data and fileUri formats\n    const hasData = 'data' in val;\n    const hasFileUri = 'fileUri' in val;\n\n    if (!hasData && !hasFileUri) {\n      return false;\n    }\n    if (hasData && hasFileUri) {\n      return false; // Cannot have both\n    }\n\n    return true;\n  };\n\n  if (field.type?.name === 'file') {\n    let msg: string | undefined;\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        if (!validFile(item)) {\n          msg =\n            'object ({ mimeType: string; data: string } | { mimeType: string; fileUri: string })';\n          break;\n        }\n      }\n    } else if (!validFile(value)) {\n      msg =\n        'object ({ mimeType: string; data: string } | { mimeType: string; fileUri: string })';\n    }\n\n    if (msg) {\n      throw new Error(\n        `Validation failed: Expected '${field.name}' to be type '${msg}' instead got '${value}'`\n      );\n    }\n    return;\n  }\n\n  const validUrl = (val: Readonly<AxFieldValue>): boolean => {\n    if (typeof val === 'string') {\n      return true; // Simple URL string\n    }\n    if (!val || typeof val !== 'object' || !('url' in val)) {\n      return false;\n    }\n    return true;\n  };\n\n  if (field.type?.name === 'url') {\n    let msg: string | undefined;\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        if (!validUrl(item)) {\n          msg =\n            'string or object ({ url: string; title?: string; description?: string })';\n          break;\n        }\n      }\n    } else if (!validUrl(value)) {\n      msg =\n        'string or object ({ url: string; title?: string; description?: string })';\n    }\n\n    if (msg) {\n      throw new Error(\n        `Validation failed: Expected '${field.name}' to be type '${msg}' instead got '${value}'`\n      );\n    }\n    return;\n  }\n\n  let isValid = true;\n\n  if (ft.isArray) {\n    if (!Array.isArray(value)) {\n      isValid = false;\n    } else {\n      for (const item of value) {\n        if (!validateSingleValue(ft.name, item)) {\n          isValid = false;\n          break;\n        }\n      }\n    }\n  } else {\n    isValid = validateSingleValue(ft.name, value);\n  }\n\n  if (!isValid) {\n    const gotType = Array.isArray(value) ? 'array' : typeof value;\n    throw new Error(\n      `Validation failed: Expected '${field.name}' to be a ${field.type?.isArray ? 'an array of ' : ''}${ft.name} instead got '${gotType}' (${JSON.stringify(value)})`\n    );\n  }\n};\n\nexport function mergeProgramUsage(\n  usages: readonly AxProgramUsage[]\n): AxProgramUsage[] {\n  const usageMap: { [key: string]: AxProgramUsage } = {};\n\n  for (const usage of usages) {\n    const key = `${usage.ai}:${usage.model}`;\n\n    if (!usageMap[key]) {\n      usageMap[key] = { ...usage };\n      continue;\n    }\n\n    const currentUsage = usageMap[key];\n    if (currentUsage) {\n      const tokens = currentUsage.tokens ?? {\n        promptTokens: 0,\n        completionTokens: 0,\n        totalTokens: 0,\n      };\n      tokens.promptTokens += usage?.tokens?.promptTokens ?? 0;\n      tokens.completionTokens += usage?.tokens?.completionTokens ?? 0;\n      tokens.totalTokens += usage?.tokens?.totalTokens ?? 0;\n      currentUsage.tokens = tokens;\n\n      // Merge citations and dedupe by URL\n      const existing = currentUsage.citations ?? [];\n      const incoming = usage.citations ?? [];\n      if (incoming.length) {\n        const seen = new Set(existing.map((c) => c.url));\n        for (const c of incoming) {\n          if (c?.url && !seen.has(c.url)) {\n            existing.push(c);\n            seen.add(c.url);\n          }\n        }\n        currentUsage.citations = existing;\n      }\n    }\n  }\n\n  return Object.values(usageMap);\n}\n\n/**\n * Parses a markdown list from a string. This is a very forgiving parser that\n * will try to handle anything that looks vaguely like a markdown list.\n */\nexport const parseMarkdownList = (input: string): string[] => {\n  // Handle empty input\n  if (!input.trim()) {\n    return [];\n  }\n\n  const listBullets = new Set(['-', '*', '+']);\n  const numberedListRegex = /^\\d+[\\s]*[.)\\]]\\s*/;\n\n  const lines = input.split('\\n');\n  const list = [];\n\n  for (const line of lines) {\n    const trimmedLine = line.trim();\n    // Skip empty lines\n    if (!trimmedLine) {\n      continue;\n    }\n\n    // Check for bullet points\n    if (trimmedLine[0] && listBullets.has(trimmedLine[0])) {\n      list.push(trimmedLine.slice(1).trim());\n    }\n    // Check for numbered lists (e.g., \"1.\", \"2.\", etc.)\n    else if (numberedListRegex.test(trimmedLine)) {\n      list.push(trimmedLine.replace(numberedListRegex, '').trim());\n    }\n    // If it's not a list item and we haven't collected any items yet, do nothing\n    else if (list.length === 0) {\n      // Skip non-list lines at the beginning\n    }\n    // If we've already started collecting list items, then this non-list line\n    //is an error\n    else {\n      throw new Error('Could not parse markdown list: mixed content detected');\n    }\n  }\n\n  // If we didn't find any list items, throw error\n  if (list.length === 0) {\n    throw new Error('Could not parse markdown list: no valid list items found');\n  }\n\n  return list;\n};\n\nexport function mergeDeltas<OUT>(\n  base: AxGenDeltaOut<OUT>[],\n  currentDelta: AxGenDeltaOut<OUT>\n) {\n  type ValueTypeOfAxGenOut = OUT[keyof OUT];\n\n  const { index, delta, version } = currentDelta;\n\n  // Cast once for mutation  safe because we'll only assign validated keys\n  const target = base.find((b) => b.index === index)?.delta as Record<\n    string,\n    ValueTypeOfAxGenOut\n  >;\n\n  if (!target) {\n    base.push({ index, delta, version });\n    return base;\n  }\n\n  for (const key of Object.keys(delta)) {\n    const baseValue = target[key];\n    const deltaValue = (delta as Record<string, unknown>)[key];\n\n    if (baseValue === undefined && Array.isArray(deltaValue)) {\n      target[key] = [...deltaValue] as ValueTypeOfAxGenOut;\n    } else if (Array.isArray(baseValue) && Array.isArray(deltaValue)) {\n      // Concatenate arrays\n      target[key] = [\n        ...(baseValue as unknown[]),\n        ...deltaValue,\n      ] as ValueTypeOfAxGenOut;\n    } else if (\n      (baseValue === undefined || typeof baseValue === 'string') &&\n      typeof deltaValue === 'string'\n    ) {\n      // Concatenate strings\n      target[key] = `${baseValue ?? ''}${deltaValue}` as ValueTypeOfAxGenOut;\n    } else {\n      // For all other types, overwrite with the new value\n      target[key] = deltaValue as ValueTypeOfAxGenOut;\n    }\n  }\n  // Always keep latest version marker\n  const entry = base.find((b) => b.index === index);\n  if (entry) entry.version = version;\n  return base;\n}\n\nexport class LRUCache<K, V> {\n  private cache = new Map<K, V>();\n  private readonly maxSize: number;\n\n  constructor(maxSize: number) {\n    this.maxSize = maxSize;\n  }\n\n  get(key: K): V | undefined {\n    const value = this.cache.get(key);\n    if (value) {\n      // Refresh position by deleting and re-adding\n      this.cache.delete(key);\n      this.cache.set(key, value);\n    }\n    return value;\n  }\n\n  set(key: K, value: V): void {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size >= this.maxSize) {\n      // Remove oldest entry (first item in map)\n      const firstKey = this.cache.keys().next().value;\n      if (firstKey) {\n        this.cache.delete(firstKey);\n      }\n    }\n    this.cache.set(key, value);\n  }\n}\n\nconst globalPrefixCache = new LRUCache<string, string[]>(500);\n\n/**\n * Checks if a streaming string matches a prefix, either fully or partially from the end.\n * For streaming content, partial matches are checked from shortest to longest since\n * the content grows at the end and we want to detect partial prefixes as they form.\n * @param content The string to check (potentially streaming)\n * @param prefix The prefix to look for\n * @param startIndex Optional starting index for the search\n * @returns\n *   - index >= 0: Position of full match\n *   - -1: No match found\n *   - -2: Partial match from the end\n *   - -3: String is only whitespace\n */\nexport function matchesContent(\n  content: string,\n  prefix: string,\n  startIndex = 0,\n  prefixCache: LRUCache<string, string[]> = globalPrefixCache\n): number {\n  // Check if string starts with a markdown block with optional language\n  if (/^```[a-zA-Z]*\\s*$/.test(content)) {\n    return -4;\n  }\n\n  // Check if string is only whitespace\n  if (/^[\\s`]*$/.test(content)) {\n    return -3;\n  }\n\n  // First check if the complete prefix exists anywhere after startIndex\n  const exactMatchIndex = content.indexOf(prefix, startIndex);\n\n  if (exactMatchIndex !== -1) {\n    return exactMatchIndex;\n  }\n\n  // Get or create cached prefixes\n  const prefixes =\n    prefixCache.get(prefix) ??\n    Array.from({ length: prefix.length }, (_, i) => prefix.slice(0, i + 1));\n\n  // Set in cache if it wasn't there\n  if (!prefixCache.get(prefix)) {\n    prefixCache.set(prefix, prefixes);\n  }\n\n  // Check for partial matches at the end (for streaming content)\n  // We want to find the longest partial prefix that the content ends with\n  let longestPartialMatch = -1;\n\n  // Start from the longest prefix and work backwards to find the longest match\n  for (let i = prefixes.length - 1; i >= 0; i--) {\n    const partialPrefix = prefixes[i] as string;\n\n    // Check if content ends with this partial prefix\n    if (content.endsWith(partialPrefix)) {\n      longestPartialMatch = i;\n      break; // Found the longest match, no need to continue\n    }\n  }\n\n  // Return -2 for partial match, -1 for no match\n  return longestPartialMatch >= 0 ? -2 : -1;\n}\n\nexport const formatTime = (ms: number): string => {\n  const seconds = Math.floor(ms / 1000);\n  if (seconds < 60) return `${seconds}s`;\n\n  const minutes = Math.floor(seconds / 60);\n  const remainingSeconds = seconds % 60;\n  if (minutes < 60) return `${minutes}m ${remainingSeconds}s`;\n\n  const hours = Math.floor(minutes / 60);\n  const remainingMinutes = minutes % 60;\n  return `${hours}h ${remainingMinutes}m ${remainingSeconds}s`;\n};\n\nexport const calculateETA = (\n  current: number,\n  total: number,\n  elapsedMs: number\n): string => {\n  if (current === 0) return 'calculating...';\n\n  const msPerItem = elapsedMs / current;\n  const remainingItems = total - current;\n  const etaMs = msPerItem * remainingItems;\n\n  return formatTime(etaMs);\n};\n","/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { parseLLMFriendlyDate, parseLLMFriendlyDateTime } from './datetime.js';\nimport {\n  createExpectedRequiredFieldNotFoundError,\n  createInvalidArrayError,\n  createInvalidJsonError,\n  createMissingRequiredFieldsError,\n  createRequiredFieldMissingError,\n  createTypeValidationError,\n} from './errors.js';\nimport type { AxField, AxSignature } from './sig.js';\nimport type { AxGenOut, GenDeltaOut } from './types.js';\nimport { matchesContent, parseMarkdownList } from './util.js';\n\nexport const extractValues = (\n  sig: Readonly<AxSignature>,\n  values: Record<string, unknown>,\n  content: string,\n  options?: { strictMode?: boolean; treatAllFieldsOptional?: boolean }\n) => {\n  const strictMode = options?.strictMode ?? false;\n  const treatAllFieldsOptional = options?.treatAllFieldsOptional ?? false;\n  const skipEarlyFail = options?.treatAllFieldsOptional ?? false;\n\n  const xstate: extractionState = {\n    extractedFields: [],\n    streamedIndex: {},\n    s: -1,\n  };\n\n  streamingExtractValues(sig, values, xstate, content, {\n    strictMode,\n    skipEarlyFail,\n    treatAllFieldsOptional,\n  });\n\n  streamingExtractFinalValue(sig, values, xstate, content, {\n    strictMode,\n    treatAllFieldsOptional,\n    forceFinalize: true,\n  });\n\n  // Filter out internal fields\n  for (const field of sig.getOutputFields()) {\n    if (field.isInternal) {\n      delete values[field.name];\n    }\n  }\n};\n\nexport interface extractionState {\n  prevFields?: { field: AxField; s: number; e: number }[];\n  currField?: AxField;\n  currFieldIndex?: number;\n  inAssumedField?: boolean;\n  extractedFields: AxField[];\n  streamedIndex: Record<string, number>;\n  s: number;\n  inBlock?: boolean;\n}\n\n// Helper function to check for missing required fields\nconst checkMissingRequiredFields = (\n  _xstate: Readonly<extractionState>,\n  values: Record<string, unknown>,\n  outputFields: Readonly<AxField[]>\n) => {\n  const missingFields: AxField[] = [];\n\n  for (const field of outputFields) {\n    if (field && !field.isOptional && values[field.name] === undefined) {\n      missingFields.push(field);\n    }\n  }\n\n  if (missingFields.length > 0) {\n    throw createMissingRequiredFieldsError(missingFields);\n  }\n};\n\nexport interface StreamingExtractValuesOptions {\n  strictMode?: boolean;\n  skipEarlyFail?: boolean;\n  treatAllFieldsOptional?: boolean;\n}\n\nexport const streamingExtractValues = (\n  sig: Readonly<AxSignature>,\n  values: Record<string, unknown>,\n  // eslint-disable-next-line functional/prefer-immutable-types\n  xstate: extractionState,\n  content: string,\n  { strictMode, skipEarlyFail }: StreamingExtractValuesOptions = {}\n) => {\n  const fields = sig.getOutputFields();\n  let expectedField: AxField | undefined;\n\n  // Keep scanning and extracting until we run out of matches\n  while (true) {\n    // Build list of candidate fields to try next\n    const doNotTry = new Set<number>();\n    if (xstate.currFieldIndex !== undefined && !xstate.inAssumedField) {\n      doNotTry.add(xstate.currFieldIndex);\n    }\n\n    // for (const [i, f] of fields.entries()) {\n    //   if (\n    //     f.name in values &&\n    //     !(i === xstate.currFieldIndex && xstate.inAssumedField)\n    //   ) {\n    //     doNotTry.add(i);\n    //   }\n    // }\n\n    const candidates = fields\n      .map((f, i) => ({ field: f, index: i }))\n      .filter(({ index }) => !doNotTry.has(index));\n\n    // Find earliest matching candidate (supports out-of-order fields)\n    let chosenIndex: number | undefined;\n    let chosenField: AxField | undefined;\n    let e = -1;\n    let prefixLen = 0;\n\n    for (const { index, field } of candidates) {\n      const isFirst = xstate.extractedFields.length === 0;\n      const prefix = `${(isFirst ? '' : '\\n') + field.title}:`;\n      const match = matchesContent(content, prefix, xstate.s);\n\n      if (match === -2) {\n        return true; // Partial match at end, skip and gather more content\n      }\n      if (match === -3) {\n        return true; // String is only whitespace, skip and gather more content\n      }\n      if (match === -4) {\n        xstate.inBlock = true;\n        return true; // String is only backticks, skip and gather more content\n      }\n      if (match >= 0 && (e === -1 || match < e)) {\n        e = match;\n        prefixLen = prefix.length;\n        chosenIndex = index;\n        chosenField = field;\n      }\n    }\n\n    if (e === -1) {\n      // Nothing matched this iteration\n      if (skipEarlyFail) {\n        return;\n      }\n      if (\n        !strictMode &&\n        xstate.currField === undefined &&\n        xstate.extractedFields.length === 0 &&\n        fields.length === 1\n      ) {\n        // Assume single field\n        xstate.inAssumedField = true;\n        xstate.currField = fields[0];\n        xstate.currFieldIndex = 0;\n        xstate.s = 0; // Set start position for assumed field\n        if (!xstate.extractedFields.includes(fields[0])) {\n          xstate.extractedFields.push(fields[0]);\n        }\n        if (xstate.streamedIndex[fields[0].name] === undefined) {\n          xstate.streamedIndex[fields[0].name] = 0;\n        }\n        return;\n      }\n\n      if (\n        strictMode &&\n        xstate.currField === undefined &&\n        xstate.extractedFields.length === 0\n      ) {\n        const firstRequiredField = fields.find((f) => !f.isOptional);\n        if (firstRequiredField) {\n          throw createExpectedRequiredFieldNotFoundError(firstRequiredField);\n        }\n      }\n      break;\n    }\n\n    // We found a field!!!\n    if (\n      expectedField &&\n      chosenField &&\n      expectedField.name !== chosenField.name\n    ) {\n      throw createExpectedRequiredFieldNotFoundError(expectedField);\n    }\n\n    if (xstate.currField !== undefined && xstate.inAssumedField) {\n      // When an explicit prefix is later found for the same field,\n      // discard previously assumed unprefixed content to avoid leaking noise\n      xstate.inAssumedField = false;\n      xstate.streamedIndex[xstate.currField.name] = 0;\n      xstate.currField = undefined;\n    }\n\n    // Wrap previous field content\n    if (xstate.currField) {\n      const val = content.substring(xstate.s, e).trim();\n      const parsedValue = validateAndParseFieldValue(xstate.currField, val);\n      if (parsedValue !== undefined) {\n        values[xstate.currField.name] = parsedValue;\n      }\n      if (xstate.prevFields) {\n        xstate.prevFields?.push({ field: xstate.currField, s: xstate.s, e });\n      } else {\n        xstate.prevFields = [{ field: xstate.currField, s: xstate.s, e }];\n      }\n    }\n\n    // Move to new current field\n    xstate.s = e + prefixLen;\n    if (chosenField !== undefined && chosenIndex !== undefined) {\n      xstate.currField = chosenField;\n      xstate.currFieldIndex = chosenIndex;\n    }\n    if (chosenField && !xstate.extractedFields.includes(chosenField)) {\n      xstate.extractedFields.push(chosenField);\n    }\n    if (chosenField && xstate.streamedIndex[chosenField.name] === undefined) {\n      xstate.streamedIndex[chosenField.name] = 0;\n    }\n  }\n};\n\nexport const streamingExtractFinalValue = (\n  sig: Readonly<AxSignature>,\n  values: Record<string, unknown>,\n  // eslint-disable-next-line functional/prefer-immutable-types\n  xstate: extractionState,\n  content: string,\n  options?: {\n    strictMode?: boolean;\n    treatAllFieldsOptional?: boolean;\n    deferRequiredCheckForStreaming?: boolean;\n    forceFinalize?: boolean;\n  }\n) => {\n  const strictMode = options?.strictMode ?? false;\n  const treatAllFieldsOptional = options?.treatAllFieldsOptional ?? false;\n  const deferRequiredCheckForStreaming =\n    options?.deferRequiredCheckForStreaming ?? false;\n  const forceFinalize = options?.forceFinalize ?? false;\n\n  if (xstate.currField) {\n    let endIndex = content.length;\n\n    // Look for the next field boundary to avoid including content from other fields\n    const outputFields = sig.getOutputFields();\n    for (const otherField of outputFields) {\n      if (otherField.name === xstate.currField.name) {\n        continue;\n      }\n\n      // Look for the next field title after current position\n      const nextFieldPattern = `\\n${otherField.title}:`;\n      const nextFieldIndex = content.indexOf(nextFieldPattern, xstate.s);\n\n      if (nextFieldIndex !== -1 && nextFieldIndex < endIndex) {\n        endIndex = nextFieldIndex;\n      }\n    }\n\n    const val = content.substring(xstate.s, endIndex).trim();\n    const parsedValue = validateAndParseFieldValue(xstate.currField, val);\n    if (parsedValue !== undefined) {\n      values[xstate.currField.name] = parsedValue;\n    }\n  }\n\n  // In strict mode, if we have content but no fields were extracted and no current field,\n  // this means field prefixes were missing when they should have been present\n  if (strictMode && !xstate.currField && xstate.extractedFields.length === 0) {\n    const trimmedContent = content.trim();\n    if (trimmedContent) {\n      // Find the first required field to report in the error\n      const outputFields = sig.getOutputFields();\n      const firstRequiredField = outputFields.find(\n        (field) => !field.isOptional\n      );\n      if (firstRequiredField) {\n        throw createExpectedRequiredFieldNotFoundError(firstRequiredField);\n      }\n      // If only optional fields exist, ignore unprefixed content in strict mode\n    }\n  }\n\n  // Check for optional fields that might have been missed by streaming parser\n  // Also handles case where assumed field content should be corrected by proper prefixes\n  parseMissedFieldsFromFullContent(sig, values, content, xstate);\n\n  // Check all previous required fields before processing current field\n  // In streaming scenarios (non-strict), defer missing-required enforcement until end\n  if (!treatAllFieldsOptional) {\n    const streamingInProgress =\n      xstate.currField !== undefined ||\n      (xstate.extractedFields?.length ?? 0) > 0;\n\n    if (strictMode || forceFinalize) {\n      checkMissingRequiredFields(xstate, values, sig.getOutputFields());\n    } else if (deferRequiredCheckForStreaming) {\n      if (!streamingInProgress) {\n        checkMissingRequiredFields(xstate, values, sig.getOutputFields());\n      }\n    } else {\n      // Default behavior: if streaming is still in progress (mid-stream),\n      // defer required checks until end of stream.\n      if (!streamingInProgress) {\n        checkMissingRequiredFields(xstate, values, sig.getOutputFields());\n      }\n    }\n  }\n};\n\n// Helper function to parse missed fields from full content that streaming parser might have missed\nconst parseMissedFieldsFromFullContent = (\n  sig: Readonly<AxSignature>,\n  values: Record<string, unknown>,\n  content: string,\n  _xstate?: extractionState\n) => {\n  const outputFields = sig.getOutputFields();\n\n  // For single-field signatures, check if there's a proper field prefix in the content\n  // This handles the case where we were in assumed field mode but proper prefix exists\n  if (outputFields.length === 1) {\n    const field = outputFields[0];\n    if (field) {\n      const prefix = `${field.title}:`;\n      const start = content.indexOf(prefix);\n      if (start !== -1) {\n        // Found proper prefix, extract value from after the prefix\n        const valueStart = start + prefix.length;\n        // Look for the next field boundary (shouldn't exist for single field, but be safe)\n        const boundary = `\\n${field.title}:`;\n        const valueEnd = content.indexOf(boundary, valueStart);\n        const rawValue = content\n          .substring(valueStart, valueEnd === -1 ? content.length : valueEnd)\n          .trim();\n        if (rawValue) {\n          try {\n            const parsedValue = validateAndParseFieldValue(field, rawValue);\n            if (parsedValue !== undefined) {\n              values[field.name] = parsedValue;\n              return; // Updated the field, return early\n            }\n          } catch {\n            // Fall through to original logic if parsing fails\n          }\n        }\n      }\n    }\n  }\n\n  // Original logic for missed fields\n  // Process content line by line for more precise field extraction\n  const lines = content.split('\\n');\n\n  for (const field of outputFields) {\n    // Skip if field is already found\n    if (field.name in values) {\n      continue;\n    }\n\n    // Look for field.title pattern in each line\n    const prefix = `${field.title}:`;\n\n    for (const line of lines) {\n      const trimmedLine = line.trim();\n      if (trimmedLine.startsWith(prefix)) {\n        // Extract the value after the colon\n        const fieldValue = trimmedLine.substring(prefix.length).trim();\n\n        if (fieldValue) {\n          try {\n            const parsedValue = validateAndParseFieldValue(field, fieldValue);\n            if (parsedValue !== undefined) {\n              values[field.name] = parsedValue;\n              break; // Found the field, stop looking\n            }\n          } catch (e) {\n            // Only ignore validation errors for optional fields\n            if (!field.isOptional) {\n              throw e;\n            }\n            // Ignore validation errors for optional fields in this fallback parser\n          }\n        }\n        break; // Found the field marker, stop looking even if value was empty\n      }\n    }\n  }\n};\n\nconst convertValueToType = (\n  field: Readonly<AxField>,\n  val: string,\n  required = false\n) => {\n  switch (field.type?.name) {\n    case 'code':\n      return extractBlock(val);\n\n    case 'string':\n      return val;\n\n    case 'number': {\n      const v = Number(val);\n      if (Number.isNaN(v)) {\n        if (field.isOptional && !required) {\n          return;\n        }\n        throw new Error('Invalid number');\n      }\n      return v;\n    }\n\n    case 'boolean': {\n      if (typeof val === 'boolean') {\n        return val;\n      }\n      const v = val.toLowerCase();\n      if (v === 'true') {\n        return true;\n      }\n      if (v === 'false') {\n        return false;\n      }\n      if (field.isOptional && !required) {\n        return;\n      }\n      throw new Error('Invalid boolean');\n    }\n    case 'date':\n      return parseLLMFriendlyDate(field, val, required);\n\n    case 'datetime':\n      return parseLLMFriendlyDateTime(field, val, required);\n\n    case 'class': {\n      const className = val;\n      if (field.type.options && !field.type.options.includes(className)) {\n        if (field.isOptional) {\n          return;\n        }\n        throw new Error(\n          `Invalid class '${val}', expected one of the following: ${field.type.options.join(', ')}`\n        );\n      }\n      return className as string;\n    }\n\n    default:\n      return val as string; // Unknown type\n  }\n};\n\nexport function* yieldDelta<OUT extends AxGenOut>(\n  content: string,\n  field: Readonly<AxField>,\n  s: number,\n  e: number,\n  // eslint-disable-next-line functional/prefer-immutable-types\n  xstate: extractionState,\n  index: number\n): GenDeltaOut<OUT> {\n  const { name: fieldName, isInternal } = field;\n  const { isArray: fieldIsArray, name: fieldTypeName } = field.type ?? {};\n\n  if (\n    isInternal ||\n    fieldIsArray ||\n    (fieldTypeName && fieldTypeName !== 'string' && fieldTypeName !== 'code')\n  ) {\n    return;\n  }\n\n  const pos = xstate.streamedIndex[fieldName] ?? 0;\n  const isFirstChunk = pos === 0;\n\n  const startIndex = (s < 0 ? 0 : s) + pos;\n  const d1 = content.substring(startIndex, e);\n  if (d1.length === 0) {\n    return;\n  }\n\n  // Remove trailing whitespace, tabs, and newlines\n  let d2 = d1.replace(/\\s+$/, '');\n\n  // If this field is a \"code\" type, remove trailing backticks\n  if (xstate.currField?.type?.name === 'code') {\n    d2 = d2.replace(/\\s*```\\s*$/, '');\n  }\n\n  // Only trim start for the first chunk\n  let d3 = isFirstChunk ? d2.trimStart() : d2;\n\n  if (xstate.currField?.type?.name === 'code') {\n    // Remove any leading triple-backtick fences (with optional language specifier)\n    d3 = d3.replace(/^[ ]*```[a-zA-Z0-9]*\\n\\s*/, '');\n  }\n\n  if (d3.length > 0) {\n    yield { index, delta: { [fieldName]: d3 } as unknown as Partial<OUT> };\n    xstate.streamedIndex[fieldName] = pos + d2.length;\n  }\n}\n\nexport function* streamValues<OUT extends AxGenOut>(\n  sig: Readonly<AxSignature>,\n  content: string,\n  values: Readonly<Record<string, OUT>>,\n  // eslint-disable-next-line functional/prefer-immutable-types\n  xstate: extractionState,\n  index: number\n): GenDeltaOut<OUT> {\n  for (const prevField of xstate.prevFields ?? []) {\n    const { field, s, e } = prevField;\n    yield* yieldDelta<OUT>(content, field, s, e, xstate, index);\n  }\n  xstate.prevFields = undefined;\n\n  // If we're in assumed-field mode (single-field, non-strict, no explicit prefix yet),\n  // allow streaming only when the signature has a single non-internal output field.\n  // This enables expected behavior for single-field scenarios in non-strict mode.\n  if (xstate.inAssumedField) {\n    const nonInternalOutputs = sig\n      .getOutputFields()\n      .filter((f) => !f.isInternal);\n    const isSingleFieldSignature = nonInternalOutputs.length === 1;\n    if (!isSingleFieldSignature) {\n      return;\n    }\n    // For single-field signatures, allow streaming regardless of whether the field is optional\n    // since all content should belong to that single field\n  }\n\n  if (!xstate.currField || xstate.currField.isInternal) {\n    return;\n  }\n\n  yield* yieldDelta<OUT>(\n    content,\n    xstate.currField,\n    xstate.s,\n    content.length,\n    xstate,\n    index\n  );\n\n  const outputFields = sig.getOutputFields();\n\n  for (const key of Object.keys(values)) {\n    const field = outputFields.find((f) => f.name === key);\n    if (!field || field.isInternal) {\n      continue;\n    }\n\n    const value = values[key];\n\n    if (Array.isArray(value)) {\n      const s = xstate.streamedIndex?.[key] ?? 0;\n      const v = value.slice(s);\n      if (v && v.length > 0) {\n        yield { index, delta: { [key]: v } as unknown as Partial<OUT> };\n        xstate.streamedIndex[key] = s + v.length;\n      }\n      continue;\n    }\n\n    if (!xstate.streamedIndex[key]) {\n      yield { index, delta: { [key]: value } as unknown as Partial<OUT> };\n      xstate.streamedIndex[key] = 1;\n    }\n  }\n}\n\nfunction validateAndParseFieldValue(\n  field: Readonly<AxField>,\n  fieldValue: string | undefined\n): unknown {\n  if (\n    !fieldValue ||\n    fieldValue === '' ||\n    /^(null|undefined)\\s*$/i.test(fieldValue)\n  ) {\n    if (field.isOptional) {\n      return;\n    }\n    throw createRequiredFieldMissingError(field);\n  }\n\n  let value: unknown | undefined;\n\n  if (field.type?.name === 'json') {\n    try {\n      const text = extractBlock(fieldValue);\n      value = JSON.parse(text);\n      return value;\n    } catch (e) {\n      throw createInvalidJsonError(field, (e as Error).message);\n    }\n  }\n\n  if (field.type?.isArray) {\n    try {\n      try {\n        value = JSON.parse(fieldValue);\n      } catch {\n        // If JSON parsing fails, try markdown parsing\n        value = parseMarkdownList(fieldValue);\n      }\n      if (!Array.isArray(value)) {\n        throw new Error('Expected an array');\n      }\n    } catch (e) {\n      throw createInvalidArrayError(field, (e as Error).message);\n    }\n  }\n\n  try {\n    if (Array.isArray(value)) {\n      for (const [index, item] of value.entries()) {\n        if (item !== undefined) {\n          const v = typeof item === 'string' ? item.trim() : item;\n          value[index] = convertValueToType(field, v, true);\n        }\n      }\n    } else {\n      value = convertValueToType(field, fieldValue);\n    }\n  } catch (e) {\n    throw createTypeValidationError(field, fieldValue, (e as Error).message);\n  }\n\n  if (typeof value === 'string' && value === '') {\n    return undefined;\n  }\n\n  return value;\n}\n\nexport const extractBlock = (input: string): string => {\n  const markdownBlockPattern = /```([A-Za-z]*)\\n([\\s\\S]*?)\\n```/g;\n  const match = markdownBlockPattern.exec(input);\n  if (!match) {\n    return input;\n  }\n  if (match.length === 3) {\n    return match[2] as string;\n  }\n  if (match.length === 2) {\n    return match[1] as string;\n  }\n  return input;\n};\n","import type { AxAIMemory } from '../mem/types.js';\n\nimport type { extractionState } from './extract.js';\nimport type { AxField } from './sig.js';\nimport type { AxFieldValue, AxGenOut } from './types.js';\n\nexport type AxFieldProcessorProcess = (\n  value: AxFieldValue,\n  context?: Readonly<{\n    values?: AxGenOut;\n    sessionId?: string;\n    done?: boolean;\n  }>\n) => unknown | Promise<unknown>;\n\nexport type AxStreamingFieldProcessorProcess = (\n  value: string,\n  context?: Readonly<{\n    values?: AxGenOut;\n    sessionId?: string;\n    done?: boolean;\n  }>\n) => unknown | Promise<unknown>;\nexport interface AxFieldProcessor {\n  field: Readonly<AxField>;\n\n  /**\n   * Process the field value and return a new value (or undefined if no update is needed).\n   * The returned value may be merged back into memory.\n   * @param value - The current field value.\n   * @param context - Additional context (e.g. memory and session id).\n   */\n  process: AxFieldProcessorProcess | AxStreamingFieldProcessorProcess;\n}\n\n/**\n * For synchronous responses: iterates over registered field processors,\n * passing in the current values. If a processor returns a new value,\n * that value is merged into memory with a special role ('processor').\n */\nexport async function processFieldProcessors(\n  fieldProcessors: AxFieldProcessor[],\n  values: AxGenOut,\n  mem: AxAIMemory,\n  sessionId?: string\n) {\n  for (const processor of fieldProcessors) {\n    if (values[processor.field.name] === undefined) {\n      continue;\n    }\n\n    const processFn = processor.process as AxFieldProcessorProcess;\n    const result = await processFn(values[processor.field.name], {\n      sessionId,\n      values,\n      done: true,\n    });\n    addToMemory(processor.field, mem, result, sessionId);\n  }\n}\n\n/**\n * For streaming responses: processes each streaming field processor\n * and yields delta updates if they return new values.\n */\nexport async function processStreamingFieldProcessors(\n  fieldProcessors: AxFieldProcessor[],\n  content: string,\n  xstate: Readonly<extractionState>,\n  mem: AxAIMemory,\n  values: AxGenOut,\n  sessionId: string | undefined,\n  done = false\n): Promise<void> {\n  for (const processor of fieldProcessors) {\n    if (xstate.currField?.name !== processor.field.name) {\n      continue;\n    }\n\n    let value = content.substring(xstate.s);\n\n    if (xstate.currField?.type?.name === 'code') {\n      // remove markdown block\n      value = value.replace(/^[ ]*```[a-zA-Z0-9]*\\n\\s*/, '');\n      value = value.replace(/\\s*```\\s*$/, '');\n    }\n    const processFn = processor.process as AxStreamingFieldProcessorProcess;\n    const result = await processFn(value, {\n      sessionId,\n      values,\n      done,\n    });\n\n    addToMemory(xstate.currField, mem, result, sessionId);\n  }\n}\n\nconst addToMemory = (\n  field: Readonly<AxField>,\n  mem: AxAIMemory,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  result: any | any[],\n  sessionId?: string\n) => {\n  if (\n    result === undefined ||\n    (typeof result === 'string' &&\n      (result === '' || /^(null|undefined)\\s*$/i.test(result)))\n  ) {\n    return;\n  }\n\n  const resultText = JSON.stringify(\n    result,\n    (_key, value) => (typeof value === 'bigint' ? Number(value) : value),\n    2\n  );\n\n  const text = getFieldProcessingMessage(field, resultText);\n  mem.addRequest(\n    [{ role: 'user', content: [{ type: 'text', text }] }],\n    sessionId\n  );\n  mem.addTag('processor', sessionId);\n};\n\nfunction getFieldProcessingMessage(\n  field: Readonly<AxField>,\n  resultText: string\n) {\n  const isCodeField = field.type?.name === 'code';\n  const fieldTitle = field.title;\n\n  if (isCodeField) {\n    return `Code in the field \"${fieldTitle}\" was executed. The code execution produced the following output: ${resultText}`;\n  }\n  return `The field \"${fieldTitle}\" was processed. The field contents were transformed into the following output: ${resultText}`;\n}\n","// ReadableStream is available globally in modern browsers and Node.js 16+\n\nimport type { AxChatResponse, AxModelUsage } from '../ai/types.js';\nimport { mergeFunctionCalls } from '../ai/util.js';\nimport type { AxAIMemory } from '../mem/types.js';\n\nimport {\n  type AxAssertion,\n  type AxStreamingAssertion,\n  assertAssertions,\n  assertStreamingAssertions,\n} from './asserts.js';\nimport {\n  extractValues,\n  streamingExtractFinalValue,\n  streamingExtractValues,\n  streamValues,\n} from './extract.js';\nimport {\n  type AxFieldProcessor,\n  processFieldProcessors,\n  processStreamingFieldProcessors,\n} from './fieldProcessor.js';\nimport { parseFunctionCalls, processFunctions } from './functions.js';\nimport type { AxResponseHandlerArgs, InternalAxGenState } from './generate.js';\n// helper no longer used since memory removal is non-throwing\nimport type { AxSignature } from './sig.js';\nimport type { SignatureToolCallingManager } from './signatureToolCalling.js';\nimport type { AsyncGenDeltaOut, AxGenOut, DeltaOut } from './types.js';\n\ntype ProcessStreamingResponseArgs = Readonly<\n  AxResponseHandlerArgs<ReadableStream<AxChatResponse>>\n> & {\n  states: InternalAxGenState[];\n  usage: AxModelUsage[];\n  asserts: AxAssertion[];\n  streamingAsserts: AxStreamingAssertion[];\n  fieldProcessors: AxFieldProcessor[];\n  streamingFieldProcessors: AxFieldProcessor[];\n  thoughtFieldName: string;\n  signature: AxSignature;\n  excludeContentFromTrace: boolean;\n  debug: boolean;\n  functionResultFormatter?: (result: unknown) => string;\n  signatureToolCallingManager: SignatureToolCallingManager | undefined;\n  stopFunctionNames?: readonly string[];\n  disableMemoryCleanup?: boolean;\n};\n\nexport async function* processStreamingResponse<OUT extends AxGenOut>({\n  res,\n  usage,\n  states,\n  debug,\n  ...args\n}: ProcessStreamingResponseArgs): AsyncGenDeltaOut<OUT> {\n  const skipEarlyFail =\n    (args.ai.getFeatures().functionCot ?? false) &&\n    args.functions !== undefined &&\n    args.functions.length > 0;\n\n  // Track latest modelUsage and aggregate citations across chunks\n  let lastChunkUsage: AxModelUsage | undefined;\n  const aggregatedCitations: NonNullable<AxModelUsage['citations']> = [];\n\n  // Handle ReadableStream async iteration for browser compatibility\n  const reader = res.getReader();\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n\n      if (done) {\n        break;\n      }\n      const v = value;\n      if (v.modelUsage) {\n        lastChunkUsage = v.modelUsage;\n      }\n\n      for (const result of v.results) {\n        // Collect citations if present\n        if (Array.isArray(result.citations)) {\n          for (const c of result.citations) {\n            if (c?.url) {\n              aggregatedCitations.push({\n                url: c.url,\n                title: c.title,\n                description: c.description,\n                license: c.license,\n                publicationDate: c.publicationDate,\n                snippet: c.snippet,\n              });\n            }\n          }\n        }\n\n        if (\n          (!result.content || result.content === '') &&\n          (!result.thought || result.thought === '') &&\n          (!result.functionCalls || result.functionCalls.length === 0)\n        ) {\n          continue;\n        }\n\n        const state = states.find((s) => s.index === result.index);\n        if (!state) {\n          throw new Error(`No state found for result (index: ${result.index})`);\n        }\n\n        yield* ProcessStreamingResponse<OUT>({\n          ...args,\n          result,\n          skipEarlyFail,\n          state,\n          debug,\n        });\n      }\n    }\n  } finally {\n    reader.releaseLock();\n  }\n\n  // Finalize the streams\n  for (const state of states) {\n    yield* finalizeStreamingResponse<OUT>({\n      ...args,\n      state,\n      debug,\n    });\n  }\n\n  // Attach aggregated citations to usage and push (and log)\n  if (lastChunkUsage) {\n    if (aggregatedCitations.length) {\n      const dedup = Array.from(\n        new Map(\n          aggregatedCitations\n            .filter((c) => c.url)\n            .map((c) => [c.url as string, c])\n        ).values()\n      );\n      lastChunkUsage.citations = dedup;\n    }\n    usage.push(lastChunkUsage);\n    // Emit usage log event when debug is enabled and logger is available\n    if (debug && args.logger) {\n      // Create a copy without citations for the usage event\n      const usageWithoutCitations = structuredClone(lastChunkUsage);\n      delete usageWithoutCitations.citations;\n\n      args.logger({\n        name: 'ChatResponseUsage',\n        value: usageWithoutCitations,\n      });\n\n      // Emit separate citations event if they exist\n      if (lastChunkUsage.citations && lastChunkUsage.citations.length > 0) {\n        args.logger({\n          name: 'ChatResponseCitations',\n          value: lastChunkUsage.citations,\n        });\n      }\n    }\n  }\n}\n\ntype ProcessStreamingResponseArgs2 = Readonly<\n  Omit<\n    ProcessStreamingResponseArgs,\n    | 'res'\n    | 'states'\n    | 'usage'\n    | 'excludeContentFromTrace'\n    | 'ai'\n    | 'model'\n    | 'traceId'\n    | 'functions'\n    | 'span'\n    | 'fieldProcessors'\n  > & {\n    result: AxChatResponse['results'][number];\n    skipEarlyFail: boolean;\n    state: InternalAxGenState;\n    treatAllFieldsOptional?: boolean;\n  }\n>;\n\nasync function* ProcessStreamingResponse<OUT extends AxGenOut>({\n  result,\n  mem,\n  sessionId,\n  strictMode,\n  skipEarlyFail,\n  treatAllFieldsOptional,\n  state,\n  signature,\n  streamingFieldProcessors,\n  thoughtFieldName,\n  streamingAsserts,\n  asserts,\n}: ProcessStreamingResponseArgs2): AsyncGenDeltaOut<OUT> {\n  if (result.functionCalls && result.functionCalls.length > 0) {\n    mergeFunctionCalls(state.functionCalls, result.functionCalls);\n    mem.updateResult(\n      {\n        name: result.name,\n        content: result.content,\n        functionCalls: state.functionCalls,\n        delta: result.functionCalls?.[0]?.function?.params as string,\n        index: result.index,\n      },\n      sessionId\n    );\n  } else if (result.content && result.content.length > 0) {\n    if (result.thought && result.thought.length > 0) {\n      yield {\n        index: result.index,\n        delta: { [thoughtFieldName]: result.thought } as Partial<OUT>,\n      };\n    }\n\n    state.content += result.content;\n    mem.updateResult(\n      {\n        name: result.name,\n        content: state.content,\n        delta: result.content,\n        index: result.index,\n      },\n      sessionId\n    );\n\n    const skip = streamingExtractValues(\n      signature,\n      state.values,\n      state.xstate,\n      state.content,\n      {\n        strictMode,\n        skipEarlyFail,\n        treatAllFieldsOptional,\n      }\n    );\n\n    if (skip) {\n      return;\n    }\n\n    if (streamingAsserts.length !== 0) {\n      await assertStreamingAssertions(\n        streamingAsserts,\n        state.xstate,\n        state.content\n      );\n    }\n\n    if (streamingFieldProcessors.length !== 0) {\n      await processStreamingFieldProcessors(\n        streamingFieldProcessors,\n        state.content,\n        state.xstate,\n        mem,\n        state.values,\n        sessionId\n      );\n    }\n\n    yield* streamValues<OUT>(\n      signature,\n      state.content,\n      state.values as Record<string, OUT>,\n      state.xstate,\n      result.index\n    );\n\n    await assertAssertions(asserts, state.values);\n  } else if (result.thought && result.thought.length > 0) {\n    state.values[thoughtFieldName] =\n      (state.values[thoughtFieldName] ?? '') + result.thought;\n\n    yield {\n      index: result.index,\n      delta: { [thoughtFieldName]: result.thought } as Partial<OUT>,\n    };\n  }\n\n  if (result.finishReason === 'length') {\n    throw new Error(\n      `Max tokens reached before completion\\nContent: ${state.content}`\n    );\n  }\n}\n\ntype FinalizeStreamingResponseArgs = Readonly<\n  Omit<ProcessStreamingResponseArgs, 'res' | 'states' | 'usage'> & {\n    state: InternalAxGenState;\n  }\n>;\n\nexport async function* finalizeStreamingResponse<OUT extends AxGenOut>({\n  state,\n  signature,\n  ai,\n  model,\n  functions,\n  mem,\n  sessionId,\n  traceId,\n  span,\n  strictMode,\n  excludeContentFromTrace,\n  streamingAsserts,\n  asserts,\n  fieldProcessors,\n  streamingFieldProcessors,\n  functionResultFormatter,\n  signatureToolCallingManager,\n  logger,\n  debug,\n  stopFunctionNames,\n}: FinalizeStreamingResponseArgs) {\n  // Prefer native function calls when provided\n  const funcs = !signatureToolCallingManager\n    ? parseFunctionCalls(ai, state.functionCalls, state.values, model)\n    : undefined;\n\n  if (funcs) {\n    if (!functions) {\n      throw new Error('Functions are not defined');\n    }\n    const fx = await processFunctions({\n      ai,\n      functionList: functions,\n      functionCalls: funcs,\n      mem,\n      sessionId,\n      traceId,\n      span,\n      index: state.index,\n      excludeContentFromTrace,\n      functionResultFormatter,\n      logger,\n      debug: debug,\n      stopFunctionNames,\n    });\n    state.functionsExecuted = new Set([...state.functionsExecuted, ...fx]);\n    // Clear accumulated function calls after processing to avoid re-execution\n    // in subsequent steps (prevents duplicate function results and loops)\n    state.functionCalls = [];\n  } else {\n    const treatAllFieldsOptional = signatureToolCallingManager !== undefined;\n    streamingExtractFinalValue(\n      signature,\n      state.values,\n      state.xstate,\n      state.content,\n      {\n        strictMode,\n        treatAllFieldsOptional,\n        deferRequiredCheckForStreaming: true,\n        forceFinalize: true,\n      }\n    );\n\n    // If no native function calls and prompt-mode is enabled, parse from text content\n    if (signatureToolCallingManager) {\n      const promptFuncs = await signatureToolCallingManager.processResults(\n        state.values\n      );\n\n      if (promptFuncs && promptFuncs.length > 0) {\n        if (!functions) {\n          throw new Error('Functions are not defined');\n        }\n\n        // Mirror native function-call processing\n        const fx = await processFunctions({\n          ai,\n          functionList: functions,\n          functionCalls: promptFuncs,\n          mem,\n          sessionId,\n          traceId,\n          span,\n          index: state.index,\n          excludeContentFromTrace,\n          functionResultFormatter,\n          logger,\n          debug,\n          stopFunctionNames,\n        });\n        state.functionsExecuted = new Set([...state.functionsExecuted, ...fx]);\n\n        // Record assistant functionCalls in memory for observability\n        mem.updateResult(\n          {\n            name: undefined,\n            content: state.content,\n            functionCalls: promptFuncs.map((fc) => ({\n              id: fc.id,\n              type: 'function' as const,\n              function: { name: fc.name, params: fc.args },\n            })),\n            index: state.index,\n          },\n          sessionId\n        );\n        // After executing tools, skip further streaming of values in finalize\n        return;\n      }\n    }\n\n    await assertStreamingAssertions(\n      streamingAsserts,\n      state.xstate,\n      state.content,\n      true\n    );\n    await assertAssertions(asserts, state.values);\n\n    if (fieldProcessors.length) {\n      await processFieldProcessors(\n        fieldProcessors,\n        state.values,\n        mem,\n        sessionId\n      );\n    }\n\n    if (streamingFieldProcessors.length !== 0) {\n      await processStreamingFieldProcessors(\n        streamingFieldProcessors,\n        state.content,\n        state.xstate,\n        mem,\n        state.values,\n        sessionId,\n        true\n      );\n    }\n\n    yield* streamValues<OUT>(\n      signature,\n      state.content,\n      state.values as Record<string, OUT>,\n      state.xstate,\n      state.index\n    );\n  }\n}\n\nexport async function* processResponse<OUT>({\n  ai,\n  res,\n  mem,\n  sessionId,\n  traceId,\n  functions,\n  span,\n  strictMode,\n  states,\n  usage,\n  excludeContentFromTrace,\n  asserts,\n  fieldProcessors,\n  thoughtFieldName,\n  signature,\n  functionResultFormatter,\n  logger,\n  debug,\n  signatureToolCallingManager,\n  stopFunctionNames,\n  disableMemoryCleanup,\n}: Readonly<AxResponseHandlerArgs<AxChatResponse>> & {\n  states: InternalAxGenState[];\n  usage: AxModelUsage[];\n  excludeContentFromTrace: boolean;\n  asserts: AxAssertion[];\n  fieldProcessors: AxFieldProcessor[];\n  thoughtFieldName: string;\n  signature: AxSignature;\n  debug: boolean;\n  functionResultFormatter?: (result: unknown) => string;\n  signatureToolCallingManager?: SignatureToolCallingManager;\n  stopFunctionNames?: readonly string[];\n  disableMemoryCleanup?: boolean;\n}): AsyncGenDeltaOut<OUT> {\n  const results = res.results ?? [];\n  const treatAllFieldsOptional = signatureToolCallingManager !== undefined;\n\n  mem.addResponse(results, sessionId);\n\n  // Aggregate citations across results\n  const citations: NonNullable<AxModelUsage['citations']> = [];\n  for (const r of results) {\n    if (Array.isArray(r?.citations)) {\n      for (const c of r.citations) {\n        if (c?.url) {\n          citations.push({\n            url: c.url,\n            title: c.title,\n            description: c.description,\n            license: c.license,\n            publicationDate: c.publicationDate,\n            snippet: c.snippet,\n          });\n        }\n      }\n    }\n  }\n\n  for (const result of results) {\n    const state = states[result.index];\n\n    if (!state) {\n      throw new Error(`No state found for result (index: ${result.index})`);\n    }\n\n    if (res.modelUsage) {\n      const dedup = Array.from(\n        new Map(\n          citations.filter((c) => c.url).map((c) => [c.url as string, c])\n        ).values()\n      );\n      const modelUsage: AxModelUsage = {\n        ...res.modelUsage,\n        ...(dedup.length ? { citations: dedup } : {}),\n      };\n      usage.push(modelUsage);\n      if (debug && logger) {\n        // Create a copy without citations for the usage event\n        const usageWithoutCitations = structuredClone(modelUsage);\n        delete usageWithoutCitations.citations;\n\n        logger({\n          name: 'ChatResponseUsage',\n          value: usageWithoutCitations,\n        });\n\n        // Emit separate citations event if they exist\n        if (modelUsage.citations && modelUsage.citations.length > 0) {\n          logger({\n            name: 'ChatResponseCitations',\n            value: modelUsage.citations,\n          });\n        }\n      }\n    }\n\n    // if signatureToolCallingManager is defined, we need to process the function calls and add update the result in memory\n    if (signatureToolCallingManager && result.content) {\n      if (result.thought && result.thought.length > 0) {\n        state.values[thoughtFieldName] = result.thought;\n      }\n\n      extractValues(signature, state.values, result.content, {\n        strictMode,\n        treatAllFieldsOptional,\n      });\n\n      const promptFuncs = await signatureToolCallingManager.processResults(\n        state.values\n      );\n\n      const functionCalls = promptFuncs?.map((fc) => ({\n        id: fc.id,\n        type: 'function' as const,\n        function: { name: fc.name, params: fc.args },\n      }));\n\n      if (functionCalls && functionCalls.length > 0) {\n        mem.updateResult(\n          {\n            name: result.name,\n            content: result.content,\n            functionCalls,\n            index: result.index,\n          },\n          sessionId\n        );\n      }\n    }\n\n    if (result.functionCalls?.length) {\n      const funcs = parseFunctionCalls(ai, result.functionCalls, state.values);\n      if (funcs && funcs.length > 0) {\n        if (!functions) {\n          throw new Error('Functions are not defined');\n        }\n\n        let fx: Set<string> | undefined;\n        try {\n          fx = await processFunctions({\n            ai,\n            functionList: functions,\n            functionCalls: funcs,\n            mem,\n            sessionId,\n            traceId,\n            span,\n            excludeContentFromTrace,\n            index: result.index,\n            functionResultFormatter,\n            logger,\n            debug,\n            stopFunctionNames,\n          });\n        } catch (e) {\n          // On function error, tag and append correction prompt for next step\n          mem.addRequest(\n            [\n              {\n                role: 'user' as const,\n                content:\n                  'The previous tool call failed. Fix arguments and try again, ensuring required fields match schema.',\n              },\n            ],\n            sessionId\n          );\n          mem.addTag('correction', sessionId);\n          throw e;\n        }\n\n        state.functionsExecuted = new Set([...state.functionsExecuted, ...fx]);\n      }\n    } else if (result.content) {\n      if (result.thought && result.thought.length > 0) {\n        state.values[thoughtFieldName] = result.thought;\n      }\n\n      extractValues(signature, state.values, result.content, {\n        strictMode,\n        treatAllFieldsOptional,\n      });\n    }\n\n    await assertAssertions(asserts, state.values);\n    // If assertions passed, remove invalid-assistant and correction prompts\n    if (!disableMemoryCleanup) {\n      mem.removeByTag('correction', sessionId);\n      mem.removeByTag('error', sessionId);\n    }\n\n    if (fieldProcessors.length) {\n      await processFieldProcessors(\n        fieldProcessors,\n        state.values,\n        mem,\n        sessionId\n      );\n    }\n\n    if (result.finishReason === 'length') {\n      throw new Error(\n        `Max tokens reached before completion\\nContent: ${result.content}`\n      );\n    }\n  }\n\n  const values = states.map((s) => s.values);\n\n  // Strip out values whose signature fields have isInternal: true\n  for (const v of values) {\n    for (const field of signature.getOutputFields()) {\n      if (field.isInternal) {\n        delete v[field.name];\n      }\n    }\n  }\n\n  const outputFields = signature.getOutputFields();\n  const deltas: DeltaOut<OUT>[] = values.map((v, index) => {\n    const delta: Record<string, unknown> = {};\n    for (const field of outputFields) {\n      if (field.isInternal) {\n        continue;\n      }\n      delta[field.name] = v[field.name];\n    }\n    // Include thought field if it exists in the values\n    if (v[thoughtFieldName] !== undefined) {\n      delta[thoughtFieldName] = v[thoughtFieldName];\n    }\n    return { index, delta: delta as Partial<OUT> };\n  });\n\n  for (const delta of deltas) {\n    yield delta;\n  }\n}\n\nexport function shouldContinueSteps(\n  mem: AxAIMemory,\n  stopFunction: readonly string[] | undefined,\n  states: InternalAxGenState[],\n  sessionId?: string\n) {\n  const lastMemItem = mem.getLast(sessionId);\n\n  if (!lastMemItem) {\n    return true;\n  }\n\n  for (const [index, state] of states.entries()) {\n    const stopFunctionExecuted = stopFunction\n      ? Array.from(stopFunction).some((s) => state.functionsExecuted.has(s))\n      : false;\n\n    const chat = lastMemItem.chat[index];\n\n    if (!chat) {\n      throw new Error(`No chat message found for result (index: ${index})`);\n    }\n\n    const isFunction = lastMemItem.role === 'function';\n    const isProcessor = lastMemItem.tags\n      ? lastMemItem.tags.some((tag) => tag === 'processor')\n      : false;\n\n    // If any state has stop function executed, return false immediately\n    if (isFunction && stopFunction && stopFunctionExecuted) {\n      return false;\n    }\n\n    // If this state doesn't meet continuation criteria, return false\n    if (!(isFunction || isProcessor)) {\n      return false;\n    }\n  }\n\n  // All states meet continuation criteria\n  return true;\n}\n","import type { AxTunable, AxUsable } from './types.js';\n\ntype AxInstanceRegistryItem<T extends AxTunable<IN, OUT>, IN, OUT> = T &\n  AxUsable;\n\nexport class AxInstanceRegistry<T extends AxTunable<IN, OUT>, IN, OUT> {\n  private reg: Set<AxInstanceRegistryItem<T, IN, OUT>>; // To track keys for iteration\n\n  constructor() {\n    this.reg = new Set();\n  }\n\n  register(instance: AxInstanceRegistryItem<T, IN, OUT>): void {\n    this.reg.add(instance);\n  }\n\n  *[Symbol.iterator]() {\n    const items = Array.from(this.reg);\n    for (let i = 0; i < items.length; i++) {\n      yield items[i];\n    }\n  }\n}\n","// Updated type definitions\n\nexport type TypeNotClass =\n  | 'string'\n  | 'number'\n  | 'boolean'\n  | 'json'\n  | 'image'\n  | 'audio'\n  | 'file'\n  | 'url'\n  | 'datetime'\n  | 'date'\n  | 'code';\nexport type Type = TypeNotClass | 'class';\nexport type ParsedIdentifier = string;\nexport type ParsedString = string;\n\nexport type ParsedSignature = {\n  desc?: string;\n  inputs: InputParsedField[];\n  outputs: OutputParsedField[];\n};\n\nexport type InputParsedField = {\n  name: ParsedIdentifier;\n  desc?: string;\n  type?: { name: TypeNotClass; isArray: boolean };\n  isOptional?: boolean;\n};\n\nexport type OutputParsedField = {\n  name: ParsedIdentifier;\n  desc?: string;\n  type?:\n    | { name: TypeNotClass; isArray: boolean; options?: string[] }\n    | { name: 'class'; isArray: boolean; options: string[] };\n  isOptional?: boolean;\n  isInternal?: boolean;\n};\n\nimport { axGlobals } from './globals.js';\n\nclass SignatureValidationError extends Error {\n  constructor(\n    message: string,\n    public readonly position: number,\n    public readonly context: string,\n    public readonly suggestion?: string\n  ) {\n    super(message);\n    this.name = 'SignatureValidationError';\n  }\n}\n\nclass SignatureParser {\n  private input: string;\n  private position: number;\n  private currentFieldName: string | null = null;\n  private currentSection: 'description' | 'inputs' | 'outputs' = 'description';\n\n  constructor(input: string) {\n    this.input = input.trim();\n    this.position = 0;\n\n    if (!this.input) {\n      throw new SignatureValidationError(\n        'Empty signature provided',\n        0,\n        '',\n        'A signature must contain at least input and output fields separated by \"->\". Example: \"userQuery:string -> aiResponse:string\"'\n      );\n    }\n  }\n\n  parse(): ParsedSignature {\n    try {\n      this.skipWhitespace();\n      const optionalDesc = this.parseParsedString();\n      this.skipWhitespace();\n\n      this.currentSection = 'inputs';\n      // Use the specialized input field parser\n      const inputs = this.parseFieldList(\n        this.parseInputField.bind(this),\n        'input'\n      );\n      this.skipWhitespace();\n\n      if (this.position >= this.input.length) {\n        throw new SignatureValidationError(\n          'Incomplete signature: Missing output section',\n          this.position,\n          this.getErrorContext(),\n          'Add \"->\" followed by output fields. Example: \"-> responseText:string\"'\n        );\n      }\n\n      this.expectArrow();\n      this.skipWhitespace();\n\n      if (this.position >= this.input.length) {\n        throw new SignatureValidationError(\n          'Incomplete signature: No output fields specified after \"->\"',\n          this.position,\n          this.getErrorContext(),\n          'Add at least one output field. Example: \"-> responseText:string\"'\n        );\n      }\n\n      this.currentSection = 'outputs';\n      // Use the specialized output field parser\n      const outputs = this.parseFieldList(\n        this.parseOutputField.bind(this),\n        'output'\n      );\n\n      // Check for any remaining content that shouldn't be there\n      this.skipWhitespace();\n      if (this.position < this.input.length) {\n        const remaining = this.input.slice(this.position);\n        throw new SignatureValidationError(\n          `Unexpected content after signature: \"${remaining}\"`,\n          this.position,\n          this.getErrorContext(),\n          'Remove any extra content after the output fields'\n        );\n      }\n\n      // Validate the parsed signature\n      this.validateParsedSignature({\n        desc: optionalDesc?.trim(),\n        inputs,\n        outputs,\n      });\n\n      return {\n        desc: optionalDesc?.trim(),\n        inputs,\n        outputs,\n      };\n    } catch (error) {\n      if (error instanceof SignatureValidationError) {\n        throw error;\n      }\n\n      // Wrap other errors with better context\n      const errorMessage =\n        error instanceof Error ? error.message : 'Unknown error';\n      throw new SignatureValidationError(\n        errorMessage,\n        this.position,\n        this.getErrorContext()\n      );\n    }\n  }\n\n  private validateParsedSignature(signature: Readonly<ParsedSignature>): void {\n    // Check for duplicate field names within inputs\n    const inputNames = new Set<string>();\n    for (const field of signature.inputs) {\n      if (inputNames.has(field.name)) {\n        throw new SignatureValidationError(\n          `Duplicate input field name: \"${field.name}\"`,\n          0,\n          '',\n          'Each field name must be unique within the signature'\n        );\n      }\n      inputNames.add(field.name);\n    }\n\n    // Check for duplicate field names within outputs\n    const outputNames = new Set<string>();\n    for (const field of signature.outputs) {\n      if (outputNames.has(field.name)) {\n        throw new SignatureValidationError(\n          `Duplicate output field name: \"${field.name}\"`,\n          0,\n          '',\n          'Each field name must be unique within the signature'\n        );\n      }\n      outputNames.add(field.name);\n    }\n\n    // Check for field names that appear in both inputs and outputs\n    for (const outputField of signature.outputs) {\n      if (inputNames.has(outputField.name)) {\n        throw new SignatureValidationError(\n          `Field name \"${outputField.name}\" appears in both inputs and outputs`,\n          0,\n          '',\n          'Use different names for input and output fields to avoid confusion'\n        );\n      }\n    }\n\n    // Validate that we have at least one input and one output\n    if (signature.inputs.length === 0) {\n      throw new SignatureValidationError(\n        'Signature must have at least one input field',\n        0,\n        '',\n        'Add an input field before \"->\". Example: \"userInput:string -> ...\"'\n      );\n    }\n\n    if (signature.outputs.length === 0) {\n      throw new SignatureValidationError(\n        'Signature must have at least one output field',\n        0,\n        '',\n        'Add an output field after \"->\". Example: \"... -> responseText:string\"'\n      );\n    }\n  }\n\n  private getErrorContext(): string {\n    const start = Math.max(0, this.position - 25);\n    const end = Math.min(this.input.length, this.position + 25);\n    const before = this.input.slice(start, this.position);\n    const after = this.input.slice(this.position, end);\n    const pointer = `${' '.repeat(before.length)}^`;\n\n    const lines = [\n      `Position ${this.position} in signature:`,\n      `\"${before}${after}\"`,\n      ` ${pointer}`,\n    ];\n\n    return lines.join('\\n');\n  }\n\n  private parseFieldList<T extends InputParsedField | OutputParsedField>(\n    parseFieldFn: () => T,\n    section: 'input' | 'output'\n  ): T[] {\n    const fields: T[] = [];\n    this.skipWhitespace();\n\n    if (this.position >= this.input.length) {\n      throw new SignatureValidationError(\n        `Empty ${section} section: Expected at least one field`,\n        this.position,\n        this.getErrorContext(),\n        `Add a ${section} field. Example: ${section === 'input' ? 'userInput:string' : 'responseText:string'}`\n      );\n    }\n\n    // Parse first field\n    try {\n      fields.push(parseFieldFn());\n    } catch (error) {\n      if (error instanceof SignatureValidationError) {\n        throw error;\n      }\n      throw new SignatureValidationError(\n        `Invalid first ${section} field: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        this.position,\n        this.getErrorContext()\n      );\n    }\n\n    this.skipWhitespace();\n\n    // Parse remaining fields\n    while (this.position < this.input.length) {\n      if (\n        this.input[this.position] === '-' &&\n        this.position + 1 < this.input.length &&\n        this.input[this.position + 1] === '>'\n      ) {\n        break;\n      }\n\n      if (this.match(',')) {\n        this.skipWhitespace();\n        if (this.position >= this.input.length) {\n          throw new SignatureValidationError(\n            `Unexpected end of input after comma in ${section} section`,\n            this.position,\n            this.getErrorContext(),\n            `Add another ${section} field after the comma`\n          );\n        }\n        try {\n          fields.push(parseFieldFn());\n        } catch (error) {\n          if (error instanceof SignatureValidationError) {\n            throw error;\n          }\n          throw new SignatureValidationError(\n            `Invalid ${section} field after comma: ${error instanceof Error ? error.message : 'Unknown error'}`,\n            this.position,\n            this.getErrorContext()\n          );\n        }\n        this.skipWhitespace();\n      } else {\n        break;\n      }\n    }\n\n    return fields;\n  }\n\n  // -------------------------------\n  // Parse input fields (no \"class\" type and no internal flag)\n  // -------------------------------\n  private parseInputField(): InputParsedField {\n    this.skipWhitespace();\n    const name = this.parseParsedIdentifier();\n    this.currentFieldName = name;\n\n    // Validate field name for inputs\n    this.validateFieldName(name, 'input');\n\n    // Only the optional marker is allowed\n    let isOptional: boolean | undefined;\n    while (true) {\n      if (this.match('?')) {\n        isOptional = true;\n        continue;\n      }\n      if (this.match('!')) {\n        throw new SignatureValidationError(\n          `Input field \"${name}\" cannot use the internal marker \"!\"`,\n          this.position - 1,\n          this.getErrorContext(),\n          'Internal markers (!) are only allowed on output fields'\n        );\n      }\n      break;\n    }\n\n    let type: { name: TypeNotClass; isArray: boolean } | undefined;\n    this.skipWhitespace();\n    if (this.match(':')) {\n      this.skipWhitespace();\n      // Disallow the \"class\" type in input fields\n      if (/^class\\b/.test(this.input.slice(this.position))) {\n        throw new SignatureValidationError(\n          `Input field \"${name}\" cannot use the \"class\" type`,\n          this.position,\n          this.getErrorContext(),\n          'Class types are only allowed on output fields. Use \"string\" type for input classifications'\n        );\n      }\n      try {\n        const typeName = this.parseTypeNotClass();\n        const isArray = this.match('[]');\n        type = { name: typeName, isArray };\n      } catch (error) {\n        if (error instanceof SignatureValidationError) {\n          throw error;\n        }\n        throw new SignatureValidationError(\n          `Input field \"${name}\": ${error instanceof Error ? error.message : 'Unknown error'}`,\n          this.position,\n          this.getErrorContext()\n        );\n      }\n    }\n\n    this.skipWhitespace();\n    const desc = this.parseParsedString();\n\n    return {\n      name,\n      desc: desc?.trim(),\n      type,\n      isOptional,\n    };\n  }\n\n  // -------------------------------\n  // Parse output fields (supports both \"class\" type and the internal marker)\n  // -------------------------------\n  private parseOutputField(): OutputParsedField {\n    this.skipWhitespace();\n    const name = this.parseParsedIdentifier();\n    this.currentFieldName = name;\n\n    // Validate field name for outputs\n    this.validateFieldName(name, 'output');\n\n    let isOptional = false;\n    let isInternal = false;\n    while (true) {\n      if (this.match('?')) {\n        isOptional = true;\n        continue;\n      }\n      if (this.match('!')) {\n        isInternal = true;\n        continue;\n      }\n      break;\n    }\n\n    let type:\n      | { name: TypeNotClass; isArray: boolean; options?: string[] }\n      | { name: 'class'; isArray: boolean; options: string[] }\n      | undefined;\n    this.skipWhitespace();\n    if (this.match(':')) {\n      this.skipWhitespace();\n      if (this.match('class')) {\n        const isArray = this.match('[]');\n        this.skipWhitespace();\n        const classNamesString = this.parseParsedString();\n        if (!classNamesString) {\n          throw new SignatureValidationError(\n            `Output field \"${name}\": Missing class options after \"class\" type`,\n            this.position,\n            this.getErrorContext(),\n            'Add class names in quotes. Example: class \"positive, negative, neutral\"'\n          );\n        }\n        const options = classNamesString\n          .split(/[,|]/)\n          .map((s) => s.trim())\n          .filter((s) => s.length > 0);\n\n        if (options.length === 0) {\n          throw new SignatureValidationError(\n            `Output field \"${name}\": Empty class list provided`,\n            this.position,\n            this.getErrorContext(),\n            'Provide at least one class option. Example: \"positive, negative\"'\n          );\n        }\n\n        type = { name: 'class', isArray, options };\n      } else {\n        try {\n          const typeName = this.parseTypeNotClass();\n          const isArray = this.match('[]');\n          type = { name: typeName, isArray };\n\n          // Validate specific type constraints\n          if (typeName === 'image' && isArray) {\n            throw new SignatureValidationError(\n              `Output field \"${name}\": Arrays of images are not supported`,\n              this.position,\n              this.getErrorContext(),\n              'Use a single image type instead: \"image\"'\n            );\n          }\n\n          if (typeName === 'audio' && isArray) {\n            throw new SignatureValidationError(\n              `Output field \"${name}\": Arrays of audio are not supported`,\n              this.position,\n              this.getErrorContext(),\n              'Use a single audio type instead: \"audio\"'\n            );\n          }\n\n          if (typeName === 'image') {\n            throw new SignatureValidationError(\n              `Output field \"${name}\": Image type is not supported in output fields`,\n              this.position,\n              this.getErrorContext(),\n              'Image types can only be used in input fields'\n            );\n          }\n\n          if (typeName === 'audio') {\n            throw new SignatureValidationError(\n              `Output field \"${name}\": Audio type is not supported in output fields`,\n              this.position,\n              this.getErrorContext(),\n              'Audio types can only be used in input fields'\n            );\n          }\n        } catch (error) {\n          if (error instanceof SignatureValidationError) {\n            throw error;\n          }\n          throw new SignatureValidationError(\n            `Output field \"${name}\": ${error instanceof Error ? error.message : 'Unknown error'}`,\n            this.position,\n            this.getErrorContext()\n          );\n        }\n      }\n    }\n\n    this.skipWhitespace();\n    const desc = this.parseParsedString();\n\n    return {\n      name,\n      desc: desc?.trim(),\n      type,\n      isOptional,\n      isInternal,\n    };\n  }\n\n  private validateFieldName(name: string, fieldType: 'input' | 'output'): void {\n    // Check for reserved/generic names that should be more descriptive\n    if (axGlobals.signatureStrict) {\n      const reservedNames = [\n        'text',\n        'object',\n        'image',\n        'string',\n        'number',\n        'boolean',\n        'json',\n        'array',\n        'datetime',\n        'date',\n        'time',\n        'type',\n        'class',\n        'input',\n        'output',\n        'data',\n        'value',\n        'result',\n        'response',\n        'request',\n        'item',\n        'element',\n      ];\n\n      if (reservedNames.includes(name.toLowerCase())) {\n        const suggestions =\n          fieldType === 'input'\n            ? ['userInput', 'questionText', 'documentContent', 'messageText']\n            : ['responseText', 'analysisResult', 'categoryType', 'summaryText'];\n\n        throw new SignatureValidationError(\n          `Field name \"${name}\" is too generic`,\n          this.position,\n          this.getErrorContext(),\n          `Use a more descriptive name. Examples: ${suggestions.join(', ')}`\n        );\n      }\n    }\n\n    // Check naming convention\n    const camelCaseRegex = /^[a-z][a-zA-Z0-9]*$/;\n    const snakeCaseRegex = /^[a-z]+(_[a-z0-9]+)*$/;\n\n    if (!camelCaseRegex.test(name) && !snakeCaseRegex.test(name)) {\n      throw new SignatureValidationError(\n        `Invalid field name \"${name}\"`,\n        this.position,\n        this.getErrorContext(),\n        'Field names must be in camelCase (e.g., \"userInput\") or snake_case (e.g., \"user_input\")'\n      );\n    }\n\n    // Check for minimum length\n    if (name.length < 2) {\n      throw new SignatureValidationError(\n        `Field name \"${name}\" is too short`,\n        this.position,\n        this.getErrorContext(),\n        'Field names must be at least 2 characters long'\n      );\n    }\n\n    // Check for maximum length\n    if (name.length > 50) {\n      throw new SignatureValidationError(\n        `Field name \"${name}\" is too long (${name.length} characters)`,\n        this.position,\n        this.getErrorContext(),\n        'Field names should be 50 characters or less'\n      );\n    }\n  }\n\n  private parseTypeNotClass(): TypeNotClass {\n    const types: TypeNotClass[] = [\n      'string',\n      'number',\n      'boolean',\n      'json',\n      'image',\n      'audio',\n      'file',\n      'url',\n      'datetime',\n      'date',\n      'code',\n    ];\n\n    const foundType = types.find((type) => this.match(type));\n    if (!foundType) {\n      const currentWord =\n        this.input.slice(this.position).match(/^\\w+/)?.[0] || '';\n      const suggestion = this.suggestType(currentWord);\n\n      const baseMessage = `Invalid type \"${currentWord || 'empty'}\"`;\n      const suggestionPart = suggestion\n        ? `. Did you mean \"${suggestion}\"?`\n        : '';\n      const fullMessage = `${baseMessage}${suggestionPart}`;\n\n      throw new SignatureValidationError(\n        fullMessage,\n        this.position,\n        this.getErrorContext(),\n        `Expected one of: ${types.join(', ')}`\n      );\n    }\n    return foundType;\n  }\n\n  private suggestType(input: string): string | null {\n    const suggestions: Record<string, string> = {\n      str: 'string',\n      text: 'string',\n      int: 'number',\n      integer: 'number',\n      float: 'number',\n      double: 'number',\n      bool: 'boolean',\n      object: 'json',\n      dict: 'json',\n      timestamp: 'datetime',\n      time: 'datetime',\n      img: 'image',\n      picture: 'image',\n      sound: 'audio',\n      voice: 'audio',\n      classification: 'class',\n      category: 'class',\n    };\n\n    return suggestions[input.toLowerCase()] || null;\n  }\n\n  private parseParsedIdentifier(): ParsedIdentifier {\n    this.skipWhitespace();\n    const match = /^[a-zA-Z_][a-zA-Z_0-9]*/.exec(\n      this.input.slice(this.position)\n    );\n    if (match) {\n      this.position += match[0].length;\n      return match[0];\n    }\n\n    const invalidMatch = /^\\S+/.exec(this.input.slice(this.position));\n    const invalidId = invalidMatch ? invalidMatch[0] : '';\n\n    if (invalidId === '') {\n      throw new SignatureValidationError(\n        'Expected field name but found end of input',\n        this.position,\n        this.getErrorContext(),\n        'Add a field name. Field names must start with a letter or underscore'\n      );\n    }\n\n    if (/^\\d/.test(invalidId)) {\n      throw new SignatureValidationError(\n        `Invalid field name \"${invalidId}\" - cannot start with a number`,\n        this.position,\n        this.getErrorContext(),\n        'Field names must start with a letter or underscore. Example: \"userInput\" or \"_internal\"'\n      );\n    }\n\n    throw new SignatureValidationError(\n      `Invalid field name \"${invalidId}\"`,\n      this.position,\n      this.getErrorContext(),\n      'Field names must start with a letter or underscore and contain only letters, numbers, or underscores'\n    );\n  }\n\n  private parseParsedString(): string | undefined {\n    const quoteChars = [\"'\", '\"'];\n    for (const quoteChar of quoteChars) {\n      if (this.match(quoteChar)) {\n        let content = '';\n        let escaped = false;\n        const startPos = this.position - 1;\n\n        while (this.position < this.input.length) {\n          const char = this.input[this.position];\n          this.position++;\n          if (escaped) {\n            content += char;\n            escaped = false;\n          } else if (char === '\\\\') {\n            escaped = true;\n          } else if (char === quoteChar) {\n            return content;\n          } else {\n            content += char;\n          }\n        }\n\n        const partialString = this.input.slice(\n          startPos,\n          Math.min(this.position, startPos + 20)\n        );\n        throw new SignatureValidationError(\n          `Unterminated string starting at position ${startPos}`,\n          startPos,\n          this.getErrorContext(),\n          `Add closing ${quoteChar} to complete the string: ${partialString}${quoteChar}`\n        );\n      }\n    }\n    return undefined;\n  }\n\n  private skipWhitespace() {\n    const match = /^[\\s\\t\\r\\n]+/.exec(this.input.slice(this.position));\n    if (match) {\n      this.position += match[0].length;\n    }\n  }\n\n  private match(strOrRegex: string | RegExp): boolean {\n    let match: RegExpExecArray | null;\n    if (typeof strOrRegex === 'string') {\n      if (this.input.startsWith(strOrRegex, this.position)) {\n        this.position += strOrRegex.length;\n        return true;\n      }\n    } else {\n      match = strOrRegex.exec(this.input.slice(this.position));\n      if (match) {\n        this.position += match[0].length;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private expectArrow() {\n    if (!this.match('->')) {\n      const found = this.input.slice(this.position, this.position + 10);\n      const suggestion = found.includes('>')\n        ? 'Use \"->\" (dash followed by greater-than)'\n        : found.includes('-')\n          ? 'Add \">\" after the dash'\n          : 'Add \"->\" to separate input and output fields';\n\n      throw new SignatureValidationError(\n        `Expected \"->\" but found \"${found}...\"`,\n        this.position,\n        this.getErrorContext(),\n        suggestion\n      );\n    }\n  }\n}\n\nexport function parseSignature(input: string): ParsedSignature {\n  const parser = new SignatureParser(input);\n  return parser.parse();\n}\n","import type { AxFunctionJSONSchema } from '../ai/types.js';\nimport { createHash } from '../util/crypto.js';\n\nimport { axGlobals } from './globals.js';\nimport {\n  type InputParsedField,\n  type OutputParsedField,\n  type ParsedSignature,\n  parseSignature,\n} from './parser.js';\nimport type { ParseSignature } from './types.js';\n// Interface for programmatically defining field types\nexport interface AxFieldType {\n  readonly type:\n    | 'string'\n    | 'number'\n    | 'boolean'\n    | 'json'\n    | 'image'\n    | 'audio'\n    | 'file'\n    | 'url'\n    | 'date'\n    | 'datetime'\n    | 'class'\n    | 'code';\n  readonly isArray?: boolean;\n  readonly options?: readonly string[];\n  readonly description?: string;\n  readonly isOptional?: boolean;\n  readonly isInternal?: boolean;\n}\n\n// Improved SignatureBuilder class for fluent API with better type inference\nexport class AxSignatureBuilder<\n  _TInput extends Record<string, any> = {},\n  _TOutput extends Record<string, any> = {},\n> {\n  private inputFields: AxField[] = [];\n  private outputFields: AxField[] = [];\n  private desc?: string;\n\n  /**\n   * Add an input field to the signature\n   * @param name - Field name\n   * @param fieldInfo - Field type created with f.string(), f.number(), etc.\n   * @param prepend - If true, adds field to the beginning of input fields\n   */\n  public input<\n    K extends string,\n    T extends\n      | AxFluentFieldInfo<any, any, any, any>\n      | AxFluentFieldType<any, any, any, any, any>,\n  >(\n    name: K,\n    fieldInfo: T,\n    prepend = false\n  ): AxSignatureBuilder<AddFieldToShape<_TInput, K, T>, _TOutput> {\n    const field: AxField = {\n      name,\n      type: {\n        name: fieldInfo.type,\n        isArray: fieldInfo.isArray || undefined,\n        options: fieldInfo.options ? [...fieldInfo.options] : undefined,\n      },\n      description: fieldInfo.description,\n      isOptional: fieldInfo.isOptional || undefined,\n      isInternal: fieldInfo.isInternal || undefined,\n    };\n\n    if (prepend) {\n      this.inputFields.unshift(field);\n    } else {\n      this.inputFields.push(field);\n    }\n\n    return this as any;\n  }\n\n  /**\n   * Add an output field to the signature\n   * @param name - Field name\n   * @param fieldInfo - Field type created with f.string(), f.number(), etc.\n   * @param prepend - If true, adds field to the beginning of output fields\n   */\n  public output<\n    K extends string,\n    T extends\n      | AxFluentFieldInfo<any, any, any, any>\n      | AxFluentFieldType<any, any, any, any, any>,\n  >(\n    name: K,\n    fieldInfo: T,\n    prepend = false\n  ): AxSignatureBuilder<_TInput, AddFieldToShape<_TOutput, K, T>> {\n    const field: AxField = {\n      name,\n      type: {\n        name: fieldInfo.type,\n        isArray: fieldInfo.isArray || undefined,\n        options: fieldInfo.options ? [...fieldInfo.options] : undefined,\n      },\n      description: fieldInfo.description,\n      isOptional: fieldInfo.isOptional || undefined,\n      isInternal: fieldInfo.isInternal || undefined,\n    };\n\n    if (prepend) {\n      this.outputFields.unshift(field);\n    } else {\n      this.outputFields.push(field);\n    }\n\n    return this as any;\n  }\n\n  /**\n   * Set the description for the signature\n   * @param description - Description text\n   */\n  public description(\n    description: string\n  ): AxSignatureBuilder<_TInput, _TOutput> {\n    this.desc = description;\n    return this;\n  }\n\n  /**\n   * Build the final AxSignature instance\n   */\n  public build(): AxSignature<_TInput, _TOutput> {\n    const config: AxSignatureConfig = {\n      description: this.desc,\n      inputs: this.inputFields,\n      outputs: this.outputFields,\n    };\n\n    return new AxSignature(config) as AxSignature<_TInput, _TOutput>;\n  }\n}\n\n// Fluent field type builder for method chaining\nexport class AxFluentFieldType<\n  TType extends AxFieldType['type'] = AxFieldType['type'],\n  TIsArray extends boolean = false,\n  TOptions extends readonly string[] | undefined = undefined,\n  TIsOptional extends boolean = false,\n  TIsInternal extends boolean = false,\n> implements AxFieldType\n{\n  readonly type: TType;\n  readonly isArray: TIsArray;\n  readonly options?: TOptions;\n  readonly description?: string;\n  readonly isOptional: TIsOptional;\n  readonly isInternal: TIsInternal;\n\n  constructor(fieldType: {\n    type: TType;\n    isArray: TIsArray;\n    options?: TOptions;\n    description?: string;\n    isOptional: TIsOptional;\n    isInternal: TIsInternal;\n  }) {\n    this.type = fieldType.type;\n    this.isArray = fieldType.isArray;\n    this.options = fieldType.options;\n    this.description = fieldType.description;\n    this.isOptional = fieldType.isOptional;\n    this.isInternal = fieldType.isInternal;\n  }\n\n  optional(): AxFluentFieldType<TType, TIsArray, TOptions, true, TIsInternal> {\n    return new AxFluentFieldType({\n      ...this,\n      isOptional: true as const,\n    });\n  }\n\n  array(): AxFluentFieldType<TType, true, TOptions, TIsOptional, TIsInternal> {\n    return new AxFluentFieldType({\n      ...this,\n      isArray: true as const,\n    });\n  }\n\n  internal(): AxFluentFieldType<TType, TIsArray, TOptions, TIsOptional, true> {\n    return new AxFluentFieldType({\n      ...this,\n      isInternal: true as const,\n    });\n  }\n}\n\n// Improved helper functions for creating strongly-typed field info\nexport const f = Object.assign(\n  (): AxSignatureBuilder => new AxSignatureBuilder(),\n  {\n    string: (\n      desc?: string\n    ): AxFluentFieldType<'string', false, undefined, false, false> =>\n      new AxFluentFieldType({\n        type: 'string' as const,\n        isArray: false as const,\n        description: desc,\n        isOptional: false as const,\n        isInternal: false as const,\n      }),\n\n    number: (\n      desc?: string\n    ): AxFluentFieldType<'number', false, undefined, false, false> =>\n      new AxFluentFieldType({\n        type: 'number' as const,\n        isArray: false as const,\n        description: desc,\n        isOptional: false as const,\n        isInternal: false as const,\n      }),\n\n    boolean: (\n      desc?: string\n    ): AxFluentFieldType<'boolean', false, undefined, false, false> =>\n      new AxFluentFieldType({\n        type: 'boolean' as const,\n        isArray: false as const,\n        description: desc,\n        isOptional: false as const,\n        isInternal: false as const,\n      }),\n\n    json: (\n      desc?: string\n    ): AxFluentFieldType<'json', false, undefined, false, false> =>\n      new AxFluentFieldType({\n        type: 'json' as const,\n        isArray: false as const,\n        description: desc,\n        isOptional: false as const,\n        isInternal: false as const,\n      }),\n\n    datetime: (\n      desc?: string\n    ): AxFluentFieldType<'datetime', false, undefined, false, false> =>\n      new AxFluentFieldType({\n        type: 'datetime' as const,\n        isArray: false as const,\n        description: desc,\n        isOptional: false as const,\n        isInternal: false as const,\n      }),\n\n    date: (\n      desc?: string\n    ): AxFluentFieldType<'date', false, undefined, false, false> =>\n      new AxFluentFieldType({\n        type: 'date' as const,\n        isArray: false as const,\n        description: desc,\n        isOptional: false as const,\n        isInternal: false as const,\n      }),\n\n    class: <const TOptions extends readonly string[]>(\n      options: TOptions,\n      desc?: string\n    ): AxFluentFieldType<'class', false, TOptions, false, false> =>\n      new AxFluentFieldType({\n        type: 'class' as const,\n        isArray: false as const,\n        options,\n        description: desc,\n        isOptional: false as const,\n        isInternal: false as const,\n      }),\n\n    image: (\n      desc?: string\n    ): AxFluentFieldType<'image', false, undefined, false, false> =>\n      new AxFluentFieldType({\n        type: 'image' as const,\n        isArray: false as const,\n        description: desc,\n        isOptional: false as const,\n        isInternal: false as const,\n      }),\n\n    audio: (\n      desc?: string\n    ): AxFluentFieldType<'audio', false, undefined, false, false> =>\n      new AxFluentFieldType({\n        type: 'audio' as const,\n        isArray: false as const,\n        description: desc,\n        isOptional: false as const,\n        isInternal: false as const,\n      }),\n\n    file: (\n      desc?: string\n    ): AxFluentFieldType<'file', false, undefined, false, false> =>\n      new AxFluentFieldType({\n        type: 'file' as const,\n        isArray: false as const,\n        description: desc,\n        isOptional: false as const,\n        isInternal: false as const,\n      }),\n\n    url: (\n      desc?: string\n    ): AxFluentFieldType<'url', false, undefined, false, false> =>\n      new AxFluentFieldType({\n        type: 'url' as const,\n        isArray: false as const,\n        description: desc,\n        isOptional: false as const,\n        isInternal: false as const,\n      }),\n\n    code: (\n      language?: string,\n      desc?: string\n    ): AxFluentFieldType<'code', false, undefined, false, false> =>\n      new AxFluentFieldType({\n        type: 'code' as const,\n        isArray: false as const,\n        description: desc || language,\n        isOptional: false as const,\n        isInternal: false as const,\n      }),\n  }\n);\n\n// Backward compatibility alias (legacy API)\nexport const createFieldType = f;\n\nexport interface AxField {\n  name: string;\n  title?: string;\n  description?: string;\n  type?: {\n    name:\n      | 'string'\n      | 'number'\n      | 'boolean'\n      | 'json'\n      | 'image'\n      | 'audio'\n      | 'file'\n      | 'url'\n      | 'date'\n      | 'datetime'\n      | 'class'\n      | 'code';\n    isArray?: boolean;\n    options?: string[];\n  };\n  isOptional?: boolean;\n  isInternal?: boolean;\n}\n\nexport type AxIField = Omit<AxField, 'title'> & { title: string };\n\n// Helper type to map AxFieldType or AxFluentFieldType to TypeScript types for type-safe field additions\ntype InferFieldValueType<T> = T extends AxFieldType | AxFluentFieldType\n  ? T['type'] extends 'string'\n    ? T['isArray'] extends true\n      ? string[]\n      : string\n    : T['type'] extends 'number'\n      ? T['isArray'] extends true\n        ? number[]\n        : number\n      : T['type'] extends 'boolean'\n        ? T['isArray'] extends true\n          ? boolean[]\n          : boolean\n        : T['type'] extends 'json'\n          ? T['isArray'] extends true\n            ? any[]\n            : any\n          : T['type'] extends 'date'\n            ? T['isArray'] extends true\n              ? Date[]\n              : Date\n            : T['type'] extends 'datetime'\n              ? T['isArray'] extends true\n                ? Date[]\n                : Date\n              : T['type'] extends 'image'\n                ? T['isArray'] extends true\n                  ? { mimeType: string; data: string }[]\n                  : { mimeType: string; data: string }\n                : T['type'] extends 'audio'\n                  ? T['isArray'] extends true\n                    ? { format?: 'wav'; data: string }[]\n                    : { format?: 'wav'; data: string }\n                  : T['type'] extends 'file'\n                    ? T['isArray'] extends true\n                      ? (\n                          | { mimeType: string; data: string }\n                          | { mimeType: string; fileUri: string }\n                        )[]\n                      :\n                          | { mimeType: string; data: string }\n                          | { mimeType: string; fileUri: string }\n                    : T['type'] extends 'url'\n                      ? T['isArray'] extends true\n                        ? string[]\n                        : string\n                      : T['type'] extends 'code'\n                        ? T['isArray'] extends true\n                          ? string[]\n                          : string\n                        : T['type'] extends 'class'\n                          ? T['options'] extends readonly (infer U)[]\n                            ? T['isArray'] extends true\n                              ? U[]\n                              : U\n                            : T['isArray'] extends true\n                              ? string[]\n                              : string\n                          : any\n  : any;\n\n// Improved fluent field type that preserves exact type information for better inference\nexport interface AxFluentFieldInfo<\n  TType extends AxFieldType['type'] = AxFieldType['type'],\n  TIsArray extends boolean = false,\n  TOptions extends readonly string[] = readonly string[],\n  TIsOptional extends boolean = false,\n> {\n  readonly type: TType;\n  readonly isArray?: TIsArray;\n  readonly options?: TOptions;\n  readonly description?: string;\n  readonly isOptional?: TIsOptional;\n  readonly isInternal?: boolean;\n}\n\n// Helper type to infer TypeScript type from fluent field info\ntype InferFluentType<\n  T extends AxFluentFieldInfo<any, any, any, any> | AxFluentFieldType,\n> = T['type'] extends 'string'\n  ? T['isArray'] extends true\n    ? string[]\n    : string\n  : T['type'] extends 'number'\n    ? T['isArray'] extends true\n      ? number[]\n      : number\n    : T['type'] extends 'boolean'\n      ? T['isArray'] extends true\n        ? boolean[]\n        : boolean\n      : T['type'] extends 'json'\n        ? T['isArray'] extends true\n          ? any[]\n          : any\n        : T['type'] extends 'date'\n          ? T['isArray'] extends true\n            ? Date[]\n            : Date\n          : T['type'] extends 'datetime'\n            ? T['isArray'] extends true\n              ? Date[]\n              : Date\n            : T['type'] extends 'image'\n              ? T['isArray'] extends true\n                ? { mimeType: string; data: string }[]\n                : { mimeType: string; data: string }\n              : T['type'] extends 'audio'\n                ? T['isArray'] extends true\n                  ? { format?: 'wav'; data: string }[]\n                  : { format?: 'wav'; data: string }\n                : T['type'] extends 'file'\n                  ? T['isArray'] extends true\n                    ? (\n                        | { mimeType: string; data: string }\n                        | { mimeType: string; fileUri: string }\n                      )[]\n                    :\n                        | { mimeType: string; data: string }\n                        | { mimeType: string; fileUri: string }\n                  : T['type'] extends 'url'\n                    ? T['isArray'] extends true\n                      ? string[]\n                      : string\n                    : T['type'] extends 'code'\n                      ? T['isArray'] extends true\n                        ? string[]\n                        : string\n                      : T['type'] extends 'class'\n                        ? T['options'] extends readonly (infer U)[]\n                          ? T['isArray'] extends true\n                            ? U[]\n                            : U\n                          : T['isArray'] extends true\n                            ? string[]\n                            : string\n                        : any;\n\n// Helper flags for fluent type modifiers\ntype _IsInternal<T> = T extends { readonly isInternal: true } ? true : false;\ntype _IsOptional<T> = T extends { readonly isOptional: true } ? true : false;\n\n// Add field K to shape S, respecting optional() and internal() modifiers\ntype AddFieldToShape<\n  S extends Record<string, any>,\n  K extends string,\n  T extends AxFluentFieldInfo<any, any, any, any> | AxFluentFieldType,\n> = _IsInternal<T> extends true\n  ? S\n  : _IsOptional<T> extends true\n    ? S & { readonly [P in K]?: InferFluentType<T> }\n    : S & { readonly [P in K]: InferFluentType<T> };\n\n// Helper function to convert AxFieldType to AxField\nfunction convertFieldTypeToAxField(\n  fieldType: AxFieldType\n): Omit<AxField, 'name'> {\n  return {\n    type: {\n      name: fieldType.type,\n      isArray: fieldType.isArray,\n      options: fieldType.options ? [...fieldType.options] : undefined,\n    },\n    description: fieldType.description,\n    isOptional: fieldType.isOptional,\n    isInternal: fieldType.isInternal,\n  };\n}\n\nclass AxSignatureValidationError extends Error {\n  constructor(\n    message: string,\n    public readonly fieldName?: string,\n    public readonly suggestion?: string\n  ) {\n    super(message);\n    this.name = 'AxSignatureValidationError';\n  }\n}\n\nexport interface AxSignatureConfig {\n  description?: string;\n  inputs: readonly AxField[];\n  outputs: readonly AxField[];\n}\n\nexport class AxSignature<\n  _TInput extends Record<string, any> = Record<string, any>,\n  _TOutput extends Record<string, any> = Record<string, any>,\n> {\n  private description?: string;\n  private inputFields: AxIField[];\n  private outputFields: AxIField[];\n\n  private sigHash: string;\n  private sigString: string;\n\n  // Validation caching - stores hash when validation last passed\n  private validatedAtHash?: string;\n\n  /**\n   * @deprecated Use `AxSignature.create()` for better type safety instead of the constructor.\n   * This constructor will be removed in v15.0.0.\n   *\n   * Migration timeline:\n   * - v13.0.24+: Deprecation warnings (current)\n   * - v14.0.0: Runtime console warnings\n   * - v15.0.0: Complete removal\n   *\n   * @example\n   * ```typescript\n   * // Instead of: new AxSignature('userInput:string -> responseText:string')\n   * // Use: AxSignature.create('userInput:string -> responseText:string')\n   * ```\n   */\n  constructor(signature?: Readonly<AxSignature | string | AxSignatureConfig>) {\n    if (!signature) {\n      this.inputFields = [];\n      this.outputFields = [];\n      this.sigHash = '';\n      this.sigString = '';\n      return;\n    }\n\n    if (typeof signature === 'string') {\n      let sig: ParsedSignature;\n      try {\n        sig = parseSignature(signature);\n      } catch (e) {\n        if (e instanceof Error) {\n          // Preserve the suggestion if it's a SignatureValidationError\n          const suggestion =\n            'suggestion' in e &&\n            typeof (e as { suggestion: unknown }).suggestion === 'string'\n              ? (e as { suggestion: string }).suggestion\n              : 'Please check the signature format. Example: \"userInput:string -> responseText:string\"';\n          throw new AxSignatureValidationError(\n            `Invalid Signature: ${e.message}`,\n            undefined,\n            suggestion\n          );\n        }\n        throw new AxSignatureValidationError(\n          `Invalid Signature: ${signature}`,\n          undefined,\n          'Please check the signature format. Example: \"userInput:string -> responseText:string\"'\n        );\n      }\n      this.description = sig.desc;\n      this.inputFields = sig.inputs.map((v) => this.parseParsedField(v));\n      this.outputFields = sig.outputs.map((v) => this.parseParsedField(v));\n      [this.sigHash, this.sigString] = this.updateHash();\n    } else if (signature instanceof AxSignature) {\n      this.description = signature.getDescription();\n      this.inputFields = structuredClone(\n        signature.getInputFields()\n      ) as AxIField[];\n      this.outputFields = structuredClone(\n        signature.getOutputFields()\n      ) as AxIField[];\n      this.sigHash = signature.hash();\n      this.sigString = signature.toString();\n      // Copy validation state if the source signature was validated\n      if (signature.validatedAtHash === this.sigHash) {\n        this.validatedAtHash = this.sigHash;\n      }\n    } else if (typeof signature === 'object' && signature !== null) {\n      // Handle AxSignatureConfig object\n      if (!('inputs' in signature) || !('outputs' in signature)) {\n        throw new AxSignatureValidationError(\n          'Invalid signature object: missing inputs or outputs',\n          undefined,\n          'Signature object must have \"inputs\" and \"outputs\" arrays. Example: { inputs: [...], outputs: [...] }'\n        );\n      }\n\n      if (\n        !Array.isArray(signature.inputs) ||\n        !Array.isArray(signature.outputs)\n      ) {\n        throw new AxSignatureValidationError(\n          'Invalid signature object: inputs and outputs must be arrays',\n          undefined,\n          'Both \"inputs\" and \"outputs\" must be arrays of AxField objects'\n        );\n      }\n\n      try {\n        this.description = signature.description;\n        this.inputFields = signature.inputs.map((v) => this.parseField(v));\n        this.outputFields = signature.outputs.map((v) => this.parseField(v));\n        [this.sigHash, this.sigString] = this.updateHash();\n      } catch (error) {\n        if (error instanceof AxSignatureValidationError) {\n          throw error;\n        }\n        throw new AxSignatureValidationError(\n          `Failed to create signature from object: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          undefined,\n          'Check that all fields in inputs and outputs arrays are valid AxField objects'\n        );\n      }\n    } else {\n      throw new AxSignatureValidationError(\n        'Invalid signature argument type',\n        undefined,\n        'Signature must be a string, another AxSignature instance, or an object with inputs and outputs arrays'\n      );\n    }\n  }\n\n  /**\n   * Static factory method for type inference.\n   * Creates a typed AxSignature instance from a signature string.\n   */\n  public static create<const T extends string>(\n    signature: T\n  ): AxSignature<ParseSignature<T>['inputs'], ParseSignature<T>['outputs']> {\n    return new AxSignature(signature) as AxSignature<\n      ParseSignature<T>['inputs'],\n      ParseSignature<T>['outputs']\n    >;\n  }\n\n  private parseParsedField = (\n    field: Readonly<InputParsedField | OutputParsedField>\n  ): AxIField => {\n    if (!field.name || field.name.length === 0) {\n      throw new AxSignatureValidationError(\n        'Field name is required',\n        field.name,\n        'Every field must have a descriptive name. Example: \"userInput\", \"responseText\"'\n      );\n    }\n\n    const title = this.toTitle(field.name);\n    return {\n      name: field.name,\n      title,\n      description: 'desc' in field ? field.desc : undefined,\n      type: field.type ?? { name: 'string', isArray: false },\n      ...('isInternal' in field ? { isInternal: field.isInternal } : {}),\n      ...('isOptional' in field ? { isOptional: field.isOptional } : {}),\n    };\n  };\n\n  private parseField = (field: Readonly<AxField>): AxIField => {\n    const title =\n      !field.title || field.title.length === 0\n        ? this.toTitle(field.name)\n        : field.title;\n\n    if (field.type && (!field.type.name || field.type.name.length === 0)) {\n      throw new AxSignatureValidationError(\n        'Field type name is required',\n        field.name,\n        'Specify a valid type. Available types: string, number, boolean, json, image, audio, file, url, date, datetime, class, code'\n      );\n    }\n\n    return { ...field, title };\n  };\n\n  public setDescription = (desc: string) => {\n    if (typeof desc !== 'string') {\n      throw new AxSignatureValidationError(\n        'Description must be a string',\n        undefined,\n        'Provide a string description for the signature'\n      );\n    }\n    this.description = desc;\n    this.invalidateValidationCache();\n    this.updateHashLight();\n  };\n\n  public addInputField = (field: Readonly<AxField>) => {\n    try {\n      const parsedField = this.parseField(field);\n      validateField(parsedField, 'input');\n\n      // Check for duplicate input field names\n      for (const existingField of this.inputFields) {\n        if (existingField.name === parsedField.name) {\n          throw new AxSignatureValidationError(\n            `Duplicate input field name: \"${parsedField.name}\"`,\n            parsedField.name,\n            'Each field name must be unique within the signature'\n          );\n        }\n      }\n\n      // Check if field name conflicts with existing output fields\n      for (const outputField of this.outputFields) {\n        if (outputField.name === parsedField.name) {\n          throw new AxSignatureValidationError(\n            `Field name \"${parsedField.name}\" appears in both inputs and outputs`,\n            parsedField.name,\n            'Use different names for input and output fields to avoid confusion'\n          );\n        }\n      }\n\n      this.inputFields.push(parsedField);\n      this.invalidateValidationCache();\n      this.updateHashLight();\n    } catch (error) {\n      if (error instanceof AxSignatureValidationError) {\n        throw error;\n      }\n      throw new AxSignatureValidationError(\n        `Failed to add input field \"${field.name}\": ${error instanceof Error ? error.message : 'Unknown error'}`,\n        field.name\n      );\n    }\n  };\n\n  public addOutputField = (field: Readonly<AxField>) => {\n    try {\n      const parsedField = this.parseField(field);\n      validateField(parsedField, 'output');\n\n      // Check for duplicate output field names\n      for (const existingField of this.outputFields) {\n        if (existingField.name === parsedField.name) {\n          throw new AxSignatureValidationError(\n            `Duplicate output field name: \"${parsedField.name}\"`,\n            parsedField.name,\n            'Each field name must be unique within the signature'\n          );\n        }\n      }\n\n      // Check if field name conflicts with existing input fields\n      for (const inputField of this.inputFields) {\n        if (inputField.name === parsedField.name) {\n          throw new AxSignatureValidationError(\n            `Field name \"${parsedField.name}\" appears in both inputs and outputs`,\n            parsedField.name,\n            'Use different names for input and output fields to avoid confusion'\n          );\n        }\n      }\n\n      this.outputFields.push(parsedField);\n      this.invalidateValidationCache();\n      this.updateHashLight();\n    } catch (error) {\n      if (error instanceof AxSignatureValidationError) {\n        throw error;\n      }\n      throw new AxSignatureValidationError(\n        `Failed to add output field \"${field.name}\": ${error instanceof Error ? error.message : 'Unknown error'}`,\n        field.name\n      );\n    }\n  };\n\n  public setInputFields = (fields: readonly AxField[]) => {\n    if (!Array.isArray(fields)) {\n      throw new AxSignatureValidationError(\n        'Input fields must be an array',\n        undefined,\n        'Provide an array of field objects'\n      );\n    }\n\n    try {\n      const parsedFields = fields.map((v) => {\n        const parsed = this.parseField(v);\n        validateField(parsed, 'input');\n        return parsed;\n      });\n      this.inputFields = parsedFields;\n      this.invalidateValidationCache();\n      this.updateHashLight();\n    } catch (error) {\n      if (error instanceof AxSignatureValidationError) {\n        throw error;\n      }\n      throw new AxSignatureValidationError(\n        `Failed to set input fields: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  };\n\n  public setOutputFields = (fields: readonly AxField[]) => {\n    if (!Array.isArray(fields)) {\n      throw new AxSignatureValidationError(\n        'Output fields must be an array',\n        undefined,\n        'Provide an array of field objects'\n      );\n    }\n\n    try {\n      const parsedFields = fields.map((v) => {\n        const parsed = this.parseField(v);\n        validateField(parsed, 'output');\n        return parsed;\n      });\n      this.outputFields = parsedFields;\n      this.invalidateValidationCache();\n      this.updateHashLight();\n    } catch (error) {\n      if (error instanceof AxSignatureValidationError) {\n        throw error;\n      }\n      throw new AxSignatureValidationError(\n        `Failed to set output fields: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  };\n\n  public getInputFields = (): Readonly<AxIField[]> => this.inputFields;\n  public getOutputFields = (): Readonly<AxIField[]> => this.outputFields;\n  public getDescription = () => this.description;\n\n  // Type-safe field addition methods that return new signature instances\n  public appendInputField = <K extends string, T extends AxFieldType>(\n    name: K,\n    fieldType: T\n  ): AxSignature<_TInput & Record<K, InferFieldValueType<T>>, _TOutput> => {\n    const newSig = new AxSignature(this);\n    newSig.addInputField({\n      name,\n      ...convertFieldTypeToAxField(fieldType),\n    });\n    return newSig as AxSignature<\n      _TInput & Record<K, InferFieldValueType<T>>,\n      _TOutput\n    >;\n  };\n\n  public prependInputField = <K extends string, T extends AxFieldType>(\n    name: K,\n    fieldType: T\n  ): AxSignature<Record<K, InferFieldValueType<T>> & _TInput, _TOutput> => {\n    const newSig = new AxSignature(this);\n    const fieldToAdd = {\n      name,\n      ...convertFieldTypeToAxField(fieldType),\n    };\n\n    // Validate the field before adding\n    const parsedField = newSig.parseField(fieldToAdd);\n    validateField(parsedField, 'input');\n\n    // Check for duplicate field names\n    for (const existingField of newSig.inputFields) {\n      if (existingField.name === parsedField.name) {\n        throw new AxSignatureValidationError(\n          `Duplicate input field name: \"${parsedField.name}\"`,\n          parsedField.name,\n          'Each field name must be unique within the signature'\n        );\n      }\n    }\n\n    // Check if field name conflicts with existing output fields\n    for (const outputField of newSig.outputFields) {\n      if (outputField.name === parsedField.name) {\n        throw new AxSignatureValidationError(\n          `Field name \"${parsedField.name}\" appears in both inputs and outputs`,\n          parsedField.name,\n          'Use different names for input and output fields to avoid confusion'\n        );\n      }\n    }\n\n    // Prepend to the beginning of input fields array\n    newSig.inputFields.unshift(parsedField);\n    newSig.invalidateValidationCache();\n    newSig.updateHashLight();\n\n    return newSig as AxSignature<\n      Record<K, InferFieldValueType<T>> & _TInput,\n      _TOutput\n    >;\n  };\n\n  public appendOutputField = <K extends string, T extends AxFieldType>(\n    name: K,\n    fieldType: T\n  ): AxSignature<_TInput, _TOutput & Record<K, InferFieldValueType<T>>> => {\n    const newSig = new AxSignature(this);\n    newSig.addOutputField({\n      name,\n      ...convertFieldTypeToAxField(fieldType),\n    });\n    return newSig as AxSignature<\n      _TInput,\n      _TOutput & Record<K, InferFieldValueType<T>>\n    >;\n  };\n\n  public prependOutputField = <K extends string, T extends AxFieldType>(\n    name: K,\n    fieldType: T\n  ): AxSignature<_TInput, Record<K, InferFieldValueType<T>> & _TOutput> => {\n    const newSig = new AxSignature(this);\n    const fieldToAdd = {\n      name,\n      ...convertFieldTypeToAxField(fieldType),\n    };\n\n    // Validate the field before adding\n    const parsedField = newSig.parseField(fieldToAdd);\n    validateField(parsedField, 'output');\n\n    // Check for duplicate field names\n    for (const existingField of newSig.outputFields) {\n      if (existingField.name === parsedField.name) {\n        throw new AxSignatureValidationError(\n          `Duplicate output field name: \"${parsedField.name}\"`,\n          parsedField.name,\n          'Each field name must be unique within the signature'\n        );\n      }\n    }\n\n    // Check if field name conflicts with existing input fields\n    for (const inputField of newSig.inputFields) {\n      if (inputField.name === parsedField.name) {\n        throw new AxSignatureValidationError(\n          `Field name \"${parsedField.name}\" appears in both inputs and outputs`,\n          parsedField.name,\n          'Use different names for input and output fields to avoid confusion'\n        );\n      }\n    }\n\n    // Prepend to the beginning of output fields array\n    newSig.outputFields.unshift(parsedField);\n    newSig.invalidateValidationCache();\n    newSig.updateHashLight();\n\n    return newSig as AxSignature<\n      _TInput,\n      Record<K, InferFieldValueType<T>> & _TOutput\n    >;\n  };\n\n  private invalidateValidationCache = (): void => {\n    this.validatedAtHash = undefined;\n  };\n\n  private toTitle = (name: string) => {\n    let result = name.replace(/_/g, ' ');\n    result = result.replace(/([A-Z]|[0-9]+)/g, ' $1').trim();\n    return result.charAt(0).toUpperCase() + result.slice(1);\n  };\n\n  public toJSONSchema = (): AxFunctionJSONSchema => {\n    const properties: Record<string, unknown> = {};\n    const required: Array<string> = [];\n\n    for (const f of this.inputFields) {\n      const type = f.type ? f.type.name : 'string';\n      if (f.type?.isArray) {\n        properties[f.name] = {\n          description: f.description,\n          type: 'array' as const,\n          items: {\n            type: type,\n            description: f.description,\n          },\n        };\n      } else {\n        properties[f.name] = {\n          description: f.description,\n          type: type,\n        };\n      }\n\n      if (!f.isOptional) {\n        required.push(f.name);\n      }\n    }\n\n    const schema = {\n      type: 'object',\n      properties: properties,\n      required: required,\n    };\n\n    return schema as AxFunctionJSONSchema;\n  };\n\n  private updateHashLight = (): [string, string] => {\n    try {\n      // Light validation - only validate individual fields, not full signature consistency\n      this.getInputFields().forEach((field) => {\n        validateField(field, 'input');\n      });\n      this.getOutputFields().forEach((field) => {\n        validateField(field, 'output');\n      });\n\n      this.sigHash = createHash('sha256')\n        .update(JSON.stringify(this.inputFields))\n        .update(JSON.stringify(this.outputFields))\n        .digest('hex');\n\n      this.sigString = renderSignature(\n        this.description,\n        this.inputFields,\n        this.outputFields\n      );\n\n      return [this.sigHash, this.sigString];\n    } catch (error) {\n      if (error instanceof AxSignatureValidationError) {\n        throw error;\n      }\n      throw new AxSignatureValidationError(\n        `Signature validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  };\n\n  private updateHash = (): [string, string] => {\n    try {\n      this.getInputFields().forEach((field) => {\n        validateField(field, 'input');\n      });\n      this.getOutputFields().forEach((field) => {\n        validateField(field, 'output');\n      });\n\n      this.validateSignatureConsistency();\n\n      this.sigHash = createHash('sha256')\n        .update(this.description ?? '')\n        .update(JSON.stringify(this.inputFields))\n        .update(JSON.stringify(this.outputFields))\n        .digest('hex');\n\n      this.sigString = renderSignature(\n        this.description,\n        this.inputFields,\n        this.outputFields\n      );\n\n      return [this.sigHash, this.sigString];\n    } catch (error) {\n      if (error instanceof AxSignatureValidationError) {\n        throw error;\n      }\n      throw new AxSignatureValidationError(\n        `Signature validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  };\n\n  private validateSignatureConsistency(): void {\n    const inputNames = new Set<string>();\n    for (const field of this.inputFields) {\n      if (inputNames.has(field.name)) {\n        throw new AxSignatureValidationError(\n          `Duplicate input field name: \"${field.name}\"`,\n          field.name,\n          'Each field name must be unique within the signature'\n        );\n      }\n      inputNames.add(field.name);\n    }\n\n    const outputNames = new Set<string>();\n    for (const field of this.outputFields) {\n      if (outputNames.has(field.name)) {\n        throw new AxSignatureValidationError(\n          `Duplicate output field name: \"${field.name}\"`,\n          field.name,\n          'Each field name must be unique within the signature'\n        );\n      }\n      outputNames.add(field.name);\n    }\n\n    for (const outputField of this.outputFields) {\n      if (inputNames.has(outputField.name)) {\n        throw new AxSignatureValidationError(\n          `Field name \"${outputField.name}\" appears in both inputs and outputs`,\n          outputField.name,\n          'Use different names for input and output fields to avoid confusion'\n        );\n      }\n    }\n\n    if (this.inputFields.length === 0) {\n      throw new AxSignatureValidationError(\n        'Signature must have at least one input field',\n        undefined,\n        'Add an input field. Example: \"userInput:string -> ...\"'\n      );\n    }\n\n    if (this.outputFields.length === 0) {\n      throw new AxSignatureValidationError(\n        'Signature must have at least one output field',\n        undefined,\n        'Add an output field. Example: \"... -> responseText:string\"'\n      );\n    }\n  }\n\n  public validate = (): boolean => {\n    // Check if already validated at current hash\n    if (this.validatedAtHash === this.sigHash) {\n      return true;\n    }\n\n    try {\n      // Perform full validation\n      this.updateHash();\n\n      // Cache validation success\n      this.validatedAtHash = this.sigHash;\n\n      return true;\n    } catch (error) {\n      // Clear validation cache on failure\n      this.validatedAtHash = undefined;\n      throw error;\n    }\n  };\n\n  public hash = () => this.sigHash;\n\n  public toString = () => this.sigString;\n\n  public toJSON = () => {\n    return {\n      id: this.hash(),\n      description: this.description,\n      inputFields: this.inputFields,\n      outputFields: this.outputFields,\n    };\n  };\n}\n\nfunction renderField(field: Readonly<AxField>): string {\n  let result = field.name;\n  if (field.isOptional) {\n    result += '?';\n  }\n  if (field.isInternal) {\n    result += '!';\n  }\n  if (field.type) {\n    result += `:${field.type.name}`;\n    if (field.type.isArray) {\n      result += '[]';\n    }\n    if (field.type.name === 'class' && field.type.options) {\n      result += ` \"${field.type.options.join(' | ')}\"`;\n    }\n  }\n  if (field.description && field.type?.name !== 'class') {\n    result += ` \"${field.description}\"`;\n  }\n  return result;\n}\n\nfunction renderSignature(\n  description: string | undefined,\n  inputFields: readonly AxField[],\n  outputFields: readonly AxField[]\n): string {\n  const descriptionPart = description ? `\"${description}\" ` : '';\n\n  const inputFieldsRendered = inputFields.map(renderField).join(', ');\n\n  const outputFieldsRendered = outputFields.map(renderField).join(', ');\n\n  return `${descriptionPart}${inputFieldsRendered} -> ${outputFieldsRendered}`;\n}\n\nfunction isValidCase(inputString: string): boolean {\n  const camelCaseRegex = /^[a-z][a-zA-Z0-9]*$/;\n  const snakeCaseRegex = /^[a-z]+(_[a-z0-9]+)*$/;\n\n  return camelCaseRegex.test(inputString) || snakeCaseRegex.test(inputString);\n}\n\nfunction validateField(\n  field: Readonly<AxField>,\n  context: 'input' | 'output'\n): void {\n  if (!field.name || field.name.length === 0) {\n    throw new AxSignatureValidationError(\n      'Field name cannot be blank',\n      field.name,\n      'Every field must have a descriptive name'\n    );\n  }\n\n  if (!isValidCase(field.name)) {\n    throw new AxSignatureValidationError(\n      `Invalid field name '${field.name}' - must be camelCase or snake_case`,\n      field.name,\n      'Use camelCase (e.g., \"userInput\") or snake_case (e.g., \"user_input\")'\n    );\n  }\n\n  if (axGlobals.signatureStrict) {\n    const reservedNames = [\n      'text',\n      'object',\n      'image',\n      'string',\n      'number',\n      'boolean',\n      'json',\n      'array',\n      'datetime',\n      'date',\n      'time',\n      'type',\n      'class',\n      'input',\n      'output',\n      'data',\n      'value',\n      'result',\n      'response',\n      'request',\n      'item',\n      'element',\n    ];\n\n    if (reservedNames.includes(field.name.toLowerCase())) {\n      const suggestions =\n        context === 'input'\n          ? [\n              'userInput',\n              'questionText',\n              'documentContent',\n              'messageText',\n              'queryString',\n            ]\n          : [\n              'responseText',\n              'analysisResult',\n              'categoryType',\n              'summaryText',\n              'outputData',\n            ];\n\n      throw new AxSignatureValidationError(\n        `Field name '${field.name}' is too generic`,\n        field.name,\n        `Use a more descriptive name. Examples for ${context} fields: ${suggestions.join(', ')}`\n      );\n    }\n  }\n\n  if (field.name.length < 2) {\n    throw new AxSignatureValidationError(\n      `Field name '${field.name}' is too short`,\n      field.name,\n      'Field names must be at least 2 characters long'\n    );\n  }\n\n  if (field.name.length > 50) {\n    throw new AxSignatureValidationError(\n      `Field name '${field.name}' is too long (${field.name.length} characters)`,\n      field.name,\n      'Field names should be 50 characters or less'\n    );\n  }\n\n  if (field.type) {\n    validateFieldType(field, context);\n  }\n}\n\nfunction validateFieldType(\n  field: Readonly<AxField>,\n  context: 'input' | 'output'\n): void {\n  if (!field.type) return;\n\n  const { type } = field;\n\n  if (\n    type.name === 'image' ||\n    type.name === 'audio' ||\n    type.name === 'file' ||\n    type.name === 'url'\n  ) {\n    if (context === 'output') {\n      throw new AxSignatureValidationError(\n        `${type.name} type is not supported in output fields`,\n        field.name,\n        `${type.name} types can only be used in input fields`\n      );\n    }\n  }\n\n  if (type.name === 'class') {\n    if (context === 'input') {\n      throw new AxSignatureValidationError(\n        'Class type is not supported in input fields',\n        field.name,\n        'Class types are only allowed on output fields. Use \"string\" type for input classifications'\n      );\n    }\n\n    if (!type.options || type.options.length === 0) {\n      throw new AxSignatureValidationError(\n        'Class type requires options',\n        field.name,\n        'Provide class options. Example: class \"positive, negative, neutral\"'\n      );\n    }\n\n    for (const option of type.options) {\n      if (!option || option.trim().length === 0) {\n        throw new AxSignatureValidationError(\n          'Empty class option found',\n          field.name,\n          'All class options must be non-empty strings'\n        );\n      }\n\n      const trimmedOption = option.trim();\n      if (trimmedOption.includes(',') || trimmedOption.includes('|')) {\n        throw new AxSignatureValidationError(\n          `Invalid class option \"${trimmedOption}\"`,\n          field.name,\n          'Class options cannot contain commas (,) or pipes (|) as they are used to separate options'\n        );\n      }\n    }\n\n    const uniqueOptions = new Set(\n      type.options.map((opt) => opt.trim().toLowerCase())\n    );\n    if (uniqueOptions.size !== type.options.length) {\n      throw new AxSignatureValidationError(\n        'Duplicate class options found',\n        field.name,\n        'Each class option must be unique (case-insensitive)'\n      );\n    }\n  }\n\n  if (type.name === 'code' && type.isArray) {\n    throw new AxSignatureValidationError(\n      'Arrays of code are not commonly supported',\n      field.name,\n      'Consider using a single code field or an array of strings instead'\n    );\n  }\n\n  if (field.isInternal && context === 'input') {\n    throw new AxSignatureValidationError(\n      'Internal marker (!) is not allowed on input fields',\n      field.name,\n      'Internal markers are only allowed on output fields'\n    );\n  }\n}\n","import type { AxOptimizedProgram } from './optimizer.js';\nimport { AxInstanceRegistry } from './registry.js';\nimport { AxSignature } from './sig.js';\nimport type {\n  AxFieldValue,\n  AxProgramDemos,\n  AxProgramExamples,\n  AxProgramOptions,\n  AxProgramTrace,\n  AxProgramUsage,\n  AxSetExamplesOptions,\n  AxTunable,\n  AxUsable,\n} from './types.js';\n\nimport { mergeProgramUsage, validateValue } from './util.js';\n\nexport class AxProgram<IN, OUT> implements AxUsable, AxTunable<IN, OUT> {\n  protected signature: AxSignature;\n  protected sigHash: string;\n\n  protected examples?: OUT[];\n  protected examplesOptions?: AxSetExamplesOptions;\n  protected demos?: OUT[];\n  protected trace?: OUT;\n  protected usage: AxProgramUsage[] = [];\n  protected traceLabel?: string;\n\n  private key: { id: string; custom?: boolean };\n  private children: AxInstanceRegistry<Readonly<AxTunable<IN, OUT>>, IN, OUT>;\n\n  constructor(\n    signature: ConstructorParameters<typeof AxSignature>[0],\n    options?: Readonly<AxProgramOptions>\n  ) {\n    this.signature = new AxSignature(signature);\n\n    if (options?.description) {\n      this.signature.setDescription(options.description);\n    }\n\n    if (options?.traceLabel) {\n      this.traceLabel = options.traceLabel;\n    }\n\n    // Only validate if signature is provided\n    if (signature) {\n      this.signature.validate();\n    }\n\n    this.sigHash = this.signature?.hash();\n    this.children = new AxInstanceRegistry();\n    this.key = { id: this.signature.hash() };\n  }\n\n  public getSignature(): AxSignature {\n    return new AxSignature(this.signature);\n  }\n\n  public setSignature(\n    signature: ConstructorParameters<typeof AxSignature>[0]\n  ): void {\n    this.signature = new AxSignature(signature);\n\n    // Validate the new signature if it's provided\n    if (signature) {\n      this.signature.validate();\n    }\n\n    // Update the signature hash and key\n    this.updateSignatureHash();\n  }\n\n  public setDescription(description: string) {\n    this.signature.setDescription(description);\n    this.updateSignatureHash();\n  }\n\n  private updateSignatureHash() {\n    this.sigHash = this.signature.hash();\n    this.key = { id: this.signature.hash() };\n  }\n\n  public register(prog: Readonly<AxTunable<IN, OUT> & AxUsable>) {\n    if (this.key) {\n      prog.setParentId(this.key.id);\n    }\n    this.children.register(prog);\n  }\n\n  public setId(id: string) {\n    this.key = { id, custom: true };\n    for (const child of Array.from(this.children)) {\n      child?.setParentId(id);\n    }\n  }\n\n  public setParentId(parentId: string) {\n    if (!this.key.custom) {\n      this.key.id = [parentId, this.key.id].join('/');\n    }\n  }\n\n  public setExamples(\n    examples: Readonly<AxProgramExamples<IN, OUT>>,\n    options?: Readonly<AxSetExamplesOptions>\n  ) {\n    this._setExamples(examples, options);\n\n    if (!('programId' in examples)) {\n      return;\n    }\n\n    for (const child of Array.from(this.children)) {\n      child?.setExamples(examples, options);\n    }\n  }\n\n  private _setExamples(\n    examples: Readonly<AxProgramExamples<IN, OUT>>,\n    options?: Readonly<AxSetExamplesOptions>\n  ) {\n    let traces: Record<string, AxFieldValue>[] = [];\n\n    if ('programId' in examples && examples.programId === this.key.id) {\n      traces = examples.traces as any;\n    }\n\n    if (Array.isArray(examples)) {\n      traces = examples as any;\n    }\n\n    if (traces) {\n      this.examplesOptions = options;\n      const sig = this.signature;\n      const fields = [...sig.getInputFields(), ...sig.getOutputFields()];\n\n      this.examples = traces.map((e) => {\n        const res: Record<string, AxFieldValue> = {};\n        for (const f of fields) {\n          const value = e[f.name];\n          if (value !== undefined) {\n            // Only validate the type of fields that are actually set\n            // Allow any field to be missing regardless of whether it's required\n            validateValue(f, value);\n            res[f.name] = value;\n          }\n        }\n        return res;\n      }) as OUT[];\n    }\n  }\n\n  public getTraces(): AxProgramTrace<IN, OUT>[] {\n    let traces: AxProgramTrace<IN, OUT>[] = [];\n\n    if (this.trace) {\n      traces.push({ trace: this.trace as OUT & IN, programId: this.key.id });\n    }\n\n    for (const child of Array.from(this.children)) {\n      const Traces = child?.getTraces();\n      traces = [...traces, ...(Traces ?? [])];\n    }\n    return traces;\n  }\n\n  public getUsage(): AxProgramUsage[] {\n    let usage: AxProgramUsage[] = [...(this.usage ?? [])];\n\n    for (const child of Array.from(this.children)) {\n      const cu = child?.getUsage();\n      usage = [...usage, ...(cu ?? [])];\n    }\n    return mergeProgramUsage(usage);\n  }\n\n  public resetUsage() {\n    this.usage = [];\n    for (const child of Array.from(this.children)) {\n      child?.resetUsage();\n    }\n  }\n\n  public setDemos(demos: readonly AxProgramDemos<IN, OUT>[]) {\n    // Check if this program has children and if its programId is not found in demos\n    const hasChildren = Array.from(this.children).length > 0;\n    const hasMatchingDemo = demos.some(\n      (demo) => demo.programId === this.key.id\n    );\n\n    if (hasChildren && !hasMatchingDemo) {\n      throw new Error(\n        `Program with id '${this.key.id}' has children but no matching programId found in demos`\n      );\n    }\n\n    // biome-ignore lint/complexity/useFlatMap: it can't\n    this.demos = demos\n      .filter((v) => v.programId === this.key.id)\n      .map((v) => v.traces)\n      .flat();\n\n    for (const child of Array.from(this.children)) {\n      child?.setDemos(demos);\n    }\n  }\n\n  /**\n   * Apply optimized configuration to this program\n   * @param optimizedProgram The optimized program configuration to apply\n   */\n  public applyOptimization(optimizedProgram: AxOptimizedProgram<OUT>): void {\n    optimizedProgram.applyTo(this as any);\n\n    // Propagate to children\n    for (const child of Array.from(this.children)) {\n      if (\n        child &&\n        'applyOptimization' in child &&\n        typeof child.applyOptimization === 'function'\n      ) {\n        child.applyOptimization(optimizedProgram);\n      }\n    }\n  }\n}\n","import type { AxChatRequest } from '../ai/types.js';\n\nimport { formatDateWithTimezone } from './datetime.js';\nimport type { AxInputFunctionType } from './functions.js';\nimport type { AxField, AxIField, AxSignature } from './sig.js';\nimport type { AxFieldValue, AxMessage } from './types.js';\nimport { validateValue } from './util.js';\n\ntype Writeable<T> = { -readonly [P in keyof T]: T[P] };\n\n// Define options type for AxPromptTemplate constructor\nexport interface AxPromptTemplateOptions {\n  functions?: Readonly<AxInputFunctionType>;\n  thoughtFieldName?: string;\n  cacheSystemPrompt?: boolean;\n}\ntype AxChatRequestChatPrompt = Writeable<AxChatRequest['chatPrompt'][0]>;\n\ntype ChatRequestUserMessage = Exclude<\n  Extract<AxChatRequestChatPrompt, { role: 'user' }>['content'],\n  string\n>;\n\nconst functionCallInstructions = `\n## Function Call Instructions\n- Complete the task, using the functions defined earlier in this prompt.\n- Output fields should only be generated after all functions have been called.\n- Use the function results to generate the output fields.`;\n\nconst formattingRules = `\n## Strict Output Formatting Rules\n- No formatting rules should override these **Strict Output Formatting Rules**\n- Output must strictly follow the defined plain-text \\`field name: value\\` field format.\n- Output field, values must strictly adhere to the specified output field formatting rules.\n- Do not include fields with empty, unknown, or placeholder values.\n- Do not add any text before or after the output fields, just the field name and value.\n- Do not use code blocks.`;\n\nexport type AxFieldTemplateFn = (\n  field: Readonly<AxField>,\n  value: Readonly<AxFieldValue>\n) => ChatRequestUserMessage;\n\nexport class AxPromptTemplate {\n  private sig: Readonly<AxSignature>;\n  private fieldTemplates?: Record<string, AxFieldTemplateFn>;\n  private task: { type: 'text'; text: string };\n  private readonly thoughtFieldName: string;\n  private readonly functions?: Readonly<AxInputFunctionType>;\n  private readonly cacheSystemPrompt?: boolean;\n\n  constructor(\n    sig: Readonly<AxSignature>,\n    options?: Readonly<AxPromptTemplateOptions>,\n    fieldTemplates?: Record<string, AxFieldTemplateFn>\n  ) {\n    this.sig = sig;\n    this.fieldTemplates = fieldTemplates;\n    this.thoughtFieldName = options?.thoughtFieldName ?? 'thought';\n    this.functions = options?.functions;\n    this.cacheSystemPrompt = options?.cacheSystemPrompt;\n\n    const task = [];\n\n    const inArgs = renderDescFields(this.sig.getInputFields());\n    const outArgs = renderDescFields(this.sig.getOutputFields());\n    task.push(\n      `You will be provided with the following fields: ${inArgs}. Your task is to generate new fields: ${outArgs}.`\n    );\n\n    // biome-ignore lint/complexity/useFlatMap: you cannot use flatMap here\n    const funcs = this.functions\n      ?.map((f) => ('toFunction' in f ? f.toFunction() : f))\n      ?.flat();\n\n    const funcList = funcs\n      ?.map((fn) => `- \\`${fn.name}\\`: ${formatDescription(fn.description)}`)\n      .join('\\n');\n\n    if (funcList && funcList.length > 0) {\n      task.push(`## Available Functions\\n${funcList}`);\n    }\n\n    const inputFields = renderInputFields(this.sig.getInputFields());\n    task.push(`## Input Fields\\n${inputFields}`);\n\n    const outputFields = renderOutputFields(this.sig.getOutputFields());\n    task.push(`## Output Fields\\n${outputFields}`);\n\n    if (funcList && funcList.length > 0) {\n      task.push(functionCallInstructions.trim());\n    }\n\n    task.push(formattingRules.trim());\n\n    const desc = this.sig.getDescription();\n    if (desc) {\n      const text = formatDescription(desc);\n      task.push(text);\n    }\n\n    this.task = {\n      type: 'text' as const,\n      text: task.join('\\n\\n'),\n    };\n  }\n\n  private renderSingleValueUserContent = <T = any>(\n    values: T,\n    renderedExamples: ChatRequestUserMessage,\n    renderedDemos: ChatRequestUserMessage,\n    examplesInSystemPrompt: boolean\n  ): string | ChatRequestUserMessage => {\n    const completion = this.renderInputFields(values);\n    const promptList: ChatRequestUserMessage = examplesInSystemPrompt\n      ? completion\n      : [...renderedExamples, ...renderedDemos, ...completion];\n\n    const prompt = promptList.filter((v) => v !== undefined);\n\n    return prompt.every((v) => v.type === 'text')\n      ? prompt.map((v) => v.text).join('\\n')\n      : prompt.reduce(combineConsecutiveStrings('\\n'), []);\n  };\n\n  public render = <T = any>(\n    values: T | ReadonlyArray<AxMessage<T>>, // Allow T or array of AxMessages\n    {\n      examples,\n      demos,\n    }: Readonly<{\n      skipSystemPrompt?: boolean;\n      examples?: Record<string, AxFieldValue>[]; // Keep as is, examples are specific structures\n      demos?: Record<string, AxFieldValue>[]; // Keep as is\n    }>\n  ): Extract<\n    AxChatRequest['chatPrompt'][number],\n    { role: 'user' | 'system' | 'assistant' }\n  >[] => {\n    const renderedExamples = examples\n      ? [\n          { type: 'text' as const, text: '\\n\\n## Examples\\n' },\n          ...this.renderExamples(examples),\n        ]\n      : [];\n\n    const renderedDemos = demos ? this.renderDemos(demos) : [];\n\n    // Check if demos and examples are all text type\n    const allTextExamples = renderedExamples.every((v) => v.type === 'text');\n    const allTextDemos = renderedDemos.every((v) => v.type === 'text');\n    const examplesInSystemPrompt = allTextExamples && allTextDemos;\n\n    let systemContent = this.task.text;\n\n    if (examplesInSystemPrompt) {\n      const combinedItems = [\n        { type: 'text' as const, text: systemContent },\n        ...renderedExamples,\n        ...renderedDemos,\n      ];\n      combinedItems.reduce(combineConsecutiveStrings(''), []);\n\n      if (combinedItems?.[0]) {\n        systemContent = combinedItems[0].text;\n      }\n    }\n\n    const systemPrompt = {\n      role: 'system' as const,\n      content: systemContent,\n      cache: this.cacheSystemPrompt,\n    };\n\n    if (Array.isArray(values)) {\n      const messages: Extract<\n        AxChatRequest['chatPrompt'][number],\n        { role: 'user' } | { role: 'assistant' }\n      >[] = [];\n\n      const history = values as ReadonlyArray<AxMessage<T>>;\n\n      let firstItem = true;\n      for (const message of history) {\n        let content: string | ChatRequestUserMessage;\n\n        if (firstItem) {\n          content = this.renderSingleValueUserContent(\n            message.values,\n            renderedExamples,\n            renderedDemos,\n            examplesInSystemPrompt\n          );\n          firstItem = false;\n        } else {\n          content = this.renderSingleValueUserContent(\n            message.values,\n            [],\n            [],\n            false\n          );\n        }\n\n        if (message.role === 'user') {\n          messages.push({ role: 'user', content });\n          continue;\n        }\n\n        if (message.role !== 'assistant') {\n          throw new Error('Invalid message role');\n        }\n\n        if (typeof content !== 'string') {\n          throw new Error(\n            'Assistant message cannot contain non-text content like images, files,etc'\n          );\n        }\n\n        messages.push({ role: 'assistant', content });\n      }\n\n      return [systemPrompt, ...messages];\n    }\n\n    // values is T - existing logic path\n    const userContent = this.renderSingleValueUserContent(\n      values as T,\n      renderedExamples,\n      renderedDemos,\n      examplesInSystemPrompt\n    );\n\n    return [systemPrompt, { role: 'user' as const, content: userContent }];\n  };\n\n  public renderExtraFields = (extraFields: readonly AxIField[]) => {\n    const prompt: ChatRequestUserMessage = [];\n\n    if (!extraFields || extraFields.length === 0) {\n      return prompt;\n    }\n\n    const groupedFields = extraFields.reduce(\n      (acc, field) => {\n        const title = field.title;\n        if (!acc[title]) {\n          acc[title] = [];\n        }\n        acc[title].push(field);\n        return acc;\n      },\n      {} as Record<string, AxIField[]>\n    );\n\n    const formattedGroupedFields = Object.entries(groupedFields)\n      .map(([title, fields]) => {\n        if (fields.length === 1) {\n          const field = fields[0]!;\n          return {\n            title,\n            name: field.name,\n            description: field.description,\n          };\n        }\n        if (fields.length > 1) {\n          const valuesList = fields\n            .map((field) => `- ${field.description}`)\n            .join('\\n');\n          return {\n            title,\n            name: fields[0]!.name,\n            description: valuesList,\n          };\n        }\n      })\n      .filter(Boolean) as AxIField[];\n\n    formattedGroupedFields.forEach((field) => {\n      const fn = this.fieldTemplates?.[field.name] ?? this.defaultRenderInField;\n      prompt.push(...fn(field, field.description));\n    });\n\n    return prompt;\n  };\n\n  private renderExamples = (data: Readonly<Record<string, AxFieldValue>[]>) => {\n    const list: ChatRequestUserMessage = [];\n    const exampleContext = {\n      isExample: true,\n    };\n\n    for (const [index, item] of data.entries()) {\n      const renderedInputItem = this.sig\n        .getInputFields()\n        .map((field) =>\n          this.renderInField(field, item, {\n            ...exampleContext,\n            isInputField: true,\n          })\n        )\n        .filter((v) => v !== undefined)\n        .flat();\n\n      const renderedOutputItem = this.sig\n        .getOutputFields()\n        .map((field) =>\n          this.renderInField(field, item, {\n            ...exampleContext,\n            isInputField: false,\n          })\n        )\n        .filter((v) => v !== undefined)\n        .flat();\n\n      const renderedItem = [...renderedInputItem, ...renderedOutputItem];\n\n      if (\n        index > 0 &&\n        renderedItem.length > 0 &&\n        renderedItem[0]?.type === 'text'\n      ) {\n        list.push({ type: 'text' as const, text: '---\\n\\n' });\n      }\n\n      renderedItem.forEach((v) => {\n        if ('text' in v) {\n          v.text = `${v.text}\\n`;\n        }\n        list.push(v);\n      });\n    }\n\n    return list;\n  };\n\n  private renderDemos = (data: Readonly<Record<string, AxFieldValue>[]>) => {\n    const list: ChatRequestUserMessage = [];\n    const inputFields = this.sig.getInputFields();\n    const outputFields = this.sig.getOutputFields();\n    const demoContext = {\n      isExample: true,\n    };\n\n    for (const item of data) {\n      const inputRenderedItems = inputFields\n        .map((field) =>\n          this.renderInField(field, item, {\n            ...demoContext,\n            isInputField: true,\n          })\n        )\n        .filter((v) => v !== undefined)\n        .flat();\n\n      const outputRenderedItems = outputFields\n        .map((field) =>\n          this.renderInField(field, item, {\n            ...demoContext,\n            isInputField: false,\n          })\n        )\n        .filter((v) => v !== undefined)\n        .flat();\n\n      const renderedItem = [...inputRenderedItems, ...outputRenderedItems];\n\n      renderedItem.slice(0, -1).forEach((v) => {\n        if ('text' in v) {\n          v.text = `${v.text}\\n`;\n        }\n        list.push(v);\n      });\n    }\n\n    return list;\n  };\n\n  private renderInputFields = <T = any>(values: T) => {\n    const renderedItems = this.sig\n      .getInputFields()\n      .map((field) => this.renderInField(field, values as any, undefined))\n      .filter((v) => v !== undefined)\n      .flat();\n\n    renderedItems\n      .filter((v) => v.type === 'text')\n      .forEach((v) => {\n        v.text = `${v.text}\\n`;\n      });\n\n    return renderedItems;\n  };\n\n  private renderInField = (\n    field: Readonly<AxField>,\n    values: Readonly<Record<string, AxFieldValue>>,\n    context?: {\n      isExample?: boolean;\n      strictExamples?: boolean;\n      optionalOutputFields?: string[];\n      isInputField?: boolean;\n    }\n  ) => {\n    const value = values[field.name];\n\n    if (isEmptyValue(field, value, context)) {\n      return;\n    }\n\n    if (field.type) {\n      validateValue(field, value!);\n    }\n\n    const processedValue = processValue(field, value!);\n\n    const textFieldFn: AxFieldTemplateFn =\n      this.fieldTemplates?.[field.name] ?? this.defaultRenderInField;\n\n    return textFieldFn(field, processedValue);\n  };\n\n  private defaultRenderInField = (\n    field: Readonly<AxField>,\n    value: Readonly<AxFieldValue>\n  ): ChatRequestUserMessage => {\n    if (field.type?.name === 'image') {\n      const validateImage = (\n        value: Readonly<AxFieldValue>\n      ): { mimeType: string; data: string } => {\n        if (!value) {\n          throw new Error('Image field value is required.');\n        }\n\n        if (typeof value !== 'object') {\n          throw new Error('Image field value must be an object.');\n        }\n        if (!('mimeType' in value)) {\n          throw new Error('Image field must have mimeType');\n        }\n        if (!('data' in value)) {\n          throw new Error('Image field must have data');\n        }\n        return value as { mimeType: string; data: string };\n      };\n\n      let result: ChatRequestUserMessage = [\n        { type: 'text', text: `${field.title}: ` as string },\n      ];\n\n      if (field.type.isArray) {\n        if (!Array.isArray(value)) {\n          throw new Error('Image field value must be an array.');\n        }\n        result = result.concat(\n          (value as unknown[]).map((v) => {\n            // Cast to unknown[] before map\n            const validated = validateImage(v as AxFieldValue);\n            return {\n              type: 'image',\n              mimeType: validated.mimeType,\n              image: validated.data,\n            };\n          })\n        );\n      } else {\n        const validated = validateImage(value);\n        result.push({\n          type: 'image',\n          mimeType: validated.mimeType,\n          image: validated.data,\n        });\n      }\n      return result;\n    }\n\n    if (field.type?.name === 'audio') {\n      const validateAudio = (\n        value: Readonly<AxFieldValue>\n      ): { format?: 'wav'; data: string } => {\n        if (!value) {\n          throw new Error('Audio field value is required.');\n        }\n\n        if (typeof value !== 'object') {\n          throw new Error('Audio field value must be an object.');\n        }\n        if (!('data' in value)) {\n          throw new Error('Audio field must have data');\n        }\n        return value as { format?: 'wav'; data: string };\n      };\n\n      let result: ChatRequestUserMessage = [\n        { type: 'text', text: `${field.title}: ` as string },\n      ];\n\n      if (field.type.isArray) {\n        if (!Array.isArray(value)) {\n          throw new Error('Audio field value must be an array.');\n        }\n        result = result.concat(\n          (value as unknown[]).map((v) => {\n            // Cast to unknown[] before map\n            const validated = validateAudio(v as AxFieldValue);\n            return {\n              type: 'audio',\n              format: validated.format ?? 'wav',\n              data: validated.data,\n            };\n          })\n        );\n      } else {\n        const validated = validateAudio(value);\n        result.push({\n          type: 'audio',\n          format: validated.format ?? 'wav',\n          data: validated.data,\n        });\n      }\n      return result;\n    }\n\n    if (field.type?.name === 'file') {\n      const validateFile = (\n        value: Readonly<AxFieldValue>\n      ):\n        | { mimeType: string; data: string }\n        | { mimeType: string; fileUri: string } => {\n        if (!value) {\n          throw new Error('File field value is required.');\n        }\n        if (typeof value !== 'object') {\n          throw new Error('File field value must be an object.');\n        }\n        if (!('mimeType' in value)) {\n          throw new Error('File field must have mimeType');\n        }\n\n        // Support both data and fileUri formats\n        const hasData = 'data' in value;\n        const hasFileUri = 'fileUri' in value;\n\n        if (!hasData && !hasFileUri) {\n          throw new Error('File field must have either data or fileUri');\n        }\n        if (hasData && hasFileUri) {\n          throw new Error('File field cannot have both data and fileUri');\n        }\n\n        return value as\n          | { mimeType: string; data: string }\n          | { mimeType: string; fileUri: string };\n      };\n      let result: ChatRequestUserMessage = [\n        { type: 'text', text: `${field.title}: ` as string },\n      ];\n      if (field.type.isArray) {\n        if (!Array.isArray(value)) {\n          throw new Error('File field value must be an array.');\n        }\n        result = result.concat(\n          (value as unknown[]).map((v) => {\n            const validated = validateFile(v as AxFieldValue);\n            return 'fileUri' in validated\n              ? {\n                  type: 'file',\n                  mimeType: validated.mimeType,\n                  fileUri: validated.fileUri,\n                }\n              : {\n                  type: 'file',\n                  mimeType: validated.mimeType,\n                  data: validated.data,\n                };\n          })\n        );\n      } else {\n        const validated = validateFile(value);\n        result.push(\n          'fileUri' in validated\n            ? {\n                type: 'file',\n                mimeType: validated.mimeType,\n                fileUri: validated.fileUri,\n              }\n            : {\n                type: 'file',\n                mimeType: validated.mimeType,\n                data: validated.data,\n              }\n        );\n      }\n      return result;\n    }\n\n    if (field.type?.name === 'url') {\n      const validateUrl = (\n        value: Readonly<AxFieldValue>\n      ): { url: string; title?: string; description?: string } => {\n        if (!value) {\n          throw new Error('URL field value is required.');\n        }\n        if (typeof value === 'string') {\n          return { url: value };\n        }\n        if (typeof value !== 'object') {\n          throw new Error('URL field value must be a string or object.');\n        }\n        if (!('url' in value)) {\n          throw new Error('URL field must have url property');\n        }\n        return value as { url: string; title?: string; description?: string };\n      };\n      let result: ChatRequestUserMessage = [\n        { type: 'text', text: `${field.title}: ` as string },\n      ];\n      if (field.type.isArray) {\n        if (!Array.isArray(value)) {\n          throw new Error('URL field value must be an array.');\n        }\n        result = result.concat(\n          (value as unknown[]).map((v) => {\n            const validated = validateUrl(v as AxFieldValue);\n            return {\n              type: 'url',\n              url: validated.url,\n              ...(validated.title ? { title: validated.title } : {}),\n              ...(validated.description\n                ? { description: validated.description }\n                : {}),\n            };\n          })\n        );\n      } else {\n        const validated = validateUrl(value);\n        result.push({\n          type: 'url',\n          url: validated.url,\n          ...(validated.title ? { title: validated.title } : {}),\n          ...(validated.description\n            ? { description: validated.description }\n            : {}),\n        });\n      }\n      return result;\n    }\n\n    const text = [field.title, ': '];\n\n    if (Array.isArray(value)) {\n      text.push('\\n');\n      text.push(value.map((v) => `- ${v}`).join('\\n'));\n    } else {\n      text.push(value as string);\n    }\n    return [{ type: 'text', text: text.join('') }];\n  };\n}\n\nconst renderDescFields = (list: readonly AxField[]) =>\n  list.map((v) => `\\`${v.title}\\``).join(', ');\n\nconst renderInputFields = (fields: readonly AxField[]) => {\n  const rows = fields.map((field) => {\n    const name = field.title;\n    const type = field.type?.name ? toFieldType(field.type) : 'string';\n\n    const requiredMsg = field.isOptional\n      ? `This optional ${type} field may be omitted`\n      : `A ${type} field`;\n\n    const description = field.description\n      ? ` ${formatDescription(field.description)}`\n      : '';\n\n    return `${name}: (${requiredMsg})${description}`.trim();\n  });\n\n  return rows.join('\\n');\n};\n\nconst renderOutputFields = (fields: readonly AxField[]) => {\n  const rows = fields.map((field) => {\n    const name = field.title;\n    const type = field.type?.name ? toFieldType(field.type) : 'string';\n\n    const requiredMsg = field.isOptional\n      ? `Only include this ${type} field if its value is available`\n      : `This ${type} field must be included`;\n\n    let description = '';\n\n    if (field.description && field.description.length > 0) {\n      const value =\n        field.type?.name === 'class'\n          ? field.description\n          : formatDescription(field.description);\n      description = ` ${value}`;\n    }\n\n    if (field.type?.options && field.type.options.length > 0) {\n      if (description.length > 0) {\n        description += '. ';\n      }\n      description += `Allowed values: ${field.type.options.join(', ')}`;\n    }\n\n    return `${name}: (${requiredMsg})${description}`.trim();\n  });\n\n  return rows.join('\\n');\n};\n\nconst processValue = (\n  field: Readonly<AxField>,\n  value: Readonly<AxFieldValue>\n): AxFieldValue => {\n  if (field.type?.name === 'date' && value instanceof Date) {\n    const v = value.toISOString();\n    return v.slice(0, v.indexOf('T'));\n  }\n  if (field.type?.name === 'datetime' && value instanceof Date) {\n    return formatDateWithTimezone(value);\n  }\n  if (field.type?.name === 'image' && typeof value === 'object') {\n    return value;\n  }\n  if (field.type?.name === 'audio' && typeof value === 'object') {\n    return value;\n  }\n  if (field.type?.name === 'file' && typeof value === 'object') {\n    return value;\n  }\n  if (\n    field.type?.name === 'url' &&\n    (typeof value === 'string' || typeof value === 'object')\n  ) {\n    return value;\n  }\n  if (typeof value === 'string') {\n    return value;\n  }\n  return JSON.stringify(value, null, 2);\n};\n\nexport const toFieldType = (type: Readonly<AxField['type']>) => {\n  const baseType = (() => {\n    switch (type?.name) {\n      case 'string':\n        return 'string';\n      case 'number':\n        return 'number';\n      case 'boolean':\n        return 'boolean (true or false)';\n      case 'date':\n        return 'date (\"YYYY-MM-DD\" format)';\n      case 'datetime':\n        return 'date time (\"YYYY-MM-DD HH:mm Timezone\" format)';\n      case 'json':\n        return 'JSON object';\n      case 'class':\n        return 'classification class';\n      case 'code':\n        return 'code';\n      case 'file':\n        return 'file (with filename, mimeType, and data)';\n      case 'url':\n        return 'URL (string or object with url, title, description)';\n      default:\n        return 'string';\n    }\n  })();\n\n  return type?.isArray ? `json array of ${baseType} items` : baseType;\n};\n\nfunction combineConsecutiveStrings(separator: string) {\n  return (acc: ChatRequestUserMessage, current: ChatRequestUserMessage[0]) => {\n    if (current.type === 'text') {\n      const previous = acc.length > 0 ? acc[acc.length - 1] : null;\n      if (previous && previous.type === 'text') {\n        previous.text += separator + current.text;\n      } else {\n        acc.push(current);\n      }\n    } else {\n      acc.push(current);\n    }\n    return acc;\n  };\n}\n\nconst isEmptyValue = (\n  field: Readonly<AxField>,\n  value?: Readonly<AxFieldValue>,\n  context?: {\n    isExample?: boolean;\n    isInputField?: boolean;\n  }\n) => {\n  if (typeof value === 'boolean') {\n    return false;\n  }\n\n  if (field?.type?.name === 'number' && typeof value === 'number') {\n    return false;\n  }\n\n  if (\n    !value ||\n    ((Array.isArray(value) || typeof value === 'string') && value.length === 0)\n  ) {\n    // Handle examples case - all fields can be missing in examples\n    if (context?.isExample) {\n      return true;\n    }\n\n    // Handle non-examples case (regular field validation)\n    if (field.isOptional || field.isInternal) {\n      return true;\n    }\n\n    const fieldType = context?.isInputField !== false ? 'input' : 'output';\n    throw new Error(\n      `Value for ${fieldType} field '${field.name}' is required.`\n    );\n  }\n  return false;\n};\n\nfunction formatDescription(str: string) {\n  const value = str.trim();\n  return value.length > 0\n    ? `${value.charAt(0).toUpperCase()}${value.slice(1)}${value.endsWith('.') ? '' : '.'}`\n    : '';\n}\n","import type { AxAIMemory } from '../mem/types.js';\nimport type {\n  AxGenDeltaOut,\n  AxResultPickerFunction,\n  AxResultPickerFunctionFunctionResults,\n} from './types.js';\n\nexport interface AxSamplePickerOptions<OUT> {\n  resultPicker?: AxResultPickerFunction<OUT>;\n}\n\n/**\n * Checks if there are function calls in memory\n */\nfunction checkForFunctionCalls(mem: AxAIMemory, sessionId?: string): boolean {\n  const history = mem.history(0, sessionId);\n\n  // Check for both function calls and function results\n  const hasFunctionResults = history.some((msg) => msg.role === 'function');\n  const hasFunctionCalls = history.some(\n    (msg) =>\n      msg.role === 'assistant' &&\n      'functionCalls' in msg &&\n      Array.isArray(msg.functionCalls) &&\n      msg.functionCalls.length > 0\n  );\n\n  return hasFunctionCalls && hasFunctionResults;\n}\n\n/**\n * Extracts function execution results from memory\n */\nfunction extractFunctionResults(\n  mem: AxAIMemory,\n  sessionId?: string\n): AxResultPickerFunctionFunctionResults['results'] {\n  const history = mem.history(0, sessionId);\n  const results: {\n    index: number;\n    functionName: string;\n    functionId: string;\n    args: string | object;\n    result: string;\n    isError?: boolean;\n  }[] = [];\n\n  // Find assistant messages with function calls\n  const assistantMessages = history.filter(\n    (msg) =>\n      msg.role === 'assistant' &&\n      'functionCalls' in msg &&\n      Array.isArray(msg.functionCalls) &&\n      msg.functionCalls.length > 0\n  );\n\n  // Find function result messages\n  const functionMessages = history.filter((msg) => msg.role === 'function');\n\n  // Match function calls with their results\n  for (const assistantMsg of assistantMessages) {\n    if ('functionCalls' in assistantMsg && assistantMsg.functionCalls) {\n      for (const funcCall of assistantMsg.functionCalls) {\n        // Find the corresponding function result\n        const funcResult = functionMessages.find(\n          (msg) => 'functionId' in msg && msg.functionId === funcCall.id\n        );\n\n        if (\n          funcResult &&\n          'result' in funcResult &&\n          'functionId' in funcResult\n        ) {\n          results.push({\n            index: results.length, // Use sequential index for function results\n            functionName: funcCall.function.name,\n            functionId: funcCall.id,\n            args: funcCall.function.params || '',\n            result: String(funcResult.result),\n            isError:\n              'isError' in funcResult ? Boolean(funcResult.isError) : false,\n          });\n        }\n      }\n    }\n  }\n  return results;\n}\n\n/**\n * Selects a result from multiple samples using the provided result picker function.\n * If no result picker is provided or only one result exists, returns the first result.\n */\nexport async function selectFromSamples<OUT>(\n  buffer: AxGenDeltaOut<OUT>[],\n  options?: AxSamplePickerOptions<OUT>,\n  mem?: AxAIMemory,\n  sessionId?: string\n): Promise<number> {\n  // If no result picker or only one result, use index 0\n  if (!options?.resultPicker || buffer.length <= 1) {\n    return 0;\n  }\n\n  const resultPicker = options.resultPicker;\n\n  // Check if there are function calls in memory to determine data type\n  const hasFunctionCalls = mem ? checkForFunctionCalls(mem, sessionId) : false;\n\n  if (hasFunctionCalls && mem) {\n    // Extract function execution data from memory\n    const functionResults = extractFunctionResults(mem, sessionId);\n    const selectedIndex = await resultPicker({\n      type: 'function',\n      results: functionResults,\n    });\n\n    // Validate the selected index\n    if (selectedIndex < 0 || selectedIndex >= functionResults.length) {\n      throw new Error(\n        `Result picker returned invalid index: ${selectedIndex}. Must be between 0 and ${functionResults.length - 1}`\n      );\n    }\n\n    return selectedIndex;\n  }\n  // Use field results\n  const fieldResults = buffer.map((b, index) => ({\n    index,\n    sample: b.delta,\n  }));\n\n  const selectedIndex = await resultPicker({\n    type: 'fields',\n    results: fieldResults,\n  });\n\n  // Validate the selected index\n  if (selectedIndex < 0 || selectedIndex >= buffer.length) {\n    throw new Error(\n      `Result picker returned invalid index: ${selectedIndex}. Must be between 0 and ${buffer.length - 1}`\n    );\n  }\n\n  return selectedIndex;\n}\n\n/**\n * Selects a result index from memory using the provided result picker function.\n * If no result picker is provided or only one result exists, returns 0.\n * If the last memory is not from an assistant role, returns 0.\n */\nexport async function selectFromSamplesInMemory<OUT>(\n  mem: AxAIMemory,\n  sessionId?: string,\n  options?: AxSamplePickerOptions<OUT>\n): Promise<number> {\n  const lastMemory = mem?.getLast(sessionId);\n\n  // If no memory or not from assistant role, return 0\n  if (!lastMemory || lastMemory.role !== 'assistant') {\n    return 0;\n  }\n\n  // If only one chat sample, return 0\n  if (lastMemory.chat.length <= 1) {\n    return 0;\n  }\n\n  // Convert memory chat to buffer format for selectFromSamples\n  const buffer = lastMemory.chat.map((chat) => ({\n    version: 0,\n    index: chat.index,\n    delta: chat.value as OUT,\n  }));\n\n  const selectedIndex = await selectFromSamples(\n    buffer,\n    options,\n    mem,\n    sessionId\n  );\n  return selectedIndex;\n}\n","import type { AxFunction } from '../ai/types.js';\nimport { ValidationError } from './errors.js';\nimport type { AxChatResponseFunctionCall } from './functions.js';\nimport type { AxField } from './sig.js';\n\nexport interface SignatureToolRouterResult {\n  functionCalls: AxChatResponseFunctionCall[];\n  remainingFields: Record<string, unknown>;\n}\n\n/**\n * Routes LLM output to tools based on populated optional fields\n */\nexport class SignatureToolRouter {\n  private tools: Map<string, AxFunction>;\n  private logger?: ((message: string) => void) | undefined;\n\n  constructor(\n    tools: AxFunction[],\n    logger?: ((message: string) => void) | undefined\n  ) {\n    this.tools = new Map(tools.map((tool) => [tool.name, tool]));\n    this.logger = logger;\n  }\n\n  /**\n   * Build and return a map of tool name -> (full param path -> AxField)\n   * Used by signature tooling to inject tool parameter fields.\n   */\n  public getToolParamFieldMap(): Map<string, Map<string, AxField>> {\n    const toolParamFieldMap = new Map<string, Map<string, AxField>>();\n    for (const [, tool] of this.tools.entries()) {\n      if (\n        tool.parameters?.properties &&\n        Object.keys(tool.parameters.properties).length > 0\n      ) {\n        const { paramFieldMap } = _generateToolParameterFields(tool);\n        toolParamFieldMap.set(tool.name, paramFieldMap);\n      } else {\n        toolParamFieldMap.set(tool.name, new Map());\n      }\n    }\n    return toolParamFieldMap;\n  }\n\n  /**\n   * Process results and return function calls for populated tool fields\n   */\n  async route(\n    results: Record<string, unknown>,\n    _options?: { sessionId?: string; traceId?: string }\n  ): Promise<SignatureToolRouterResult> {\n    const functionCalls: AxChatResponseFunctionCall[] = [];\n    const remainingFields: Record<string, unknown> = {};\n\n    // Prepare accumulators for per-tool argument collection (from parameter fields)\n    const argsByTool: Map<string, Record<string, unknown>> = new Map();\n\n    // Precompute field maps for tools: sanitized field name -> path segments\n    const fieldMaps: Map<string, Map<string, string[]>> = new Map();\n    for (const [toolName, tool] of this.tools.entries()) {\n      fieldMaps.set(toolName, this.buildSanitizedFieldMap(tool));\n    }\n\n    // First pass: collect plain fields and any explicit tool objects\n    for (const [key, value] of Object.entries(results)) {\n      const tool = this.tools.get(this.normalizeToolName(key));\n      if (tool) {\n        // Explicit tool object provided\n        if (\n          value !== undefined &&\n          value !== null &&\n          typeof value === 'object'\n        ) {\n          argsByTool.set(tool.name, value as Record<string, unknown>);\n        }\n        continue; // don't add to remaining yet; we'll add result after execution\n      }\n      remainingFields[key] = value;\n    }\n\n    // Second pass: collect parameter-style fields (e.g., search_web_query)\n    for (const [key, value] of Object.entries(results)) {\n      // For each tool, check if key matches a sanitized parameter field\n      for (const [toolName, tool] of this.tools.entries()) {\n        const fmap = fieldMaps.get(toolName);\n        if (!fmap) continue;\n        const path = fmap.get(key);\n        if (!path) continue;\n        const args = argsByTool.get(tool.name) ?? {};\n        this.setNested(args, path, value);\n        argsByTool.set(tool.name, args);\n      }\n    }\n\n    // Build function calls for tools with collected args\n    for (const [_toolName, tool] of this.tools.entries()) {\n      const args = argsByTool.get(tool.name);\n      if (!args || Object.keys(args).length === 0) {\n        continue;\n      }\n\n      // Validate required parameters against provided args when parameters schema exists\n      if (tool.parameters && tool.parameters.type === 'object') {\n        const required = (tool.parameters.required as string[]) || [];\n        const missing = required.filter(\n          (key) => (args as Record<string, unknown>)[key] === undefined\n        );\n        if (missing.length > 0) {\n          throw new ValidationError(\n            `Missing required arguments for tool '${tool.name}': ${missing.join(', ')}`\n          );\n        }\n      }\n\n      functionCalls.push({\n        id: tool.name,\n        name: tool.name,\n        args: JSON.stringify(args),\n      });\n    }\n\n    // Return remaining fields and function calls (no execution here)\n    return { functionCalls, remainingFields };\n  }\n\n  /**\n   * Normalize tool name to match field names\n   */\n  private normalizeToolName(fieldName: string): string {\n    // Convert snake_case back to camelCase for tool matching\n    return fieldName.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());\n  }\n\n  private sanitizeFieldName(name: string): string {\n    return name\n      .replace(/([A-Z])/g, '_$1')\n      .toLowerCase()\n      .replace(/^_|_$/g, '')\n      .replace(/[^a-z0-9_]/g, '_');\n  }\n\n  private buildSanitizedFieldMap(tool: AxFunction): Map<string, string[]> {\n    const map = new Map<string, string[]>();\n    if (!tool.parameters || !('properties' in (tool.parameters as any))) {\n      return map;\n    }\n    const walk = (props: Record<string, any>, prefix: string[]) => {\n      for (const [key, schema] of Object.entries(props)) {\n        const path = [...prefix, key];\n        if (schema && schema.type === 'object' && schema.properties) {\n          walk(schema.properties as Record<string, any>, path);\n        } else {\n          const full = `${tool.name}.${path.join('.')}`;\n          const sanitized = this.sanitizeFieldName(full);\n          map.set(sanitized, path);\n        }\n      }\n    };\n    walk((tool.parameters as any).properties ?? {}, []);\n    return map;\n  }\n\n  private setNested(\n    target: Record<string, unknown>,\n    path: string[],\n    value: unknown\n  ) {\n    let obj: Record<string, unknown> = target;\n    for (let i = 0; i < path.length - 1; i++) {\n      const k = path[i];\n      const next = obj[k];\n      if (typeof next !== 'object' || next === null) {\n        obj[k] = {} as Record<string, unknown>;\n      }\n      obj = obj[k] as Record<string, unknown>;\n    }\n    obj[path[path.length - 1]] = value as unknown;\n  }\n\n  /**\n   * Check if a field name corresponds to a tool\n   */\n  isToolField(fieldName: string): boolean {\n    return this.tools.has(this.normalizeToolName(fieldName));\n  }\n\n  /**\n   * Get all tool field names\n   */\n  getToolFieldNames(): string[] {\n    return Array.from(this.tools.keys()).map((name) =>\n      name\n        .replace(/([A-Z])/g, '_$1')\n        .toLowerCase()\n        .replace(/^_/, '')\n    );\n  }\n}\n\n/**\n * Generate signature fields for tool parameters using dot notation\n */\nfunction _generateToolParameterFields(tool: AxFunction): {\n  fields: AxField[];\n  paramFieldMap: Map<string, AxField>;\n} {\n  const fields: AxField[] = [];\n  const paramFieldMap = new Map<string, AxField>();\n\n  if (!tool.parameters || !tool.parameters.properties) {\n    return { fields, paramFieldMap };\n  }\n\n  const properties = tool.parameters.properties as Record<string, any>;\n  const required = (tool.parameters.required as string[]) || [];\n\n  const processProperties = (\n    props: Record<string, any>,\n    prefix: string,\n    _parentRequired: string[]\n  ) => {\n    for (const [key, schema] of Object.entries(props)) {\n      const fieldPath = prefix ? `${prefix}.${key}` : key;\n      const fullName = `${tool.name}.${fieldPath}`;\n\n      if (schema.type === 'object' && schema.properties) {\n        // Recursively handle nested objects\n        processProperties(schema.properties, fieldPath, schema.required || []);\n      } else {\n        // Create field for this parameter\n        const fieldType = inferParameterType(schema);\n\n        // All tool parameters should be optional since they're for signature tool calling\n        fields.push({\n          name: sanitizeFieldName(fullName),\n          title: formatParameterTitle(tool.name, fieldPath),\n          type: fieldType,\n          description:\n            schema.description || `${key} parameter for ${tool.name}`,\n          isOptional: true,\n        });\n        paramFieldMap.set(fullName, fields[fields.length - 1]);\n      }\n    }\n  };\n\n  processProperties(properties, '', required);\n  return { fields, paramFieldMap };\n}\n\n/**\n * Infer signature field type from JSON Schema parameter\n */\nfunction inferParameterType(schema: any): {\n  name: 'string' | 'number' | 'boolean' | 'json';\n  isArray: boolean;\n} {\n  switch (schema.type) {\n    case 'string':\n      return { name: 'string', isArray: false };\n    case 'number':\n    case 'integer':\n      return { name: 'number', isArray: false };\n    case 'boolean':\n      return { name: 'boolean', isArray: false };\n    case 'array': {\n      const items = schema.items;\n      if (items?.type) {\n        switch (items.type) {\n          case 'string':\n            return { name: 'string', isArray: true };\n          case 'number':\n          case 'integer':\n            return { name: 'number', isArray: true };\n          case 'boolean':\n            return { name: 'boolean', isArray: true };\n          default:\n            return { name: 'json', isArray: true };\n        }\n      }\n      return { name: 'json', isArray: true };\n    }\n    case 'object':\n      return { name: 'json', isArray: false };\n    default:\n      return { name: 'string', isArray: false };\n  }\n}\n\n/**\n * Format parameter title for display\n */\nfunction formatParameterTitle(toolName: string, paramPath: string): string {\n  return `${toolName} ${paramPath.replace(/\\./g, ' ')}`;\n}\n\nfunction sanitizeFieldName(name: string): string {\n  // Convert camelCase/PascalCase to snake_case\n  return name\n    .replace(/([A-Z])/g, '_$1')\n    .toLowerCase()\n    .replace(/^_|_$/g, '')\n    .replace(/[^a-z0-9_]/g, '_');\n}\n\nfunction _formatTitle(name: string): string {\n  // Convert camelCase to Title Case\n  return name\n    .replace(/([A-Z])/g, ' $1')\n    .replace(/^./, (str) => str.toUpperCase())\n    .trim();\n}\n","import type { AxFunction, AxFunctionJSONSchema } from '../ai/types.js';\nimport { type AxField, AxSignature } from './sig.js';\nimport type { SignatureToolRouter } from './signatureToolRouter.js';\n\n/**\n * Inject tool schemas as optional output fields for signature tool calling\n * Uses dot notation for nested parameters (jq-like syntax)\n */\nexport function injectToolFields<\n  TInput extends Record<string, any>,\n  TOutput extends Record<string, any>,\n>(\n  tools: readonly AxFunction[],\n  signature: AxSignature<TInput, TOutput>,\n  router?: SignatureToolRouter\n): {\n  signature: AxSignature<TInput, TOutput>;\n  toolParamFieldMap: Map<string, Map<string, AxField>>;\n} {\n  const newSig = new AxSignature(signature);\n\n  if (router) {\n    // Use the router's pre-built toolParamFieldMap\n    const toolParamFieldMap = router.getToolParamFieldMap();\n\n    for (const tool of tools) {\n      const paramFieldMap = toolParamFieldMap.get(tool.name);\n      if (paramFieldMap && paramFieldMap.size > 0) {\n        // Add fields from the router's paramFieldMap\n        for (const field of paramFieldMap.values()) {\n          const exists = newSig\n            .getOutputFields()\n            .some((f) => f.name === field.name);\n          if (!exists) {\n            newSig.addOutputField(field);\n          }\n        }\n      } else {\n        // Fallback for tools without parameters or empty parameters\n        const fieldName = sanitizeFieldName(tool.name);\n        const fieldType = inferToolFieldType(tool.parameters);\n\n        const exists = newSig\n          .getOutputFields()\n          .some((f) => f.name === fieldName);\n\n        if (!exists) {\n          newSig.addOutputField({\n            name: fieldName,\n            title: formatTitle(tool.name),\n            type: fieldType,\n            description: tool.description || `Parameters for ${tool.name}`,\n            isOptional: true,\n          });\n        }\n      }\n    }\n\n    return { signature: newSig, toolParamFieldMap };\n  } else {\n    // Fallback to original behavior when no router is provided\n    const toolParamFieldMap = new Map<string, Map<string, AxField>>();\n\n    for (const tool of tools) {\n      if (\n        tool.parameters?.properties &&\n        Object.keys(tool.parameters.properties).length > 0\n      ) {\n        // Generate fields for each parameter using dot notation\n        const { fields, paramFieldMap } = generateToolParameterFields(tool);\n\n        toolParamFieldMap.set(tool.name, paramFieldMap);\n\n        for (const field of fields) {\n          // Check if field already exists to avoid duplicates\n          const exists = newSig\n            .getOutputFields()\n            .some((f) => f.name === field.name);\n          if (!exists) {\n            newSig.addOutputField(field);\n          }\n        }\n      } else {\n        // Fallback for tools without parameters or empty parameters\n        const fieldName = sanitizeFieldName(tool.name);\n        const fieldType = inferToolFieldType(tool.parameters);\n\n        const exists = newSig\n          .getOutputFields()\n          .some((f) => f.name === fieldName);\n        if (!exists) {\n          newSig.addOutputField({\n            name: fieldName,\n            title: formatTitle(tool.name),\n            type: fieldType,\n            description: tool.description || `Parameters for ${tool.name}`,\n            isOptional: true,\n          });\n        }\n      }\n    }\n\n    return { signature: newSig, toolParamFieldMap };\n  }\n}\n\n/**\n * Generate signature fields for tool parameters using dot notation\n */\nfunction generateToolParameterFields(tool: AxFunction): {\n  fields: AxField[];\n  paramFieldMap: Map<string, AxField>;\n} {\n  const fields: AxField[] = [];\n  const paramFieldMap = new Map<string, AxField>();\n\n  if (!tool.parameters || !tool.parameters.properties) {\n    return { fields, paramFieldMap };\n  }\n\n  const properties = tool.parameters.properties as Record<string, any>;\n  const required = (tool.parameters.required as string[]) || [];\n\n  const processProperties = (\n    props: Record<string, any>,\n    prefix: string,\n    _parentRequired: string[]\n  ) => {\n    for (const [key, schema] of Object.entries(props)) {\n      const fieldPath = prefix ? `${prefix}.${key}` : key;\n      const fullName = `${tool.name}.${fieldPath}`;\n\n      if (schema.type === 'object' && schema.properties) {\n        // Recursively handle nested objects\n        processProperties(schema.properties, fieldPath, schema.required || []);\n      } else {\n        // Create field for this parameter\n        const fieldType = inferParameterType(schema);\n\n        // All tool parameters should be optional since they're for signature tool calling\n        const field: AxField = {\n          name: sanitizeFieldName(fullName),\n          title: formatParameterTitle(tool.name, fieldPath),\n          type: fieldType,\n          description:\n            schema.description || `${key} parameter for ${tool.name}`,\n          isOptional: true,\n        };\n        fields.push(field);\n        paramFieldMap.set(fullName, field);\n      }\n    }\n  };\n\n  processProperties(properties, '', required);\n  return { fields, paramFieldMap };\n}\n\n/**\n * Infer signature field type from JSON Schema parameter\n */\nfunction inferParameterType(schema: any): {\n  name: 'string' | 'number' | 'boolean' | 'json';\n  isArray: boolean;\n} {\n  switch (schema.type) {\n    case 'string':\n      return { name: 'string', isArray: false };\n    case 'number':\n    case 'integer':\n      return { name: 'number', isArray: false };\n    case 'boolean':\n      return { name: 'boolean', isArray: false };\n    case 'array': {\n      const items = schema.items;\n      if (items?.type) {\n        switch (items.type) {\n          case 'string':\n            return { name: 'string', isArray: true };\n          case 'number':\n          case 'integer':\n            return { name: 'number', isArray: true };\n          case 'boolean':\n            return { name: 'boolean', isArray: true };\n          default:\n            return { name: 'json', isArray: true };\n        }\n      }\n      return { name: 'json', isArray: true };\n    }\n    case 'object':\n      return { name: 'json', isArray: false };\n    default:\n      return { name: 'string', isArray: false };\n  }\n}\n\n/**\n * Format parameter title for display\n */\nfunction formatParameterTitle(toolName: string, paramPath: string): string {\n  return `${toolName} ${paramPath.replace(/\\./g, ' ')}`;\n}\n\nfunction sanitizeFieldName(name: string): string {\n  // Convert camelCase/PascalCase to snake_case\n  return name\n    .replace(/([A-Z])/g, '_$1')\n    .toLowerCase()\n    .replace(/^_|_$/g, '')\n    .replace(/[^a-z0-9_]/g, '_');\n}\n\nfunction formatTitle(name: string): string {\n  // Convert camelCase to Title Case\n  return name\n    .replace(/([A-Z])/g, ' $1')\n    .replace(/^./, (str) => str.toUpperCase())\n    .trim();\n}\n\nfunction inferToolFieldType(parameters?: AxFunctionJSONSchema) {\n  if (\n    !parameters ||\n    !parameters.properties ||\n    Object.keys(parameters.properties).length === 0\n  ) {\n    return { name: 'string' as const, isArray: false };\n  }\n\n  // For tools with parameters, use JSON type to capture the arguments\n  return { name: 'json' as const, isArray: false };\n}\n","import type { AxFunction } from '../ai/types.js';\nimport type { AxChatResponseFunctionCall } from './functions.js';\nimport type { AxField, AxSignature } from './sig.js';\nimport { SignatureToolRouter } from './signatureToolRouter.js';\nimport { injectToolFields } from './sigTools.js';\n\nexport interface SignatureToolCallingOptions {\n  functions?: AxFunction[];\n}\n\n/**\n * Manages signature tool calling functionality\n */\nexport class SignatureToolCallingManager {\n  private tools: AxFunction[];\n  private router: SignatureToolRouter;\n  private injectedToolFieldNames: Set<string> = new Set();\n\n  constructor(tools: AxFunction[]) {\n    this.tools = tools;\n    this.router = new SignatureToolRouter(tools);\n  }\n\n  /**\n   * Get the current function call mode\n   */\n  // Mode is implicitly 'prompt' when this manager exists\n\n  /**\n   * Process signature for tool injection if prompt mode is enabled\n   */\n  processSignature(signature: AxSignature): AxSignature {\n    const { signature: injected } = injectToolFields(this.tools, signature);\n\n    // Track which fields were injected so extraction can treat them as optional if needed\n    const injectedNames = new Set(\n      injected.getOutputFields().map((f: AxField) => f.name) as string[]\n    );\n    const originalNames = new Set(\n      signature.getOutputFields().map((f: AxField) => f.name) as string[]\n    );\n    this.injectedToolFieldNames = new Set(\n      [...injectedNames].filter(\n        (n: string) => !originalNames.has(n)\n      ) as string[]\n    );\n    return injected;\n  }\n\n  /**\n   * Process results and return function calls (no execution)\n   */\n  async processResults(\n    results: Record<string, unknown>,\n    options?: { sessionId?: string; traceId?: string }\n  ): Promise<AxChatResponseFunctionCall[] | undefined> {\n    const { functionCalls } = await this.router.route(results, options);\n    return functionCalls.length > 0 ? functionCalls : undefined;\n  }\n\n  /**\n   * Return names of fields injected for prompt-mode tools\n   */\n  getInjectedToolFieldNames(): string[] {\n    return Array.from(this.injectedToolFieldNames);\n  }\n\n  /**\n   * Get the tool router if available\n   */\n  getRouter(): SignatureToolRouter {\n    return this.router;\n  }\n}\n","const trimNonAlphaNum = (str: string) => {\n  return str.replace(/^\\W+|\\W+$/g, '');\n};\n\nconst splitIntoTwo = (\n  str: string,\n  separator: Readonly<RegExp | string>\n): string[] => {\n  const index = str.search(separator);\n  if (index === -1) {\n    return [str]; // No separator found, return the original string as the only part\n  }\n  const matchResult = str.match(separator);\n  if (!matchResult) {\n    throw new Error('Match failed unexpectedly.');\n  }\n  const firstPart = str.substring(0, index);\n  const secondPart = str.substring(index + matchResult[0].length);\n  return [firstPart, secondPart];\n};\n\nconst dedup = (seq: readonly string[]): string[] => {\n  const seen = new Set<string>();\n  const result: string[] = [];\n\n  for (const x of seq) {\n    if (!seen.has(x)) {\n      seen.add(x);\n      result.push(x);\n    }\n  }\n\n  return result;\n};\n\nconst extractIdAndText = (input: string): { id: number; text: string } => {\n  const match = input.match(/^(\\d+)[.,\\s]+(.*)$/);\n  if (!match || match.length < 3) {\n    throw new Error(\n      'line must start with a number, a dot and then text. e.g. \"1. hello\"'\n    );\n  }\n\n  const id = Number.parseInt(match[1] as string, 10);\n  const text = (match[2] as string).trim();\n  return { id, text };\n};\n\nconst extractIndexPrefixedText = (input: string): string => {\n  const match = input.match(/^(\\d+)[.,\\s]+(.*)$/);\n  // Check if match is not null and if the second capturing group is present\n  if (match && match[2] !== undefined) {\n    return match[2].trim();\n  }\n  return input;\n};\n\nconst batchArray = <T>(arr: readonly T[], size: number): T[][] => {\n  const chunkedArr: T[][] = [];\n  for (let i = 0; i < arr.length; i += size) {\n    chunkedArr.push(arr.slice(i, i + size));\n  }\n  return chunkedArr;\n};\n\nexport const AxStringUtil = {\n  trimNonAlphaNum,\n  splitIntoTwo,\n  dedup,\n  extractIdAndText,\n  extractIndexPrefixedText,\n  batchArray,\n};\n","import type { AxAIService } from '../ai/types.js';\nimport { AxGen } from '../dsp/generate.js';\nimport { AxStringUtil } from '../dsp/strutil.js';\nimport type {\n  AxProgramForwardOptions,\n  AxProgramForwardOptionsWithModels,\n} from '../dsp/types.js';\n\nimport type { AxRerankerIn, AxRerankerOut } from './manager.js';\n\nexport class AxDefaultResultReranker extends AxGen<\n  AxRerankerIn,\n  AxRerankerOut\n> {\n  constructor(options?: Readonly<AxProgramForwardOptions<string>>) {\n    const signature = `\"You are a re-ranker assistant tasked with evaluating a set of content items in relation to a specific question. Your role involves critically analyzing each content item to determine its relevance to the question and re-ranking them accordingly. This process includes assigning a relevance score from 0 to 10 to each content item based on how well it answers the question, its coverage of the topic, and the reliability of its information. This re-ranked list should start with the content item that is most relevant to the question and end with the least relevant. Output only the list.\"\n    query: string, items: string[] -> rankedItems: string[] \"list of id, 5-words Rationale, relevance score\"`;\n\n    super(signature, options);\n  }\n\n  public override forward = async <T extends Readonly<AxAIService>>(\n    ai: T,\n    input: Readonly<AxRerankerIn>,\n    options?: Readonly<AxProgramForwardOptionsWithModels<T>>\n  ): Promise<AxRerankerOut> => {\n    const { rankedItems } = await super.forward(ai, input, options);\n\n    const sortedIndexes: number[] = rankedItems.map((item) => {\n      const { id: index } = AxStringUtil.extractIdAndText(item);\n      return index;\n    });\n\n    // Ensure all elements are strings and filter out null or undefined\n    const sortedItems = input.items\n      .map((_, index) => {\n        const originalIndex = sortedIndexes[index];\n        return originalIndex !== undefined\n          ? input.items[originalIndex]\n          : undefined;\n      })\n      .filter((item): item is string => item !== undefined);\n\n    return { rankedItems: sortedItems };\n  };\n}\n","// Dynamic import for Node.js-specific functionality to maintain browser compatibility\n\nexport interface AxApacheTikaArgs {\n  url?: string | URL;\n  fetch?: typeof fetch;\n}\n\nexport interface AxApacheTikaConvertOptions {\n  format?: 'text' | 'html';\n}\n\nexport class AxApacheTika {\n  private tikaUrl: URL;\n  private fetch?: typeof fetch;\n\n  constructor(args?: Readonly<AxApacheTikaArgs>) {\n    const Args = args ?? { url: 'http://localhost:9998/' };\n    this.tikaUrl = new URL('/tika', Args.url);\n    this.fetch = Args.fetch;\n  }\n\n  private async _convert(\n    fileData: ReadableStream | Blob,\n    options?: Readonly<AxApacheTikaConvertOptions>\n  ): Promise<string> {\n    if (!fileData) {\n      throw new Error('Failed to read file data');\n    }\n\n    const acceptValue = options?.format === 'html' ? 'text/html' : 'text/plain';\n\n    try {\n      const fetchOptions: RequestInit = {\n        body: fileData as any,\n        headers: { Accept: acceptValue },\n        method: 'PUT',\n      };\n\n      // Add duplex option only in Node.js environments\n      if (typeof window === 'undefined' && typeof process !== 'undefined') {\n        (fetchOptions as any).duplex = 'half';\n      }\n\n      const res = await (this.fetch ?? fetch)(this.tikaUrl, fetchOptions);\n\n      if (!res.ok) {\n        throw new Error(`Failed to upload file: ${res.statusText}`);\n      }\n\n      const text = await res.text();\n      return text;\n    } catch (error) {\n      throw new Error(`Error converting file: ${error}`);\n    }\n  }\n\n  public async convert(\n    files: Readonly<Blob[] | ReadableStream[]>,\n    options?: Readonly<{ batchSize?: number; format?: 'html' | 'text' }>\n  ): Promise<string[]> {\n    const results: string[] = [];\n    const bs = options?.batchSize ?? 10;\n\n    for (let i = 0; i < files.length; i += bs) {\n      const batch = files.slice(i, i + bs);\n      const uploadPromises = batch.map((files) =>\n        this._convert(files, { format: options?.format })\n      );\n      const batchResults = await Promise.all(uploadPromises);\n      results.push(...batchResults);\n    }\n\n    return results;\n  }\n}\nexport default AxApacheTika;\n","import type { AxAIService } from '../ai/types.js';\nimport { AxDBMemory, type AxDBState } from '../db/memory.js';\nimport { ColorLog } from '../util/log.js';\n\nconst _colorLog = new ColorLog();\n\nexport interface AxSimpleClassifierForwardOptions {\n  cutoff?: number;\n  abortSignal?: AbortSignal;\n}\n\nexport class AxSimpleClassifierClass {\n  private readonly name: string;\n  private readonly context: readonly string[];\n\n  constructor(name: string, context: readonly string[]) {\n    this.name = name;\n    this.context = context;\n  }\n\n  public getName(): string {\n    return this.name;\n  }\n\n  public getContext(): readonly string[] {\n    return this.context;\n  }\n}\n\nexport class AxSimpleClassifier {\n  private readonly ai: AxAIService;\n\n  private db: AxDBMemory;\n  private debug?: boolean;\n\n  public constructor(ai: AxAIService) {\n    this.db = new AxDBMemory();\n    this.ai = ai;\n  }\n\n  public getState(): AxDBState | undefined {\n    return this.db.getDB();\n  }\n\n  public setState(state: AxDBState) {\n    this.db.setDB(state);\n  }\n\n  public setClasses = async (\n    classes: readonly AxSimpleClassifierClass[],\n    options?: Readonly<{ abortSignal?: AbortSignal }>\n  ): Promise<void> => {\n    for (const c of classes) {\n      const ret = await this.ai.embed(\n        { texts: c.getContext() },\n        {\n          abortSignal: options?.abortSignal,\n        }\n      );\n      await this.db.upsert({\n        id: c.getName(),\n        table: 'classes',\n        values: ret.embeddings[0],\n      });\n    }\n  };\n\n  public async forward(\n    text: string,\n    options?: Readonly<AxSimpleClassifierForwardOptions>\n  ): Promise<string> {\n    const { embeddings } = await this.ai.embed(\n      { texts: [text] },\n      {\n        abortSignal: options?.abortSignal,\n      }\n    );\n\n    const matches = await this.db.query({\n      table: 'classes',\n      values: embeddings[0],\n    });\n\n    let m = matches.matches;\n    if (typeof options?.cutoff === 'number') {\n      const { cutoff } = options;\n      m = m.filter((m) => m.score <= cutoff);\n    }\n\n    const matchedClass = m.at(0);\n    if (!matchedClass) {\n      return '';\n    }\n\n    return matchedClass.id;\n  }\n\n  public setOptions(options: Readonly<{ debug?: boolean }>): void {\n    if (typeof options.debug === 'boolean') {\n      this.debug = options.debug;\n    }\n  }\n}\n","export const stopwords = new Set([\n  '0o',\n  '0s',\n  '3a',\n  '3b',\n  '3d',\n  '6b',\n  '6o',\n  'a',\n  'a1',\n  'a2',\n  'a3',\n  'a4',\n  'ab',\n  'able',\n  'about',\n  'above',\n  'abst',\n  'ac',\n  'accordance',\n  'according',\n  'accordingly',\n  'across',\n  'act',\n  'actually',\n  'ad',\n  'added',\n  'adj',\n  'ae',\n  'af',\n  'affected',\n  'affecting',\n  'affects',\n  'after',\n  'afterwards',\n  'ag',\n  'again',\n  'against',\n  'ah',\n  'ain',\n  \"ain't\",\n  'aj',\n  'al',\n  'all',\n  'allow',\n  'allows',\n  'almost',\n  'alone',\n  'along',\n  'already',\n  'also',\n  'although',\n  'always',\n  'am',\n  'among',\n  'amongst',\n  'amoungst',\n  'amount',\n  'an',\n  'and',\n  'announce',\n  'another',\n  'any',\n  'anybody',\n  'anyhow',\n  'anymore',\n  'anyone',\n  'anything',\n  'anyway',\n  'anyways',\n  'anywhere',\n  'ao',\n  'ap',\n  'apart',\n  'apparently',\n  'appear',\n  'appreciate',\n  'appropriate',\n  'approximately',\n  'ar',\n  'are',\n  'aren',\n  'arent',\n  \"aren't\",\n  'arise',\n  'around',\n  'as',\n  \"a's\",\n  'aside',\n  'ask',\n  'asking',\n  'associated',\n  'at',\n  'au',\n  'auth',\n  'av',\n  'available',\n  'aw',\n  'away',\n  'awfully',\n  'ax',\n  'ay',\n  'az',\n  'b',\n  'b1',\n  'b2',\n  'b3',\n  'ba',\n  'back',\n  'bc',\n  'bd',\n  'be',\n  'became',\n  'because',\n  'become',\n  'becomes',\n  'becoming',\n  'been',\n  'before',\n  'beforehand',\n  'begin',\n  'beginning',\n  'beginnings',\n  'begins',\n  'behind',\n  'being',\n  'believe',\n  'below',\n  'beside',\n  'besides',\n  'best',\n  'better',\n  'between',\n  'beyond',\n  'bi',\n  'bill',\n  'biol',\n  'bj',\n  'bk',\n  'bl',\n  'bn',\n  'both',\n  'bottom',\n  'bp',\n  'br',\n  'brief',\n  'briefly',\n  'bs',\n  'bt',\n  'bu',\n  'but',\n  'bx',\n  'by',\n  'c',\n  'c1',\n  'c2',\n  'c3',\n  'ca',\n  'call',\n  'came',\n  'can',\n  'cannot',\n  'cant',\n  \"can't\",\n  'cause',\n  'causes',\n  'cc',\n  'cd',\n  'ce',\n  'certain',\n  'certainly',\n  'cf',\n  'cg',\n  'ch',\n  'changes',\n  'ci',\n  'cit',\n  'cj',\n  'cl',\n  'clearly',\n  'cm',\n  \"c'mon\",\n  'cn',\n  'co',\n  'com',\n  'come',\n  'comes',\n  'con',\n  'concerning',\n  'consequently',\n  'consider',\n  'considering',\n  'contain',\n  'containing',\n  'contains',\n  'corresponding',\n  'could',\n  'couldn',\n  'couldnt',\n  \"couldn't\",\n  'course',\n  'cp',\n  'cq',\n  'cr',\n  'cry',\n  'cs',\n  \"c's\",\n  'ct',\n  'cu',\n  'currently',\n  'cv',\n  'cx',\n  'cy',\n  'cz',\n  'd',\n  'd2',\n  'da',\n  'date',\n  'dc',\n  'dd',\n  'de',\n  'definitely',\n  'describe',\n  'described',\n  'despite',\n  'detail',\n  'df',\n  'di',\n  'did',\n  'didn',\n  \"didn't\",\n  'different',\n  'dj',\n  'dk',\n  'dl',\n  'do',\n  'does',\n  'doesn',\n  \"doesn't\",\n  'doing',\n  'don',\n  'done',\n  \"don't\",\n  'down',\n  'downwards',\n  'dp',\n  'dr',\n  'ds',\n  'dt',\n  'du',\n  'due',\n  'during',\n  'dx',\n  'dy',\n  'e',\n  'e2',\n  'e3',\n  'ea',\n  'each',\n  'ec',\n  'ed',\n  'edu',\n  'ee',\n  'ef',\n  'effect',\n  'eg',\n  'ei',\n  'eight',\n  'eighty',\n  'either',\n  'ej',\n  'el',\n  'eleven',\n  'else',\n  'elsewhere',\n  'em',\n  'empty',\n  'en',\n  'end',\n  'ending',\n  'enough',\n  'entirely',\n  'eo',\n  'ep',\n  'eq',\n  'er',\n  'es',\n  'especially',\n  'est',\n  'et',\n  'et-al',\n  'etc',\n  'eu',\n  'ev',\n  'even',\n  'ever',\n  'every',\n  'everybody',\n  'everyone',\n  'everything',\n  'everywhere',\n  'ex',\n  'exactly',\n  'example',\n  'except',\n  'ey',\n  'f',\n  'f2',\n  'fa',\n  'far',\n  'fc',\n  'few',\n  'ff',\n  'fi',\n  'fifteen',\n  'fifth',\n  'fify',\n  'fill',\n  'find',\n  'fire',\n  'first',\n  'five',\n  'fix',\n  'fj',\n  'fl',\n  'fn',\n  'fo',\n  'followed',\n  'following',\n  'follows',\n  'for',\n  'former',\n  'formerly',\n  'forth',\n  'forty',\n  'found',\n  'four',\n  'fr',\n  'from',\n  'front',\n  'ft',\n  'fu',\n  'full',\n  'further',\n  'furthermore',\n  'fy',\n  'g',\n  'ga',\n  'gave',\n  'ge',\n  'get',\n  'gets',\n  'getting',\n  'gi',\n  'give',\n  'given',\n  'gives',\n  'giving',\n  'gj',\n  'gl',\n  'go',\n  'goes',\n  'going',\n  'gone',\n  'got',\n  'gotten',\n  'gr',\n  'greetings',\n  'gs',\n  'gy',\n  'h',\n  'h2',\n  'h3',\n  'had',\n  'hadn',\n  \"hadn't\",\n  'happens',\n  'hardly',\n  'has',\n  'hasn',\n  'hasnt',\n  \"hasn't\",\n  'have',\n  'haven',\n  \"haven't\",\n  'having',\n  'he',\n  'hed',\n  \"he'd\",\n  \"he'll\",\n  'hello',\n  'help',\n  'hence',\n  'her',\n  'here',\n  'hereafter',\n  'hereby',\n  'herein',\n  'heres',\n  \"here's\",\n  'hereupon',\n  'hers',\n  'herself',\n  'hes',\n  \"he's\",\n  'hh',\n  'hi',\n  'hid',\n  'him',\n  'himself',\n  'his',\n  'hither',\n  'hj',\n  'ho',\n  'home',\n  'hopefully',\n  'how',\n  'howbeit',\n  'however',\n  \"how's\",\n  'hr',\n  'hs',\n  'http',\n  'hu',\n  'hundred',\n  'hy',\n  'i',\n  'i2',\n  'i3',\n  'i4',\n  'i6',\n  'i7',\n  'i8',\n  'ia',\n  'ib',\n  'ibid',\n  'ic',\n  'id',\n  \"i'd\",\n  'ie',\n  'if',\n  'ig',\n  'ignored',\n  'ih',\n  'ii',\n  'ij',\n  'il',\n  \"i'll\",\n  'im',\n  \"i'm\",\n  'immediate',\n  'immediately',\n  'importance',\n  'important',\n  'in',\n  'inasmuch',\n  'inc',\n  'indeed',\n  'index',\n  'indicate',\n  'indicated',\n  'indicates',\n  'information',\n  'inner',\n  'insofar',\n  'instead',\n  'interest',\n  'into',\n  'invention',\n  'inward',\n  'io',\n  'ip',\n  'iq',\n  'ir',\n  'is',\n  'isn',\n  \"isn't\",\n  'it',\n  'itd',\n  \"it'd\",\n  \"it'll\",\n  'its',\n  \"it's\",\n  'itself',\n  'iv',\n  \"i've\",\n  'ix',\n  'iy',\n  'iz',\n  'j',\n  'jj',\n  'jr',\n  'js',\n  'jt',\n  'ju',\n  'just',\n  'k',\n  'ke',\n  'keep',\n  'keeps',\n  'kept',\n  'kg',\n  'kj',\n  'km',\n  'know',\n  'known',\n  'knows',\n  'ko',\n  'l',\n  'l2',\n  'la',\n  'largely',\n  'last',\n  'lately',\n  'later',\n  'latter',\n  'latterly',\n  'lb',\n  'lc',\n  'le',\n  'least',\n  'les',\n  'less',\n  'lest',\n  'let',\n  'lets',\n  \"let's\",\n  'lf',\n  'like',\n  'liked',\n  'likely',\n  'line',\n  'little',\n  'lj',\n  'll',\n  'll',\n  'ln',\n  'lo',\n  'look',\n  'looking',\n  'looks',\n  'los',\n  'lr',\n  'ls',\n  'lt',\n  'ltd',\n  'm',\n  'm2',\n  'ma',\n  'made',\n  'mainly',\n  'make',\n  'makes',\n  'many',\n  'may',\n  'maybe',\n  'me',\n  'mean',\n  'means',\n  'meantime',\n  'meanwhile',\n  'merely',\n  'mg',\n  'might',\n  'mightn',\n  \"mightn't\",\n  'mill',\n  'million',\n  'mine',\n  'miss',\n  'ml',\n  'mn',\n  'mo',\n  'more',\n  'moreover',\n  'most',\n  'mostly',\n  'move',\n  'mr',\n  'mrs',\n  'ms',\n  'mt',\n  'mu',\n  'much',\n  'mug',\n  'must',\n  'mustn',\n  \"mustn't\",\n  'my',\n  'myself',\n  'model',\n  'n',\n  'n2',\n  'na',\n  'name',\n  'namely',\n  'nay',\n  'nc',\n  'nd',\n  'ne',\n  'near',\n  'nearly',\n  'necessarily',\n  'necessary',\n  'need',\n  'needn',\n  \"needn't\",\n  'needs',\n  'neither',\n  'never',\n  'nevertheless',\n  'new',\n  'next',\n  'ng',\n  'ni',\n  'nine',\n  'ninety',\n  'nj',\n  'nl',\n  'nn',\n  'no',\n  'nobody',\n  'non',\n  'none',\n  'nonetheless',\n  'noone',\n  'nor',\n  'normally',\n  'nos',\n  'not',\n  'noted',\n  'nothing',\n  'novel',\n  'now',\n  'nowhere',\n  'nr',\n  'ns',\n  'nt',\n  'ny',\n  'o',\n  'oa',\n  'ob',\n  'obtain',\n  'obtained',\n  'obviously',\n  'oc',\n  'od',\n  'of',\n  'off',\n  'often',\n  'og',\n  'oh',\n  'oi',\n  'oj',\n  'ok',\n  'okay',\n  'ol',\n  'old',\n  'om',\n  'omitted',\n  'on',\n  'once',\n  'one',\n  'ones',\n  'only',\n  'onto',\n  'oo',\n  'op',\n  'oq',\n  'or',\n  'ord',\n  'os',\n  'ot',\n  'other',\n  'others',\n  'otherwise',\n  'ou',\n  'ought',\n  'our',\n  'ours',\n  'ourselves',\n  'out',\n  'outside',\n  'over',\n  'overall',\n  'ow',\n  'owing',\n  'own',\n  'ox',\n  'oz',\n  'p',\n  'p1',\n  'p2',\n  'p3',\n  'page',\n  'pagecount',\n  'pages',\n  'par',\n  'part',\n  'particular',\n  'particularly',\n  'pas',\n  'past',\n  'pc',\n  'pd',\n  'pe',\n  'per',\n  'perhaps',\n  'pf',\n  'ph',\n  'pi',\n  'pj',\n  'pk',\n  'pl',\n  'placed',\n  'please',\n  'plus',\n  'pm',\n  'pn',\n  'po',\n  'poorly',\n  'possible',\n  'possibly',\n  'potentially',\n  'pp',\n  'pq',\n  'pr',\n  'predominantly',\n  'present',\n  'presumably',\n  'previously',\n  'primarily',\n  'probably',\n  'promptly',\n  'proud',\n  'provides',\n  'ps',\n  'pt',\n  'pu',\n  'put',\n  'py',\n  'q',\n  'qj',\n  'qu',\n  'que',\n  'quickly',\n  'quite',\n  'qv',\n  'r',\n  'r2',\n  'ra',\n  'ran',\n  'rather',\n  'rc',\n  'rd',\n  're',\n  'readily',\n  'really',\n  'reasonably',\n  'recent',\n  'recently',\n  'ref',\n  'refs',\n  'regarding',\n  'regardless',\n  'regards',\n  'related',\n  'relatively',\n  'research',\n  'research-articl',\n  'respectively',\n  'resulted',\n  'resulting',\n  'results',\n  'rf',\n  'rh',\n  'ri',\n  'right',\n  'rj',\n  'rl',\n  'rm',\n  'rn',\n  'ro',\n  'rq',\n  'rr',\n  'rs',\n  'rt',\n  'ru',\n  'run',\n  'rv',\n  'ry',\n  's',\n  's2',\n  'sa',\n  'said',\n  'same',\n  'saw',\n  'say',\n  'saying',\n  'says',\n  'sc',\n  'sd',\n  'se',\n  'sec',\n  'second',\n  'secondly',\n  'section',\n  'see',\n  'seeing',\n  'seem',\n  'seemed',\n  'seeming',\n  'seems',\n  'seen',\n  'self',\n  'selves',\n  'sensible',\n  'sent',\n  'serious',\n  'seriously',\n  'seven',\n  'several',\n  'sf',\n  'shall',\n  'shan',\n  \"shan't\",\n  'she',\n  'shed',\n  \"she'd\",\n  \"she'll\",\n  'shes',\n  \"she's\",\n  'should',\n  'shouldn',\n  \"shouldn't\",\n  \"should've\",\n  'show',\n  'showed',\n  'shown',\n  'showns',\n  'shows',\n  'si',\n  'side',\n  'significant',\n  'significantly',\n  'similar',\n  'similarly',\n  'since',\n  'sincere',\n  'six',\n  'sixty',\n  'sj',\n  'sl',\n  'slightly',\n  'sm',\n  'sn',\n  'so',\n  'some',\n  'somebody',\n  'somehow',\n  'someone',\n  'somethan',\n  'something',\n  'sometime',\n  'sometimes',\n  'somewhat',\n  'somewhere',\n  'soon',\n  'sorry',\n  'sp',\n  'specifically',\n  'specified',\n  'specify',\n  'specifying',\n  'sq',\n  'sr',\n  'ss',\n  'st',\n  'still',\n  'stop',\n  'strongly',\n  'sub',\n  'substantially',\n  'successfully',\n  'such',\n  'sufficiently',\n  'suggest',\n  'sup',\n  'sure',\n  'sy',\n  'system',\n  'sz',\n  't',\n  't1',\n  't2',\n  't3',\n  'take',\n  'taken',\n  'taking',\n  'tb',\n  'tc',\n  'td',\n  'te',\n  'tell',\n  'ten',\n  'tends',\n  'tf',\n  'th',\n  'than',\n  'thank',\n  'thanks',\n  'thanx',\n  'that',\n  \"that'll\",\n  'thats',\n  \"that's\",\n  \"that've\",\n  'the',\n  'their',\n  'theirs',\n  'them',\n  'themselves',\n  'then',\n  'thence',\n  'there',\n  'thereafter',\n  'thereby',\n  'thered',\n  'therefore',\n  'therein',\n  \"there'll\",\n  'thereof',\n  'therere',\n  'theres',\n  \"there's\",\n  'thereto',\n  'thereupon',\n  \"there've\",\n  'these',\n  'they',\n  'theyd',\n  \"they'd\",\n  \"they'll\",\n  'theyre',\n  \"they're\",\n  \"they've\",\n  'thickv',\n  'thin',\n  'think',\n  'third',\n  'this',\n  'thorough',\n  'thoroughly',\n  'those',\n  'thou',\n  'though',\n  'thoughh',\n  'thousand',\n  'three',\n  'throug',\n  'through',\n  'throughout',\n  'thru',\n  'thus',\n  'ti',\n  'til',\n  'tip',\n  'tj',\n  'tl',\n  'tm',\n  'tn',\n  'to',\n  'together',\n  'too',\n  'took',\n  'top',\n  'toward',\n  'towards',\n  'tp',\n  'tq',\n  'tr',\n  'tried',\n  'tries',\n  'truly',\n  'try',\n  'trying',\n  'ts',\n  \"t's\",\n  'tt',\n  'tv',\n  'twelve',\n  'twenty',\n  'twice',\n  'two',\n  'tx',\n  'u',\n  'u201d',\n  'ue',\n  'ui',\n  'uj',\n  'uk',\n  'um',\n  'un',\n  'under',\n  'unfortunately',\n  'unless',\n  'unlike',\n  'unlikely',\n  'until',\n  'unto',\n  'uo',\n  'up',\n  'upon',\n  'ups',\n  'ur',\n  'us',\n  'use',\n  'used',\n  'useful',\n  'usefully',\n  'usefulness',\n  'uses',\n  'using',\n  'usually',\n  'ut',\n  'v',\n  'va',\n  'value',\n  'various',\n  'vd',\n  've',\n  've',\n  'very',\n  'via',\n  'viz',\n  'vj',\n  'vo',\n  'vol',\n  'vols',\n  'volumtype',\n  'vq',\n  'vs',\n  'vt',\n  'vu',\n  'w',\n  'wa',\n  'want',\n  'wants',\n  'was',\n  'wasn',\n  'wasnt',\n  \"wasn't\",\n  'way',\n  'we',\n  'wed',\n  \"we'd\",\n  'welcome',\n  'well',\n  \"we'll\",\n  'well-b',\n  'went',\n  'were',\n  \"we're\",\n  'weren',\n  'werent',\n  \"weren't\",\n  \"we've\",\n  'what',\n  'whatever',\n  \"what'll\",\n  'whats',\n  \"what's\",\n  'when',\n  'whence',\n  'whenever',\n  \"when's\",\n  'where',\n  'whereafter',\n  'whereas',\n  'whereby',\n  'wherein',\n  'wheres',\n  \"where's\",\n  'whereupon',\n  'wherever',\n  'whether',\n  'which',\n  'while',\n  'whim',\n  'whither',\n  'who',\n  'whod',\n  'whoever',\n  'whole',\n  \"who'll\",\n  'whom',\n  'whomever',\n  'whos',\n  \"who's\",\n  'whose',\n  'why',\n  \"why's\",\n  'wi',\n  'widely',\n  'will',\n  'willing',\n  'wish',\n  'with',\n  'within',\n  'without',\n  'wo',\n  'won',\n  'wonder',\n  'wont',\n  \"won't\",\n  'words',\n  'world',\n  'would',\n  'wouldn',\n  'wouldnt',\n  \"wouldn't\",\n  'www',\n  'x',\n  'x1',\n  'x2',\n  'x3',\n  'xf',\n  'xi',\n  'xj',\n  'xk',\n  'xl',\n  'xn',\n  'xo',\n  'xs',\n  'xt',\n  'xv',\n  'xx',\n  'y',\n  'y2',\n  'yes',\n  'yet',\n  'yj',\n  'yl',\n  'you',\n  'youd',\n  \"you'd\",\n  \"you'll\",\n  'your',\n  'youre',\n  \"you're\",\n  'yours',\n  'yourself',\n  'yourselves',\n  \"you've\",\n  'yr',\n  'ys',\n  'yt',\n  'z',\n  'zero',\n  'zi',\n  'zz',\n  'task',\n]);\n","import { stopwords } from './stopwords.js';\n\n/**\n * Filters out tokens based on a set of exclusion tokens.\n *\n * @param tokens The array of tokens to filter.\n * @param exclusions A set containing tokens to exclude.\n * @returns An array of filtered tokens.\n */\nfunction filterTokens(\n  tokens: readonly string[],\n  exclusions: ReadonlySet<string>\n): string[] {\n  return tokens.filter((token) => !exclusions.has(token));\n}\n\n/**\n * Counts the occurrences of each token in an array of tokens.\n *\n * This function supports the preprocessing step for NLP tasks like text similarity\n * and classification by transforming text into a bag-of-words model, facilitating\n * the comparison of different texts based on their content.\n *\n * @param tokens An array of string tokens.\n * @returns A Counter object mapping each token to its count.\n */\nfunction countTokens(tokens: readonly string[]): Record<string, number> {\n  const counter: Record<string, number> = {};\n  for (const token of tokens) {\n    counter[token] = (counter[token] || 0) + 1;\n  }\n  return counter;\n}\n\n/**\n * Normalizes text by lowercasing, removing punctuation, and squashing multiple spaces.\n *\n * This normalization is crucial in NLP for reducing the complexity of the text data,\n * minimizing the variance between words that should be considered the same for analysis\n * purposes (e.g., \"Dog!\" and \"dog\" are treated as the same word).\n *\n * @param s A string to be normalized.\n * @returns A normalized string.\n */\nfunction normalizeText(s: string): string {\n  let normalized = s.normalize('NFD');\n  normalized = normalized.replace(/\\b(a|an|the)\\b/g, ' ');\n  normalized = normalized.split(/\\s+/).join(' ');\n  normalized = normalized.replace(/[!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~]/g, '');\n  return normalized.toLowerCase();\n}\n\n/**\n * Calculates the Exact Match (EM) score between a prediction and ground truth.\n *\n * The EM score is a strict metric used in machine learning to assess if the predicted\n * answer matches the ground truth exactly, commonly used in tasks like question answering.\n *\n * @param prediction The predicted text.\n * @param groundTruth The actual correct text.\n * @returns A number (1.0 for exact match, 0.0 otherwise).\n */\nfunction emScore(prediction: string, groundTruth: string): number {\n  return normalizeText(prediction) === normalizeText(groundTruth) ? 1.0 : 0.0;\n}\n\n/**\n * Calculates the F1 score between a prediction and ground truth.\n *\n * The F1 score is a harmonic mean of precision and recall, widely used in NLP to measure\n * a model's accuracy in considering both false positives and false negatives, offering a\n * balance for evaluating classification models.\n *\n * @param prediction The predicted text.\n * @param groundTruth The actual correct text.\n * @returns The F1 score as a number.\n */\nfunction f1Score(prediction: string, groundTruth: string): number {\n  const predictionTokens = normalizeText(prediction).split(' ');\n  const groundTruthTokens = normalizeText(groundTruth).split(' ');\n\n  // Calculate the intersection of common tokens between prediction and ground truth\n  const predictionCounts = countTokens(predictionTokens);\n  const groundTruthCounts = countTokens(groundTruthTokens);\n\n  let numSame = 0;\n  for (const token in predictionCounts) {\n    const v1 = predictionCounts[token] ?? 0;\n    const v2 = groundTruthCounts[token] ?? 0;\n    numSame += Math.min(v1, v2);\n  }\n  if (numSame === 0) {\n    return 0;\n  }\n\n  const precision = numSame / predictionTokens.length;\n  const recall = numSame / groundTruthTokens.length;\n  return (2 * precision * recall) / (precision + recall);\n}\n\n/**\n * Calculates a novel F1 score, taking into account a history of interaction and excluding stopwords.\n *\n * This metric extends the F1 score by considering contextual relevance and filtering out common words\n * that might skew the assessment of the prediction's quality, especially in conversational models or\n * when historical context is relevant.\n *\n * @param history The historical context or preceding interactions.\n * @param prediction The predicted text.\n * @param groundTruth The actual correct text.\n * @param returnRecall Optionally return the recall score instead of F1.\n * @returns The novel F1 or recall score as a number.\n */\nfunction novelF1ScoreOptimized(\n  history: string,\n  prediction: string,\n  groundTruth: string,\n  returnRecall = false\n): number {\n  // Normalize and split the input texts into tokens\n  const historyTokens = normalizeText(history).split(' ');\n  let predictionTokens = normalizeText(prediction).split(' ');\n  let groundTruthTokens = normalizeText(groundTruth).split(' ');\n\n  // Combine stopwords and history tokens for exclusion\n  const exclusions = new Set([...stopwords, ...historyTokens]);\n\n  // Filter prediction and ground truth tokens against the exclusions\n  predictionTokens = filterTokens(predictionTokens, exclusions);\n  groundTruthTokens = filterTokens(groundTruthTokens, exclusions);\n\n  // Proceed with calculating common tokens, precision, recall, and F1 score as previously outlined\n\n  // Placeholder for the calculation logic\n  const numSame = 0; // This should be calculated as before\n  const precision = numSame / predictionTokens.length;\n  const recall = numSame / groundTruthTokens.length;\n  const f1 = (2 * precision * recall) / (precision + recall);\n\n  return returnRecall ? recall : f1;\n}\n\nexport const AxEvalUtil = {\n  emScore,\n  f1Score,\n  novelF1ScoreOptimized,\n};\n","import type { AxAIService } from '../ai/types.js';\nimport type { AxExample, AxMetricFn } from './common_types.js';\nimport type { AxGen } from './generate.js';\nimport type { AxGenIn, AxGenOut } from './types.js';\n\nexport type AxEvaluateArgs<IN extends AxGenIn, OUT extends AxGenOut> = {\n  ai: AxAIService;\n  program: Readonly<AxGen<IN, OUT>>;\n  examples: Readonly<AxExample[]>;\n};\n\nexport class AxTestPrompt<\n  IN extends AxGenIn = AxGenIn,\n  OUT extends AxGenOut = AxGenOut,\n> {\n  private ai: AxAIService;\n  private program: Readonly<AxGen<IN, OUT>>;\n  private examples: Readonly<AxExample[]>;\n\n  constructor({\n    ai,\n    program,\n    examples = [],\n  }: Readonly<AxEvaluateArgs<IN, OUT>>) {\n    if (examples.length === 0) {\n      throw new Error('No examples found');\n    }\n    this.ai = ai;\n    this.program = program;\n    this.examples = examples;\n  }\n\n  public async run(metricFn: AxMetricFn) {\n    const _st = Date.now();\n    const total = this.examples.length;\n    let sumOfScores = 0;\n\n    for (let i = 0; i < total; i++) {\n      const ex = this.examples[i];\n      if (!ex) {\n        throw new Error('Invalid example');\n      }\n\n      try {\n        const res = await this.program.forward(this.ai, ex as IN, {\n          maxRetries: 1,\n        });\n        const score = await metricFn({ prediction: res, example: ex });\n        sumOfScores += score;\n      } catch (error) {\n        console.warn(\n          `Program evaluation failed for example ${i}: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n        // Continue with next example - score remains 0 for this example\n      }\n    }\n\n    const averageScore = total > 0 ? sumOfScores / total : 0;\n\n    // Only log performance results when debug is enabled\n    if (this.ai.getOptions().debug) {\n      console.log(\n        '\\nPerformance: ',\n        sumOfScores,\n        '/',\n        total,\n        'Average Score: ',\n        averageScore,\n        '\\n'\n      );\n    }\n  }\n}\n","import type { AxFieldValue } from './types.js';\n\nexport type AxDataRow = { row: Record<string, AxFieldValue> };\n\nexport class AxHFDataLoader {\n  private rows: AxDataRow[] = [];\n  private baseUrl: string;\n\n  private dataset: string;\n  private split: string;\n  private config: string;\n  private options?: Readonly<{ offset?: number; length?: number }>;\n\n  constructor({\n    dataset,\n    split,\n    config,\n    options,\n  }: Readonly<{\n    dataset: string;\n    split: string;\n    config: string;\n    options?: Readonly<{ offset?: number; length?: number }>;\n  }>) {\n    this.baseUrl = 'https://datasets-server.huggingface.co/rows';\n    this.dataset = dataset;\n    this.split = split;\n    this.config = config;\n    this.options = options;\n  }\n\n  private async fetchDataFromAPI(url: string): Promise<AxDataRow[]> {\n    try {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`Error fetching data: ${response.statusText}`);\n      }\n      const data = (await response.json()) as { rows: AxDataRow[] };\n      if (!data?.rows) {\n        throw new Error('Invalid data format');\n      }\n      return data.rows;\n    } catch (error) {\n      console.error('Error fetching data from API:', error);\n      throw error;\n    }\n  }\n\n  // https://datasets-server.huggingface.co/rows?dataset=hotpot_qa&config=distractor&split=train&offset=0&length=100\n\n  public async loadData() {\n    const offset = this.options?.offset ?? 0;\n    const length = this.options?.length ?? 100;\n    const ds = encodeURIComponent(this.dataset);\n\n    const url = `${this.baseUrl}?dataset=${ds}&config=${this.config}&split=${this.split}&offset=${offset}&length=${length}`;\n\n    this.rows = (await this.fetchDataFromAPI(url)) as AxDataRow[];\n    return this.rows;\n  }\n\n  public setData(rows: AxDataRow[]) {\n    this.rows = rows;\n  }\n\n  public getData() {\n    return this.rows;\n  }\n\n  public async getRows<T>({\n    count,\n    fields,\n    renameMap,\n  }: Readonly<{\n    count: number;\n    fields: readonly string[];\n    renameMap?: Record<string, string>;\n  }>): Promise<T[]> {\n    if (this.rows.length === 0) {\n      throw new Error('No data loaded, call loadData or setData first.');\n    }\n    const dataRows = this.rows.slice(0, count);\n\n    return dataRows\n      .map((item) => {\n        const result: Record<string, AxFieldValue> = {};\n\n        fields.forEach((field) => {\n          const keys = field.split('.');\n          // Initial value should match the type of the rows, and be indexable by string\n          let value: AxFieldValue | unknown = item.row;\n          for (const key of keys) {\n            // Use type assertion to tell TypeScript that value will always be an object that can be indexed with string keys\n            if (Object.hasOwn(value as Record<string, unknown>, key)) {\n              value = (value as Record<string, unknown>)[key];\n            }\n          }\n          if (!value) {\n            return;\n          }\n          const resultFieldName =\n            renameMap && field in renameMap ? renameMap[field] : field;\n          if (!resultFieldName) {\n            throw new Error(`Invalid field name: ${field}`);\n          }\n          result[resultFieldName] = value as AxFieldValue;\n        });\n\n        return result;\n      })\n      .filter((v) => Object.keys(v).length !== 0) as T[];\n  }\n}\n","import { ColorLog } from '../util/log.js';\nimport type {\n  AxOptimizerLoggerData,\n  AxOptimizerLoggerFunction,\n} from './optimizerTypes.js';\n\n// Default output function that writes to stdout\nconst defaultOutput = (message: string): void => {\n  console.log(message);\n};\n\n/**\n * Factory function to create a default optimizer logger with color formatting\n */\nexport const axCreateDefaultOptimizerColorLogger = (\n  output: (message: string) => void = defaultOutput\n): AxOptimizerLoggerFunction => {\n  const cl = new ColorLog();\n  const lightDivider = cl.gray(''.repeat(50));\n  const heavyDivider = cl.gray(''.repeat(50));\n\n  return (data: AxOptimizerLoggerData) => {\n    let formattedMessage = '';\n\n    switch (data.name) {\n      case 'OptimizationStart':\n        formattedMessage =\n          `\\n${cl.blueBright(' ')}${cl.whiteBright('Optimization Started')}\\n` +\n          `${lightDivider}\\n` +\n          `  ${cl.white('Optimizer:')} ${cl.cyan(data.value.optimizerType)}\\n` +\n          `  ${cl.white('Examples:')} ${cl.green(data.value.exampleCount.toString())} training, ${cl.green(data.value.validationCount.toString())} validation\\n` +\n          `  ${cl.white('Config:')} ${cl.white(JSON.stringify(data.value.config).slice(0, 80))}${JSON.stringify(data.value.config).length > 80 ? '...' : ''}\\n` +\n          `${heavyDivider}\\n`;\n        break;\n\n      case 'RoundProgress':\n        {\n          const config = data.value.configuration || {};\n          const configParts = [];\n\n          // Add temperature if present\n          if (\n            config.temperature !== undefined &&\n            typeof config.temperature === 'number'\n          ) {\n            configParts.push(`T=${config.temperature.toFixed(2)}`);\n          }\n\n          // Add bootstrapped demos if present\n          if (config.bootstrappedDemos !== undefined) {\n            configParts.push(`demos=${config.bootstrappedDemos}`);\n          }\n\n          // Add any other numeric configs\n          Object.entries(config).forEach(([key, value]) => {\n            if (\n              key !== 'temperature' &&\n              key !== 'bootstrappedDemos' &&\n              key !== 'trialNumber' &&\n              typeof value === 'number'\n            ) {\n              configParts.push(`${key}=${value.toFixed(2)}`);\n            }\n          });\n\n          const improvement = data.value.currentScore - data.value.bestScore;\n          const improvementStr =\n            improvement > 0\n              ? cl.greenBright(` ${improvement.toFixed(3)}`)\n              : improvement < 0\n                ? cl.red(` ${Math.abs(improvement).toFixed(3)}`)\n                : '';\n\n          const totalRounds =\n            typeof data.value.totalRounds === 'number' &&\n            data.value.totalRounds > 0\n              ? data.value.totalRounds\n              : typeof (config as any).totalRounds === 'number' &&\n                  (config as any).totalRounds > 0\n                ? (config as any).totalRounds\n                : 0;\n\n          formattedMessage =\n            `${cl.yellow(' ')}${cl.whiteBright(`Round ${data.value.round}/${totalRounds}`)}` +\n            (config.trialNumber !== undefined\n              ? cl.gray(` [Trial #${config.trialNumber}]`)\n              : '') +\n            '\\n' +\n            `  ${cl.white('Score:')} ${cl.green(data.value.currentScore.toFixed(3))} ${cl.white('(best:')} ${cl.greenBright(data.value.bestScore.toFixed(3))}${cl.white(')')}${improvementStr}\\n` +\n            (configParts.length > 0\n              ? `  ${cl.white('Config:')} ${cl.cyan(configParts.join(', '))}\\n`\n              : '');\n        }\n        break;\n\n      case 'EarlyStopping':\n        formattedMessage =\n          `\\n${cl.red(' ')}${cl.whiteBright('Early Stopping')}\\n` +\n          `${lightDivider}\\n` +\n          `  ${cl.white('Round:')} ${cl.yellow(data.value.round.toString())}\\n` +\n          `  ${cl.white('Reason:')} ${cl.yellow(data.value.reason)}\\n` +\n          `  ${cl.white('Final Score:')} ${cl.green(data.value.finalScore.toFixed(3))}\\n` +\n          `${heavyDivider}\\n`;\n        break;\n\n      case 'OptimizationComplete':\n        {\n          let explanationSection = '';\n\n          // Add human-readable explanation if available\n          if (data.value.explanation) {\n            explanationSection += `\\n${cl.blueBright(' Summary:')}\\n  ${cl.white(data.value.explanation)}\\n`;\n          }\n\n          // Add performance assessment if available\n          if (data.value.performanceAssessment) {\n            explanationSection += `\\n${cl.yellowBright(' Performance:')}\\n  ${cl.white(data.value.performanceAssessment)}\\n`;\n          }\n\n          // Add recommendations if available\n          if (\n            data.value.recommendations &&\n            data.value.recommendations.length > 0\n          ) {\n            explanationSection += `\\n${cl.greenBright(' Recommendations:')}\\n`;\n            data.value.recommendations.forEach((rec: string, idx: number) => {\n              explanationSection += `  ${cl.white(`${idx + 1}.`)} ${cl.white(rec)}\\n`;\n            });\n          }\n\n          formattedMessage =\n            `\\n${cl.green(' ')}${cl.whiteBright('Optimization Complete')}\\n` +\n            `${lightDivider}\\n` +\n            `  ${cl.white('Best Score:')} ${cl.greenBright(data.value.bestScore.toFixed(3))}\\n` +\n            `  ${cl.white('Best Config:')} ${cl.cyan(JSON.stringify(data.value.bestConfiguration).slice(0, 80))}${JSON.stringify(data.value.bestConfiguration).length > 80 ? '...' : ''}\\n` +\n            `  ${cl.white('Total Calls:')} ${cl.white(data.value.stats?.totalCalls?.toString() || 'N/A')}\\n` +\n            `  ${cl.white('Success Rate:')} ${cl.green(`${(((data.value.stats?.successfulDemos || 0) / Math.max(data.value.stats?.totalCalls || 1, 1)) * 100).toFixed(1)}%`)}\\n` +\n            explanationSection +\n            `${heavyDivider}\\n`;\n        }\n        break;\n\n      case 'ConfigurationProposal':\n        formattedMessage =\n          `${cl.magenta(' ')}${cl.whiteBright(`${data.value.type} Proposals`)} ${cl.white(`(${data.value.count})`)}\\n` +\n          `  ${cl.white('Candidates:')} ${cl.white(\n            data.value.proposals\n              .slice(0, 2)\n              .map((p) =>\n                typeof p === 'string'\n                  ? `\"${p.slice(0, 40)}...\"`\n                  : `${JSON.stringify(p).slice(0, 40)}...`\n              )\n              .join(', ')\n          )}\\n`;\n        break;\n\n      case 'BootstrappedDemos':\n        formattedMessage =\n          `${cl.cyan(' ')}${cl.whiteBright('Bootstrapped Demos')} ${cl.white(`(${data.value.count})`)}\\n` +\n          `  ${cl.white('Generated:')} ${cl.green(data.value.count.toString())} demonstration examples\\n`;\n        break;\n\n      case 'BestConfigFound':\n        formattedMessage =\n          `${cl.green(' ')}${cl.whiteBright('Best Configuration Found')}\\n` +\n          `  ${cl.white('Score:')} ${cl.greenBright(data.value.score.toFixed(3))}\\n` +\n          `  ${cl.white('Config:')} ${cl.cyan(JSON.stringify(data.value.config).slice(0, 80))}${JSON.stringify(data.value.config).length > 80 ? '...' : ''}\\n`;\n        break;\n\n      default:\n        formattedMessage =\n          `${cl.red(' ')}${cl.whiteBright('Unknown Event')}\\n` +\n          `  ${cl.white(JSON.stringify(data).slice(0, 100))}${JSON.stringify(data).length > 100 ? '...' : ''}\\n`;\n    }\n\n    output(formattedMessage);\n  };\n};\n\n/**\n * Factory function to create a text-only optimizer logger (no colors)\n */\nexport const axCreateDefaultOptimizerTextLogger = (\n  output: (message: string) => void = defaultOutput\n): AxOptimizerLoggerFunction => {\n  const divider = ''.repeat(60);\n\n  return (data: AxOptimizerLoggerData) => {\n    let formattedMessage = '';\n\n    switch (data.name) {\n      case 'OptimizationStart':\n        formattedMessage =\n          `[ OPTIMIZATION START: ${data.value.optimizerType} ]\n${divider}\n` +\n          `Config: ${JSON.stringify(data.value.config, null, 2)}\n` +\n          `Examples: ${data.value.exampleCount}, Validation: ${data.value.validationCount}\n` +\n          `${divider}`;\n        break;\n      case 'RoundProgress':\n        formattedMessage =\n          `[ ROUND ${data.value.round}/${data.value.totalRounds} ]\n` +\n          `Current Score: ${data.value.currentScore.toFixed(3)}, Best: ${data.value.bestScore.toFixed(3)}\n` +\n          `Config: ${JSON.stringify(data.value.configuration)}\n` +\n          `${divider}`;\n        break;\n      case 'EarlyStopping':\n        formattedMessage =\n          `[ EARLY STOPPING at Round ${data.value.round} ]\n` +\n          `Reason: ${data.value.reason}\n` +\n          `Final Score: ${data.value.finalScore.toFixed(3)}\n` +\n          `${divider}`;\n        break;\n      case 'OptimizationComplete':\n        formattedMessage =\n          `[ OPTIMIZATION COMPLETE ]\n${divider}\n` +\n          `Best Score: ${data.value.bestScore.toFixed(3)}\n` +\n          `Best Config: ${JSON.stringify(data.value.bestConfiguration)}\n` +\n          `Stats: ${JSON.stringify(data.value.stats, null, 2)}\n` +\n          `${divider}`;\n        break;\n      case 'ConfigurationProposal':\n        formattedMessage =\n          `[ CONFIG PROPOSAL: ${data.value.type} ]\n` +\n          `Count: ${data.value.count}\n` +\n          `Proposals: ${JSON.stringify(data.value.proposals.slice(0, 3), null, 2)} ${data.value.proposals.length > 3 ? '... (truncated)' : ''}\n` +\n          `${divider}`;\n        break;\n      case 'BootstrappedDemos':\n        formattedMessage =\n          `[ BOOTSTRAPPED DEMOS ]\n` +\n          `Count: ${data.value.count}\n` +\n          `Demos: ${JSON.stringify(data.value.demos.slice(0, 2), null, 2)} ${data.value.demos.length > 2 ? '... (truncated)' : ''}\n` +\n          `${divider}`;\n        break;\n      case 'BestConfigFound':\n        formattedMessage =\n          `[ BEST CONFIG FOUND ]\n` +\n          `Score: ${data.value.score.toFixed(3)}\n` +\n          `Config: ${JSON.stringify(data.value.config)}\n` +\n          `${divider}`;\n        break;\n      default:\n        formattedMessage = `[ UNKNOWN OPTIMIZER EVENT ]\n${JSON.stringify(data)}\n${divider}`;\n    }\n\n    output(formattedMessage);\n  };\n};\n\n/**\n * Default optimizer logger instance with color formatting\n */\nexport const axDefaultOptimizerLogger = axCreateDefaultOptimizerColorLogger();\n","import type { Counter, Gauge, Histogram, Meter } from '@opentelemetry/api';\n\nimport type { AxAIService, AxLoggerFunction } from '../ai/types.js';\n\n// FIXME: Circular dependency - import { ax } from '../index.js';\n\nimport type {\n  AxCheckpointLoadFn,\n  AxCheckpointSaveFn,\n  AxCompileOptions,\n  AxCostTracker,\n  AxCostTrackerOptions,\n  AxExample,\n  AxMetricFn,\n  AxMultiMetricFn,\n  AxOptimizationCheckpoint,\n  AxOptimizationProgress,\n  AxOptimizationStats,\n  AxOptimizerArgs,\n  AxTypedExample,\n} from './common_types.js';\nimport { AxGen } from './generate.js';\nimport { axGlobals } from './globals.js';\nimport { axDefaultOptimizerLogger } from './optimizerLogging.js';\nimport type { AxOptimizerLoggerFunction } from './optimizerTypes.js';\nimport type { AxGenOut, AxProgramDemos } from './types.js';\n\n// Shared optimizer-related types are exported exclusively from `common_types.ts`\n// to avoid duplicate type exports when generating the package index.\n\n// Logger utilities are now exported from ./loggers.js\n\n// Multi-objective metric function for Pareto optimization\n\n// Common types moved to ./common_types.ts\n\n// Progress tracking interface for real-time updates\n// AxOptimizationProgress moved to ./common_types.ts\n\n// Cost tracking interface for monitoring resource usage\n// AxCostTracker moved to ./common_types.ts\n\n// Checkpoint interface for saving/loading optimization state\n// AxOptimizationCheckpoint moved to ./common_types.ts\n\n// Simple checkpoint functions moved to ./common_types.ts\n\n// Cost tracker configuration options now provided by ./types\n\n// AxOptimizerArgs moved to ./common_types.ts\n\n// AxOptimizationStats moved to ./common_types.ts\n\n// Optimizer metrics configuration interface\nexport interface AxOptimizerMetricsConfig {\n  enabled: boolean;\n  enabledCategories: (\n    | 'optimization'\n    | 'convergence'\n    | 'resource_usage'\n    | 'teacher_student'\n    | 'checkpointing'\n    | 'pareto'\n  )[];\n  maxLabelLength: number;\n  samplingRate: number;\n}\n\n// Default optimizer metrics configuration\nexport const axDefaultOptimizerMetricsConfig: AxOptimizerMetricsConfig = {\n  enabled: true,\n  enabledCategories: [\n    'optimization',\n    'convergence',\n    'resource_usage',\n    'teacher_student',\n    'checkpointing',\n    'pareto',\n  ],\n  maxLabelLength: 100,\n  samplingRate: 1.0,\n};\n\n// Optimizer metrics instruments interface\nexport interface AxOptimizerMetricsInstruments {\n  // Optimization flow metrics\n  optimizationLatencyHistogram?: Histogram;\n  optimizationRequestsCounter?: Counter;\n  optimizationErrorsCounter?: Counter;\n\n  // Convergence metrics\n  convergenceRoundsHistogram?: Histogram;\n  convergenceScoreGauge?: Gauge;\n  convergenceImprovementGauge?: Gauge;\n  stagnationRoundsGauge?: Gauge;\n  earlyStoppingCounter?: Counter;\n\n  // Resource usage metrics\n  tokenUsageCounter?: Counter;\n  costUsageCounter?: Counter;\n  memoryUsageGauge?: Gauge;\n  optimizationDurationHistogram?: Histogram;\n\n  // Teacher-student metrics\n  teacherStudentUsageCounter?: Counter;\n  teacherStudentLatencyHistogram?: Histogram;\n  teacherStudentScoreImprovementGauge?: Gauge;\n\n  // Checkpointing metrics\n  checkpointSaveCounter?: Counter;\n  checkpointLoadCounter?: Counter;\n  checkpointSaveLatencyHistogram?: Histogram;\n  checkpointLoadLatencyHistogram?: Histogram;\n\n  // Pareto optimization metrics\n  paretoOptimizationsCounter?: Counter;\n  paretoFrontSizeHistogram?: Histogram;\n  paretoHypervolumeGauge?: Gauge;\n  paretoSolutionsGeneratedHistogram?: Histogram;\n\n  // Program complexity metrics\n  programInputFieldsGauge?: Gauge;\n  programOutputFieldsGauge?: Gauge;\n  examplesCountGauge?: Gauge;\n  validationSetSizeGauge?: Gauge;\n\n  // Performance metrics\n  evaluationLatencyHistogram?: Histogram;\n  demoGenerationLatencyHistogram?: Histogram;\n  metricComputationLatencyHistogram?: Histogram;\n\n  // Configuration metrics\n  optimizerTypeGauge?: Gauge;\n  targetScoreGauge?: Gauge;\n  maxRoundsGauge?: Gauge;\n}\n\n// Singleton instance for optimizer metrics instruments\nlet globalOptimizerMetricsInstruments:\n  | AxOptimizerMetricsInstruments\n  | undefined;\n\n// Function to get or create optimizer metrics instruments (singleton pattern)\nexport const getOrCreateOptimizerMetricsInstruments = (\n  meter?: Meter\n): AxOptimizerMetricsInstruments | undefined => {\n  // Return existing instance if available\n  if (globalOptimizerMetricsInstruments) {\n    return globalOptimizerMetricsInstruments;\n  }\n\n  if (meter) {\n    globalOptimizerMetricsInstruments =\n      createOptimizerMetricsInstruments(meter);\n    return globalOptimizerMetricsInstruments;\n  }\n\n  return undefined;\n};\n\n// Function to reset the optimizer metrics singleton (useful for testing)\nexport const resetOptimizerMetricsInstruments = (): void => {\n  globalOptimizerMetricsInstruments = undefined;\n};\n\n// Global optimizer metrics configuration\nlet currentOptimizerMetricsConfig: AxOptimizerMetricsConfig =\n  axDefaultOptimizerMetricsConfig;\n\n// Function to update optimizer metrics configuration\nexport const axUpdateOptimizerMetricsConfig = (\n  config: Readonly<Partial<AxOptimizerMetricsConfig>>\n): void => {\n  currentOptimizerMetricsConfig = {\n    ...currentOptimizerMetricsConfig,\n    ...config,\n  };\n};\n\n// Function to get current optimizer metrics configuration\nexport const axGetOptimizerMetricsConfig = (): AxOptimizerMetricsConfig => {\n  return { ...currentOptimizerMetricsConfig };\n};\n\nexport const createOptimizerMetricsInstruments = (\n  meter: Meter\n): AxOptimizerMetricsInstruments => {\n  return {\n    // Optimization flow metrics\n    optimizationLatencyHistogram: meter.createHistogram(\n      'ax_optimizer_optimization_duration_ms',\n      {\n        description: 'End-to-end duration of optimization runs',\n        unit: 'ms',\n      }\n    ),\n\n    optimizationRequestsCounter: meter.createCounter(\n      'ax_optimizer_optimization_requests_total',\n      {\n        description: 'Total number of optimization requests',\n      }\n    ),\n\n    optimizationErrorsCounter: meter.createCounter(\n      'ax_optimizer_optimization_errors_total',\n      {\n        description: 'Total number of failed optimizations',\n      }\n    ),\n\n    // Convergence metrics\n    convergenceRoundsHistogram: meter.createHistogram(\n      'ax_optimizer_convergence_rounds',\n      {\n        description: 'Number of rounds until convergence',\n      }\n    ),\n\n    convergenceScoreGauge: meter.createGauge('ax_optimizer_convergence_score', {\n      description: 'Current best score during optimization',\n    }),\n\n    convergenceImprovementGauge: meter.createGauge(\n      'ax_optimizer_convergence_improvement',\n      {\n        description: 'Improvement in score from baseline',\n      }\n    ),\n\n    stagnationRoundsGauge: meter.createGauge('ax_optimizer_stagnation_rounds', {\n      description: 'Number of rounds without improvement',\n    }),\n\n    earlyStoppingCounter: meter.createCounter(\n      'ax_optimizer_early_stopping_total',\n      {\n        description: 'Total number of early stopping events',\n      }\n    ),\n\n    // Resource usage metrics\n    tokenUsageCounter: meter.createCounter('ax_optimizer_token_usage_total', {\n      description: 'Total tokens used during optimization',\n    }),\n\n    costUsageCounter: meter.createCounter('ax_optimizer_cost_usage_total', {\n      description: 'Total cost incurred during optimization',\n      unit: '$',\n    }),\n\n    memoryUsageGauge: meter.createGauge('ax_optimizer_memory_usage_bytes', {\n      description: 'Peak memory usage during optimization',\n      unit: 'By',\n    }),\n\n    optimizationDurationHistogram: meter.createHistogram(\n      'ax_optimizer_duration_ms',\n      {\n        description: 'Duration of optimization runs',\n        unit: 'ms',\n      }\n    ),\n\n    // Teacher-student metrics\n    teacherStudentUsageCounter: meter.createCounter(\n      'ax_optimizer_teacher_student_usage_total',\n      {\n        description: 'Total number of teacher-student interactions',\n      }\n    ),\n\n    teacherStudentLatencyHistogram: meter.createHistogram(\n      'ax_optimizer_teacher_student_latency_ms',\n      {\n        description: 'Latency of teacher-student interactions',\n        unit: 'ms',\n      }\n    ),\n\n    teacherStudentScoreImprovementGauge: meter.createGauge(\n      'ax_optimizer_teacher_student_score_improvement',\n      {\n        description: 'Score improvement from teacher-student interactions',\n      }\n    ),\n\n    // Checkpointing metrics\n    checkpointSaveCounter: meter.createCounter(\n      'ax_optimizer_checkpoint_save_total',\n      {\n        description: 'Total number of checkpoint saves',\n      }\n    ),\n\n    checkpointLoadCounter: meter.createCounter(\n      'ax_optimizer_checkpoint_load_total',\n      {\n        description: 'Total number of checkpoint loads',\n      }\n    ),\n\n    checkpointSaveLatencyHistogram: meter.createHistogram(\n      'ax_optimizer_checkpoint_save_latency_ms',\n      {\n        description: 'Latency of checkpoint save operations',\n        unit: 'ms',\n      }\n    ),\n\n    checkpointLoadLatencyHistogram: meter.createHistogram(\n      'ax_optimizer_checkpoint_load_latency_ms',\n      {\n        description: 'Latency of checkpoint load operations',\n        unit: 'ms',\n      }\n    ),\n\n    // Pareto optimization metrics\n    paretoOptimizationsCounter: meter.createCounter(\n      'ax_optimizer_pareto_optimizations_total',\n      {\n        description: 'Total number of Pareto optimizations',\n      }\n    ),\n\n    paretoFrontSizeHistogram: meter.createHistogram(\n      'ax_optimizer_pareto_front_size',\n      {\n        description: 'Size of Pareto frontier',\n      }\n    ),\n\n    paretoHypervolumeGauge: meter.createGauge(\n      'ax_optimizer_pareto_hypervolume',\n      {\n        description: 'Hypervolume of Pareto frontier',\n      }\n    ),\n\n    paretoSolutionsGeneratedHistogram: meter.createHistogram(\n      'ax_optimizer_pareto_solutions_generated',\n      {\n        description: 'Number of solutions generated for Pareto optimization',\n      }\n    ),\n\n    // Program complexity metrics\n    programInputFieldsGauge: meter.createGauge(\n      'ax_optimizer_program_input_fields',\n      {\n        description: 'Number of input fields in optimized program',\n      }\n    ),\n\n    programOutputFieldsGauge: meter.createGauge(\n      'ax_optimizer_program_output_fields',\n      {\n        description: 'Number of output fields in optimized program',\n      }\n    ),\n\n    examplesCountGauge: meter.createGauge('ax_optimizer_examples_count', {\n      description: 'Number of training examples used',\n    }),\n\n    validationSetSizeGauge: meter.createGauge(\n      'ax_optimizer_validation_set_size',\n      {\n        description: 'Size of validation set used',\n      }\n    ),\n\n    // Performance metrics\n    evaluationLatencyHistogram: meter.createHistogram(\n      'ax_optimizer_evaluation_latency_ms',\n      {\n        description: 'Latency of program evaluations',\n        unit: 'ms',\n      }\n    ),\n\n    demoGenerationLatencyHistogram: meter.createHistogram(\n      'ax_optimizer_demo_generation_latency_ms',\n      {\n        description: 'Latency of demo generation',\n        unit: 'ms',\n      }\n    ),\n\n    metricComputationLatencyHistogram: meter.createHistogram(\n      'ax_optimizer_metric_computation_latency_ms',\n      {\n        description: 'Latency of metric computation',\n        unit: 'ms',\n      }\n    ),\n\n    // Configuration metrics\n    optimizerTypeGauge: meter.createGauge('ax_optimizer_type', {\n      description: 'Type of optimizer being used',\n    }),\n\n    targetScoreGauge: meter.createGauge('ax_optimizer_target_score', {\n      description: 'Target score for optimization',\n    }),\n\n    maxRoundsGauge: meter.createGauge('ax_optimizer_max_rounds', {\n      description: 'Maximum rounds for optimization',\n    }),\n  };\n};\n\n// Utility function to sanitize optimizer metric labels\nconst sanitizeOptimizerLabels = (\n  labels: Record<string, unknown>\n): Record<string, string> => {\n  const sanitized: Record<string, string> = {};\n  for (const [key, value] of Object.entries(labels)) {\n    if (value !== undefined && value !== null) {\n      const stringValue = String(value);\n      // Limit label length based on configuration\n      const maxLength = currentOptimizerMetricsConfig.maxLabelLength;\n      sanitized[key] =\n        stringValue.length > maxLength\n          ? stringValue.substring(0, maxLength)\n          : stringValue;\n    }\n  }\n  return sanitized;\n};\n\n// Recording functions for optimization flow metrics\nexport const recordOptimizationMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  duration: number,\n  success: boolean,\n  optimizerType: string,\n  programSignature?: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      success: success.toString(),\n      optimizer_type: optimizerType,\n      ...(programSignature ? { program_signature: programSignature } : {}),\n    });\n\n    if (instruments.optimizationLatencyHistogram) {\n      instruments.optimizationLatencyHistogram.record(duration, labels);\n    }\n\n    if (instruments.optimizationRequestsCounter) {\n      instruments.optimizationRequestsCounter.add(1, labels);\n    }\n\n    if (!success && instruments.optimizationErrorsCounter) {\n      instruments.optimizationErrorsCounter.add(1, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record optimization metric:', error);\n  }\n};\n\n// Recording functions for convergence metrics\nexport const recordConvergenceMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  rounds: number,\n  currentScore: number,\n  improvement: number,\n  stagnationRounds: number,\n  optimizerType: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.convergenceRoundsHistogram) {\n      instruments.convergenceRoundsHistogram.record(rounds, labels);\n    }\n\n    if (instruments.convergenceScoreGauge) {\n      instruments.convergenceScoreGauge.record(currentScore, labels);\n    }\n\n    if (instruments.convergenceImprovementGauge) {\n      instruments.convergenceImprovementGauge.record(improvement, labels);\n    }\n\n    if (instruments.stagnationRoundsGauge) {\n      instruments.stagnationRoundsGauge.record(stagnationRounds, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record convergence metric:', error);\n  }\n};\n\nexport const recordEarlyStoppingMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  reason: string,\n  optimizerType: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      reason,\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.earlyStoppingCounter) {\n      instruments.earlyStoppingCounter.add(1, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record early stopping metric:', error);\n  }\n};\n\n// Recording functions for resource usage metrics\nexport const recordResourceUsageMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  tokensUsed: number,\n  costIncurred: number,\n  optimizerType: string,\n  memoryUsage?: number\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.tokenUsageCounter) {\n      instruments.tokenUsageCounter.add(tokensUsed, labels);\n    }\n\n    if (instruments.costUsageCounter) {\n      instruments.costUsageCounter.add(costIncurred, labels);\n    }\n\n    if (memoryUsage !== undefined && instruments.memoryUsageGauge) {\n      instruments.memoryUsageGauge.record(memoryUsage, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record resource usage metric:', error);\n  }\n};\n\nexport const recordOptimizationDurationMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  duration: number,\n  optimizerType: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.optimizationDurationHistogram) {\n      instruments.optimizationDurationHistogram.record(duration, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record optimization duration metric:', error);\n  }\n};\n\n// Recording functions for teacher-student metrics\nexport const recordTeacherStudentMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  latency: number,\n  scoreImprovement: number,\n  optimizerType: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.teacherStudentUsageCounter) {\n      instruments.teacherStudentUsageCounter.add(1, labels);\n    }\n\n    if (instruments.teacherStudentLatencyHistogram) {\n      instruments.teacherStudentLatencyHistogram.record(latency, labels);\n    }\n\n    if (instruments.teacherStudentScoreImprovementGauge) {\n      instruments.teacherStudentScoreImprovementGauge.record(\n        scoreImprovement,\n        labels\n      );\n    }\n  } catch (error) {\n    console.warn('Failed to record teacher-student metric:', error);\n  }\n};\n\n// Recording functions for checkpointing metrics\nexport const recordCheckpointMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  operation: 'save' | 'load',\n  latency: number,\n  success: boolean,\n  optimizerType: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      operation,\n      success: success.toString(),\n      optimizer_type: optimizerType,\n    });\n\n    if (operation === 'save') {\n      if (instruments.checkpointSaveCounter) {\n        instruments.checkpointSaveCounter.add(1, labels);\n      }\n      if (instruments.checkpointSaveLatencyHistogram) {\n        instruments.checkpointSaveLatencyHistogram.record(latency, labels);\n      }\n    } else {\n      if (instruments.checkpointLoadCounter) {\n        instruments.checkpointLoadCounter.add(1, labels);\n      }\n      if (instruments.checkpointLoadLatencyHistogram) {\n        instruments.checkpointLoadLatencyHistogram.record(latency, labels);\n      }\n    }\n  } catch (error) {\n    console.warn('Failed to record checkpoint metric:', error);\n  }\n};\n\n// Recording functions for Pareto optimization metrics\nexport const recordParetoMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  frontSize: number,\n  solutionsGenerated: number,\n  optimizerType: string,\n  hypervolume?: number\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.paretoOptimizationsCounter) {\n      instruments.paretoOptimizationsCounter.add(1, labels);\n    }\n\n    if (instruments.paretoFrontSizeHistogram) {\n      instruments.paretoFrontSizeHistogram.record(frontSize, labels);\n    }\n\n    if (hypervolume !== undefined && instruments.paretoHypervolumeGauge) {\n      instruments.paretoHypervolumeGauge.record(hypervolume, labels);\n    }\n\n    if (instruments.paretoSolutionsGeneratedHistogram) {\n      instruments.paretoSolutionsGeneratedHistogram.record(\n        solutionsGenerated,\n        labels\n      );\n    }\n  } catch (error) {\n    console.warn('Failed to record Pareto metric:', error);\n  }\n};\n\n// Recording functions for program complexity metrics\nexport const recordProgramComplexityMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  inputFields: number,\n  outputFields: number,\n  examplesCount: number,\n  validationSetSize: number,\n  optimizerType: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.programInputFieldsGauge) {\n      instruments.programInputFieldsGauge.record(inputFields, labels);\n    }\n\n    if (instruments.programOutputFieldsGauge) {\n      instruments.programOutputFieldsGauge.record(outputFields, labels);\n    }\n\n    if (instruments.examplesCountGauge) {\n      instruments.examplesCountGauge.record(examplesCount, labels);\n    }\n\n    if (instruments.validationSetSizeGauge) {\n      instruments.validationSetSizeGauge.record(validationSetSize, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record program complexity metric:', error);\n  }\n};\n\n// Recording functions for performance metrics\nexport const recordOptimizerPerformanceMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  metricType: 'evaluation' | 'demo_generation' | 'metric_computation',\n  duration: number,\n  optimizerType: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      metric_type: metricType,\n      optimizer_type: optimizerType,\n    });\n\n    switch (metricType) {\n      case 'evaluation':\n        if (instruments.evaluationLatencyHistogram) {\n          instruments.evaluationLatencyHistogram.record(duration, labels);\n        }\n        break;\n      case 'demo_generation':\n        if (instruments.demoGenerationLatencyHistogram) {\n          instruments.demoGenerationLatencyHistogram.record(duration, labels);\n        }\n        break;\n      case 'metric_computation':\n        if (instruments.metricComputationLatencyHistogram) {\n          instruments.metricComputationLatencyHistogram.record(\n            duration,\n            labels\n          );\n        }\n        break;\n    }\n  } catch (error) {\n    console.warn('Failed to record optimizer performance metric:', error);\n  }\n};\n\n// Recording functions for configuration metrics\nexport const recordOptimizerConfigurationMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  optimizerType: string,\n  targetScore?: number,\n  maxRounds?: number\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.optimizerTypeGauge) {\n      instruments.optimizerTypeGauge.record(1, labels);\n    }\n\n    if (targetScore !== undefined && instruments.targetScoreGauge) {\n      instruments.targetScoreGauge.record(targetScore, labels);\n    }\n\n    if (maxRounds !== undefined && instruments.maxRoundsGauge) {\n      instruments.maxRoundsGauge.record(maxRounds, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record optimizer configuration metric:', error);\n  }\n};\n\n// Simplified result - no program since it's passed to compile\n// Legacy interface - kept for backward compatibility\nexport interface AxOptimizerResult<OUT> {\n  demos?: AxProgramDemos<any, OUT>[];\n  stats: AxOptimizationStats;\n  bestScore: number;\n  finalConfiguration?: Record<string, unknown>;\n\n  // Optimization history for analysis\n  scoreHistory?: number[];\n  configurationHistory?: Record<string, unknown>[];\n}\n\n// Unified optimization result that consolidates all optimization outputs\nexport interface AxOptimizedProgram<OUT = any> {\n  // Core optimization results\n  bestScore: number;\n  stats: AxOptimizationStats;\n\n  // Program configuration\n  instruction?: string;\n  demos?: AxProgramDemos<any, OUT>[];\n  examples?: AxExample[];\n\n  // Model configuration\n  modelConfig?: {\n    temperature?: number;\n    maxTokens?: number;\n    topP?: number;\n    topK?: number;\n    frequencyPenalty?: number;\n    presencePenalty?: number;\n    stop?: string | string[];\n    [key: string]: unknown;\n  };\n\n  // Optimization metadata\n  optimizerType: string;\n  optimizationTime: number;\n  totalRounds: number;\n  converged: boolean;\n\n  // Historical data for analysis\n  scoreHistory?: number[];\n  configurationHistory?: Record<string, unknown>[];\n\n  // Apply this optimization to a program\n  applyTo<IN, T extends AxGenOut>(program: AxGen<IN, T>): void;\n}\n\n// Concrete implementation of AxOptimizedProgram\nexport class AxOptimizedProgramImpl<OUT = any>\n  implements AxOptimizedProgram<OUT>\n{\n  public readonly bestScore: number;\n  public readonly stats: AxOptimizationStats;\n  public readonly instruction?: string;\n  public readonly demos?: AxProgramDemos<any, OUT>[];\n  public readonly examples?: AxExample[];\n  public readonly modelConfig?: {\n    temperature?: number;\n    maxTokens?: number;\n    topP?: number;\n    topK?: number;\n    frequencyPenalty?: number;\n    presencePenalty?: number;\n    stop?: string | string[];\n    [key: string]: unknown;\n  };\n  public readonly optimizerType: string;\n  public readonly optimizationTime: number;\n  public readonly totalRounds: number;\n  public readonly converged: boolean;\n  public readonly scoreHistory?: number[];\n  public readonly configurationHistory?: Record<string, unknown>[];\n\n  constructor(config: {\n    bestScore: number;\n    stats: AxOptimizationStats;\n    instruction?: string;\n    demos?: AxProgramDemos<any, OUT>[];\n    examples?: AxExample[];\n    modelConfig?: AxOptimizedProgram<OUT>['modelConfig'];\n    optimizerType: string;\n    optimizationTime: number;\n    totalRounds: number;\n    converged: boolean;\n    scoreHistory?: number[];\n    configurationHistory?: Record<string, unknown>[];\n  }) {\n    this.bestScore = config.bestScore;\n    this.stats = config.stats;\n    this.instruction = config.instruction;\n    this.demos = config.demos;\n    this.examples = config.examples;\n    this.modelConfig = config.modelConfig;\n    this.optimizerType = config.optimizerType;\n    this.optimizationTime = config.optimizationTime;\n    this.totalRounds = config.totalRounds;\n    this.converged = config.converged;\n    this.scoreHistory = config.scoreHistory;\n    this.configurationHistory = config.configurationHistory;\n  }\n\n  public applyTo<IN, T extends AxGenOut>(program: AxGen<IN, T>): void {\n    // Apply demos if available\n    if (this.demos && this.demos.length > 0) {\n      program.setDemos(this.demos as any);\n    }\n\n    // Apply examples if available\n    if (this.examples && this.examples.length > 0) {\n      program.setExamples(this.examples as any);\n    }\n\n    // Apply instruction if available (via program options)\n    if (this.instruction) {\n      // Store instruction in program options for use in prompt generation\n      (program as any)._optimizedInstruction = this.instruction;\n    }\n\n    // Apply model config if available (stored for use in forward calls)\n    if (this.modelConfig) {\n      (program as any)._optimizedModelConfig = this.modelConfig;\n    }\n  }\n}\n\n// Pareto optimization result for multi-objective optimization\nexport interface AxParetoResult<OUT = any> extends AxOptimizerResult<OUT> {\n  paretoFront: ReadonlyArray<{\n    demos: readonly AxProgramDemos<any, OUT>[];\n    scores: Readonly<Record<string, number>>;\n    configuration: Readonly<Record<string, unknown>>;\n    dominatedSolutions: number;\n  }>;\n\n  // Multi-objective specific stats\n  hypervolume?: number;\n  paretoFrontSize: number;\n  convergenceMetrics?: Record<string, number>;\n}\n\n// AxCompileOptions moved to ./common_types.ts\n\n// Enhanced base optimizer interface\nexport interface AxOptimizer {\n  /**\n   * Optimize a program using the provided metric function\n   * @param program The program to optimize\n   * @param examples Training examples (typed based on the program) - will be auto-split into train/validation\n   * @param metricFn Evaluation metric function to assess program performance\n   * @param options Optional configuration options\n   * @returns Optimization result containing demos, stats, and configuration\n   */\n  compile<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>,\n    examples: readonly AxTypedExample<IN>[],\n    metricFn: AxMetricFn,\n    options?: AxCompileOptions\n  ): Promise<AxOptimizerResult<OUT>>;\n\n  /**\n   * Optimize a program with real-time streaming updates\n   * @param program The program to optimize\n   * @param examples Training examples\n   * @param metricFn Evaluation metric function\n   * @param options Optional configuration options\n   * @returns Async iterator yielding optimization progress\n   */\n  compileStream?<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>,\n    examples: readonly AxTypedExample<IN>[],\n    metricFn: AxMetricFn,\n    options?: AxCompileOptions\n  ): AsyncIterableIterator<AxOptimizationProgress>;\n\n  /**\n   * Multi-objective optimization using Pareto frontier\n   * @param program The program to optimize\n   * @param examples Training examples\n   * @param metricFn Multi-objective metric function\n   * @param options Optional configuration options\n   * @returns Pareto optimization result\n   */\n  compilePareto?<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>,\n    examples: readonly AxTypedExample<IN>[],\n    metricFn: AxMultiMetricFn,\n    options?: AxCompileOptions\n  ): Promise<AxParetoResult<OUT>>;\n\n  /**\n   * Get current optimization statistics\n   * @returns Current optimization statistics\n   */\n  getStats(): AxOptimizationStats;\n\n  /**\n   * Cancel ongoing optimization gracefully\n   * @returns Promise that resolves when cancellation is complete\n   */\n  cancel?(): Promise<void>;\n\n  /**\n   * Reset optimizer state for reuse with different programs\n   */\n  reset?(): void;\n\n  /**\n   * Get optimizer-specific configuration\n   * @returns Current optimizer configuration\n   */\n  getConfiguration?(): Record<string, unknown>;\n\n  /**\n   * Update optimizer configuration\n   * @param config New configuration to merge with existing\n   */\n  updateConfiguration?(config: Readonly<Record<string, unknown>>): void;\n\n  /**\n   * Validate that the optimizer can handle the given program\n   * @param program Program to validate\n   * @returns Validation result with any issues found\n   */\n  validateProgram?<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>\n  ): {\n    isValid: boolean;\n    issues: string[];\n    suggestions: string[];\n  };\n}\n\n// Specific optimizer options interfaces\n\nexport interface AxBootstrapOptimizerOptions {\n  maxRounds?: number;\n  maxExamples?: number;\n  maxDemos?: number;\n  batchSize?: number;\n  earlyStoppingPatience?: number;\n  teacherAI?: AxAIService;\n  costMonitoring?: boolean;\n  maxTokensPerGeneration?: number;\n  verboseMode?: boolean;\n  debugMode?: boolean;\n\n  // Enhanced options\n  adaptiveBatching?: boolean;\n  dynamicTemperature?: boolean;\n  qualityThreshold?: number;\n  diversityWeight?: number;\n}\n\nexport interface AxMiPROOptimizerOptions {\n  numCandidates?: number;\n  initTemperature?: number;\n  maxBootstrappedDemos?: number;\n  maxLabeledDemos?: number;\n  numTrials?: number;\n  minibatch?: boolean;\n  minibatchSize?: number;\n  minibatchFullEvalSteps?: number;\n  programAwareProposer?: boolean;\n  dataAwareProposer?: boolean;\n  viewDataBatchSize?: number;\n  tipAwareProposer?: boolean;\n  fewshotAwareProposer?: boolean;\n  verbose?: boolean;\n  earlyStoppingTrials?: number;\n  minImprovementThreshold?: number;\n\n  // Enhanced options\n  bayesianOptimization?: boolean;\n  acquisitionFunction?:\n    | 'expected_improvement'\n    | 'upper_confidence_bound'\n    | 'probability_improvement';\n  explorationWeight?: number;\n\n  // New option: number of samples to generate per forward call for self-consistency\n  sampleCount?: number;\n}\n\n// Default cost tracker implementation\nexport class AxDefaultCostTracker implements AxCostTracker {\n  private tokenUsage: Record<string, number> = {};\n  private totalTokens = 0;\n\n  // Configuration options\n  private readonly costPerModel: Record<string, number>;\n  private readonly maxCost?: number;\n  private readonly maxTokens?: number;\n\n  constructor(options?: AxCostTrackerOptions) {\n    this.costPerModel = options?.costPerModel ?? {};\n    this.maxCost = options?.maxCost;\n    this.maxTokens = options?.maxTokens;\n  }\n\n  trackTokens(count: number, model: string): void {\n    this.tokenUsage[model] = (this.tokenUsage[model] || 0) + count;\n    this.totalTokens += count;\n  }\n\n  getCurrentCost(): number {\n    // Calculate cost on-demand\n    let totalCost = 0;\n    for (const [model, tokens] of Object.entries(this.tokenUsage)) {\n      const costPer1K = this.costPerModel[model] || 0.001; // Default fallback\n      totalCost += (tokens / 1000) * costPer1K;\n    }\n    return totalCost;\n  }\n\n  getTokenUsage(): Record<string, number> {\n    return { ...this.tokenUsage };\n  }\n\n  getTotalTokens(): number {\n    return this.totalTokens;\n  }\n\n  isLimitReached(): boolean {\n    // Check token limit if configured\n    if (this.maxTokens !== undefined && this.totalTokens >= this.maxTokens) {\n      return true;\n    }\n\n    // Check cost limit if configured (calculate cost on-demand)\n    if (this.maxCost !== undefined) {\n      const currentCost = this.getCurrentCost();\n      if (currentCost >= this.maxCost) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  reset(): void {\n    this.tokenUsage = {};\n    this.totalTokens = 0;\n  }\n}\n\n/**\n * Abstract base class for optimizers that provides common functionality\n * and standardized handling of AxOptimizerArgs\n */\nexport abstract class AxBaseOptimizer implements AxOptimizer {\n  // Common AxOptimizerArgs fields\n  protected readonly studentAI: AxAIService;\n  protected readonly teacherAI?: AxAIService;\n  protected readonly targetScore?: number;\n  protected readonly minSuccessRate?: number;\n  protected readonly onProgress?: (\n    progress: Readonly<AxOptimizationProgress>\n  ) => void;\n  protected readonly onEarlyStop?: (\n    reason: string,\n    stats: Readonly<AxOptimizationStats>\n  ) => void;\n  protected readonly costTracker?: AxCostTracker;\n  protected readonly seed?: number;\n\n  // Checkpointing fields\n  protected readonly checkpointSave?: AxCheckpointSaveFn;\n  protected readonly checkpointLoad?: AxCheckpointLoadFn;\n  protected readonly checkpointInterval?: number;\n  protected readonly resumeFromCheckpoint?: string;\n\n  // Logging fields\n  protected readonly logger?: AxLoggerFunction;\n  protected readonly verbose?: boolean;\n\n  // Optimizer logging\n  protected readonly debugOptimizer: boolean;\n  protected readonly optimizerLogger?: AxOptimizerLoggerFunction;\n\n  // Checkpoint state\n  protected currentRound = 0;\n  private scoreHistory: number[] = [];\n  private configurationHistory: Record<string, unknown>[] = [];\n\n  // Common optimization statistics\n  protected stats: AxOptimizationStats;\n\n  // Metrics instruments\n  protected readonly metricsInstruments?: AxOptimizerMetricsInstruments;\n\n  // Result explanation generator\n  // FIXME: Disabled due to circular dependency - private resultExplainer?: ReturnType<typeof ax>;\n  private resultExplainer?: any;\n\n  constructor(args: Readonly<AxOptimizerArgs>) {\n    // Set common fields from AxOptimizerArgs\n    this.studentAI = args.studentAI;\n    this.teacherAI = args.teacherAI;\n    this.targetScore = args.targetScore;\n    this.minSuccessRate = args.minSuccessRate;\n    this.onProgress = args.onProgress;\n    this.onEarlyStop = args.onEarlyStop;\n    this.seed = args.seed;\n\n    // Set up checkpointing\n    this.checkpointSave = args.checkpointSave;\n    this.checkpointLoad = args.checkpointLoad;\n    this.checkpointInterval = args.checkpointInterval ?? 10; // Default: checkpoint every 10 rounds\n    this.resumeFromCheckpoint = args.resumeFromCheckpoint;\n\n    // Set up logging\n    this.logger = args.logger;\n    this.verbose = args.verbose;\n\n    // Set up cost tracker with default if not provided\n    const costTracker = new AxDefaultCostTracker({\n      maxTokens: 1000000,\n    });\n    this.costTracker = args.costTracker ?? costTracker;\n\n    // Initialize metrics instruments\n    this.metricsInstruments = getOrCreateOptimizerMetricsInstruments(\n      axGlobals.meter\n    );\n\n    // Initialize common stats structure\n    this.stats = this.initializeStats();\n\n    // Set up optimizer logging\n    this.debugOptimizer = args.debugOptimizer ?? false;\n    this.optimizerLogger =\n      args.optimizerLogger ??\n      (this.verbose ? axDefaultOptimizerLogger : undefined);\n\n    // Initialize result explanation generator\n    this.initializeResultExplainer();\n  }\n\n  /**\n   * Initialize the result explanation generator\n   * FIXME: Disabled due to circular dependency with ax() function\n   */\n  private initializeResultExplainer(): void {\n    // FIXME: Circular dependency - cannot import ax() from index.js\n    this.resultExplainer = undefined;\n    /*\n    try {\n      this.resultExplainer = ax(`\n        optimizationScore:number \"Final optimization score (0.0 to 1.0)\",\n        bestConfiguration:json \"Best configuration found during optimization\",\n        totalRounds:number \"Number of optimization rounds completed\",\n        converged:boolean \"Whether optimization converged to a stable solution\",\n        earlyStoppedReason?:string \"Reason for early stopping if applicable\",\n        resourcesUsed:json \"Tokens, time, and cost consumed during optimization\" ->\n        humanExplanation:string \"Clear, jargon-free explanation of optimization results for humans\",\n        recommendations:string[] \"Actionable recommendations based on the results\",\n        performanceAssessment:string \"Assessment of how well the optimization performed\"\n      `);\n    } catch (error) {\n      // If ax generator initialization fails, continue without it\n      this.resultExplainer = undefined;\n      if (this.verbose) {\n        console.warn(\n          '[AxBaseOptimizer] Failed to initialize result explainer:',\n          error\n        );\n      }\n    }\n    */\n  }\n\n  /**\n   * Initialize the optimization statistics structure\n   */\n  protected initializeStats(): AxOptimizationStats {\n    return {\n      totalCalls: 0,\n      successfulDemos: 0,\n      estimatedTokenUsage: 0,\n      earlyStopped: false,\n      resourceUsage: {\n        totalTokens: 0,\n        totalTime: 0,\n        avgLatencyPerEval: 0,\n        costByModel: {},\n      },\n      convergenceInfo: {\n        converged: false,\n        finalImprovement: 0,\n        stagnationRounds: 0,\n        convergenceThreshold: 0.01,\n      },\n      bestScore: 0,\n      bestConfiguration: {},\n    };\n  }\n\n  /**\n   * Set up reproducible random seed if provided\n   */\n  protected setupRandomSeed(): void {\n    if (this.seed !== undefined) {\n      // Note: For full reproducibility, we'd need a proper PRNG\n      Math.random = (() => {\n        let seed = this.seed!;\n        return () => {\n          seed = (seed * 9301 + 49297) % 233280;\n          return seed / 233280;\n        };\n      })();\n    }\n  }\n\n  /**\n   * Check if optimization should stop early due to cost limits\n   */\n  protected checkCostLimits(): boolean {\n    return this.costTracker?.isLimitReached() ?? false;\n  }\n\n  /**\n   * Check if target score has been reached\n   */\n  protected checkTargetScore(currentScore: number): boolean {\n    return this.targetScore !== undefined && currentScore >= this.targetScore;\n  }\n\n  /**\n   * Update resource usage statistics\n   */\n  protected updateResourceUsage(startTime: number, tokensUsed = 0): void {\n    this.stats.resourceUsage.totalTime = Date.now() - startTime;\n    this.stats.resourceUsage.totalTokens += tokensUsed;\n\n    if (this.stats.totalCalls > 0) {\n      this.stats.resourceUsage.avgLatencyPerEval =\n        this.stats.resourceUsage.totalTime / this.stats.totalCalls;\n    }\n  }\n\n  /**\n   * Trigger early stopping with appropriate callbacks\n   */\n  protected triggerEarlyStopping(reason: string, bestScoreRound: number): void {\n    this.stats.earlyStopped = true;\n    this.stats.earlyStopping = {\n      bestScoreRound,\n      patienceExhausted: reason.includes('improvement'),\n      reason,\n    };\n\n    // Record early stopping metrics (use a default optimizer type)\n    this.recordEarlyStoppingMetrics(reason, 'unknown');\n\n    if (this.onEarlyStop) {\n      this.onEarlyStop(reason, this.stats);\n    }\n    const optLogger = this.getOptimizerLogger();\n    optLogger?.({\n      name: 'EarlyStopping',\n      value: {\n        reason,\n        finalScore: this.stats.bestScore ?? 0,\n        round: bestScoreRound,\n      },\n    });\n  }\n\n  /**\n   * Validate that examples meet minimum requirements for optimization\n   * @param examples Examples to validate\n   * @param requireSplit Whether this optimizer requires train/validation split (default: true)\n   * @throws Error if examples don't meet minimum requirements\n   */\n  protected validateExamples<IN>(\n    examples: readonly AxTypedExample<IN>[],\n    requireSplit = true\n  ): void {\n    if (!examples || examples.length === 0) {\n      throw new Error('At least 1 example is required for optimization');\n    }\n\n    if (requireSplit) {\n      // For auto-splitting optimizers, we need at least 2 examples\n      // (1 for training, 1 for validation)\n      if (examples.length < 2) {\n        throw new Error(\n          'At least 2 examples are required for optimization with auto-splitting. ' +\n            'Provide more examples to enable proper train/validation split.'\n        );\n      }\n    }\n\n    // Warn if very few examples\n    const recommendedMin = requireSplit ? 10 : 5;\n    if (examples.length < recommendedMin && this.verbose) {\n      console.warn(\n        `[Ax Optimizer] Warning: Only ${examples.length} examples provided. Consider providing more examples (${recommendedMin}+ recommended) for better optimization results.`\n      );\n    }\n  }\n\n  /**\n   * Get the AI service to use for a specific task, preferring teacher when available\n   * @param preferTeacher Whether to prefer teacher AI over student AI\n   * @param options Optional compile options that may override teacher AI\n   * @returns The appropriate AI service to use\n   */\n  protected getAIService(\n    preferTeacher = false,\n    options?: AxCompileOptions\n  ): AxAIService {\n    // Check for override teacher AI first\n    if (preferTeacher && options?.overrideTeacherAI) {\n      return options.overrideTeacherAI;\n    }\n\n    // Then check for configured teacher AI\n    if (preferTeacher && this.teacherAI) {\n      return this.teacherAI;\n    }\n\n    return this.studentAI;\n  }\n\n  /**\n   * Check if teacher AI is available (including overrides)\n   * @param options Optional compile options that may override teacher AI\n   * @returns True if teacher AI is configured or overridden\n   */\n  protected hasTeacherAI(options?: AxCompileOptions): boolean {\n    return (\n      options?.overrideTeacherAI !== undefined || this.teacherAI !== undefined\n    );\n  }\n\n  /**\n   * Get teacher AI if available, otherwise return student AI\n   * @param options Optional compile options that may override teacher AI\n   * @returns Teacher AI if available, otherwise student AI\n   */\n  protected getTeacherOrStudentAI(options?: AxCompileOptions): AxAIService {\n    return options?.overrideTeacherAI || this.teacherAI || this.studentAI;\n  }\n\n  /**\n   * Execute a task with teacher AI if available, otherwise use student AI\n   * @param task Function that takes an AI service and returns a promise\n   * @param preferTeacher Whether to prefer teacher AI (default: true)\n   * @param options Optional compile options that may override teacher AI\n   * @returns Result of the task execution\n   */\n  protected async executeWithTeacher<T>(\n    task: (ai: AxAIService) => Promise<T>,\n    preferTeacher = true,\n    options?: AxCompileOptions\n  ): Promise<T> {\n    const ai = this.getAIService(preferTeacher, options);\n    return await task(ai);\n  }\n\n  /**\n   * Abstract method that must be implemented by concrete optimizers\n   */\n  public abstract compile<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>,\n    examples: readonly AxTypedExample<IN>[],\n    metricFn: AxMetricFn,\n    options?: AxCompileOptions\n  ): Promise<AxOptimizerResult<OUT>>;\n\n  /**\n   * Optimize a program with real-time streaming updates\n   * @param program The program to optimize\n   * @param examples Training examples\n   * @param metricFn Evaluation metric function\n   * @param options Optional configuration options\n   * @returns Async iterator yielding optimization progress\n   */\n  public async *compileStream<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>,\n    examples: readonly AxTypedExample<IN>[],\n    metricFn: AxMetricFn,\n    options?: AxCompileOptions\n  ): AsyncIterableIterator<AxOptimizationProgress> {\n    const startTime = Date.now();\n    const optimizerType = this.constructor.name;\n    const programSignature = program.getSignature().toString();\n\n    this.recordOptimizationStart(optimizerType, programSignature);\n\n    let earlyStopReason: string | undefined;\n\n    const updateProgress = (\n      round: number,\n      score: number,\n      configuration: Record<string, unknown>,\n      optimizerType: string,\n      optimizerConfig: Record<string, unknown>,\n      bestScore: number,\n      bestConfiguration: Record<string, unknown> | undefined,\n      optimizerState: Record<string, unknown> = {},\n      options?: AxCompileOptions\n    ) => {\n      const optLogger = this.getOptimizerLogger(options);\n      optLogger?.({\n        name: 'RoundProgress',\n        value: {\n          round,\n          totalRounds: options?.maxIterations ?? 0,\n          currentScore: score,\n          bestScore,\n          configuration,\n        },\n      });\n      this.updateOptimizationProgress(\n        round,\n        score,\n        configuration,\n        optimizerType,\n        optimizerConfig,\n        bestScore,\n        bestConfiguration,\n        optimizerState,\n        options\n      );\n    };\n\n    const onEarlyStop = (\n      reason: string,\n      _stats: Readonly<AxOptimizationStats>\n    ) => {\n      earlyStopReason = reason;\n      this.triggerEarlyStopping(reason, this.currentRound);\n    };\n\n    const onProgress = (progress: Readonly<AxOptimizationProgress>) => {\n      this.onProgress?.(progress);\n      updateProgress(\n        progress.round,\n        progress.currentScore,\n        progress.currentConfiguration || {},\n        optimizerType,\n        {}, // No optimizerConfig here, it's part of the progress object\n        progress.bestScore,\n        progress.bestConfiguration,\n        progress.convergenceInfo,\n        options\n      );\n    };\n\n    const compileResult = await this.compile(program, examples, metricFn, {\n      ...options,\n      overrideOnProgress: onProgress,\n      overrideOnEarlyStop: onEarlyStop,\n    });\n\n    const duration = Date.now() - startTime;\n    this.recordOptimizationComplete(\n      duration,\n      true,\n      optimizerType,\n      programSignature\n    );\n\n    if (earlyStopReason) {\n      this.getLogger(options)?.({\n        name: 'Notification',\n        id: 'optimization_early_stop',\n        value: `Optimization stopped early due to ${earlyStopReason}`,\n      });\n    }\n\n    return {\n      demos: compileResult.demos,\n      stats: compileResult.stats,\n      bestScore: compileResult.bestScore,\n      finalConfiguration: compileResult.finalConfiguration,\n      scoreHistory: compileResult.scoreHistory,\n      configurationHistory: compileResult.configurationHistory,\n    };\n  }\n\n  /**\n   * Multi-objective optimization using Pareto frontier\n   * Default implementation that leverages the single-objective compile method\n   * @param program The program to optimize\n   * @param examples Training examples\n   * @param metricFn Multi-objective metric function that returns multiple scores\n   * @param options Optional configuration options\n   * @returns Pareto optimization result with frontier of non-dominated solutions\n   */\n  public async compilePareto<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>,\n    examples: readonly AxTypedExample<IN>[],\n    metricFn: AxMultiMetricFn,\n    options?: AxCompileOptions\n  ): Promise<AxParetoResult<OUT>> {\n    const _optimizerType = this.constructor.name;\n    const startTime = Date.now();\n\n    // Strategy 1: Generate different weighted combinations of objectives\n    const solutions = await this.generateWeightedSolutions(\n      program,\n      examples,\n      metricFn,\n      options\n    );\n\n    // Strategy 2: Generate constraint-based solutions (optimize one objective while constraining others)\n    const constraintSolutions = await this.generateConstraintSolutions(\n      program,\n      examples,\n      metricFn,\n      options\n    );\n\n    // Combine all solutions\n    const allSolutions = [...solutions, ...constraintSolutions];\n\n    // if (options?.verbose) {\n    //   this.getLogger(options)?.(\n    //     `Generated ${allSolutions.length} candidate solutions`,\n    //     { tags: ['discovery'] }\n    //   );\n    // }\n\n    // Find Pareto frontier\n    const paretoFront = this.findParetoFrontier(allSolutions);\n\n    // Calculate hypervolume if possible\n    const hypervolume = this.calculateHypervolume(paretoFront);\n\n    // if (options?.verbose) {\n    //   this.getLogger(options)?.(\n    //     `Found ${paretoFront.length} non-dominated solutions`,\n    //     { tags: ['discovery'] }\n    //   );\n    //   this.getLogger(options)?.(\n    //     `Hypervolume: ${hypervolume?.toFixed(4) || 'N/A'}`,\n    //     { tags: ['discovery'] }\n    //   );\n    // }\n\n    // Update stats\n    this.updateResourceUsage(startTime);\n    this.stats.convergenceInfo.converged = true;\n\n    // Record Pareto optimization metrics\n    this.recordParetoMetrics(\n      paretoFront.length,\n      allSolutions.length,\n      'base_optimizer',\n      hypervolume\n    );\n\n    // Calculate best score as the maximum across all objectives and solutions\n    const bestScore =\n      paretoFront.length > 0\n        ? Math.max(\n            ...paretoFront.map((sol) => Math.max(...Object.values(sol.scores)))\n          )\n        : 0;\n\n    return {\n      demos: paretoFront.length > 0 ? [...paretoFront[0]!.demos] : undefined,\n      stats: this.stats,\n      bestScore,\n      paretoFront,\n      hypervolume,\n      paretoFrontSize: paretoFront.length,\n      finalConfiguration: {\n        paretoFrontSize: paretoFront.length,\n        hypervolume,\n        strategy: 'weighted_combinations_and_constraints',\n        numSolutions: allSolutions.length,\n      },\n    };\n  }\n\n  /**\n   * Generate solutions using different weighted combinations of objectives\n   */\n  private async generateWeightedSolutions<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>,\n    examples: readonly AxTypedExample<IN>[],\n    metricFn: AxMultiMetricFn,\n    options?: AxCompileOptions\n  ): Promise<\n    Array<{\n      scores: Record<string, number>;\n      demos?: AxProgramDemos<any, OUT>[];\n      configuration: Record<string, unknown>;\n    }>\n  > {\n    const solutions: Array<{\n      scores: Record<string, number>;\n      demos?: AxProgramDemos<any, OUT>[];\n      configuration: Record<string, unknown>;\n    }> = [];\n\n    // First, determine the objectives by running the metric on a sample\n    if (!examples || examples.length === 0) {\n      throw new Error('No examples provided for Pareto optimization');\n    }\n    const sampleExample = examples[0]!;\n    const samplePrediction = await program.forward(\n      this.getAIService(false, options),\n      sampleExample as any\n    );\n    const sampleScores = await metricFn({\n      prediction: samplePrediction,\n      example: sampleExample,\n    });\n    const objectives = Object.keys(sampleScores);\n\n    // if (options?.verbose) {\n    //   this.getLogger(options)?.(\n    //     `Detected objectives: ${objectives.join(', ')}`,\n    //     { tags: ['discovery'] }\n    //   );\n    // }\n\n    // Generate different weight combinations\n    const weightCombinations = this.generateWeightCombinations(objectives);\n\n    for (let i = 0; i < weightCombinations.length; i++) {\n      const weights = weightCombinations[i]!;\n\n      // if (options?.verbose) {\n      //   this.getLogger(options)?.(\n      //     `Optimizing with weights: ${JSON.stringify(weights)}`,\n      //     { tags: ['discovery'] }\n      //   );\n      // }\n\n      // Create a weighted single-objective metric\n      const weightedMetric: AxMetricFn = async ({ prediction, example }) => {\n        const scores = await metricFn({ prediction, example });\n        let weightedScore = 0;\n        for (const [objective, score] of Object.entries(scores)) {\n          weightedScore += score * (weights[objective] || 0);\n        }\n        return weightedScore;\n      };\n\n      try {\n        // Use the concrete optimizer's compile method\n        const result = await this.compile(program, examples, weightedMetric, {\n          ...options,\n          verbose: false, // Suppress inner optimization logs\n        });\n\n        // Evaluate the result with the multi-objective metric\n        const scores = await this.evaluateWithMultiObjective(\n          program,\n          result,\n          metricFn,\n          examples\n        );\n\n        solutions.push({\n          scores,\n          demos: result.demos,\n          configuration: {\n            ...result.finalConfiguration,\n            weights,\n            strategy: 'weighted_combination',\n          },\n        });\n      } catch (_error) {\n        // if (options?.verbose) {\n        //   this.getLogger(options)?.(\n        //     `Failed optimization with weights ${JSON.stringify(weights)}: ${error}`,\n        //     { tags: ['warning'] }\n        //   );\n        // }\n      }\n    }\n\n    return solutions;\n  }\n\n  /**\n   * Generate solutions using constraint-based optimization\n   */\n  private async generateConstraintSolutions<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>,\n    examples: readonly AxTypedExample<IN>[],\n    metricFn: AxMultiMetricFn,\n    options?: AxCompileOptions\n  ): Promise<\n    Array<{\n      scores: Record<string, number>;\n      demos?: AxProgramDemos<any, OUT>[];\n      configuration: Record<string, unknown>;\n    }>\n  > {\n    const solutions: Array<{\n      scores: Record<string, number>;\n      demos?: AxProgramDemos<any, OUT>[];\n      configuration: Record<string, unknown>;\n    }> = [];\n\n    // Get objectives from a sample evaluation\n    if (!examples || examples.length === 0) {\n      throw new Error('No examples provided for multi-objective optimization');\n    }\n    const sampleExample = examples[0]!;\n    const samplePrediction = await program.forward(\n      this.getAIService(false, options),\n      sampleExample as any\n    );\n    const sampleScores = await metricFn({\n      prediction: samplePrediction,\n      example: sampleExample,\n    });\n    const objectives = Object.keys(sampleScores);\n\n    // For each objective, optimize it while constraining others\n    for (const primaryObjective of objectives) {\n      // if (options?.verbose) {\n      //   this.getLogger(options)?.(\n      //     `Optimizing ${primaryObjective} with constraints on other objectives`,\n      //     { tags: ['discovery'] }\n      //   );\n      // }\n\n      // Create a constraint-based metric\n      const constraintMetric: AxMetricFn = async ({ prediction, example }) => {\n        const scores = await metricFn({ prediction, example });\n\n        // Primary objective score\n        const primaryScore = scores[primaryObjective] || 0;\n\n        // Penalty for violating constraints on other objectives\n        let penalty = 0;\n        for (const [objective, score] of Object.entries(scores)) {\n          if (objective !== primaryObjective) {\n            // Simple constraint: other objectives should be at least 0.3\n            // This is a heuristic - in practice you'd set domain-specific thresholds\n            if (score < 0.3) {\n              penalty += (0.3 - score) * 2; // Penalty factor\n            }\n          }\n        }\n\n        return primaryScore - penalty;\n      };\n\n      try {\n        const result = await this.compile(program, examples, constraintMetric, {\n          ...options,\n          verbose: false,\n        });\n\n        const scores = await this.evaluateWithMultiObjective(\n          program,\n          result,\n          metricFn,\n          examples\n        );\n\n        solutions.push({\n          scores,\n          demos: result.demos,\n          configuration: {\n            ...result.finalConfiguration,\n            primaryObjective,\n            strategy: 'constraint_based',\n          },\n        });\n      } catch (_error) {\n        // if (options?.verbose) {\n        //   this.getLogger(options)?.(\n        //     `Failed constraint optimization for ${primaryObjective}: ${error}`,\n        //     { tags: ['warning'] }\n        //   );\n        // }\n      }\n    }\n\n    return solutions;\n  }\n\n  /**\n   * Generate different weight combinations for objectives\n   */\n  private generateWeightCombinations(\n    objectives: string[]\n  ): Record<string, number>[] {\n    const combinations: Record<string, number>[] = [];\n\n    // Single-objective focus (one objective gets weight 1, others get 0)\n    for (const objective of objectives) {\n      const weights: Record<string, number> = {};\n      for (const obj of objectives) {\n        weights[obj] = obj === objective ? 1 : 0;\n      }\n      combinations.push(weights);\n    }\n\n    // Equal weights\n    const equalWeights: Record<string, number> = {};\n    for (const objective of objectives) {\n      equalWeights[objective] = 1 / objectives.length;\n    }\n    combinations.push(equalWeights);\n\n    // If we have 2 objectives, generate more granular combinations\n    if (objectives.length === 2) {\n      const [obj1, obj2] = objectives;\n      for (let w1 = 0.1; w1 <= 0.9; w1 += 0.2) {\n        const w2 = 1 - w1;\n        combinations.push({ [obj1!]: w1, [obj2!]: w2 });\n      }\n    }\n\n    // If we have 3 objectives, generate some key combinations\n    if (objectives.length === 3) {\n      const [obj1, obj2, obj3] = objectives;\n      combinations.push(\n        { [obj1!]: 0.5, [obj2!]: 0.3, [obj3!]: 0.2 },\n        { [obj1!]: 0.3, [obj2!]: 0.5, [obj3!]: 0.2 },\n        { [obj1!]: 0.2, [obj2!]: 0.3, [obj3!]: 0.5 }\n      );\n    }\n\n    return combinations;\n  }\n\n  /**\n   * Evaluate a single-objective result with multi-objective metrics\n   */\n  private async evaluateWithMultiObjective<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>,\n    result: Readonly<AxOptimizerResult<OUT>>,\n    metricFn: AxMultiMetricFn,\n    examples: readonly AxTypedExample<IN>[]\n  ): Promise<Record<string, number>> {\n    const testProgram = new AxGen(program.getSignature());\n    if (result.demos) {\n      testProgram.setDemos(result.demos);\n    }\n\n    // NOTE: This evaluation method needs examples to be passed as parameter\n    // For now, returning empty predictions array\n    const _predictions: { prediction: OUT; example: any }[] = [];\n    // for (const ex of examples) {\n    //   const prediction = await testProgram.forward(this.studentAI, ex as IN);\n    //   predictions.push({ prediction, example: ex });\n    // }\n\n    // Create validation split from examples (use last 20% or max 5 examples)\n    const valSplitSize = Math.max(\n      1,\n      Math.min(5, Math.floor(examples.length * 0.2))\n    );\n    const valSet = examples.slice(-valSplitSize);\n    const allScores: Record<string, number[]> = {};\n\n    // Evaluate on validation set\n    const evalSet = valSet;\n\n    for (const example of evalSet) {\n      try {\n        const prediction = await testProgram.forward(\n          this.studentAI,\n          example as IN\n        );\n        const scores = await metricFn({ prediction, example });\n\n        // Collect scores for each objective\n        for (const [objective, score] of Object.entries(scores)) {\n          if (!allScores[objective]) {\n            allScores[objective] = [];\n          }\n          allScores[objective]!.push(score);\n        }\n      } catch {}\n    }\n\n    // Calculate average scores for each objective\n    const avgScores: Record<string, number> = {};\n    for (const [objective, scores] of Object.entries(allScores)) {\n      avgScores[objective] =\n        scores.length > 0\n          ? scores.reduce((sum, score) => sum + score, 0) / scores.length\n          : 0;\n    }\n\n    return avgScores;\n  }\n\n  /**\n   * Find the Pareto frontier from a set of solutions\n   */\n  private findParetoFrontier<OUT extends AxGenOut>(\n    solutions: Array<{\n      scores: Record<string, number>;\n      demos?: AxProgramDemos<any, OUT>[];\n      configuration: Record<string, unknown>;\n    }>\n  ): Array<{\n    demos: readonly AxProgramDemos<any, OUT>[];\n    scores: Readonly<Record<string, number>>;\n    configuration: Readonly<Record<string, unknown>>;\n    dominatedSolutions: number;\n  }> {\n    const paretoFront: Array<{\n      demos: readonly AxProgramDemos<any, OUT>[];\n      scores: Readonly<Record<string, number>>;\n      configuration: Readonly<Record<string, unknown>>;\n      dominatedSolutions: number;\n    }> = [];\n\n    // For each solution, check if it's dominated by any other solution\n    for (let i = 0; i < solutions.length; i++) {\n      const solutionA = solutions[i]!;\n      let isDominated = false;\n      let dominatedCount = 0;\n\n      for (let j = 0; j < solutions.length; j++) {\n        if (i === j) continue;\n\n        const solutionB = solutions[j]!;\n\n        // Check if B dominates A\n        if (this.dominates(solutionB.scores, solutionA.scores)) {\n          isDominated = true;\n          break;\n        }\n\n        // Count how many solutions A dominates\n        if (this.dominates(solutionA.scores, solutionB.scores)) {\n          dominatedCount++;\n        }\n      }\n\n      // If A is not dominated by any solution, it's on the Pareto frontier\n      if (!isDominated) {\n        paretoFront.push({\n          demos: solutionA.demos || [],\n          scores: solutionA.scores,\n          configuration: solutionA.configuration,\n          dominatedSolutions: dominatedCount,\n        });\n      }\n    }\n\n    return paretoFront;\n  }\n\n  /**\n   * Check if solution A dominates solution B\n   * A dominates B if A is better or equal in all objectives and strictly better in at least one\n   */\n  private dominates(\n    scoresA: Record<string, number>,\n    scoresB: Record<string, number>\n  ): boolean {\n    const objectives = Object.keys(scoresA);\n\n    // Check if A is at least as good as B in all objectives\n    let atLeastAsGood = true;\n    let strictlyBetter = false;\n\n    for (const objective of objectives) {\n      const scoreA = scoresA[objective] || 0;\n      const scoreB = scoresB[objective] || 0;\n\n      if (scoreA < scoreB) {\n        atLeastAsGood = false;\n        break;\n      }\n\n      if (scoreA > scoreB) {\n        strictlyBetter = true;\n      }\n    }\n\n    return atLeastAsGood && strictlyBetter;\n  }\n\n  /**\n   * Calculate hypervolume of the Pareto frontier\n   * Simplified implementation using reference point at origin\n   */\n  private calculateHypervolume(\n    paretoFront: Array<{\n      scores: Readonly<Record<string, number>>;\n    }>\n  ): number | undefined {\n    if (paretoFront.length === 0) return undefined;\n\n    // For simplicity, calculate 2D hypervolume if we have exactly 2 objectives\n    const firstSolution = paretoFront[0]!;\n    const objectives = Object.keys(firstSolution.scores);\n\n    if (objectives.length === 2) {\n      const [obj1, obj2] = objectives;\n      let hypervolume = 0;\n\n      // Sort solutions by first objective (descending)\n      const sortedSolutions = [...paretoFront].sort(\n        (a, b) => (b.scores[obj1!] || 0) - (a.scores[obj1!] || 0)\n      );\n\n      let prevScore2 = 0;\n      for (const solution of sortedSolutions) {\n        const score1 = solution.scores[obj1!] || 0;\n        const score2 = solution.scores[obj2!] || 0;\n\n        // Calculate area contribution\n        hypervolume += score1 * (score2 - prevScore2);\n        prevScore2 = Math.max(prevScore2, score2);\n      }\n\n      return hypervolume;\n    }\n\n    // For higher dimensions, return undefined (would need more complex algorithm)\n    return undefined;\n  }\n\n  /**\n   * Save current optimization state to checkpoint\n   */\n  protected async saveCheckpoint(\n    optimizerType: string,\n    optimizerConfig: Record<string, unknown>,\n    bestScore: number,\n    bestConfiguration?: Record<string, unknown>,\n    optimizerState: Record<string, unknown> = {},\n    options?: AxCompileOptions\n  ): Promise<string | undefined> {\n    const saveFn = options?.overrideCheckpointSave || this.checkpointSave;\n    if (!saveFn) return undefined;\n\n    const startTime = Date.now();\n    let success = false;\n    let checkpointId: string | undefined;\n\n    try {\n      const checkpoint: AxOptimizationCheckpoint = {\n        version: '1.0.0',\n        timestamp: Date.now(),\n        optimizerType,\n        optimizerConfig,\n        currentRound: this.currentRound,\n        totalRounds:\n          this.stats.resourceUsage.totalTime > 0 ? this.currentRound : 0,\n        bestScore,\n        bestConfiguration,\n        scoreHistory: [...this.scoreHistory],\n        configurationHistory: [...this.configurationHistory],\n        stats: { ...this.stats },\n        optimizerState,\n        examples: [], // examples now passed to compile\n      };\n\n      checkpointId = await saveFn(checkpoint);\n      success = true;\n    } catch (error) {\n      success = false;\n      throw error;\n    } finally {\n      const latency = Date.now() - startTime;\n      this.recordCheckpointMetrics('save', latency, success, optimizerType);\n    }\n\n    return checkpointId;\n  }\n\n  /**\n   * Load optimization state from checkpoint\n   */\n  protected async loadCheckpoint(\n    checkpointId: string,\n    options?: AxCompileOptions\n  ): Promise<AxOptimizationCheckpoint | null> {\n    const loadFn = options?.overrideCheckpointLoad || this.checkpointLoad;\n    if (!loadFn) return null;\n\n    const startTime = Date.now();\n    let success = false;\n    let checkpoint: AxOptimizationCheckpoint | null = null;\n\n    try {\n      checkpoint = await loadFn(checkpointId);\n      success = checkpoint !== null;\n    } catch (error) {\n      success = false;\n      throw error;\n    } finally {\n      const latency = Date.now() - startTime;\n      // Use a default optimizer type since we don't know it at load time\n      this.recordCheckpointMetrics('load', latency, success, 'unknown');\n    }\n\n    return checkpoint;\n  }\n\n  /**\n   * Restore optimizer state from checkpoint\n   */\n  protected restoreFromCheckpoint(\n    checkpoint: Readonly<AxOptimizationCheckpoint>\n  ): void {\n    this.currentRound = checkpoint.currentRound;\n    this.scoreHistory = [...checkpoint.scoreHistory];\n    this.configurationHistory = [...checkpoint.configurationHistory];\n    this.stats = { ...checkpoint.stats };\n  }\n\n  /**\n   * Check if checkpoint should be saved\n   */\n  protected shouldSaveCheckpoint(\n    round: number,\n    options?: AxCompileOptions\n  ): boolean {\n    const interval =\n      options?.overrideCheckpointInterval || this.checkpointInterval;\n    return interval !== undefined && round % interval === 0;\n  }\n\n  /**\n   * Update optimization progress and handle checkpointing\n   */\n  protected async updateOptimizationProgress(\n    round: number,\n    score: number,\n    configuration: Record<string, unknown>,\n    optimizerType: string,\n    optimizerConfig: Record<string, unknown>,\n    bestScore: number,\n    bestConfiguration?: Record<string, unknown>,\n    optimizerState: Record<string, unknown> = {},\n    options?: AxCompileOptions\n  ): Promise<void> {\n    this.currentRound = round;\n    this.scoreHistory.push(score);\n    this.configurationHistory.push(configuration);\n\n    // Save checkpoint if needed\n    if (this.shouldSaveCheckpoint(round, options)) {\n      await this.saveCheckpoint(\n        optimizerType,\n        optimizerConfig,\n        bestScore,\n        bestConfiguration,\n        optimizerState,\n        options\n      );\n    }\n    const optLogger = this.getOptimizerLogger(options);\n    optLogger?.({\n      name: 'RoundProgress',\n      value: {\n        round,\n        totalRounds: options?.maxIterations ?? 0,\n        currentScore: score,\n        bestScore,\n        configuration,\n      },\n    });\n  }\n\n  /**\n   * Save final checkpoint on completion\n   */\n  protected async saveFinalCheckpoint(\n    optimizerType: string,\n    optimizerConfig: Record<string, unknown>,\n    bestScore: number,\n    bestConfiguration?: Record<string, unknown>,\n    optimizerState: Record<string, unknown> = {},\n    options?: AxCompileOptions\n  ): Promise<void> {\n    if (options?.saveCheckpointOnComplete !== false) {\n      await this.saveCheckpoint(\n        optimizerType,\n        optimizerConfig,\n        bestScore,\n        bestConfiguration,\n        { ...optimizerState, final: true },\n        options\n      );\n    }\n  }\n\n  /**\n   * Get the logger function with fallback hierarchy:\n   * 1. Explicit logger passed to optimizer\n   * 2. Logger from student AI service\n   * 3. undefined if verbose is false\n   */\n  protected getLogger(\n    options?: AxCompileOptions\n  ): AxLoggerFunction | undefined {\n    // Check if logging should be disabled\n    const isVerbose = this.isLoggingEnabled(options);\n    if (!isVerbose) {\n      return undefined;\n    }\n\n    // Use explicit logger if provided\n    if (this.logger) {\n      return this.logger;\n    }\n\n    // Fall back to student AI logger\n    return this.studentAI.getLogger();\n  }\n\n  /**\n   * Check if logging is enabled based on verbose settings\n   */\n  protected isLoggingEnabled(options?: AxCompileOptions): boolean {\n    // Explicit verbose setting in options takes precedence\n    if (options?.verbose !== undefined) {\n      return options.verbose;\n    }\n\n    // Use optimizer's verbose setting\n    return this.verbose ?? true; // Default to true if not specified\n  }\n\n  /**\n   * Record optimization start metrics\n   */\n  protected recordOptimizationStart(\n    optimizerType: string,\n    programSignature?: string\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    // Record program complexity metrics\n    if (programSignature) {\n      // Extract field counts from signature (simplified)\n      const inputFields = (programSignature.match(/input:/g) || []).length;\n      const outputFields = (programSignature.match(/output:/g) || []).length;\n\n      recordProgramComplexityMetric(\n        this.metricsInstruments,\n        inputFields,\n        outputFields,\n        0, // this.examples.length - now in options\n        0, // this.getValidationSet().length - now in options\n        optimizerType\n      );\n    }\n\n    // Record configuration metrics\n    recordOptimizerConfigurationMetric(\n      this.metricsInstruments,\n      optimizerType,\n      this.targetScore,\n      undefined // maxRounds would be set by concrete optimizers\n    );\n  }\n\n  /**\n   * Record optimization completion metrics\n   */\n  protected recordOptimizationComplete(\n    duration: number,\n    success: boolean,\n    optimizerType: string,\n    programSignature?: string\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    recordOptimizationMetric(\n      this.metricsInstruments,\n      duration,\n      success,\n      optimizerType,\n      programSignature\n    );\n\n    recordOptimizationDurationMetric(\n      this.metricsInstruments,\n      duration,\n      optimizerType\n    );\n\n    // Record resource usage\n    const currentCost = this.costTracker?.getCurrentCost() ?? 0;\n    const totalTokens = this.costTracker?.getTotalTokens() ?? 0;\n    recordResourceUsageMetric(\n      this.metricsInstruments,\n      totalTokens,\n      currentCost,\n      optimizerType\n    );\n  }\n\n  /**\n   * Record convergence metrics\n   */\n  protected recordConvergenceMetrics(\n    rounds: number,\n    currentScore: number,\n    improvement: number,\n    stagnationRounds: number,\n    optimizerType: string\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    recordConvergenceMetric(\n      this.metricsInstruments,\n      rounds,\n      currentScore,\n      improvement,\n      stagnationRounds,\n      optimizerType\n    );\n  }\n\n  /**\n   * Record early stopping metrics\n   */\n  protected recordEarlyStoppingMetrics(\n    reason: string,\n    optimizerType: string\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    recordEarlyStoppingMetric(this.metricsInstruments, reason, optimizerType);\n  }\n\n  /**\n   * Record teacher-student interaction metrics\n   */\n  protected recordTeacherStudentMetrics(\n    latency: number,\n    scoreImprovement: number,\n    optimizerType: string\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    recordTeacherStudentMetric(\n      this.metricsInstruments,\n      latency,\n      scoreImprovement,\n      optimizerType\n    );\n  }\n\n  /**\n   * Record checkpoint metrics\n   */\n  protected recordCheckpointMetrics(\n    operation: 'save' | 'load',\n    latency: number,\n    success: boolean,\n    optimizerType: string\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    recordCheckpointMetric(\n      this.metricsInstruments,\n      operation,\n      latency,\n      success,\n      optimizerType\n    );\n  }\n\n  /**\n   * Record Pareto optimization metrics\n   */\n  protected recordParetoMetrics(\n    frontSize: number,\n    solutionsGenerated: number,\n    optimizerType: string,\n    hypervolume?: number\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    recordParetoMetric(\n      this.metricsInstruments,\n      frontSize,\n      solutionsGenerated,\n      optimizerType,\n      hypervolume\n    );\n  }\n\n  /**\n   * Record performance metrics\n   */\n  protected recordPerformanceMetrics(\n    metricType: 'evaluation' | 'demo_generation' | 'metric_computation',\n    duration: number,\n    optimizerType: string\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    recordOptimizerPerformanceMetric(\n      this.metricsInstruments,\n      metricType,\n      duration,\n      optimizerType\n    );\n  }\n\n  // Optimizer logging methods\n  protected isOptimizerLoggingEnabled(options?: AxCompileOptions): boolean {\n    return this.debugOptimizer || (options?.verbose ?? this.verbose ?? false);\n  }\n\n  protected getOptimizerLogger(\n    options?: AxCompileOptions\n  ): AxOptimizerLoggerFunction | undefined {\n    if (!this.isOptimizerLoggingEnabled(options)) return undefined;\n    return (\n      this.optimizerLogger ??\n      axGlobals.optimizerLogger ??\n      axDefaultOptimizerLogger\n    );\n  }\n\n  public getStats(): AxOptimizationStats {\n    return { ...this.stats };\n  }\n\n  protected async explainOptimizationResults(\n    bestScore: number,\n    bestConfiguration?: Record<string, unknown>,\n    _options?: AxCompileOptions\n  ): Promise<\n    | {\n        humanExplanation: string;\n        recommendations: string[];\n        performanceAssessment: string;\n      }\n    | undefined\n  > {\n    const converged = this.stats.convergenceInfo.converged;\n    const totalCalls = this.stats.totalCalls;\n    const successRate =\n      totalCalls > 0 ? (this.stats.successfulDemos / totalCalls) * 100 : 0;\n\n    const humanExplanation = `Optimization finished with best score ${bestScore.toFixed(3)}${\n      bestConfiguration\n        ? ` using configuration ${JSON.stringify(bestConfiguration)}`\n        : ''\n    }. Convergence: ${converged ? 'yes' : 'no'}. Success rate: ${successRate.toFixed(1)}%.`;\n\n    const recommendations: string[] = [];\n    if (!converged) {\n      recommendations.push(\n        'Increase numTrials or relax earlyStoppingTrials to allow further improvement.'\n      );\n    }\n    if (typeof this.targetScore === 'number' && bestScore < this.targetScore) {\n      recommendations.push(\n        'Tighten the metric or supply more/better-labeled examples to reach targetScore.'\n      );\n    }\n    if (\n      bestConfiguration &&\n      'bootstrappedDemos' in (bestConfiguration as any)\n    ) {\n      const demos = (bestConfiguration as any).bootstrappedDemos as number;\n      if (typeof demos === 'number' && demos === 0) {\n        recommendations.push(\n          'Consider allowing a small number of bootstrapped demos to boost performance.'\n        );\n      }\n    }\n    if (recommendations.length === 0) {\n      recommendations.push(\n        'Re-run with more trials or different acquisition settings to explore more of the space.'\n      );\n    }\n\n    const performanceAssessment = `Tokens used: ${this.stats.resourceUsage.totalTokens}, rounds: ${this.currentRound}, stagnationRounds: ${this.stats.convergenceInfo.stagnationRounds}.`;\n\n    return { humanExplanation, recommendations, performanceAssessment };\n  }\n  /**\n   * Log human-readable optimization completion message\n   */\n  protected async logOptimizationComplete(\n    optimizerType: string,\n    bestScore: number,\n    bestConfiguration?: Record<string, unknown>,\n    options?: AxCompileOptions,\n    explanation?: {\n      humanExplanation: string;\n      recommendations: string[];\n      performanceAssessment: string;\n    }\n  ): Promise<void> {\n    const optLogger = this.getOptimizerLogger(options);\n    if (!optLogger) return;\n\n    if (explanation) {\n      optLogger({\n        name: 'OptimizationComplete',\n        value: {\n          optimizerType,\n          bestScore,\n          bestConfiguration: bestConfiguration || {},\n          totalCalls: this.stats.totalCalls,\n          successRate:\n            this.stats.totalCalls > 0\n              ? `${((this.stats.successfulDemos / this.stats.totalCalls) * 100).toFixed(1)}%`\n              : 'N/A',\n          explanation: explanation.humanExplanation,\n          recommendations: explanation.recommendations,\n          performanceAssessment: explanation.performanceAssessment,\n          stats: this.stats,\n        },\n      });\n    } else {\n      // Fallback to basic completion logging\n      optLogger({\n        name: 'OptimizationComplete',\n        value: {\n          optimizerType,\n          bestScore,\n          bestConfiguration: bestConfiguration || {},\n          totalCalls: this.stats.totalCalls,\n          successRate:\n            this.stats.totalCalls > 0\n              ? `${((this.stats.successfulDemos / this.stats.totalCalls) * 100).toFixed(1)}%`\n              : 'N/A',\n          stats: this.stats,\n        },\n      });\n    }\n  }\n\n  public reset(): void {\n    this.stats = this.initializeStats();\n    this.costTracker?.reset();\n    this.currentRound = 0;\n    this.scoreHistory = [];\n    this.configurationHistory = [];\n  }\n}\n","import { AxGen } from './generate.js';\nimport { AxSignature } from './sig.js';\nimport type { ParseSignature } from './sigtypes.js';\nimport type { AxProgramForwardOptions } from './types.js';\n\n// Function for string-based type-safe signature creation\nexport function s<const T extends string>(\n  signature: T\n): AxSignature<ParseSignature<T>['inputs'], ParseSignature<T>['outputs']> {\n  return AxSignature.create(signature);\n}\n\n// Function for type-safe generator creation - supports both strings and AxSignature objects\nexport function ax<\n  const T extends string,\n  ThoughtKey extends string = 'thought',\n>(\n  signature: T,\n  options?: Readonly<\n    AxProgramForwardOptions<any> & { thoughtFieldName?: ThoughtKey }\n  >\n): AxGen<\n  ParseSignature<T>['inputs'],\n  ParseSignature<T>['outputs'] &\n    (string extends ThoughtKey\n      ? { thought?: string }\n      : { [P in ThoughtKey]?: string })\n>;\nexport function ax<\n  TInput extends Record<string, any>,\n  TOutput extends Record<string, any>,\n  ThoughtKey extends string = 'thought',\n>(\n  signature: AxSignature<TInput, TOutput>,\n  options?: Readonly<\n    AxProgramForwardOptions<any> & { thoughtFieldName?: ThoughtKey }\n  >\n): AxGen<\n  TInput,\n  TOutput &\n    (string extends ThoughtKey\n      ? { thought?: string }\n      : { [P in ThoughtKey]?: string })\n>;\nexport function ax<\n  T extends string | AxSignature<any, any>,\n  ThoughtKey extends string = 'thought',\n  TInput extends Record<string, any> = T extends string\n    ? ParseSignature<T>['inputs']\n    : T extends AxSignature<infer I, any>\n      ? I\n      : never,\n  TOutput extends Record<string, any> = T extends string\n    ? ParseSignature<T>['outputs']\n    : T extends AxSignature<any, infer O>\n      ? O\n      : never,\n>(\n  signature: T,\n  options?: Readonly<\n    AxProgramForwardOptions<any> & { thoughtFieldName?: ThoughtKey }\n  >\n): AxGen<\n  TInput,\n  TOutput &\n    (string extends ThoughtKey\n      ? { thought?: string }\n      : { [P in ThoughtKey]?: string })\n> {\n  const typedSignature =\n    typeof signature === 'string'\n      ? AxSignature.create(signature)\n      : (signature as AxSignature<TInput, TOutput>);\n  return new AxGen<\n    TInput,\n    TOutput &\n      (string extends ThoughtKey\n        ? { thought?: string }\n        : { [P in ThoughtKey]?: string })\n  >(typedSignature, options as any);\n}\n","import crypto from 'node:crypto';\n\nimport type {\n  AxACEBullet,\n  AxACECuratorOperation,\n  AxACEPlaybook,\n} from './aceTypes.js';\n\ninterface ApplyOperationsOptions {\n  maxSectionSize?: number;\n  allowDynamicSections?: boolean;\n  enableAutoPrune?: boolean;\n  protectedBulletIds?: ReadonlySet<string>;\n}\n\n/**\n * Create a fresh, empty playbook structure.\n */\nexport function createEmptyPlaybook(description?: string): AxACEPlaybook {\n  const timestamp = new Date().toISOString();\n  return {\n    version: 1,\n    sections: {},\n    stats: {\n      bulletCount: 0,\n      helpfulCount: 0,\n      harmfulCount: 0,\n      tokenEstimate: 0,\n    },\n    updatedAt: timestamp,\n    description,\n  };\n}\n\n/**\n * Produce a deep clone to prevent accidental mutation of stored artifacts.\n */\nexport function clonePlaybook(\n  playbook: Readonly<AxACEPlaybook>\n): AxACEPlaybook {\n  return JSON.parse(JSON.stringify(playbook)) as AxACEPlaybook;\n}\n\n/**\n * Lightweight token estimation based on character count (fallback when tiktoken\n * is unavailable). The constant (4 chars/token) approximates GPT-style tokenizers.\n */\nexport function estimateTokenCount(text: string): number {\n  const avgCharsPerToken = 4;\n  return Math.ceil(text.length / avgCharsPerToken);\n}\n\n/**\n * Apply curator operations (delta updates) to the playbook in-place.\n * Returns the list of bullet ids that were added or updated for auditing.\n */\nexport function applyCuratorOperations(\n  playbook: AxACEPlaybook,\n  operations: readonly AxACECuratorOperation[],\n  options?: Readonly<ApplyOperationsOptions>\n): { updatedBulletIds: string[]; autoRemoved: AxACECuratorOperation[] } {\n  const updatedBullets: string[] = [];\n  const autoRemoved: AxACECuratorOperation[] = [];\n  const {\n    maxSectionSize = Number.POSITIVE_INFINITY,\n    allowDynamicSections = true,\n    enableAutoPrune = false,\n    protectedBulletIds,\n  } = options ?? {};\n\n  const now = new Date().toISOString();\n\n  const protectedIds = protectedBulletIds ?? new Set<string>();\n\n  for (const op of operations) {\n    if (!op.section) {\n      continue;\n    }\n\n    if (!playbook.sections[op.section]) {\n      if (!allowDynamicSections) {\n        continue;\n      }\n      playbook.sections[op.section] = [];\n    }\n\n    const section = playbook.sections[op.section]!;\n\n    switch (op.type) {\n      case 'ADD': {\n        if (section.length >= maxSectionSize) {\n          if (!enableAutoPrune) {\n            continue;\n          }\n          const pruned = pruneSectionForAddition(section, protectedIds);\n          if (!pruned) {\n            continue;\n          }\n          updatedBullets.push(pruned.id);\n          autoRemoved.push({\n            type: 'REMOVE',\n            section: op.section,\n            bulletId: pruned.id,\n            metadata: {\n              ...(pruned.metadata ?? {}),\n              autoPruned: true,\n              removedAt: now,\n            },\n          });\n        }\n\n        const id = op.bulletId ?? generateBulletId(op.section);\n        const bullet: AxACEBullet = {\n          id,\n          section: op.section,\n          content: op.content ?? '',\n          helpfulCount: 0,\n          harmfulCount: 0,\n          createdAt: now,\n          updatedAt: now,\n          metadata: op.metadata ? { ...op.metadata } : undefined,\n        };\n        section.push(bullet);\n        updatedBullets.push(id);\n        break;\n      }\n      case 'UPDATE': {\n        const bullet = section.find((b) => b.id === op.bulletId);\n        if (!bullet) {\n          continue;\n        }\n        if (typeof op.content === 'string') {\n          bullet.content = op.content;\n        }\n        bullet.updatedAt = now;\n        if (op.metadata) {\n          bullet.metadata = {\n            ...(bullet.metadata ?? {}),\n            ...op.metadata,\n          };\n        }\n        updatedBullets.push(bullet.id);\n        break;\n      }\n      case 'REMOVE': {\n        const idx = section.findIndex((b) => b.id === op.bulletId);\n        if (idx >= 0) {\n          const [removed] = section.splice(idx, 1);\n          if (removed) {\n            updatedBullets.push(removed.id);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  recomputePlaybookStats(playbook);\n  playbook.updatedAt = now;\n\n  return { updatedBulletIds: updatedBullets, autoRemoved };\n}\n\n/**\n * Increase the helpful/harmful counters reported by the Reflector stage.\n */\nexport function updateBulletFeedback(\n  playbook: AxACEPlaybook,\n  bulletId: string,\n  tag: 'helpful' | 'harmful' | 'neutral'\n): void {\n  for (const section of Object.values(playbook.sections)) {\n    const bullet = section.find((b) => b.id === bulletId);\n    if (bullet) {\n      if (tag === 'helpful') {\n        bullet.helpfulCount += 1;\n      } else if (tag === 'harmful') {\n        bullet.harmfulCount += 1;\n      }\n      bullet.updatedAt = new Date().toISOString();\n      recomputePlaybookStats(playbook);\n      return;\n    }\n  }\n}\n\n/**\n * Render the playbook into a markdown-like instruction block that can be\n * appended to a system prompt.\n */\nexport function renderPlaybook(playbook: Readonly<AxACEPlaybook>): string {\n  const header = playbook.description\n    ? `## Context Playbook\\n${playbook.description.trim()}\\n`\n    : '## Context Playbook\\n';\n\n  const sections = Object.entries(playbook.sections)\n    .map(([sectionName, bullets]) => {\n      const body = bullets\n        .map((bullet) => `- [${bullet.id}] ${bullet.content}`)\n        .join('\\n');\n      return body\n        ? `### ${sectionName}\\n${body}`\n        : `### ${sectionName}\\n_(empty)_`;\n    })\n    .join('\\n\\n');\n\n  return `${header}\\n${sections}`.trim();\n}\n\n/**\n * Simple deterministic bullet id generator (section prefix + random suffix).\n * Aligns with paper examples like \"calc-00001\".\n */\nexport function generateBulletId(section: string): string {\n  const normalized = section\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-+|-+$/g, '')\n    .slice(0, 6);\n  const randomHex = crypto.randomBytes(4).toString('hex');\n  return `${normalized || 'ctx'}-${randomHex}`;\n}\n\nfunction pruneSectionForAddition(\n  section: AxACEBullet[],\n  protectedIds: ReadonlySet<string>\n): AxACEBullet | undefined {\n  let candidateIndex = -1;\n  let candidateScore: [number, number, number] | undefined;\n\n  for (let index = 0; index < section.length; index += 1) {\n    const bullet = section[index]!;\n    if (protectedIds.has(bullet.id)) {\n      continue;\n    }\n\n    const helpful = bullet.helpfulCount ?? 0;\n    const harmful = bullet.harmfulCount ?? 0;\n    const netScore = helpful - harmful * 2;\n    const recency = Date.parse(bullet.updatedAt ?? bullet.createdAt);\n\n    const score: [number, number, number] = [\n      netScore,\n      helpful,\n      Number.isFinite(recency) ? recency : Number.POSITIVE_INFINITY,\n    ];\n\n    if (!candidateScore) {\n      candidateIndex = index;\n      candidateScore = score;\n      continue;\n    }\n\n    const candidateBullet = section[candidateIndex]!;\n    const candidateHelpful = candidateBullet.helpfulCount ?? 0;\n    const candidateHarmful = candidateBullet.harmfulCount ?? 0;\n    const candidateNet = candidateHelpful - candidateHarmful * 2;\n    const candidateRecency = Date.parse(\n      candidateBullet.updatedAt ?? candidateBullet.createdAt\n    );\n    const candidateVector: [number, number, number] = [\n      candidateNet,\n      candidateHelpful,\n      Number.isFinite(candidateRecency)\n        ? candidateRecency\n        : Number.POSITIVE_INFINITY,\n    ];\n\n    if (\n      score[0] < candidateVector[0] ||\n      (score[0] === candidateVector[0] && score[1] < candidateVector[1]) ||\n      (score[0] === candidateVector[0] &&\n        score[1] === candidateVector[1] &&\n        score[2] < candidateVector[2])\n    ) {\n      candidateIndex = index;\n      candidateScore = score;\n    }\n  }\n\n  if (candidateIndex === -1) {\n    return undefined;\n  }\n\n  const [removed] = section.splice(candidateIndex, 1);\n  return removed;\n}\n\n/**\n * Remove duplicate bullets based on cosine similarity of content embeddings.\n * The default implementation uses a naive string comparison fallback so that\n * ACE remains functional without embedding services. Callers can inject a more\n * sophisticated deduper if desired.\n */\nexport function dedupePlaybookByContent(\n  playbook: AxACEPlaybook,\n  _similarityThreshold = 0.95\n): void {\n  for (const [sectionName, bullets] of Object.entries(playbook.sections)) {\n    const seen = new Map<string, AxACEBullet>();\n    const unique: AxACEBullet[] = [];\n\n    for (const bullet of bullets) {\n      const key = bullet.content.trim().toLowerCase();\n      const existing = seen.get(key);\n      if (existing) {\n        // Merge counters if they are near-identical\n        existing.helpfulCount += bullet.helpfulCount;\n        existing.harmfulCount += bullet.harmfulCount;\n        existing.updatedAt = bullet.updatedAt;\n      } else {\n        seen.set(key, bullet);\n        unique.push(bullet);\n      }\n    }\n\n    playbook.sections[sectionName] = unique;\n  }\n\n  recomputePlaybookStats(playbook);\n}\n\nfunction recomputePlaybookStats(playbook: AxACEPlaybook): void {\n  let bulletCount = 0;\n  let helpfulCount = 0;\n  let harmfulCount = 0;\n  let tokenEstimate = 0;\n\n  for (const bullets of Object.values(playbook.sections)) {\n    for (const bullet of bullets) {\n      bulletCount += 1;\n      helpfulCount += bullet.helpfulCount;\n      harmfulCount += bullet.harmfulCount;\n      tokenEstimate += estimateTokenCount(bullet.content);\n    }\n  }\n\n  playbook.stats = {\n    bulletCount,\n    helpfulCount,\n    harmfulCount,\n    tokenEstimate,\n  };\n}\n","import type {\n  AxCompileOptions,\n  AxExample,\n  AxMetricFn,\n  AxOptimizationStats,\n  AxOptimizerArgs,\n  AxTypedExample,\n} from '../common_types.js';\nimport { ax } from '../template.js';\nimport type { AxGen } from '../generate.js';\nimport {\n  AxBaseOptimizer,\n  AxOptimizedProgramImpl,\n  type AxOptimizedProgram,\n  type AxOptimizerResult,\n} from '../optimizer.js';\nimport type { AxGenOut } from '../types.js';\n\nimport {\n  applyCuratorOperations,\n  clonePlaybook,\n  createEmptyPlaybook,\n  dedupePlaybookByContent,\n  renderPlaybook,\n  updateBulletFeedback,\n} from './acePlaybook.js';\nimport { f } from '../sig.js';\nimport type {\n  AxACEBullet,\n  AxACECuratorOperation,\n  AxACECuratorOutput,\n  AxACEFeedbackEvent,\n  AxACEGeneratorOutput,\n  AxACEOptimizationArtifact,\n  AxACEPlaybook,\n  AxACEReflectionOutput,\n  AxACEOptions,\n} from './aceTypes.js';\n\ninterface AxACECompileOptions extends AxCompileOptions {\n  aceOptions?: AxACEOptions;\n}\n\nconst DEFAULT_CONFIG: Required<\n  Pick<\n    AxACEOptions,\n    | 'maxEpochs'\n    | 'maxReflectorRounds'\n    | 'maxSectionSize'\n    | 'similarityThreshold'\n    | 'allowDynamicSections'\n  >\n> = {\n  maxEpochs: 1,\n  maxReflectorRounds: 2,\n  maxSectionSize: 25,\n  similarityThreshold: 0.95,\n  allowDynamicSections: true,\n};\n\nexport interface AxACEResult<OUT extends AxGenOut>\n  extends AxOptimizerResult<OUT> {\n  optimizedProgram?: AxACEOptimizedProgram<OUT>;\n  playbook: AxACEPlaybook;\n  artifact: AxACEOptimizationArtifact;\n}\n\n/**\n * Optimized program artifact that persists ACE playbook updates.\n */\nexport class AxACEOptimizedProgram<\n  OUT = any,\n> extends AxOptimizedProgramImpl<OUT> {\n  public readonly playbook: AxACEPlaybook;\n  public readonly artifact: AxACEOptimizationArtifact;\n  private readonly baseInstruction?: string;\n\n  constructor(config: {\n    baseInstruction?: string;\n    playbook: AxACEPlaybook;\n    artifact: AxACEOptimizationArtifact;\n    bestScore: number;\n    stats: AxOptimizationStats;\n    optimizerType: string;\n    optimizationTime: number;\n    totalRounds: number;\n    converged: boolean;\n    instruction?: string;\n    demos?: AxOptimizedProgram<OUT>['demos'];\n    examples?: AxExample[];\n    modelConfig?: AxOptimizedProgram<OUT>['modelConfig'];\n    scoreHistory?: number[];\n    configurationHistory?: Record<string, unknown>[];\n  }) {\n    super({\n      bestScore: config.bestScore,\n      stats: config.stats,\n      instruction: config.instruction,\n      demos: config.demos,\n      examples: config.examples,\n      modelConfig: config.modelConfig,\n      optimizerType: config.optimizerType,\n      optimizationTime: config.optimizationTime,\n      totalRounds: config.totalRounds,\n      converged: config.converged,\n      scoreHistory: config.scoreHistory,\n      configurationHistory: config.configurationHistory,\n    });\n\n    this.playbook = clonePlaybook(config.playbook);\n    this.artifact = config.artifact;\n    this.baseInstruction = config.baseInstruction;\n  }\n\n  public override applyTo<IN, T extends AxGenOut>(program: AxGen<IN, T>): void {\n    super.applyTo(program);\n\n    const signature = program.getSignature();\n    const originalDescription =\n      this.baseInstruction ?? signature.getDescription() ?? '';\n\n    const combinedInstruction = [\n      originalDescription.trim(),\n      '',\n      renderPlaybook(this.playbook),\n    ]\n      .filter((block) => block && block.trim().length > 0)\n      .join('\\n\\n');\n\n    program.setDescription(combinedInstruction);\n  }\n}\n\n/**\n * AxACE implements the Agentic Context Engineering loop (Generator  Reflector  Curator).\n * The implementation mirrors the paper's architecture while integrating with the Ax optimizer\n * ergonomics (unified optimized program artifacts, metrics, and checkpointing).\n */\nexport class AxACE extends AxBaseOptimizer {\n  private readonly aceConfig: Required<typeof DEFAULT_CONFIG> & {\n    initialPlaybook?: AxACEPlaybook;\n  };\n  private playbook: AxACEPlaybook;\n  private generatorHistory: AxACEFeedbackEvent[] = [];\n  private deltaHistory: AxACEOptimizationArtifact['history'] = [];\n\n  private reflectorProgram?: AxGen<any, any>;\n\n  private curatorProgram?: AxGen<any, any>;\n\n  constructor(\n    args: Readonly<AxOptimizerArgs>,\n    options?: Readonly<AxACEOptions>\n  ) {\n    super(args);\n\n    this.aceConfig = {\n      ...DEFAULT_CONFIG,\n      ...options,\n    };\n\n    this.playbook =\n      options?.initialPlaybook !== undefined\n        ? clonePlaybook(options.initialPlaybook)\n        : createEmptyPlaybook();\n  }\n\n  public override reset(): void {\n    super.reset();\n    this.playbook =\n      this.aceConfig.initialPlaybook !== undefined\n        ? clonePlaybook(this.aceConfig.initialPlaybook)\n        : createEmptyPlaybook();\n    this.generatorHistory = [];\n    this.deltaHistory = [];\n  }\n\n  public configureAuto(level: 'light' | 'medium' | 'heavy'): void {\n    switch (level) {\n      case 'light':\n        this.aceConfig.maxEpochs = 1;\n        this.aceConfig.maxReflectorRounds = 1;\n        break;\n      case 'medium':\n        this.aceConfig.maxEpochs = 2;\n        this.aceConfig.maxReflectorRounds = 2;\n        break;\n      case 'heavy':\n        this.aceConfig.maxEpochs = 3;\n        this.aceConfig.maxReflectorRounds = 3;\n        break;\n    }\n  }\n\n  public async compile<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>,\n    examples: readonly AxTypedExample<IN>[],\n    metricFn: AxMetricFn,\n    options?: AxACECompileOptions\n  ): Promise<AxACEResult<OUT>> {\n    const aceOptions = (options as AxACECompileOptions | undefined)?.aceOptions;\n    if (aceOptions) {\n      Object.assign(this.aceConfig, {\n        maxEpochs: aceOptions.maxEpochs ?? this.aceConfig.maxEpochs,\n        maxReflectorRounds:\n          aceOptions.maxReflectorRounds ?? this.aceConfig.maxReflectorRounds,\n        maxSectionSize:\n          aceOptions.maxSectionSize ?? this.aceConfig.maxSectionSize,\n        similarityThreshold:\n          aceOptions.similarityThreshold ?? this.aceConfig.similarityThreshold,\n        allowDynamicSections:\n          aceOptions.allowDynamicSections ??\n          this.aceConfig.allowDynamicSections,\n      });\n\n      if (aceOptions.initialPlaybook) {\n        this.playbook = clonePlaybook(aceOptions.initialPlaybook);\n      }\n    }\n\n    const startTime = Date.now();\n    this.validateExamples(examples);\n\n    const baseInstruction = await this.extractProgramInstruction(program);\n    const originalDescription = program.getSignature().getDescription() ?? '';\n\n    this.generatorHistory = [];\n    this.deltaHistory = [];\n\n    let bestScore = Number.NEGATIVE_INFINITY;\n    let round = 0;\n\n    const epochs = Math.max(this.aceConfig.maxEpochs, 1);\n    const totalRoundsTarget = epochs * examples.length;\n\n    try {\n      for (let epoch = 0; epoch < epochs; epoch++) {\n        for (let index = 0; index < examples.length; index++) {\n          const example = examples[index]!;\n\n          // Compose prompt with current playbook\n          const composedInstruction = this.composeInstruction(\n            baseInstruction ?? originalDescription,\n            this.playbook\n          );\n          (program as any).setDescription?.(composedInstruction);\n\n          const prediction = await program.forward(\n            this.studentAI,\n            example as IN\n          );\n          this.stats.totalCalls += 1;\n\n          const score = await metricFn({\n            prediction,\n            example: example as AxExample,\n          });\n\n          if (typeof score === 'number') {\n            this.stats.bestScore = Math.max(this.stats.bestScore, score);\n            bestScore = Math.max(bestScore, score);\n          }\n\n          const predictedSeverity = (prediction as { severity?: string })\n            ?.severity;\n          const expectedSeverity = (example as { severity?: string })?.severity;\n\n          const generatorOutput = this.createGeneratorOutput(\n            prediction,\n            example\n          );\n\n          const severityMismatch =\n            expectedSeverity &&\n            predictedSeverity &&\n            expectedSeverity !== predictedSeverity;\n\n          const reflection = await this.runReflectionRounds({\n            example,\n            generatorOutput,\n            feedback:\n              expectedSeverity &&\n              predictedSeverity &&\n              expectedSeverity !== predictedSeverity\n                ? `Expected severity \"${expectedSeverity}\" but model predicted \"${predictedSeverity}\".`\n                : undefined,\n          });\n\n          const rawCurator = await this.runCurator({\n            example,\n            reflection,\n            playbook: this.playbook,\n          });\n\n          let operations = this.normalizeCuratorOperations(\n            rawCurator?.operations\n          );\n          if (operations.length === 0 && severityMismatch) {\n            operations = this.inferOperationsFromReflection(reflection);\n          }\n          operations = this.resolveCuratorOperationTargets(\n            operations,\n            this.playbook,\n            reflection,\n            generatorOutput\n          );\n\n          const curatorResult =\n            rawCurator || operations.length > 0\n              ? ({\n                  ...(rawCurator ?? {}),\n                  operations,\n                } as AxACECuratorOutput)\n              : undefined;\n\n          let appliedDeltaIds: string[] = [];\n          if (operations.length > 0) {\n            const protectedIds = this.collectProtectedBulletIds(operations);\n            const applicationResult = applyCuratorOperations(\n              this.playbook,\n              operations,\n              {\n                maxSectionSize: this.aceConfig.maxSectionSize,\n                allowDynamicSections: this.aceConfig.allowDynamicSections,\n                enableAutoPrune: true,\n                protectedBulletIds: protectedIds,\n              }\n            );\n            appliedDeltaIds = applicationResult.updatedBulletIds;\n            if (applicationResult.autoRemoved.length > 0) {\n              operations.push(...applicationResult.autoRemoved);\n              if (curatorResult) {\n                curatorResult.operations = operations;\n              }\n            }\n          }\n\n          if (reflection?.bulletTags) {\n            for (const tag of reflection.bulletTags) {\n              updateBulletFeedback(this.playbook, tag.id, tag.tag);\n            }\n          }\n\n          if (operations.length > 0 && appliedDeltaIds.length > 0) {\n            dedupePlaybookByContent(\n              this.playbook,\n              this.aceConfig.similarityThreshold\n            );\n          }\n\n          const feedbackEvent: AxACEFeedbackEvent = {\n            example: example as AxExample,\n            prediction,\n            score: typeof score === 'number' ? score : 0,\n            generatorOutput,\n            reflection,\n            curator: curatorResult,\n            timestamp: new Date().toISOString(),\n          };\n\n          this.generatorHistory.push(feedbackEvent);\n\n          if (appliedDeltaIds.length > 0 && curatorResult?.operations?.length) {\n            this.deltaHistory.push({\n              epoch,\n              exampleIndex: index,\n              operations: curatorResult.operations,\n            });\n          }\n\n          round += 1;\n          this.currentRound = round;\n\n          const numericScore =\n            typeof score === 'number' && Number.isFinite(score) ? score : 0;\n          const bestScoreForProgress = Number.isFinite(bestScore)\n            ? bestScore\n            : numericScore;\n\n          const progressOptions: AxACECompileOptions = {\n            ...(options ?? {}),\n            maxIterations: totalRoundsTarget,\n          };\n\n          await this.updateOptimizationProgress(\n            round,\n            numericScore,\n            {\n              epoch,\n              exampleIndex: index,\n              playbookBullets: this.playbook.stats.bulletCount,\n            },\n            'ACE',\n            { epochs, totalRounds: totalRoundsTarget },\n            bestScoreForProgress,\n            {\n              playbookBullets: this.playbook.stats.bulletCount,\n            },\n            undefined,\n            progressOptions\n          );\n\n          this.stats.convergenceInfo.finalImprovement = Math.max(\n            this.stats.convergenceInfo.finalImprovement,\n            numericScore\n          );\n        }\n      }\n    } finally {\n      (program as any).setDescription?.(originalDescription);\n    }\n\n    const optimizationTime = Date.now() - startTime;\n    this.stats.resourceUsage.totalTime = optimizationTime;\n    this.stats.convergenceInfo.converged = true;\n    this.stats.bestScore = Number.isFinite(bestScore) ? bestScore : 0;\n\n    const artifact: AxACEOptimizationArtifact = {\n      playbook: clonePlaybook(this.playbook),\n      feedback: [...this.generatorHistory],\n      history: [...this.deltaHistory],\n    };\n\n    const optimizedProgram = new AxACEOptimizedProgram<OUT>({\n      baseInstruction: baseInstruction ?? originalDescription,\n      playbook: this.playbook,\n      artifact,\n      bestScore: Number.isFinite(bestScore) ? bestScore : 0,\n      stats: this.stats,\n      optimizerType: 'ACE',\n      optimizationTime,\n      totalRounds: round,\n      converged: this.stats.convergenceInfo.converged,\n    });\n\n    const result: AxACEResult<OUT> = {\n      stats: this.stats,\n      bestScore: Number.isFinite(bestScore) ? bestScore : 0,\n      finalConfiguration: {\n        strategy: 'ace',\n        epochs,\n      },\n      optimizedProgram,\n      playbook: clonePlaybook(this.playbook),\n      artifact,\n    };\n    return result;\n  }\n\n  /**\n   * Apply ACE updates after each online inference. Mirrors the online adaptation\n   * flow described in the paper; can be called by user-land code between queries.\n   */\n  public async applyOnlineUpdate(\n    args: Readonly<{\n      example: AxExample;\n      prediction: unknown;\n      feedback?: string;\n    }>\n  ): Promise<AxACECuratorOutput | undefined> {\n    const generatorOutput = this.createGeneratorOutput(\n      args.prediction,\n      args.example\n    );\n\n    const predictedSeverity = (args.prediction as { severity?: string })\n      ?.severity;\n    const expectedSeverity = (args.example as { severity?: string })?.severity;\n\n    const reflection = await this.runReflectionRounds({\n      example: args.example,\n      generatorOutput,\n      feedback:\n        args.feedback ??\n        (expectedSeverity &&\n        predictedSeverity &&\n        expectedSeverity !== predictedSeverity\n          ? `Expected severity \"${expectedSeverity}\" but model predicted \"${predictedSeverity}\".`\n          : undefined),\n    });\n\n    const rawCurator = await this.runCurator({\n      example: args.example,\n      reflection,\n      playbook: this.playbook,\n    });\n\n    let operations = this.normalizeCuratorOperations(rawCurator?.operations);\n    const severityMismatch =\n      expectedSeverity &&\n      predictedSeverity &&\n      expectedSeverity !== predictedSeverity;\n    if (operations.length === 0 && severityMismatch) {\n      operations = this.inferOperationsFromReflection(reflection);\n    }\n    operations = this.resolveCuratorOperationTargets(\n      operations,\n      this.playbook,\n      reflection,\n      generatorOutput\n    );\n\n    const curatorResult =\n      rawCurator || operations.length > 0\n        ? ({\n            ...(rawCurator ?? {}),\n            operations,\n          } as AxACECuratorOutput)\n        : undefined;\n\n    if (reflection?.bulletTags) {\n      for (const tag of reflection.bulletTags) {\n        updateBulletFeedback(this.playbook, tag.id, tag.tag);\n      }\n    }\n\n    if (operations.length > 0) {\n      const protectedIds = this.collectProtectedBulletIds(operations);\n      const result = applyCuratorOperations(this.playbook, operations, {\n        maxSectionSize: this.aceConfig.maxSectionSize,\n        allowDynamicSections: this.aceConfig.allowDynamicSections,\n        enableAutoPrune: true,\n        protectedBulletIds: protectedIds,\n      });\n      if (result.autoRemoved.length > 0) {\n        operations.push(...result.autoRemoved);\n        if (curatorResult) {\n          curatorResult.operations = operations;\n        }\n      }\n      dedupePlaybookByContent(\n        this.playbook,\n        this.aceConfig.similarityThreshold\n      );\n    }\n\n    const feedbackEvent: AxACEFeedbackEvent = {\n      example: args.example,\n      prediction: args.prediction,\n      score: 0,\n      generatorOutput,\n      reflection,\n      curator: curatorResult,\n      timestamp: new Date().toISOString(),\n    };\n\n    this.generatorHistory.push(feedbackEvent);\n\n    return curatorResult;\n  }\n\n  private composeInstruction(\n    baseInstruction: string,\n    playbook: AxACEPlaybook\n  ): string {\n    const instructionParts = [\n      baseInstruction.trim(),\n      '',\n      renderPlaybook(playbook),\n    ].filter((part) => part.trim().length > 0);\n\n    return instructionParts.join('\\n\\n');\n  }\n\n  private async extractProgramInstruction<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>\n  ): Promise<string | undefined> {\n    try {\n      const signature = program.getSignature();\n      return signature.getDescription() ?? undefined;\n    } catch {\n      return undefined;\n    }\n  }\n\n  private createGeneratorOutput<IN>(\n    prediction: unknown,\n    example: AxTypedExample<IN>\n  ): AxACEGeneratorOutput {\n    const reasoning =\n      (prediction as Record<string, unknown>)?.thought?.toString() ?? '';\n\n    const bulletIds = Array.isArray(\n      (prediction as Record<string, unknown>)?.bullet_ids\n    )\n      ? ((prediction as Record<string, unknown>)?.bullet_ids as string[])\n      : [];\n\n    return {\n      reasoning,\n      answer: prediction,\n      bulletIds,\n      trajectory: JSON.stringify({\n        example,\n        prediction,\n      }),\n      metadata: {\n        predictedSeverity: (prediction as { severity?: string })?.severity,\n        expectedSeverity: (example as { severity?: string })?.severity,\n      },\n    };\n  }\n\n  private resolveCuratorOperationTargets(\n    operations: AxACECuratorOperation[],\n    playbook: AxACEPlaybook,\n    reflection?: AxACEReflectionOutput,\n    generatorOutput?: AxACEGeneratorOutput\n  ): AxACECuratorOperation[] {\n    if (!operations.length) {\n      return operations;\n    }\n\n    const resolved: AxACECuratorOperation[] = [];\n    const usedIds = new Set<string>(\n      operations\n        .map((op) => op.bulletId)\n        .filter((id): id is string => typeof id === 'string')\n    );\n\n    interface SectionQueues {\n      harmful: string[];\n      primary: string[];\n      generator: string[];\n    }\n\n    const sectionQueues = new Map<string, SectionQueues>();\n\n    const enqueueCandidate = (\n      bulletId: string,\n      priority: keyof SectionQueues\n    ): void => {\n      if (usedIds.has(bulletId)) {\n        return;\n      }\n      const located = this.locateBullet(playbook, bulletId);\n      if (!located) {\n        return;\n      }\n      const queues = sectionQueues.get(located.section) ?? {\n        harmful: [],\n        primary: [],\n        generator: [],\n      };\n      queues[priority].push(located.id);\n      sectionQueues.set(located.section, queues);\n    };\n\n    for (const tag of reflection?.bulletTags ?? []) {\n      const priority = tag.tag === 'harmful' ? 'harmful' : 'primary';\n      enqueueCandidate(tag.id, priority);\n    }\n\n    if (generatorOutput?.bulletIds) {\n      for (const bulletId of generatorOutput.bulletIds) {\n        enqueueCandidate(bulletId, 'generator');\n      }\n    }\n\n    const dequeueForSection = (section: string): string | undefined => {\n      const queues = sectionQueues.get(section);\n      if (!queues) {\n        return this.locateFallbackBullet(playbook, section, usedIds);\n      }\n\n      const shift = (list: string[]): string | undefined => {\n        while (list.length > 0) {\n          const candidate = list.shift()!;\n          if (!usedIds.has(candidate)) {\n            return candidate;\n          }\n        }\n        return undefined;\n      };\n\n      const candidate =\n        shift(queues.harmful) ??\n        shift(queues.primary) ??\n        shift(queues.generator);\n\n      if (candidate) {\n        return candidate;\n      }\n\n      return this.locateFallbackBullet(playbook, section, usedIds);\n    };\n\n    for (const operation of operations) {\n      if (\n        (operation.type === 'UPDATE' || operation.type === 'REMOVE') &&\n        !operation.bulletId\n      ) {\n        const candidate = dequeueForSection(operation.section);\n        if (candidate) {\n          operation.bulletId = candidate;\n          usedIds.add(candidate);\n        }\n      }\n\n      if (\n        (operation.type === 'UPDATE' || operation.type === 'REMOVE') &&\n        !operation.bulletId\n      ) {\n        // No viable target; drop this operation.\n        continue;\n      }\n\n      resolved.push(operation);\n    }\n\n    return resolved;\n  }\n\n  private locateBullet(\n    playbook: AxACEPlaybook,\n    bulletId: string\n  ): AxACEBullet | undefined {\n    for (const sectionBullets of Object.values(playbook.sections)) {\n      const bullet = sectionBullets.find((entry) => entry.id === bulletId);\n      if (bullet) {\n        return bullet;\n      }\n    }\n    return undefined;\n  }\n\n  private locateFallbackBullet(\n    playbook: AxACEPlaybook,\n    section: string,\n    usedIds: ReadonlySet<string>\n  ): string | undefined {\n    const bullets = playbook.sections[section] ?? [];\n    for (const bullet of bullets) {\n      if (!usedIds.has(bullet.id)) {\n        return bullet.id;\n      }\n    }\n    return undefined;\n  }\n\n  private collectProtectedBulletIds(\n    operations: readonly AxACECuratorOperation[]\n  ): Set<string> {\n    const protectedIds = new Set<string>();\n    for (const operation of operations) {\n      if (operation.type === 'UPDATE' && operation.bulletId) {\n        protectedIds.add(operation.bulletId);\n      }\n    }\n    return protectedIds;\n  }\n\n  private normalizeCuratorOperations(\n    operations: unknown\n  ): AxACECuratorOperation[] {\n    if (!operations) {\n      return [];\n    }\n\n    if (Array.isArray(operations)) {\n      const normalized: AxACECuratorOperation[] = [];\n      const seen = new Set<string>();\n\n      for (const entry of operations) {\n        if (!entry || typeof entry !== 'object') {\n          continue;\n        }\n\n        const typeRaw = (entry as { type?: string }).type ?? 'ADD';\n        const typeUpper =\n          typeof typeRaw === 'string' ? typeRaw.toUpperCase() : 'ADD';\n        const type: AxACECuratorOperation['type'] =\n          typeUpper === 'UPDATE'\n            ? 'UPDATE'\n            : typeUpper === 'REMOVE'\n              ? 'REMOVE'\n              : 'ADD';\n\n        const sectionRaw =\n          (entry as { section?: string }).section ?? 'Guidelines';\n        const section =\n          typeof sectionRaw === 'string' && sectionRaw.trim().length > 0\n            ? sectionRaw.trim()\n            : 'Guidelines';\n\n        const contentRaw = (entry as { content?: string }).content ?? '';\n        const content = typeof contentRaw === 'string' ? contentRaw.trim() : '';\n\n        if (type !== 'REMOVE' && content.length === 0) {\n          continue;\n        }\n\n        const bulletIdRaw =\n          (entry as { bulletId?: string }).bulletId ??\n          (entry as { id?: string }).id;\n        const bulletId =\n          typeof bulletIdRaw === 'string' && bulletIdRaw.trim().length > 0\n            ? bulletIdRaw.trim()\n            : undefined;\n\n        const keyParts = [type, section, content, bulletId ?? ''];\n        const key = keyParts.join(':');\n        if (seen.has(key)) {\n          continue;\n        }\n        seen.add(key);\n\n        const normalizedEntry: AxACECuratorOperation = {\n          type,\n          section,\n        };\n\n        if (type !== 'REMOVE') {\n          normalizedEntry.content = content;\n        }\n        if (bulletId) {\n          normalizedEntry.bulletId = bulletId;\n        }\n\n        const metadataRaw = (entry as { metadata?: Record<string, unknown> })\n          .metadata;\n        if (metadataRaw && typeof metadataRaw === 'object') {\n          normalizedEntry.metadata = { ...metadataRaw };\n        }\n\n        normalized.push(normalizedEntry);\n      }\n\n      return normalized;\n    }\n\n    if (typeof operations === 'string') {\n      try {\n        const parsed = JSON.parse(operations);\n        return this.normalizeCuratorOperations(parsed);\n      } catch {\n        return [];\n      }\n    }\n\n    if (typeof operations === 'object') {\n      const opsObj = operations as { operations?: unknown };\n      if (opsObj && Array.isArray(opsObj.operations)) {\n        return this.normalizeCuratorOperations(opsObj.operations);\n      }\n      if (opsObj && typeof opsObj.operations === 'string') {\n        try {\n          const parsed = JSON.parse(opsObj.operations);\n          return this.normalizeCuratorOperations(parsed);\n        } catch {\n          return [];\n        }\n      }\n      return [];\n    }\n\n    return [];\n  }\n\n  private inferOperationsFromReflection(\n    reflection?: AxACEReflectionOutput\n  ): AxACECuratorOperation[] {\n    if (!reflection) {\n      return [];\n    }\n\n    const operations: AxACECuratorOperation[] = [];\n    const seen = new Set<string>();\n\n    const addOperation = (section: string, content?: string) => {\n      if (!content) {\n        return;\n      }\n      const trimmed = content.trim();\n      if (!trimmed) {\n        return;\n      }\n      const lower = trimmed.toLowerCase();\n      if (lower.startsWith('no error')) {\n        return;\n      }\n      const key = `${section}:${trimmed}`;\n      if (seen.has(key)) {\n        return;\n      }\n      seen.add(key);\n      operations.push({\n        type: 'ADD',\n        section,\n        content: trimmed,\n      });\n    };\n\n    addOperation('Guidelines', reflection.keyInsight);\n    addOperation('Response Strategies', reflection.correctApproach);\n    addOperation('Common Pitfalls', reflection.errorIdentification);\n    addOperation('Root Cause Notes', reflection.rootCauseAnalysis);\n\n    return operations;\n  }\n\n  private async runReflectionRounds({\n    example,\n    generatorOutput,\n    feedback,\n  }: Readonly<{\n    example: AxExample;\n    generatorOutput: AxACEGeneratorOutput;\n    feedback?: string;\n  }>): Promise<AxACEReflectionOutput | undefined> {\n    const rounds = Math.max(this.aceConfig.maxReflectorRounds, 1);\n    let previous: AxACEReflectionOutput | undefined;\n\n    for (let round = 0; round < rounds; round++) {\n      const reflection = await this.runReflector({\n        example,\n        generatorOutput,\n        feedback,\n        previousReflection: previous,\n      });\n\n      if (!reflection) {\n        break;\n      }\n\n      previous = reflection;\n\n      const errorText =\n        reflection.errorIdentification?.toLowerCase().trim() ?? '';\n      const resolved = (\n        reflection.metadata as { resolved?: boolean } | undefined\n      )?.resolved;\n\n      if (\n        resolved === true ||\n        errorText.length === 0 ||\n        errorText.startsWith('no error') ||\n        errorText.startsWith('resolved')\n      ) {\n        break;\n      }\n    }\n\n    return previous;\n  }\n\n  private async runReflector({\n    example,\n    generatorOutput,\n    feedback,\n    previousReflection,\n  }: Readonly<{\n    example: AxExample;\n    generatorOutput: AxACEGeneratorOutput;\n    feedback?: string;\n    previousReflection?: AxACEReflectionOutput;\n  }>): Promise<AxACEReflectionOutput | undefined> {\n    const reflector = this.getOrCreateReflectorProgram();\n    const reflectorAI = this.teacherAI ?? this.studentAI;\n\n    try {\n      const expectedAnswer = {\n        severity: (example as { severity?: string })?.severity,\n        policyHint: (example as { policyHint?: string })?.policyHint,\n      };\n      const reflectionRaw = await reflector.forward(reflectorAI, {\n        question: JSON.stringify(example),\n        generator_answer: JSON.stringify(generatorOutput.answer),\n        generator_reasoning: generatorOutput.reasoning,\n        playbook: JSON.stringify({\n          markdown: renderPlaybook(this.playbook),\n          structured: this.playbook,\n        }),\n        expected_answer:\n          expectedAnswer.severity || expectedAnswer.policyHint\n            ? JSON.stringify(expectedAnswer)\n            : undefined,\n        feedback,\n        previous_reflection: previousReflection\n          ? JSON.stringify(previousReflection)\n          : undefined,\n      });\n      return reflectionRaw as AxACEReflectionOutput;\n    } catch (error) {\n      if (this.verbose) {\n        console.warn(\n          '[AxACE] Reflector error:',\n          error instanceof Error ? error.message : error\n        );\n      }\n      return undefined;\n    }\n  }\n\n  private async runCurator({\n    example,\n    reflection,\n    playbook,\n  }: Readonly<{\n    example: AxExample;\n    reflection?: AxACEReflectionOutput;\n    playbook: AxACEPlaybook;\n  }>): Promise<AxACECuratorOutput | undefined> {\n    if (!reflection) {\n      return undefined;\n    }\n\n    const curator = this.getOrCreateCuratorProgram();\n    const curatorAI = this.teacherAI ?? this.studentAI;\n\n    try {\n      const outputRaw = await curator.forward(curatorAI, {\n        playbook: JSON.stringify({\n          markdown: renderPlaybook(playbook),\n          structured: playbook,\n        }),\n        reflection: JSON.stringify(reflection),\n        question_context: JSON.stringify(example),\n        token_budget: 1024,\n      });\n\n      return outputRaw as AxACECuratorOutput;\n    } catch (error) {\n      if (this.verbose) {\n        console.warn(\n          '[AxACE] Curator error:',\n          error instanceof Error ? error.message : error\n        );\n      }\n      return undefined;\n    }\n  }\n\n  private getOrCreateReflectorProgram(): AxGen<any, any> {\n    if (!this.reflectorProgram) {\n      const signature = f()\n        .input('question', f.string('Original task input serialized as JSON'))\n        .input(\n          'generator_answer',\n          f.string('Generator output serialized as JSON')\n        )\n        .input(\n          'generator_reasoning',\n          f.string('Generator reasoning trace').optional()\n        )\n        .input(\n          'playbook',\n          f.string('Current context playbook rendered as markdown')\n        )\n        .input(\n          'expected_answer',\n          f.string('Expected output when ground truth is available').optional()\n        )\n        .input(\n          'feedback',\n          f.string('External feedback or reward signal').optional()\n        )\n        .input(\n          'previous_reflection',\n          f\n            .string(\n              'Most recent reflection JSON when running multi-round refinement'\n            )\n            .optional()\n        )\n        .output(\n          'reasoning',\n          f.string('Step-by-step analysis of generator performance')\n        )\n        .output('errorIdentification', f.string('Specific mistakes detected'))\n        .output('rootCauseAnalysis', f.string('Underlying cause of the error'))\n        .output(\n          'correctApproach',\n          f.string('What the generator should do differently')\n        )\n        .output('keyInsight', f.string('Reusable insight to remember'))\n        .output(\n          'bulletTags',\n          f.json('Array of {id, tag} entries referencing playbook bullets')\n        )\n        .build();\n      this.reflectorProgram = ax(signature);\n    }\n    return this.reflectorProgram;\n  }\n\n  private getOrCreateCuratorProgram(): AxGen<any, any> {\n    if (!this.curatorProgram) {\n      const signature = f()\n        .input('playbook', f.string('Current playbook serialized as JSON'))\n        .input(\n          'reflection',\n          f.string('Latest reflection output serialized as JSON')\n        )\n        .input(\n          'question_context',\n          f.string('Original task input serialized as JSON')\n        )\n        .input(\n          'token_budget',\n          f.number('Approximate token budget for curator response').optional()\n        )\n        .output('reasoning', f.string('Justification for the proposed updates'))\n        .output(\n          'operations',\n          f.json('List of operations with type/section/content fields')\n        )\n        .build();\n      this.curatorProgram = ax(signature);\n    }\n    return this.curatorProgram;\n  }\n}\n","import type {\n  AxCompileOptions,\n  AxExample,\n  AxMetricFn,\n  AxOptimizerArgs,\n  AxTypedExample,\n} from '../common_types.js';\nimport type { AxGen } from '../generate.js';\nimport {\n  AxBaseOptimizer,\n  type AxBootstrapOptimizerOptions,\n  type AxOptimizerResult,\n} from '../optimizer.js';\nimport type {\n  AxFieldValue,\n  AxGenOut,\n  AxProgramDemos,\n  AxProgramTrace,\n} from '../types.js';\n\n// Define model config interface\ninterface ModelConfig {\n  temperature: number;\n  max_tokens?: number;\n  [key: string]: number | string | boolean | undefined;\n}\n\nexport class AxBootstrapFewShot extends AxBaseOptimizer {\n  private maxRounds: number;\n  private maxDemos: number;\n  private maxExamples: number;\n  private batchSize: number;\n  private earlyStoppingPatience: number;\n  private costMonitoring: boolean;\n  private maxTokensPerGeneration: number;\n  private verboseMode: boolean;\n  private debugMode: boolean;\n  private traces: AxProgramTrace<any, any>[] = [];\n\n  constructor(\n    args: Readonly<AxOptimizerArgs & { options?: AxBootstrapOptimizerOptions }>\n  ) {\n    // Call parent constructor\n    super(args);\n\n    const options = args.options || {};\n\n    this.maxRounds = options.maxRounds ?? 3;\n    this.maxDemos = options.maxDemos ?? 4;\n    this.maxExamples = options.maxExamples ?? 16;\n    this.batchSize = options.batchSize ?? 1;\n    this.earlyStoppingPatience = options.earlyStoppingPatience ?? 0;\n    this.costMonitoring = options.costMonitoring ?? false;\n    this.maxTokensPerGeneration = options.maxTokensPerGeneration ?? 0;\n    this.verboseMode = options.verboseMode ?? true;\n    this.debugMode = options.debugMode ?? false;\n\n    // Note: teacherAI from options can be used via compile options overrideTeacherAI\n    // The base class provides methods to access teacher AI with fallbacks\n  }\n\n  private async compileRound<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>,\n    examples: readonly AxTypedExample<IN>[],\n    roundIndex: number,\n    metricFn: AxMetricFn,\n    options?: AxCompileOptions\n  ): Promise<void> {\n    const _st = Date.now();\n    const maxDemos = options?.maxDemos ?? this.maxDemos;\n    const aiOpt = {\n      modelConfig: {\n        temperature: 0.7,\n      } as ModelConfig,\n    };\n\n    // Apply token limit if specified\n    if (this.maxTokensPerGeneration > 0) {\n      aiOpt.modelConfig.max_tokens = this.maxTokensPerGeneration;\n    }\n\n    const examplesSample = randomSample(\n      [...examples] as AxExample[],\n      this.maxExamples\n    );\n    const previousSuccessCount = this.traces.length;\n\n    // Process examples in batches if batch size > 1\n    for (let i = 0; i < examplesSample.length; i += this.batchSize) {\n      if (i > 0) {\n        aiOpt.modelConfig.temperature = 0.7 + 0.001 * i;\n      }\n\n      const batch = examplesSample.slice(i, i + this.batchSize);\n\n      // Process batch sequentially for now (could be parallelized if AI service supports it)\n      for (const ex of batch) {\n        if (!ex || typeof ex !== 'object') {\n          continue;\n        }\n\n        // Use remaining examples as demonstration examples (excluding current one)\n        const exList = examples.filter((e) => e !== ex);\n        (program as AxGen<IN, OUT>).setExamples(\n          exList as unknown as readonly (OUT & IN)[]\n        );\n\n        // Use teacher AI if provided, otherwise use student AI\n        const aiService = this.getTeacherOrStudentAI();\n\n        this.stats.totalCalls++;\n        let res: OUT;\n\n        try {\n          // Add maxRetries to forward options\n          const forwardOptions = {\n            ...aiOpt,\n            maxRetries: 1,\n          };\n\n          res = await program.forward(aiService, ex as IN, forwardOptions);\n\n          // Estimate token usage if cost monitoring is enabled\n          if (this.costMonitoring) {\n            // Very rough estimate - replace with actual token counting from your AI service\n            this.stats.estimatedTokenUsage +=\n              JSON.stringify(ex).length / 4 + JSON.stringify(res).length / 4;\n          }\n\n          const score = await metricFn({\n            prediction: res,\n            example: ex as AxExample,\n          });\n          const success = score >= 0.5; // Assuming a threshold of 0.5 for success\n          if (success) {\n            this.traces = [...this.traces, ...program.getTraces()];\n            this.stats.successfulDemos++;\n          }\n        } catch (error) {\n          // Log the error but continue bootstrap - student model failures are expected during bootstrapping\n          if (this.verboseMode || this.debugMode) {\n            console.warn(\n              `Student model failed during bootstrap: ${error instanceof Error ? error.message : 'Unknown error'}`\n            );\n          }\n          res = {} as OUT;\n        }\n\n        // Remove progress bars - now handled by the optimizer logging system\n\n        if (this.traces.length >= maxDemos) {\n          return;\n        }\n      }\n    }\n\n    // Check if we should early stop based on no improvement\n    if (this.earlyStoppingPatience > 0) {\n      const newSuccessCount = this.traces.length;\n      const improvement = newSuccessCount - previousSuccessCount;\n\n      if (!this.stats.earlyStopping) {\n        this.stats.earlyStopping = {\n          bestScoreRound: improvement > 0 ? roundIndex : 0,\n          patienceExhausted: false,\n          reason: 'No improvement detected',\n        };\n      } else if (improvement > 0) {\n        this.stats.earlyStopping.bestScoreRound = roundIndex;\n      } else if (\n        roundIndex - this.stats.earlyStopping.bestScoreRound >=\n        this.earlyStoppingPatience\n      ) {\n        this.stats.earlyStopping.patienceExhausted = true;\n        this.stats.earlyStopped = true;\n        this.stats.earlyStopping.reason = `No improvement for ${this.earlyStoppingPatience} rounds`;\n\n        return;\n      }\n    }\n  }\n\n  public async compile<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>,\n    examples: readonly AxTypedExample<IN>[],\n    metricFn: AxMetricFn,\n    options?: AxCompileOptions\n  ): Promise<AxOptimizerResult<OUT>> {\n    // Validate examples meet minimum requirements (Bootstrap doesn't split)\n    this.validateExamples(examples, false);\n\n    const maxRounds = options?.maxIterations ?? this.maxRounds;\n    this.traces = [];\n\n    // Reset stats using parent method\n    this.reset();\n\n    for (let i = 0; i < maxRounds; i++) {\n      await this.compileRound(program, examples, i, metricFn, options);\n\n      // Break early if early stopping was triggered\n      if (this.stats.earlyStopped) {\n        break;\n      }\n    }\n\n    if (this.traces.length === 0) {\n      throw new Error(\n        'No demonstrations found. Either provide more examples or improve the existing ones.'\n      );\n    }\n\n    const demos: AxProgramDemos<any, OUT>[] = groupTracesByKeys(this.traces);\n\n    // Calculate best score from traces\n    let bestScore = 0;\n    if (this.traces.length > 0) {\n      // Simple approximation - in a real implementation you'd track scores properly\n      bestScore =\n        this.stats.successfulDemos / Math.max(1, this.stats.totalCalls);\n    }\n\n    // Log human-readable completion message\n    await this.logOptimizationComplete(\n      'BootstrapFewShot',\n      bestScore,\n      {\n        maxRounds: this.maxRounds,\n        maxDemos: this.maxDemos,\n        batchSize: this.batchSize,\n        successRate: bestScore,\n        demosGenerated: demos.length,\n        tracesCollected: this.traces.length,\n      },\n      options\n    );\n\n    return {\n      demos,\n      stats: this.stats,\n      bestScore,\n      finalConfiguration: {\n        maxRounds: this.maxRounds,\n        maxDemos: this.maxDemos,\n        batchSize: this.batchSize,\n        successRate: bestScore,\n      },\n    };\n  }\n}\n\nfunction groupTracesByKeys<IN, OUT>(\n  programTraces: readonly AxProgramTrace<IN, OUT>[]\n): AxProgramDemos<any, any>[] {\n  const groupedTraces = new Map<string, Record<string, AxFieldValue>[]>();\n\n  // Group all traces by their keys\n  for (const programTrace of programTraces) {\n    if (groupedTraces.has(programTrace.programId)) {\n      const traces = groupedTraces.get(programTrace.programId);\n      if (traces) {\n        traces.push(programTrace.trace as any);\n      }\n    } else {\n      groupedTraces.set(programTrace.programId, [programTrace.trace as any]);\n    }\n  }\n\n  // Convert the Map into an array of ProgramDemos\n  const programDemosArray: AxProgramDemos<any, any>[] = [];\n  groupedTraces.forEach((traces, programId) => {\n    programDemosArray.push({\n      traces: traces as unknown as (OUT & IN)[],\n      programId,\n    });\n  });\n\n  return programDemosArray;\n}\n\nconst randomSample = <T>(array: readonly T[], n: number): T[] => {\n  // Clone the array to avoid modifying the original array\n  const clonedArray = [...array];\n  // Shuffle the cloned array\n  for (let i = clonedArray.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const caI = clonedArray[i];\n    const caJ = clonedArray[j];\n\n    if (!caI || !caJ) {\n      throw new Error('Invalid array elements');\n    }\n\n    [clonedArray[i], clonedArray[j]] = [caJ, caI];\n  }\n  // Return the first `n` items of the shuffled array\n  return clonedArray.slice(0, n);\n};\n","// Shared Pareto / multi-objective helpers for GEPA optimizers\n\nexport function dominatesVector(\n  a: Readonly<Record<string, number>>,\n  b: Readonly<Record<string, number>>\n): boolean {\n  const keys = new Set([...Object.keys(a), ...Object.keys(b)]);\n  let atLeastAsGood = true;\n  let strictlyBetter = false;\n  for (const k of keys) {\n    const va = a[k] ?? 0;\n    const vb = b[k] ?? 0;\n    if (va < vb) {\n      atLeastAsGood = false;\n      break;\n    }\n    if (va > vb) strictlyBetter = true;\n  }\n  return atLeastAsGood && strictlyBetter;\n}\n\nexport function dominatesVectorEps(\n  a: Readonly<Record<string, number>>,\n  b: Readonly<Record<string, number>>,\n  eps = 0\n): boolean {\n  const keys = new Set([...Object.keys(a), ...Object.keys(b)]);\n  let atLeastAsGood = true;\n  let strictlyBetter = false;\n  for (const k of keys) {\n    const va = a[k] ?? 0;\n    const vb = b[k] ?? 0;\n    if (va + eps < vb) {\n      atLeastAsGood = false;\n      break;\n    }\n    if (va > vb + eps) strictlyBetter = true;\n  }\n  return atLeastAsGood && strictlyBetter;\n}\n\nexport function buildParetoFront(\n  items: ReadonlyArray<{\n    idx: number;\n    scores: Readonly<Record<string, number>>;\n  }>,\n  eps = 0\n): Array<{\n  idx: number;\n  scores: Readonly<Record<string, number>>;\n  dominated: number;\n}> {\n  const front: Array<{\n    idx: number;\n    scores: Readonly<Record<string, number>>;\n    dominated: number;\n  }> = [];\n  for (let i = 0; i < items.length; i++) {\n    let dominatedCount = 0;\n    let isDominated = false;\n    for (let j = 0; j < items.length; j++) {\n      if (i === j) continue;\n      if (dominatesVectorEps(items[j]!.scores, items[i]!.scores, eps)) {\n        isDominated = true;\n        break;\n      }\n      if (dominatesVectorEps(items[i]!.scores, items[j]!.scores, eps))\n        dominatedCount++;\n    }\n    if (!isDominated)\n      front.push({\n        idx: items[i]!.idx,\n        scores: items[i]!.scores,\n        dominated: dominatedCount,\n      });\n  }\n  return front;\n}\n\nexport function computeCrowdingDistances(\n  front: ReadonlyArray<{\n    idx: number;\n    scores: Readonly<Record<string, number>>;\n  }>\n): Map<number, number> {\n  const dist = new Map<number, number>();\n  if (front.length === 0) return dist;\n  const keys = new Set<string>();\n  for (const f of front) for (const k of Object.keys(f.scores)) keys.add(k);\n  for (const f of front) dist.set(f.idx, 0);\n  for (const key of keys) {\n    const sorted = [...front].sort(\n      (a, b) => (a.scores[key] ?? 0) - (b.scores[key] ?? 0)\n    );\n    const min = sorted[0] ? (sorted[0].scores[key] ?? 0) : 0;\n    const max = sorted[sorted.length - 1]\n      ? (sorted[sorted.length - 1].scores[key] ?? 0)\n      : 0;\n    const range = Math.max(max - min, 1e-9);\n    if (sorted.length > 0) dist.set(sorted[0]!.idx, Number.POSITIVE_INFINITY);\n    if (sorted.length > 1)\n      dist.set(sorted[sorted.length - 1]!.idx, Number.POSITIVE_INFINITY);\n    for (let i = 1; i < sorted.length - 1; i++) {\n      const prev = sorted[i - 1]!.scores[key] ?? 0;\n      const next = sorted[i + 1]!.scores[key] ?? 0;\n      const inc = (next - prev) / range;\n      dist.set(sorted[i]!.idx, (dist.get(sorted[i]!.idx) ?? 0) + inc);\n    }\n  }\n  return dist;\n}\n\nexport function hypervolume2D(\n  front: ReadonlyArray<Readonly<Record<string, number>>>\n): number | undefined {\n  if (front.length === 0) return undefined;\n  const keys = Object.keys(front[0] ?? {});\n  if (keys.length !== 2) return undefined;\n  const [k1, k2] = keys;\n  const sorted = [...front].sort((a, b) => (b[k1!] ?? 0) - (a[k1!] ?? 0));\n  let hv = 0;\n  let prevY = 0;\n  for (const p of sorted) {\n    const x = p[k1!] ?? 0;\n    const y = p[k2!] ?? 0;\n    const dy = Math.max(y - prevY, 0);\n    hv += x * dy;\n    prevY = Math.max(prevY, y);\n  }\n  return hv;\n}\n\nexport function weightedPick<T>(\n  items: readonly T[],\n  weights: readonly number[]\n): T {\n  const sum = weights.reduce((a, b) => a + (Number.isFinite(b) ? b : 0), 0);\n  if (sum <= 0) return items[Math.floor(Math.random() * items.length)]!;\n  let r = Math.random() * sum;\n  for (let i = 0; i < items.length; i++) {\n    const w = Number.isFinite(weights[i]!) ? (weights[i] as number) : 0;\n    if (r < w) return items[i]!;\n    r -= w;\n  }\n  return items[items.length - 1]!;\n}\n\nexport function average(a: readonly number[]): number {\n  if (a.length === 0) return 0;\n  let s = 0;\n  for (const v of a) s += v;\n  return s / a.length;\n}\n\nexport function randomSubset<T>(arr: readonly T[], k: number): T[] {\n  if (k >= arr.length) return [...arr];\n  const picked = new Set<number>();\n  while (picked.size < k) picked.add(Math.floor(Math.random() * arr.length));\n  return Array.from(picked).map((i) => arr[i]!);\n}\n\nexport function selectCandidatePareto(S: number[][]): { index: number } {\n  const nCand = S.length;\n  const nInst = S[0]?.length ?? 0;\n  if (nCand <= 1 || nInst === 0) return { index: 0 };\n\n  const bestPerInst: number[] = new Array(nInst).fill(Number.NEGATIVE_INFINITY);\n  for (let i = 0; i < nInst; i++) {\n    for (let k = 0; k < nCand; k++)\n      bestPerInst[i] = Math.max(bestPerInst[i], S[k]![i]!);\n  }\n\n  const appears: number[] = new Array(nCand).fill(0);\n  for (let i = 0; i < nInst; i++) {\n    for (let k = 0; k < nCand; k++)\n      if (S[k]![i]! === bestPerInst[i]) appears[k]! += 1;\n  }\n\n  const dominated = new Array(nCand).fill(false);\n  for (let a = 0; a < nCand; a++) {\n    for (let b = 0; b < nCand; b++) {\n      if (a === b) continue;\n      let allLe = true;\n      let strictlyLt = false;\n      for (let i = 0; i < nInst; i++) {\n        if (S[a]![i]! > S[b]![i]!) allLe = false;\n        if (S[b]![i]! > S[a]![i]!) strictlyLt = true;\n        if (!allLe) break;\n      }\n      if (allLe && strictlyLt) {\n        dominated[a] = true;\n        break;\n      }\n    }\n  }\n\n  const weights: number[] = [];\n  const indices: number[] = [];\n  for (let k = 0; k < nCand; k++) {\n    if (!dominated[k] && appears[k] > 0) {\n      indices.push(k);\n      weights.push(appears[k]);\n    }\n  }\n  if (indices.length === 0) return { index: Math.floor(Math.random() * nCand) };\n\n  const sumW = weights.reduce((a, b) => a + b, 0);\n  let r = Math.random() * sumW;\n  for (let j = 0; j < indices.length; j++) {\n    if (r < weights[j]!) return { index: indices[j]! };\n    r -= weights[j]!;\n  }\n  return { index: indices[indices.length - 1]! };\n}\n\nexport function avgVec(\n  arrs: ReadonlyArray<Record<string, number>>\n): Record<string, number> {\n  const sums: Record<string, number> = {};\n  const counts: Record<string, number> = {};\n  for (const r of arrs) {\n    for (const [k, v] of Object.entries(r)) {\n      sums[k] = (sums[k] || 0) + (typeof v === 'number' ? v : 0);\n      counts[k] = (counts[k] || 0) + 1;\n    }\n  }\n  const out: Record<string, number> = {};\n  for (const [k, s] of Object.entries(sums))\n    out[k] = s / Math.max(counts[k] || 1, 1);\n  return out;\n}\n\n// ===== GEPA instance-front utilities (align with reference) =====\n\nexport function removeDominatedProgramsByInstanceFronts(\n  fronts: ReadonlyArray<Readonly<Set<number>>>,\n  scores: ReadonlyArray<number>\n): Array<Set<number>> {\n  // Gather all program indices present in any front\n  const allPrograms = new Set<number>();\n  for (const f of fronts) for (const p of f) allPrograms.add(p);\n  const programs = Array.from(allPrograms);\n\n  // Sort ascending by aggregate score (like reference)\n  const sorted = [...programs].sort(\n    (a, b) => (scores[a] ?? 0) - (scores[b] ?? 0)\n  );\n\n  const dominated = new Set<number>();\n\n  const isDominated = (y: number, others: ReadonlySet<number>): boolean => {\n    // y is dominated if for every front that contains y, there exists\n    // at least one program from 'others' that is also in that front\n    for (const front of fronts) {\n      if (!front.has(y)) continue;\n      let found = false;\n      for (const o of others) {\n        if (front.has(o)) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) return false; // in this front, no dominator present\n    }\n    return true;\n  };\n\n  let progress = true;\n  while (progress) {\n    progress = false;\n    for (const y of sorted) {\n      if (dominated.has(y)) continue;\n      const others = new Set(\n        sorted.filter((p) => p !== y && !dominated.has(p))\n      );\n      if (isDominated(y, others)) {\n        dominated.add(y);\n        progress = true;\n        break;\n      }\n    }\n  }\n\n  const dominators = sorted.filter((p) => !dominated.has(p));\n  const dominatorSet = new Set(dominators);\n\n  // Filter each front to only include dominators\n  return fronts.map((front) => {\n    const nf = new Set<number>();\n    for (const p of front) if (dominatorSet.has(p)) nf.add(p);\n    return nf;\n  });\n}\n\nexport function selectProgramCandidateFromInstanceFronts(\n  fronts: ReadonlyArray<Readonly<Set<number>>>,\n  scores: ReadonlyArray<number>,\n  rng?: () => number\n): number {\n  const reduced = removeDominatedProgramsByInstanceFronts(fronts, scores);\n  const freq: Record<number, number> = {};\n  for (const f of reduced) {\n    for (const p of f) freq[p] = (freq[p] || 0) + 1;\n  }\n  const sampling: number[] = [];\n  for (const [pStr, count] of Object.entries(freq)) {\n    const p = Number(pStr);\n    for (let k = 0; k < count; k++) sampling.push(p);\n  }\n  if (sampling.length === 0) return 0;\n  const r = typeof rng === 'function' ? rng() : Math.random();\n  const idx = Math.floor(r * sampling.length);\n  return sampling[idx]!;\n}\n","import type { AxAIService } from '../../ai/types.js';\nimport type {\n  AxCompileOptions,\n  AxExample,\n  AxMetricFn,\n  AxMultiMetricFn,\n  AxOptimizerArgs,\n  AxTypedExample,\n} from '../common_types.js';\nimport type { AxGen } from '../generate.js';\nimport {\n  AxBaseOptimizer,\n  type AxParetoResult,\n  AxOptimizedProgramImpl,\n} from '../optimizer.js';\nimport type { AxGenOut } from '../types.js';\nimport { ax } from '../template.js';\nimport {\n  buildParetoFront,\n  hypervolume2D,\n  average,\n  avgVec,\n  selectProgramCandidateFromInstanceFronts,\n  removeDominatedProgramsByInstanceFronts,\n} from './paretoUtils.js';\nimport type { AxGEPAAdapter } from './gepaAdapter.js';\n\n/** Single-module GEPA (reflective prompt evolution with Pareto sampling) */\nexport class AxGEPA extends AxBaseOptimizer {\n  // Core knobs\n  private numTrials: number;\n  private minibatch: boolean;\n  private minibatchSize: number;\n  private earlyStoppingTrials: number;\n  private minImprovementThreshold: number;\n  private sampleCount: number;\n  private paretoSetSize: number;\n\n  // GEPA+ enhancements\n  private crossoverEvery: number;\n  private tieEpsilon: number;\n  private feedbackMemorySize: number;\n  private feedbackMemory: string[] = [];\n  private mergeMax: number;\n  private mergesUsed = 0;\n  private mergesDue = 0;\n  private totalMergesTested = 0;\n  private lastIterFoundNewProgram = false;\n  private mergeAttemptKeys = new Set<string>();\n  private mergeCompositionKeys = new Set<string>();\n\n  private rngState: number = 123456789;\n  private samplerState: {\n    epoch: number;\n    shuffled: number[];\n    freq: Map<number, number>;\n  } = {\n    epoch: -1,\n    shuffled: [],\n    freq: new Map(),\n  };\n\n  // Local histories for result object\n  private localScoreHistory: number[] = [];\n  private localConfigurationHistory: Record<string, unknown>[] = [];\n\n  constructor(args: Readonly<AxOptimizerArgs>) {\n    super(args);\n\n    const seedRaw = (args as any)?.seed;\n    const seedNum = Number.isFinite(seedRaw) ? Math.floor(Number(seedRaw)) : 0;\n    this.rngState = seedNum && seedNum !== 0 ? seedNum : 123456789;\n\n    this.numTrials = args.numTrials ?? 30;\n    this.minibatch = args.minibatch ?? true;\n    this.minibatchSize = args.minibatchSize ?? 20;\n    this.earlyStoppingTrials = args.earlyStoppingTrials ?? 5;\n    this.minImprovementThreshold = args.minImprovementThreshold ?? 0.0;\n    this.sampleCount = args.sampleCount ?? 1;\n    // How many validation instances to track for Pareto set (cap cost)\n    const argPareto = (args as any)?.paretoSetSize as number | undefined;\n    this.paretoSetSize =\n      argPareto && argPareto > 0\n        ? Math.min(1000, Math.max(5, Math.floor(argPareto)))\n        : Math.max(10, Math.min(200, this.minibatchSize * 3));\n\n    // GEPA+ defaults\n    const argCrossoverEvery = (args as any)?.crossoverEvery as\n      | number\n      | undefined;\n    this.crossoverEvery = Math.max(\n      0,\n      Math.floor(\n        argCrossoverEvery ?? Math.max(3, Math.floor(this.numTrials / 4))\n      )\n    );\n    const argTieEps = (args as any)?.tieEpsilon as number | undefined;\n    this.tieEpsilon = Number.isFinite(argTieEps!) ? (argTieEps as number) : 0;\n    const argFbMem = (args as any)?.feedbackMemorySize as number | undefined;\n    this.feedbackMemorySize = Math.max(0, Math.floor(argFbMem ?? 4));\n    const argMergeMax = (args as any)?.mergeMax as number | undefined;\n    this.mergeMax = Math.max(0, Math.floor(argMergeMax ?? 0));\n    this.mergesUsed = 0;\n\n    // Hook convergence threshold to base stats\n    this.stats.convergenceInfo.convergenceThreshold =\n      this.minImprovementThreshold;\n  }\n\n  public override reset(): void {\n    super.reset();\n    this.stats.convergenceInfo.convergenceThreshold =\n      this.minImprovementThreshold;\n    this.localScoreHistory = [];\n    this.localConfigurationHistory = [];\n    this.feedbackMemory = [];\n    this.mergesUsed = 0;\n    this.mergesDue = 0;\n    this.totalMergesTested = 0;\n    this.lastIterFoundNewProgram = false;\n    this.mergeAttemptKeys.clear();\n    this.mergeCompositionKeys.clear();\n    this.samplerState.epoch = -1;\n    this.samplerState.shuffled = [];\n    this.samplerState.freq.clear();\n  }\n\n  /**\n   * Multi-objective GEPA: reflective evolution with Pareto frontier\n   */\n  public async compile<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>,\n    examples: readonly AxTypedExample<IN>[],\n    metricFn: AxMetricFn,\n    options?: AxCompileOptions\n  ): Promise<AxParetoResult<OUT>> {\n    const _startTime = Date.now();\n    this.validateExamples(examples);\n    if (options?.auto) this.configureAuto(options.auto);\n\n    const validationExamples = (options as any)?.validationExamples as\n      | readonly AxTypedExample<IN>[]\n      | undefined;\n    const feedbackExamples = (options as any)?.feedbackExamples as\n      | readonly AxTypedExample<IN>[]\n      | undefined;\n\n    const paretoSet = (\n      validationExamples && validationExamples.length > 0\n        ? validationExamples\n        : examples\n    ).slice(0, this.paretoSetSize);\n\n    const feedbackSet =\n      feedbackExamples && feedbackExamples.length > 0\n        ? feedbackExamples\n        : examples;\n\n    // Evaluate one example -> objective vector\n    const evalOne = async (\n      instruction: string,\n      ex: Readonly<AxTypedExample<IN>>\n    ): Promise<Record<string, number>> => {\n      try {\n        (program as any).setInstruction?.(instruction);\n        const prediction = await program.forward(\n          this.studentAI,\n          ex as IN,\n          {\n            sampleCount: this.sampleCount,\n          } as any\n        );\n        this.stats.totalCalls += 1;\n        const scores = await (metricFn as unknown as AxMultiMetricFn)({\n          prediction,\n          example: ex as any,\n        });\n        return scores || {};\n      } catch {\n        return {};\n      }\n    };\n\n    // Evaluate on set -> average vector\n    const evalOnSet = async (\n      instruction: string,\n      set: readonly AxTypedExample<IN>[]\n    ): Promise<Record<string, number>> => {\n      const vecs: Record<string, number>[] = [];\n      for (const ex of set) vecs.push(await evalOne(instruction, ex));\n      return avgVec(vecs);\n    };\n\n    // Start with base instruction\n    const baseInstruction = await this.getBaseInstruction(program);\n    const candidates: {\n      instruction: string;\n      parent?: number;\n      scores: Record<string, number>;\n    }[] = [\n      {\n        instruction: baseInstruction,\n        parent: undefined,\n        scores: await evalOnSet(baseInstruction, paretoSet),\n      },\n    ];\n\n    // Scalarizer for multi-metric vectors\n    const scalarize = (v: Readonly<Record<string, number>>): number => {\n      const key = (options as any)?.paretoMetricKey as string | undefined;\n      const fn = (options as any)?.paretoScalarize as\n        | ((scores: Readonly<Record<string, number>>) => number)\n        | undefined;\n      if (typeof fn === 'function') return fn(v);\n      if (key)\n        return Number.isFinite(v[key] as number) ? (v[key] as number) : 0;\n      const vals = Object.values(v);\n      return vals.length ? vals.reduce((a, b) => a + b, 0) / vals.length : 0;\n    };\n\n    // Track per-instance scalar scores on the validation/Pareto set for Algorithm 2 selection\n    const perInstanceScores: number[][] = [];\n    const evalOnSetScalar = async (\n      instruction: string,\n      set: readonly AxTypedExample<IN>[]\n    ): Promise<number[]> => {\n      const out: number[] = [];\n      for (const ex of set) {\n        const vec = await evalOne(instruction, ex);\n        out.push(scalarize(vec));\n      }\n      return out;\n    };\n    perInstanceScores.push(await evalOnSetScalar(baseInstruction, paretoSet));\n\n    // Parent selection helper via instance-front frequency (source-style)\n    const _selectParentIdx = (): number => {\n      const nInst = perInstanceScores[0]?.length ?? 0;\n      const instanceFronts: Array<Set<number>> = [];\n      for (let i = 0; i < nInst; i++) {\n        let best = Number.NEGATIVE_INFINITY;\n        const front = new Set<number>();\n        for (let k = 0; k < perInstanceScores.length; k++) {\n          const v = perInstanceScores[k]![i]!;\n          if (v > best + this.tieEpsilon) {\n            best = v;\n            front.clear();\n            front.add(k);\n          } else if (Math.abs(v - best) <= this.tieEpsilon) {\n            front.add(k);\n          }\n        }\n        instanceFronts.push(front);\n      }\n      const perProgScores = perInstanceScores.map((arr) => average(arr));\n      return selectProgramCandidateFromInstanceFronts(\n        instanceFronts,\n        perProgScores\n      );\n    };\n\n    const optLogger = this.getOptimizerLogger(options);\n    optLogger?.({\n      name: 'OptimizationStart',\n      value: {\n        optimizerType: 'GEPA',\n        exampleCount: examples.length,\n        validationCount: paretoSet.length,\n        config: { numTrials: this.numTrials, minibatch: this.minibatch },\n      },\n    });\n\n    let stagnation = 0;\n\n    // Initialize Pareto archive (indices into candidates)\n    let archive = buildParetoFront(\n      candidates.map((c, idx) => ({ idx, scores: c.scores })),\n      this.tieEpsilon\n    ).map((p) => p.idx);\n\n    let _prevHypervolume: number | undefined;\n    const rolloutBudgetParetoRaw = (options as any)?.maxMetricCalls as number;\n    if (\n      !Number.isFinite(rolloutBudgetParetoRaw) ||\n      rolloutBudgetParetoRaw <= 0\n    ) {\n      throw new Error(\n        'AxGEPA: options.maxMetricCalls must be set to a positive integer'\n      );\n    }\n    const rolloutBudgetPareto = Math.floor(rolloutBudgetParetoRaw);\n\n    for (let t = 0; t < this.numTrials; t++) {\n      if (\n        rolloutBudgetPareto !== undefined &&\n        this.stats.totalCalls >= Math.max(1, Math.floor(rolloutBudgetPareto))\n      ) {\n        break;\n      }\n      // Parent selection via per-instance fronts (frequency sampling)\n      const nInst = perInstanceScores[0]?.length ?? 0;\n      const instanceFronts: Array<Set<number>> = [];\n      for (let i = 0; i < nInst; i++) {\n        let best = Number.NEGATIVE_INFINITY;\n        const front = new Set<number>();\n        for (let k = 0; k < perInstanceScores.length; k++) {\n          const v = perInstanceScores[k]![i]!;\n          if (v > best + this.tieEpsilon) {\n            best = v;\n            front.clear();\n            front.add(k);\n          } else if (Math.abs(v - best) <= this.tieEpsilon) {\n            front.add(k);\n          }\n        }\n        instanceFronts.push(front);\n      }\n      const perProgScores = perInstanceScores.map((arr) => average(arr));\n\n      // Scheduled merge attempt (parity with source) before reflective\n      if (\n        this.mergeMax > 0 &&\n        this.mergesDue > 0 &&\n        this.lastIterFoundNewProgram\n      ) {\n        const ancestors = (idx: number): number[] => {\n          const path: number[] = [];\n          let cur: number | undefined = idx;\n          while (cur !== undefined) {\n            path.push(cur);\n            cur = candidates[cur]?.parent;\n          }\n          return path;\n        };\n        const rngPick = <T>(arr: readonly T[]): T | undefined =>\n          arr.length ? arr[Math.floor(this.rand() * arr.length)]! : undefined;\n        // Merge candidates = union of reduced instance fronts\n        const reducedFronts = removeDominatedProgramsByInstanceFronts(\n          instanceFronts,\n          perProgScores\n        );\n        const mergeCandidatesSet = new Set<number>();\n        for (const f of reducedFronts)\n          for (const p of f) mergeCandidatesSet.add(p);\n        const mergeCandidates = Array.from(mergeCandidatesSet);\n\n        let picked: { i: number; j: number; a: number } | undefined;\n        for (let attempts = 0; attempts < 10 && !picked; attempts++) {\n          if (mergeCandidates.length < 2) break;\n          let i = rngPick(mergeCandidates)!;\n          let j = rngPick(mergeCandidates)!;\n          if (i === j) continue;\n          if (j < i) [i, j] = [j, i];\n          const Ai = new Set(ancestors(i));\n          const Aj = new Set(ancestors(j));\n          if (Ai.has(j) || Aj.has(i)) continue;\n          const commons = [...Ai].filter((x) => Aj.has(x));\n          if (commons.length === 0) continue;\n          // Choose ancestor weighted by valset agg score\n          const weights = commons.map((a) => Math.max(1e-9, perProgScores[a]!));\n          let r = this.rand() * weights.reduce((s, w) => s + w, 0);\n          let a = commons[commons.length - 1]!;\n          for (let idx = 0; idx < commons.length; idx++) {\n            if (r < weights[idx]!) {\n              a = commons[idx]!;\n              break;\n            }\n            r -= weights[idx]!;\n          }\n          picked = { i, j, a };\n        }\n\n        // Clear scheduling flag before reflective attempt (parity)\n        this.lastIterFoundNewProgram = false;\n\n        if (picked) {\n          const { i, j, a } = picked;\n          // Ancestor guard + desirability filter for single-component merge\n          const Sa = perProgScores[a]!;\n          const Si = perProgScores[i]!;\n          const Sj = perProgScores[j]!;\n          const instrA = candidates[a]!.instruction;\n          const instrI = candidates[i]!.instruction;\n          const instrJ = candidates[j]!.instruction;\n          const desirable =\n            (instrI === instrA && instrJ !== instrI) ||\n            (instrJ === instrA && instrI !== instrJ);\n          let allowed = Sa <= Math.min(Si, Sj) && desirable;\n          let childInstrMerged = '';\n          let descSig: 'i' | 'j' = 'i';\n          let attempted = false;\n          if (allowed) {\n            const triKey = `${i}|${j}|${a}`;\n            if (this.mergeAttemptKeys.has(triKey)) {\n              allowed = false;\n            } else {\n              if (instrI === instrA && instrJ !== instrI) {\n                childInstrMerged = instrJ;\n                descSig = 'j';\n              } else if (instrJ === instrA && instrI !== instrJ) {\n                childInstrMerged = instrI;\n                descSig = 'i';\n              } else if (\n                instrI !== instrA &&\n                instrJ !== instrA &&\n                instrI !== instrJ\n              ) {\n                if (Si > Sj || (Si === Sj && this.rand() < 0.5)) {\n                  childInstrMerged = instrI;\n                  descSig = 'i';\n                } else {\n                  childInstrMerged = instrJ;\n                  descSig = 'j';\n                }\n              } else {\n                childInstrMerged = instrI;\n                descSig = 'i';\n              }\n              const compKey = `${Math.min(i, j)}|${Math.max(i, j)}|${descSig}`;\n              if (this.mergeCompositionKeys.has(compKey)) {\n                allowed = false;\n              } else {\n                this.mergeAttemptKeys.add(triKey);\n                this.mergeCompositionKeys.add(compKey);\n                // Targeted subsample selection on validation set\n                const s1 = perInstanceScores[i]!;\n                const s2 = perInstanceScores[j]!;\n                const allIdx = Array.from({ length: s1.length }, (_, z) => z);\n                const p1 = allIdx.filter((z) => (s1[z] ?? 0) > (s2[z] ?? 0));\n                const p2 = allIdx.filter((z) => (s2[z] ?? 0) > (s1[z] ?? 0));\n                const p3 = allIdx.filter(\n                  (z) => !(p1.includes(z) || p2.includes(z))\n                );\n                const K = 5;\n                const nEach = Math.ceil(K / 3);\n                const pickSome = (arr: number[], k: number): number[] => {\n                  if (k <= 0 || arr.length === 0) return [];\n                  if (arr.length <= k) return [...arr];\n                  const out: number[] = [];\n                  const used = new Set<number>();\n                  while (out.length < k) {\n                    const idx = Math.floor(this.rand() * arr.length);\n                    if (!used.has(idx)) {\n                      used.add(idx);\n                      out.push(arr[idx]!);\n                    }\n                  }\n                  return out;\n                };\n                const chosen: number[] = [];\n                chosen.push(...pickSome(p1, Math.min(nEach, p1.length)));\n                chosen.push(...pickSome(p2, Math.min(nEach, p2.length)));\n                const rem = K - chosen.length;\n                chosen.push(...pickSome(p3, Math.max(0, rem)));\n                const remaining = K - chosen.length;\n                if (remaining > 0) {\n                  const unused = allIdx.filter((z) => !chosen.includes(z));\n                  chosen.push(\n                    ...pickSome(unused, Math.min(remaining, unused.length))\n                  );\n                }\n                const idxs = chosen.slice(0, Math.min(K, allIdx.length));\n\n                const subsample = idxs.map((z) => paretoSet[z]!);\n                attempted = true;\n                const newSubArr = await evalOnSetScalar(\n                  childInstrMerged,\n                  subsample\n                );\n                const newSum = newSubArr.reduce((a, b) => a + b, 0);\n                const id1Sum = idxs.reduce((a, z) => a + (s1[z] ?? 0), 0);\n                const id2Sum = idxs.reduce((a, z) => a + (s2[z] ?? 0), 0);\n\n                if (newSum >= Math.max(id1Sum, id2Sum) + this.tieEpsilon) {\n                  const childVec = await evalOnSet(childInstrMerged, paretoSet);\n                  candidates.push({\n                    instruction: childInstrMerged,\n                    parent: a,\n                    scores: childVec,\n                  });\n                  perInstanceScores.push(\n                    await evalOnSetScalar(childInstrMerged, paretoSet)\n                  );\n                  const beforeSize = archive.length;\n                  const hvBefore =\n                    hypervolume2D(\n                      archive.map((idx) => candidates[idx]!.scores)\n                    ) ?? 0;\n                  archive = buildParetoFront(\n                    candidates.map((c, idx) => ({ idx, scores: c.scores })),\n                    this.tieEpsilon\n                  ).map((p) => p.idx);\n                  const hvAfter =\n                    hypervolume2D(\n                      archive.map((idx) => candidates[idx]!.scores)\n                    ) ?? 0;\n                  if (\n                    archive.length > beforeSize ||\n                    hvAfter > hvBefore + 1e-6\n                  ) {\n                    stagnation = 0;\n                  }\n                  this.mergesDue -= 1;\n                  this.totalMergesTested += 1;\n                }\n              }\n            }\n          }\n          if (attempted) {\n            // Skip reflective this iteration\n            continue;\n          }\n        }\n      }\n\n      const parentIdx = selectProgramCandidateFromInstanceFronts(\n        instanceFronts,\n        perProgScores,\n        () => this.rand()\n      );\n\n      const mini = this.minibatch\n        ? this.nextMinibatchIndices(feedbackSet.length, t).map(\n            (z: number) => feedbackSet[z]!\n          )\n        : feedbackSet;\n\n      // Skip reflection if all minibatch scores are perfect (default: true)\n      if ((options as any)?.skipPerfectScore ?? true) {\n        const perfect = Number((options as any)?.perfectScore ?? 1);\n        const parentMiniScores = await evalOnSetScalar(\n          candidates[parentIdx]!.instruction,\n          mini\n        );\n        if (\n          parentMiniScores.length > 0 &&\n          parentMiniScores.every((s) => s >= perfect)\n        ) {\n          continue;\n        }\n      }\n\n      const useMerge = false as const;\n\n      let childInstr = candidates[parentIdx]!.instruction;\n      let strategy: 'reflective_mutation' | 'merge' = 'reflective_mutation';\n      // For adapter-based strict acceptance\n      let adapterParentSum: number | undefined;\n      let adapterChildSum: number | undefined;\n\n      if (useMerge) {\n        const second = (parentIdx + 1) % candidates.length;\n        childInstr = await this.mergeInstructions(\n          candidates[parentIdx]!.instruction,\n          candidates[second]!.instruction,\n          options\n        );\n        strategy = 'merge';\n        this.mergesUsed += 1;\n      } else {\n        const adapter = (options as any)?.gepaAdapter as\n          | AxGEPAAdapter\n          | undefined;\n        if (adapter) {\n          try {\n            const parentMap = {\n              instruction: candidates[parentIdx]!.instruction,\n            };\n            const evalParent = await adapter.evaluate(\n              mini as any,\n              parentMap,\n              true\n            );\n            adapterParentSum = Array.isArray(evalParent?.scores)\n              ? evalParent.scores.reduce((a, b) => a + (Number(b) || 0), 0)\n              : undefined;\n            const reflDs = adapter.make_reflective_dataset(\n              parentMap,\n              evalParent as any,\n              ['instruction']\n            );\n            const proposedMap = await (adapter.propose_new_texts?.(\n              parentMap,\n              reflDs,\n              ['instruction']\n            ) as any);\n            const proposedText =\n              proposedMap?.instruction ??\n              (proposedMap\n                ? (Object.values(proposedMap)[0] as any)\n                : undefined);\n            if (typeof proposedText === 'string' && proposedText.length > 0) {\n              childInstr = proposedText;\n            } else {\n              childInstr = await this.reflectInstruction(\n                candidates[parentIdx]!.instruction,\n                program,\n                mini,\n                async ({ prediction, example }) => {\n                  const scores = await (metricFn as unknown as AxMultiMetricFn)(\n                    {\n                      prediction,\n                      example,\n                    }\n                  );\n                  const vals = Object.values(scores || {});\n                  return vals.length\n                    ? vals.reduce((a, b) => a + b, 0) / vals.length\n                    : 0;\n                },\n                options\n              );\n            }\n          } catch {\n            childInstr = await this.reflectInstruction(\n              candidates[parentIdx]!.instruction,\n              program,\n              mini,\n              async ({ prediction, example }) => {\n                const scores = await (metricFn as unknown as AxMultiMetricFn)({\n                  prediction,\n                  example,\n                });\n                const vals = Object.values(scores || {});\n                return vals.length\n                  ? vals.reduce((a, b) => a + b, 0) / vals.length\n                  : 0;\n              },\n              options\n            );\n          }\n          if (adapterParentSum !== undefined) {\n            try {\n              const evalChild = await adapter.evaluate(\n                mini as any,\n                { instruction: childInstr },\n                false\n              );\n              adapterChildSum = Array.isArray(evalChild?.scores)\n                ? evalChild.scores.reduce((a, b) => a + (Number(b) || 0), 0)\n                : undefined;\n            } catch {}\n          }\n        } else {\n          childInstr = await this.reflectInstruction(\n            candidates[parentIdx]!.instruction,\n            program,\n            mini,\n            async ({ prediction, example }) => {\n              const scores = await (metricFn as unknown as AxMultiMetricFn)({\n                prediction,\n                example,\n              });\n              const vals = Object.values(scores || {});\n              return vals.length\n                ? vals.reduce((a, b) => a + b, 0) / vals.length\n                : 0;\n            },\n            options\n          );\n        }\n      }\n\n      const parentMiniArr = await evalOnSetScalar(\n        candidates[parentIdx]!.instruction,\n        mini\n      );\n      const childMiniArr = await evalOnSetScalar(childInstr, mini);\n      const parentMiniSum = parentMiniArr.reduce((a, b) => a + b, 0);\n      const childMiniSum = childMiniArr.reduce((a, b) => a + b, 0);\n\n      this.currentRound = t + 1;\n      await this.updateOptimizationProgress(\n        this.currentRound,\n        childMiniSum,\n        {\n          instructionLen: childInstr.length,\n          parent: parentIdx,\n          totalRounds: this.numTrials,\n        },\n        'GEPA',\n        { strategy, paretoSetSize: paretoSet.length },\n        childMiniSum,\n        {\n          instructionLen: candidates[parentIdx]!.instruction.length,\n          idx: parentIdx,\n        },\n        { ...(options ?? {}), maxIterations: this.numTrials }\n      );\n\n      const accepted =\n        childMiniSum > parentMiniSum + this.tieEpsilon &&\n        (adapterParentSum === undefined ||\n          adapterChildSum === undefined ||\n          adapterChildSum > adapterParentSum + this.tieEpsilon);\n      if (!accepted) {\n        if (++stagnation >= this.earlyStoppingTrials) break;\n        continue;\n      }\n\n      // Full evaluation on validation set (vector) and archive update\n      const childVec = await evalOnSet(childInstr, paretoSet);\n      candidates.push({\n        instruction: childInstr,\n        parent: parentIdx,\n        scores: childVec,\n      });\n      // Store per-instance scalar scores for Algorithm 2 selection\n      perInstanceScores.push(await evalOnSetScalar(childInstr, paretoSet));\n\n      const beforeSize = archive.length;\n      const hvBefore =\n        hypervolume2D(archive.map((idx) => candidates[idx]!.scores)) ?? 0;\n      archive = buildParetoFront(\n        candidates.map((c, idx) => ({ idx, scores: c.scores })),\n        this.tieEpsilon\n      ).map((p) => p.idx);\n      const hvAfter =\n        hypervolume2D(archive.map((idx) => candidates[idx]!.scores)) ?? 0;\n\n      // Reset stagnation if archive improved (hypervolume or size)\n      if (archive.length > beforeSize || hvAfter > hvBefore + 1e-6) {\n        stagnation = 0;\n      } else {\n        stagnation++;\n        if (stagnation >= this.earlyStoppingTrials) break;\n      }\n      // Schedule merge attempt for next iteration (parity)\n      this.lastIterFoundNewProgram = true;\n      if (this.mergeMax > 0 && this.totalMergesTested < this.mergeMax) {\n        this.mergesDue += 1;\n      }\n    }\n\n    // Build Pareto frontier of candidate average vectors\n    const pareto = buildParetoFront(\n      candidates.map((c, idx) => ({\n        idx,\n        scores: c.scores,\n      })),\n      this.tieEpsilon\n    );\n\n    // Pick bestScore as max scalarized score on frontier\n    const bestScore =\n      pareto.length > 0\n        ? Math.max(...pareto.map((p) => scalarize(p.scores)))\n        : 0;\n\n    // Identify best candidate on the front (by scalarized score)\n    let bestCandidateIdx: number | undefined;\n    if (pareto.length > 0) {\n      let maxS = Number.NEGATIVE_INFINITY;\n      for (const p of pareto) {\n        const s = scalarize(p.scores);\n        if (s > maxS) {\n          maxS = s;\n          bestCandidateIdx = p.idx;\n        }\n      }\n    }\n\n    // Compute hypervolume (2D only)\n    const hv = hypervolume2D(pareto.map((p) => p.scores));\n\n    this.stats.convergenceInfo.converged = true;\n\n    // Record metrics for monitoring\n    this.recordParetoMetrics(pareto.length, candidates.length, 'GEPA', hv);\n\n    // Build a unified optimized program (mirrors MiPRO) for the selected best candidate\n    const optimizationTime = Date.now() - _startTime;\n    const optimizedProgram =\n      typeof bestCandidateIdx === 'number'\n        ? new AxOptimizedProgramImpl<OUT>({\n            bestScore,\n            stats: this.stats,\n            instruction: candidates[bestCandidateIdx]!.instruction,\n            demos: [],\n            examples: examples as unknown as any[],\n            modelConfig: undefined,\n            optimizerType: 'GEPA',\n            optimizationTime,\n            totalRounds: this.numTrials,\n            converged: this.stats.convergenceInfo.converged,\n          })\n        : undefined;\n\n    // Generate optimization insights report\n    this.generateOptimizationReport(pareto, hv, bestScore);\n\n    return {\n      demos: [],\n      stats: this.stats,\n      bestScore,\n      paretoFront: pareto.map((p) => ({\n        demos: [],\n        scores: p.scores,\n        configuration: { candidate: p.idx },\n        dominatedSolutions: p.dominated,\n      })),\n      paretoFrontSize: pareto.length,\n      hypervolume: hv,\n      finalConfiguration: {\n        strategy: 'gepa',\n        candidates: candidates.length,\n      },\n      // Extra field (not part of AxParetoResult): unified optimized program for easy save/apply\n      optimizedProgram,\n    } as AxParetoResult<OUT>;\n  }\n\n  /** Lightweight auto presets */\n  public configureAuto(level: 'light' | 'medium' | 'heavy'): void {\n    switch (level) {\n      case 'light':\n        this.numTrials = 10;\n        this.minibatch = true;\n        this.minibatchSize = 15;\n        break;\n      case 'medium':\n        this.numTrials = 20;\n        this.minibatch = true;\n        this.minibatchSize = 25;\n        break;\n      case 'heavy':\n        this.numTrials = 35;\n        this.minibatch = true;\n        this.minibatchSize = 35;\n        break;\n    }\n  }\n\n  // --- Helpers ---\n\n  private async getBaseInstruction<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>\n  ): Promise<string> {\n    try {\n      // If program exposes instruction via signature, prefer it\n      const sig: any = program.getSignature?.();\n      if (\n        sig &&\n        typeof sig.instruction === 'string' &&\n        sig.instruction.length > 0\n      ) {\n        return sig.instruction as string;\n      }\n    } catch {}\n    return 'Follow the task precisely. Be concise, correct, and consistent.';\n  }\n\n  private async evaluateOnSet<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>,\n    instruction: string,\n    set: readonly AxTypedExample<IN>[],\n    metricFn: AxMetricFn\n  ): Promise<number[]> {\n    const out: number[] = [];\n    for (const ex of set) {\n      const s = await this.evaluateOne(program, instruction, ex, metricFn);\n      out.push(s);\n    }\n    return out;\n  }\n\n  private async evaluateAvg<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>,\n    instruction: string,\n    set: readonly AxTypedExample<IN>[],\n    metricFn: AxMetricFn\n  ): Promise<number> {\n    const arr = await this.evaluateOnSet(program, instruction, set, metricFn);\n    return arr.length > 0 ? average(arr) : 0;\n  }\n\n  private async evaluateOne<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>,\n    instruction: string,\n    example: Readonly<AxTypedExample<IN>>,\n    metricFn: AxMetricFn\n  ): Promise<number> {\n    try {\n      // Apply instruction (best-effort) before calling forward\n      (program as any).setInstruction?.(instruction);\n\n      const prediction = await program.forward(\n        this.studentAI,\n        example as IN,\n        {\n          sampleCount: this.sampleCount,\n          // Use the base default majority-picker from MiPRO if available via AxBaseOptimizer\n          // leave undefined to use program/model defaults when sampleCount===1\n        } as any\n      );\n\n      this.stats.totalCalls += 1;\n      const score = await metricFn({\n        prediction,\n        example: example as AxExample,\n      });\n      if (typeof score === 'number' && !Number.isNaN(score)) {\n        const threshold =\n          typeof this.targetScore === 'number' ? this.targetScore : 0.5;\n        if (score >= threshold) this.stats.successfulDemos += 1;\n        return score;\n      }\n      return 0;\n    } catch (err) {\n      const logger = this.getLogger();\n      logger?.({ name: 'Notification', id: 'gepa_eval', value: String(err) });\n      return 0;\n    }\n  }\n\n  private async reflectInstruction<IN, OUT extends AxGenOut>(\n    currentInstruction: string,\n    program: Readonly<AxGen<IN, OUT>>,\n    minibatch: readonly AxTypedExample<IN>[],\n    metricFn: AxMetricFn,\n    options?: AxCompileOptions\n  ): Promise<string> {\n    // Collect quick feedback tuples from minibatch\n    const tuples: Array<{\n      input: AxExample;\n      prediction: unknown;\n      score: number;\n    }> = [];\n    for (const ex of minibatch) {\n      try {\n        (program as any).setInstruction?.(currentInstruction);\n        const pred = await program.forward(\n          this.studentAI,\n          ex as IN,\n          {\n            sampleCount: this.sampleCount,\n          } as any\n        );\n        this.stats.totalCalls += 1;\n        const score = await metricFn({\n          prediction: pred,\n          example: ex as AxExample,\n        });\n        tuples.push({\n          input: ex as AxExample,\n          prediction: pred,\n          score: typeof score === 'number' ? score : 0,\n        });\n      } catch {\n        tuples.push({ input: ex as AxExample, prediction: {}, score: 0 });\n      }\n    }\n\n    const aiToUse: AxAIService =\n      (options as any)?.overrideTeacherAI ?? this.teacherAI ?? this.studentAI;\n\n    // Summarize feedback and maintain short memory\n    const critic = ax(\n      `minibatch:json \"Array of {input,prediction,score}\", evalFeedback?:string[] \"Evaluator feedback per case if available\" -> feedbackSummary:string \"Concise feedback: common errors, missing constraints, desired changes\"`\n    );\n\n    // Optional: external feedback f\n    const externalFeedback: string[] = [];\n    const feedbackFn:\n      | ((\n          arg: Readonly<{ prediction: any; example: AxExample }>\n        ) => string | string[] | undefined)\n      | undefined = (options as any)?.feedbackFn;\n    if (typeof feedbackFn === 'function') {\n      for (let i = 0; i < tuples.length; i++) {\n        try {\n          const fb = feedbackFn({\n            prediction: tuples[i]!.prediction,\n            example: tuples[i]!.input,\n          });\n          if (fb) {\n            if (Array.isArray(fb)) externalFeedback.push(...fb);\n            else externalFeedback.push(fb);\n          }\n        } catch {}\n      }\n    }\n\n    let feedbackSummary = '';\n    try {\n      const out = (await critic.forward(aiToUse, {\n        minibatch: tuples,\n        evalFeedback: externalFeedback,\n      } as any)) as any;\n      feedbackSummary =\n        (out?.feedbackSummary as string | undefined)?.trim() || '';\n      if (feedbackSummary) {\n        this.feedbackMemory.unshift(feedbackSummary);\n        if (this.feedbackMemory.length > this.feedbackMemorySize)\n          this.feedbackMemory.pop();\n      }\n    } catch {}\n\n    // Use a small reflective update program to produce an improved instruction\n    const refl = ax(\n      `currentInstruction:string \"Current instruction\", feedbackSummary?:string \"Summarized feedback\", recentFeedback?:string[] \"Past feedback memory\", minibatch:json \"Array of {input,prediction,score}\" -> newInstruction:string \"Improved instruction within 1-6 sentences.\"`\n    );\n\n    try {\n      const out = (await refl.forward(aiToUse, {\n        currentInstruction,\n        feedbackSummary,\n        recentFeedback: this.feedbackMemory,\n        minibatch: tuples,\n      } as any)) as any;\n      const instr = (out?.newInstruction as string | undefined)?.trim();\n      if (instr && instr.length > 16) return instr;\n    } catch {}\n\n    // Fallback: tweak the instruction minimally\n    return `${currentInstruction.trim()} Focus on step-by-step evidence-based reasoning. Avoid hallucinations.`.slice(\n      0,\n      2000\n    );\n  }\n\n  private updateSamplerShuffled(trainSize: number): void {\n    const ids = Array.from({ length: trainSize }, (_, i) => i);\n    for (let i = ids.length - 1; i > 0; i--) {\n      const j = Math.floor(this.rand() * (i + 1));\n      [ids[i], ids[j]] = [ids[j]!, ids[i]!];\n    }\n    for (const i of ids)\n      this.samplerState.freq.set(i, (this.samplerState.freq.get(i) ?? 0) + 1);\n    const mb = this.minibatchSize;\n    const mod = trainSize % mb;\n    const numToPad = mod === 0 ? 0 : mb - mod;\n    const candidates = Array.from({ length: trainSize }, (_, i) => i).sort(\n      (a, b) =>\n        (this.samplerState.freq.get(a) ?? 0) -\n        (this.samplerState.freq.get(b) ?? 0)\n    );\n    const padded = [...ids];\n    for (let k = 0; k < numToPad; k++) {\n      const id = candidates[k % candidates.length]!;\n      padded.push(id);\n      this.samplerState.freq.set(id, (this.samplerState.freq.get(id) ?? 0) + 1);\n    }\n    this.samplerState.shuffled = padded;\n    this.samplerState.epoch += 1;\n  }\n\n  private nextMinibatchIndices(trainSize: number, iteration: number): number[] {\n    if (this.samplerState.epoch === -1) {\n      this.samplerState.epoch = 0;\n      this.updateSamplerShuffled(trainSize);\n    }\n    const mb = this.minibatchSize;\n    const blocksPerEpoch = Math.max(\n      1,\n      Math.floor(this.samplerState.shuffled.length / mb)\n    );\n    const currEpoch = Math.floor(iteration / blocksPerEpoch);\n    while (currEpoch >= this.samplerState.epoch)\n      this.updateSamplerShuffled(trainSize);\n    const base = (iteration * mb) % this.samplerState.shuffled.length;\n    return this.samplerState.shuffled.slice(base, base + mb);\n  }\n\n  private rand(): number {\n    this.rngState ^= this.rngState << 13;\n    this.rngState ^= this.rngState >>> 17;\n    this.rngState ^= this.rngState << 5;\n    return ((this.rngState >>> 0) as number) / 4294967296;\n  }\n\n  private generateOptimizationReport(\n    paretoFront: Array<{ scores: Record<string, number>; dominated: number }>,\n    hypervolume: number | undefined,\n    bestScore: number | undefined\n  ): void {\n    console.log('\\n GEPA Multi-Objective Optimization Complete!\\n');\n\n    console.log(' Improvements:');\n    if (paretoFront.length > 1) {\n      console.log(' Successfully found multiple Pareto-optimal solutions');\n    } else {\n      console.log(' Found at least one optimal solution');\n    }\n    if (hypervolume !== undefined && hypervolume > 0) {\n      console.log(\n        ` Hypervolume improvement: ${(hypervolume * 100).toFixed(1)}%`\n      );\n    }\n    if (bestScore !== undefined) {\n      console.log(` Best score achieved: ${bestScore.toFixed(3)}`);\n    }\n    console.log(' Multi-objective approach balances competing goals\\n');\n\n    console.log(' Limitations:');\n    if (paretoFront.length === 1) {\n      console.log(' Limited diversity in Pareto frontier');\n    }\n    if (this.stats.totalCalls < 100) {\n      console.log(' Relatively few optimization trials performed');\n    }\n    console.log(' Results depend on training data quality and size');\n    console.log(' Optimization time scales with problem complexity\\n');\n\n    console.log(' Key Issues:');\n    if (paretoFront.length < 3) {\n      console.log(' Few distinct trade-off points found');\n    }\n    if (this.stats.convergenceInfo?.converged === false) {\n      console.log(' Optimization may not have fully converged');\n    }\n    console.log(' Evaluation metrics may need domain-specific tuning');\n    console.log(' Model selection impacts optimization effectiveness\\n');\n\n    console.log(' What This Means:');\n    console.log(\n      ' GEPA framework successfully demonstrates multi-objective optimization'\n    );\n    console.log(' Pareto frontier reveals real trade-offs between objectives');\n    console.log(\n      ' Users can select solutions based on their specific priorities'\n    );\n    console.log(' More training data and trials would likely improve results');\n  }\n\n  private async mergeInstructions(\n    instructionA: string,\n    instructionB: string,\n    options?: AxCompileOptions\n  ): Promise<string> {\n    const aiToUse: AxAIService =\n      (options as any)?.overrideTeacherAI ?? this.teacherAI ?? this.studentAI;\n\n    // Merge via meta-prompt\n    const merger = ax(\n      `instructionA:string \"Parent A instruction\",\n       instructionB:string \"Parent B instruction\",\n       recentFeedback?:string[] \"Past feedback memory\"\n       -> mergedInstruction:string \"Merged instruction (1-6 sentences) combining strengths, fixing weaknesses\"`\n    );\n\n    try {\n      const out = (await merger.forward(aiToUse, {\n        instructionA,\n        instructionB,\n        recentFeedback: this.feedbackMemory,\n      } as any)) as any;\n      const instr = (out?.mergedInstruction as string | undefined)?.trim();\n      if (instr && instr.length > 16) return instr;\n    } catch {}\n\n    // Fallback: prefer the longer instruction (richer constraints)\n    return (\n      instructionA.length >= instructionB.length ? instructionA : instructionB\n    ).slice(0, 2000);\n  }\n}\n","import type { AxAIService } from '../../ai/types.js';\nimport type {\n  AxCompileOptions,\n  AxExample,\n  AxMetricFn,\n  AxMultiMetricFn,\n  AxOptimizerArgs,\n  AxTypedExample,\n} from '../common_types.js';\nimport { AxBaseOptimizer, type AxParetoResult } from '../optimizer.js';\nimport type { AxGenOut } from '../types.js';\nimport { ax } from '../template.js';\nimport type { AxFlow } from '../../flow/flow.js';\nimport {\n  buildParetoFront,\n  hypervolume2D,\n  average,\n  avgVec,\n  selectProgramCandidateFromInstanceFronts,\n  removeDominatedProgramsByInstanceFronts,\n} from './paretoUtils.js';\nimport type { AxGEPAAdapter } from './gepaAdapter.js';\n\n/** Flow-aware GEPA (system-level reflective evolution with module selection + system-aware merge) */\nexport class AxGEPAFlow extends AxBaseOptimizer {\n  private numTrials: number;\n  private minibatch: boolean;\n  private minibatchSize: number;\n  private earlyStoppingTrials: number;\n  private minImprovementThreshold: number;\n  private sampleCount: number;\n  private crossoverEvery: number;\n  private tieEpsilon: number;\n  private paretoSetSize: number;\n  private mergeMax: number;\n  private mergesUsed = 0;\n  private mergesDue = 0;\n  private totalMergesTested = 0;\n  private lastIterFoundNewProgram = false;\n  private rngState: number;\n  private mergeAttemptKeys = new Set<string>();\n  private mergeCompositionKeys = new Set<string>();\n  private samplerState: {\n    epoch: number;\n    shuffled: number[];\n    freq: Map<number, number>;\n  } = {\n    epoch: -1,\n    shuffled: [],\n    freq: new Map(),\n  };\n\n  constructor(args: Readonly<AxOptimizerArgs>) {\n    super(args);\n    this.numTrials = args.numTrials ?? 24;\n    this.minibatch = args.minibatch ?? true;\n    this.minibatchSize = args.minibatchSize ?? 8;\n    this.earlyStoppingTrials = args.earlyStoppingTrials ?? 5;\n    this.minImprovementThreshold = args.minImprovementThreshold ?? 0.0;\n    this.sampleCount = args.sampleCount ?? 1;\n    this.crossoverEvery = Math.max(\n      0,\n      Math.floor(\n        (args as any)?.crossoverEvery ??\n          Math.max(3, Math.floor(this.numTrials / 3))\n      )\n    );\n    this.tieEpsilon = Number.isFinite((args as any)?.tieEpsilon)\n      ? Number((args as any)?.tieEpsilon)\n      : 0;\n\n    // Seeded RNG for deterministic sampling/merges\n    const seedRaw = (args as any)?.seed;\n    const seedNum = Number.isFinite(seedRaw) ? Math.floor(Number(seedRaw)) : 0;\n    this.rngState = seedNum && seedNum !== 0 ? seedNum : 123456789;\n\n    const argPareto = (args as any)?.paretoSetSize as number | undefined;\n    this.paretoSetSize =\n      argPareto && argPareto > 0\n        ? Math.min(1000, Math.max(5, Math.floor(argPareto)))\n        : Math.max(10, Math.min(200, this.minibatchSize * 3));\n\n    const argMergeMax = (args as any)?.mergeMax as number | undefined;\n    this.mergeMax = Math.max(0, Math.floor(argMergeMax ?? 5));\n    this.mergesUsed = 0;\n\n    this.stats.convergenceInfo.convergenceThreshold =\n      this.minImprovementThreshold;\n  }\n\n  public override reset(): void {\n    super.reset();\n    this.stats.convergenceInfo.convergenceThreshold =\n      this.minImprovementThreshold;\n    this.mergesUsed = 0;\n    this.mergesDue = 0;\n    this.totalMergesTested = 0;\n    this.lastIterFoundNewProgram = false;\n    this.mergeAttemptKeys.clear();\n    this.mergeCompositionKeys.clear();\n    this.samplerState.epoch = -1;\n    this.samplerState.shuffled = [];\n    this.samplerState.freq.clear();\n  }\n\n  public configureAuto(level: 'light' | 'medium' | 'heavy'): void {\n    switch (level) {\n      case 'light':\n        this.numTrials = 8;\n        this.minibatch = true;\n        this.minibatchSize = 6;\n        break;\n      case 'medium':\n        this.numTrials = 16;\n        this.minibatch = true;\n        this.minibatchSize = 10;\n        break;\n      case 'heavy':\n        this.numTrials = 28;\n        this.minibatch = true;\n        this.minibatchSize = 14;\n        break;\n    }\n  }\n\n  /**\n   * Multi-objective GEPA-Flow: system-level reflective evolution with Pareto frontier\n   */\n  public async compile<IN, OUT extends AxGenOut>(\n    program: Readonly<any>,\n    examples: readonly AxTypedExample<IN>[],\n    metricFn: AxMetricFn,\n    options?: AxCompileOptions\n  ): Promise<AxParetoResult<OUT>> {\n    const _startTime = Date.now();\n    const flow = program as unknown as AxFlow<any, OUT>;\n    this.validateExamples(examples);\n    if (options?.auto) this.configureAuto(options.auto);\n\n    // Discover modules\n    const nodes = (flow as any).getNodePrograms?.() as\n      | ReadonlyArray<{ name: string; program: any }>\n      | undefined;\n    if (!nodes || nodes.length === 0)\n      throw new Error('AxGEPAFlow: flow has no nodes to optimize');\n\n    // Validation/Pareto set and Feedback/Training set\n    const validationExamples = (options as any)?.validationExamples as\n      | readonly AxTypedExample<IN>[]\n      | undefined;\n    const feedbackExamples = (options as any)?.feedbackExamples as\n      | readonly AxTypedExample<IN>[]\n      | undefined;\n    const paretoSet = (\n      validationExamples && validationExamples.length > 0\n        ? validationExamples\n        : examples\n    ).slice(0, this.paretoSetSize);\n    const feedbackSet =\n      feedbackExamples && feedbackExamples.length > 0\n        ? feedbackExamples\n        : examples;\n\n    const optLogger = this.getOptimizerLogger(options);\n    optLogger?.({\n      name: 'OptimizationStart',\n      value: {\n        optimizerType: 'GEPA-Flow',\n        exampleCount: examples.length,\n        validationCount: paretoSet.length,\n        config: { numTrials: this.numTrials, minibatch: this.minibatch },\n      },\n    });\n\n    const evalOne = async (\n      cfg: Readonly<Record<string, string>>,\n      ex: Readonly<AxTypedExample<IN>>\n    ): Promise<Record<string, number>> => {\n      try {\n        (flow as any).setAllNodeInstructions?.(cfg);\n        const prediction = await (flow as any).forward(\n          this.studentAI,\n          ex as any,\n          {\n            sampleCount: this.sampleCount,\n          }\n        );\n        this.stats.totalCalls += 1;\n        const scores = await (metricFn as unknown as AxMultiMetricFn)({\n          prediction,\n          example: ex as any,\n        });\n        return scores || {};\n      } catch {\n        return {};\n      }\n    };\n\n    const evalOnSet = async (\n      cfg: Readonly<Record<string, string>>,\n      set: readonly AxTypedExample<IN>[]\n    ): Promise<Record<string, number>> => {\n      const vecs: Record<string, number>[] = [];\n      for (const ex of set) vecs.push(await evalOne(cfg, ex));\n      return avgVec(vecs);\n    };\n\n    // Initialize base candidate from current node instructions\n    const baseInstrs: Record<string, string> = {};\n    for (const n of nodes)\n      baseInstrs[n.name] = await this.getBaseInstruction(n.program);\n\n    const candidates: {\n      cfg: Record<string, string>;\n      parent?: number;\n      scores: Record<string, number>;\n    }[] = [\n      {\n        cfg: { ...baseInstrs },\n        parent: undefined,\n        scores: await evalOnSet(baseInstrs, paretoSet),\n      },\n    ];\n\n    // Scalarizer for multi-metric vectors\n    const scalarize = (v: Readonly<Record<string, number>>): number => {\n      const key = (options as any)?.paretoMetricKey as string | undefined;\n      const fn = (options as any)?.paretoScalarize as\n        | ((scores: Readonly<Record<string, number>>) => number)\n        | undefined;\n      if (typeof fn === 'function') return fn(v);\n      if (key)\n        return Number.isFinite(v[key] as number) ? (v[key] as number) : 0;\n      const vals = Object.values(v);\n      return vals.length ? vals.reduce((a, b) => a + b, 0) / vals.length : 0;\n    };\n\n    // Track per-instance scalar scores on validation set for Algorithm 2 selection\n    const perInstanceScores: number[][] = [];\n    const evalOnSetScalar = async (\n      cfg: Readonly<Record<string, string>>,\n      set: readonly AxTypedExample<IN>[]\n    ): Promise<number[]> => {\n      const out: number[] = [];\n      for (const ex of set) {\n        const vec = await evalOne(cfg, ex);\n        out.push(scalarize(vec));\n      }\n      return out;\n    };\n    perInstanceScores.push(await evalOnSetScalar(baseInstrs, paretoSet));\n\n    // Initialize archive\n    let archive = buildParetoFront(\n      candidates.map((c, idx) => ({ idx, scores: c.scores })),\n      this.tieEpsilon\n    ).map((p) => p.idx);\n    let stagnation = 0;\n    const triedMerges = new Set<string>();\n\n    const rolloutBudgetRaw = (options as any)?.maxMetricCalls as number;\n    if (!Number.isFinite(rolloutBudgetRaw) || rolloutBudgetRaw <= 0) {\n      throw new Error(\n        'AxGEPA-Flow: options.maxMetricCalls must be set to a positive integer'\n      );\n    }\n    const rolloutBudget = Math.floor(rolloutBudgetRaw);\n\n    for (let t = 0; t < this.numTrials; t++) {\n      if (\n        rolloutBudget !== undefined &&\n        this.stats.totalCalls >= Math.max(1, Math.floor(rolloutBudget))\n      ) {\n        break;\n      }\n\n      // Parent selection via per-instance fronts (frequency sampling)\n      const nInst = perInstanceScores[0]?.length ?? 0;\n      const instanceFronts: Array<Set<number>> = [];\n      for (let i = 0; i < nInst; i++) {\n        let best = Number.NEGATIVE_INFINITY;\n        const front = new Set<number>();\n        for (let k = 0; k < perInstanceScores.length; k++) {\n          const v = perInstanceScores[k]![i]!;\n          if (v > best + this.tieEpsilon) {\n            best = v;\n            front.clear();\n            front.add(k);\n          } else if (Math.abs(v - best) <= this.tieEpsilon) {\n            front.add(k);\n          }\n        }\n        instanceFronts.push(front);\n      }\n      const perProgScores = perInstanceScores.map((arr) => average(arr));\n\n      // Scheduled merge attempt (parity with source): only when mergesDue>0 and lastIterFoundNewProgram\n      if (\n        this.mergeMax > 0 &&\n        this.mergesDue > 0 &&\n        this.lastIterFoundNewProgram\n      ) {\n        // Build dominator merge candidates from reduced instance fronts\n        const reducedFronts = removeDominatedProgramsByInstanceFronts(\n          instanceFronts,\n          perProgScores\n        );\n        const mergeCandidatesSet = new Set<number>();\n        for (const f of reducedFronts)\n          for (const p of f) mergeCandidatesSet.add(p);\n        const mergeCandidates = Array.from(mergeCandidatesSet);\n\n        const ancestors = (idx: number): number[] => {\n          const path: number[] = [];\n          let cur: number | undefined = idx;\n          while (cur !== undefined) {\n            path.push(cur);\n            cur = candidates[cur]?.parent;\n          }\n          return path;\n        };\n\n        const rngPick = <T>(arr: readonly T[]): T | undefined =>\n          arr.length ? arr[Math.floor(this.rand() * arr.length)]! : undefined;\n\n        // Try up to 10 random pairs to find a viable (i, j, ancestor)\n        let picked: { i: number; j: number; a: number } | undefined;\n        for (let attempts = 0; attempts < 10 && !picked; attempts++) {\n          if (mergeCandidates.length < 2) break;\n          let i = rngPick(mergeCandidates)!;\n          let j = rngPick(mergeCandidates)!;\n          if (i === j) continue;\n          if (j < i) [i, j] = [j, i];\n          const Ai = new Set(ancestors(i));\n          const Aj = new Set(ancestors(j));\n          if (Ai.has(j) || Aj.has(i)) continue; // cannot merge ancestor with descendant\n          const commons = [...Ai].filter((x) => Aj.has(x));\n          if (commons.length === 0) continue;\n\n          // Filter ancestors using desirability (at least one module where ancestor matches one child but differs from the other)\n          const desirables: number[] = [];\n          for (const a of commons) {\n            const cfgA = candidates[a]!.cfg;\n            const cfgI = candidates[i]!.cfg;\n            const cfgJ = candidates[j]!.cfg;\n            let ok = false;\n            const allKeys = new Set([\n              ...Object.keys(cfgA),\n              ...Object.keys(cfgI),\n              ...Object.keys(cfgJ),\n            ]);\n            for (const k of allKeys) {\n              const pa = cfgA[k];\n              const pi = cfgI[k];\n              const pj = cfgJ[k];\n              if ((pi === pa && pj !== pi) || (pj === pa && pi !== pj)) {\n                ok = true;\n                break;\n              }\n            }\n            if (ok) desirables.push(a);\n          }\n          if (desirables.length === 0) continue;\n\n          // Weight ancestors by aggregate score\n          const weights = desirables.map((a) =>\n            Math.max(1e-9, perProgScores[a]!)\n          );\n          let r = this.rand() * weights.reduce((s, w) => s + w, 0);\n          let a = desirables[desirables.length - 1]!;\n          for (let idx = 0; idx < desirables.length; idx++) {\n            if (r < weights[idx]!) {\n              a = desirables[idx]!;\n              break;\n            }\n            r -= weights[idx]!;\n          }\n\n          // Ancestor guard: Sa <= min(Si, Sj)\n          const Sa = perProgScores[a]!;\n          const Si = perProgScores[i]!;\n          const Sj = perProgScores[j]!;\n          if (Sa > Math.min(Si, Sj)) continue;\n          const triKey = `${i}|${j}|${a}`;\n          if (this.mergeAttemptKeys.has(triKey)) continue;\n          this.mergeAttemptKeys.add(triKey);\n          const key = `${i}|${j}|${a}`;\n          if (triedMerges.has(key)) continue;\n          picked = { i, j, a };\n        }\n\n        // Clear scheduling flag before reflective (parity)\n        this.lastIterFoundNewProgram = false;\n\n        if (picked) {\n          const { i, j, a } = picked;\n          // Build merged candidate (system-aware)\n          const { cfg: mergedCfg, descSig } = this.systemAwareMergeWithSig(\n            candidates,\n            i,\n            j,\n            (ia, ib) => (perProgScores[ia]! >= perProgScores[ib]! ? ia : ib)\n          );\n          const compKey = `${Math.min(i, j)}|${Math.max(i, j)}|${descSig}`;\n          if (this.mergeCompositionKeys.has(compKey)) continue;\n          this.mergeCompositionKeys.add(compKey);\n\n          // Targeted subsample selection on validation set (parents' per-instance subscores)\n          const s1 = perInstanceScores[i]!;\n          const s2 = perInstanceScores[j]!;\n          const allIdx = Array.from({ length: s1.length }, (_, z) => z);\n          const p1 = allIdx.filter((z) => (s1[z] ?? 0) > (s2[z] ?? 0));\n          const p2 = allIdx.filter((z) => (s2[z] ?? 0) > (s1[z] ?? 0));\n          const p3 = allIdx.filter((z) => !(p1.includes(z) || p2.includes(z)));\n          const K = 5;\n          const nEach = Math.ceil(K / 3);\n          const pickSome = (arr: number[], k: number): number[] => {\n            if (k <= 0 || arr.length === 0) return [];\n            if (arr.length <= k) return [...arr];\n            const out: number[] = [];\n            const used = new Set<number>();\n            while (out.length < k) {\n              const idx = Math.floor(this.rand() * arr.length);\n              if (!used.has(idx)) {\n                used.add(idx);\n                out.push(arr[idx]!);\n              }\n            }\n            return out;\n          };\n          const chosen: number[] = [];\n          chosen.push(...pickSome(p1, Math.min(nEach, p1.length)));\n          chosen.push(...pickSome(p2, Math.min(nEach, p2.length)));\n          const rem = K - chosen.length;\n          chosen.push(...pickSome(p3, Math.max(0, rem)));\n          // Fill remaining from rest\n          const remaining = K - chosen.length;\n          if (remaining > 0) {\n            const unused = allIdx.filter((z) => !chosen.includes(z));\n            chosen.push(\n              ...pickSome(unused, Math.min(remaining, unused.length))\n            );\n          }\n          const idxs = chosen.slice(0, Math.min(K, allIdx.length));\n\n          const subsample = idxs.map((z) => paretoSet[z]!);\n          const newSubScoresArr = await evalOnSetScalar(\n            mergedCfg,\n            subsample as any\n          );\n          const newSum = newSubScoresArr.reduce((a, b) => a + b, 0);\n          const id1Sum = idxs.reduce((a, z) => a + (s1[z] ?? 0), 0);\n          const id2Sum = idxs.reduce((a, z) => a + (s2[z] ?? 0), 0);\n\n          if (newSum >= Math.max(id1Sum, id2Sum) + this.tieEpsilon) {\n            // ACCEPT: full eval and add\n            const childVec = await evalOnSet(mergedCfg, paretoSet);\n            candidates.push({ cfg: mergedCfg, parent: a, scores: childVec });\n            perInstanceScores.push(await evalOnSetScalar(mergedCfg, paretoSet));\n            const beforeSize = archive.length;\n            const hvBefore =\n              hypervolume2D(archive.map((idx) => candidates[idx]!.scores)) ?? 0;\n            archive = buildParetoFront(\n              candidates.map((c, idx) => ({ idx, scores: c.scores })),\n              this.tieEpsilon\n            ).map((p) => p.idx);\n            const hvAfter =\n              hypervolume2D(archive.map((idx) => candidates[idx]!.scores)) ?? 0;\n            if (archive.length > beforeSize || hvAfter > hvBefore + 1e-6)\n              stagnation = 0;\n            this.mergesDue -= 1;\n            this.totalMergesTested += 1;\n            triedMerges.add(`${Math.min(i, j)}|${Math.max(i, j)}|${a}`);\n          }\n          // Skip reflective this iteration\n          continue;\n        } else {\n          // No merge attempted; fall through to reflective (flag cleared above)\n        }\n      }\n\n      const parentIdx = selectProgramCandidateFromInstanceFronts(\n        instanceFronts,\n        perProgScores,\n        () => this.rand()\n      );\n\n      // Clear merge flag before reflective\n      this.lastIterFoundNewProgram = false;\n\n      const mini = this.minibatch\n        ? this.nextMinibatchIndices(feedbackSet.length, t).map(\n            (z) => feedbackSet[z]!\n          )\n        : feedbackSet;\n\n      // Skip reflective mutation if minibatch is already perfect\n      if ((options as any)?.skipPerfectScore ?? true) {\n        const perfect = Number((options as any)?.perfectScore ?? 1);\n        const parentMiniScores = await evalOnSetScalar(\n          candidates[parentIdx]!.cfg,\n          mini as any\n        );\n        if (\n          parentMiniScores.length > 0 &&\n          parentMiniScores.every((s) => s >= perfect)\n        ) {\n          continue;\n        }\n      }\n\n      // Scheduled merges are handled above; disable periodic merges\n      const useCrossover = false as const;\n\n      let proposedCfg: Record<string, string> = {\n        ...candidates[parentIdx]!.cfg,\n      };\n      let strategy: 'reflective_mutation' | 'system_merge' =\n        'reflective_mutation';\n\n      const moduleIndex = t % nodes.length; // round-robin module selection\n      const module = nodes[moduleIndex]!;\n\n      // For adapter-based strict acceptance\n      let adapterParentSum: number | undefined;\n      let adapterChildSum: number | undefined;\n\n      if (useCrossover && this.mergesUsed < this.mergeMax) {\n        const second = (parentIdx + 1) % candidates.length;\n\n        const ancestors = (idx: number): number[] => {\n          const path: number[] = [];\n          let cur: number | undefined = idx;\n          while (cur !== undefined) {\n            path.push(cur);\n            cur = candidates[cur]?.parent;\n          }\n          return path;\n        };\n        const Ai = ancestors(parentIdx);\n        const Aj = ancestors(second);\n        const common = Ai.find((x) => Aj.includes(x));\n\n        let doMerge = true;\n        if (!common) doMerge = false;\n        if (Aj.includes(parentIdx) || Ai.includes(second)) doMerge = false;\n        if (doMerge) {\n          const cfgA = candidates[common!]!.cfg;\n          const cfgI = candidates[parentIdx]!.cfg;\n          const cfgJ = candidates[second]!.cfg;\n          let desirable = false;\n          const allKeys = new Set([\n            ...Object.keys(cfgA),\n            ...Object.keys(cfgI),\n            ...Object.keys(cfgJ),\n          ]);\n          for (const k of allKeys) {\n            const pa = cfgA[k];\n            const pi = cfgI[k];\n            const pj = cfgJ[k];\n            if ((pi === pa && pj !== pi) || (pj === pa && pi !== pj)) {\n              desirable = true;\n              break;\n            }\n          }\n          if (!desirable) doMerge = false;\n        }\n\n        if (doMerge) {\n          // Guard: skip if (i,j,a) tried before\n          const i0 = Math.min(parentIdx, second);\n          const j0 = Math.max(parentIdx, second);\n          const key = `${i0}|${j0}|${common}`;\n          if (!triedMerges.has(key)) {\n            // Guard: S[a] > min(S[i], S[j])\n            const Sa = scalarize(candidates[common!]!.scores);\n            const Si = scalarize(candidates[parentIdx]!.scores);\n            const Sj = scalarize(candidates[second]!.scores);\n            if (Sa <= Math.min(Si, Sj)) {\n              proposedCfg = this.systemAwareMerge(\n                candidates,\n                parentIdx,\n                second,\n                (ia, ib) => {\n                  const sa = scalarize(candidates[ia]!.scores);\n                  const sb = scalarize(candidates[ib]!.scores);\n                  return sa >= sb ? ia : ib;\n                }\n              );\n              strategy = 'system_merge';\n              this.mergesUsed += 1;\n              triedMerges.add(key);\n            }\n          }\n        } else {\n          const currentInstr = candidates[parentIdx]!.cfg[module.name]!;\n          const adapter = (options as any)?.gepaAdapter as\n            | AxGEPAAdapter\n            | undefined;\n          let newInstr: string | undefined;\n          if (adapter) {\n            try {\n              const evalParent = await adapter.evaluate(\n                mini as any,\n                { ...candidates[parentIdx]!.cfg },\n                true\n              );\n              adapterParentSum = Array.isArray(evalParent?.scores)\n                ? evalParent.scores.reduce((a, b) => a + (Number(b) || 0), 0)\n                : undefined;\n              const reflDs = adapter.make_reflective_dataset(\n                { ...candidates[parentIdx]!.cfg },\n                evalParent as any,\n                [module.name]\n              );\n              const proposedMap = await (adapter.propose_new_texts?.(\n                { ...candidates[parentIdx]!.cfg },\n                reflDs,\n                [module.name]\n              ) as any);\n              const proposedText = proposedMap?.[module.name];\n              if (typeof proposedText === 'string' && proposedText.length > 0) {\n                newInstr = proposedText;\n              }\n            } catch {}\n          }\n          if (!newInstr) {\n            newInstr = await this.reflectModuleInstruction(\n              module.name,\n              currentInstr,\n              flow,\n              nodes,\n              { ...candidates[parentIdx]!.cfg },\n              mini,\n              async ({ prediction, example }) => {\n                const scores = await (metricFn as unknown as AxMultiMetricFn)({\n                  prediction,\n                  example,\n                });\n                const vals = Object.values(scores || {});\n                return vals.length\n                  ? vals.reduce((a, b) => a + b, 0) / vals.length\n                  : 0;\n              },\n              options\n            );\n          }\n          proposedCfg[module.name] = newInstr!;\n          if (adapter && adapterParentSum !== undefined) {\n            try {\n              const evalChild = await adapter.evaluate(\n                mini as any,\n                proposedCfg,\n                false\n              );\n              adapterChildSum = Array.isArray(evalChild?.scores)\n                ? evalChild.scores.reduce((a, b) => a + (Number(b) || 0), 0)\n                : undefined;\n            } catch {}\n          }\n        }\n      } else {\n        const currentInstr = candidates[parentIdx]!.cfg[module.name]!;\n        const adapter = (options as any)?.gepaAdapter as\n          | AxGEPAAdapter\n          | undefined;\n        let newInstr: string | undefined;\n        if (adapter) {\n          try {\n            const evalParent = await adapter.evaluate(\n              mini as any,\n              { ...candidates[parentIdx]!.cfg },\n              true\n            );\n            adapterParentSum = Array.isArray(evalParent?.scores)\n              ? evalParent.scores.reduce((a, b) => a + (Number(b) || 0), 0)\n              : undefined;\n            const reflDs = adapter.make_reflective_dataset(\n              { ...candidates[parentIdx]!.cfg },\n              evalParent as any,\n              [module.name]\n            );\n            const proposedMap = await (adapter.propose_new_texts?.(\n              { ...candidates[parentIdx]!.cfg },\n              reflDs,\n              [module.name]\n            ) as any);\n            const proposedText = proposedMap?.[module.name];\n            if (typeof proposedText === 'string' && proposedText.length > 0) {\n              newInstr = proposedText;\n            }\n          } catch {}\n        }\n        if (!newInstr) {\n          newInstr = await this.reflectModuleInstruction(\n            module.name,\n            currentInstr,\n            flow,\n            nodes,\n            { ...candidates[parentIdx]!.cfg },\n            mini,\n            async ({ prediction, example }) => {\n              const scores = await (metricFn as unknown as AxMultiMetricFn)({\n                prediction,\n                example,\n              });\n              const vals = Object.values(scores || {});\n              return vals.length\n                ? vals.reduce((a, b) => a + b, 0) / vals.length\n                : 0;\n            },\n            options\n          );\n        }\n        proposedCfg[module.name] = newInstr!;\n        if (adapter && adapterParentSum !== undefined) {\n          try {\n            const evalChild = await adapter.evaluate(\n              mini as any,\n              proposedCfg,\n              false\n            );\n            adapterChildSum = Array.isArray(evalChild?.scores)\n              ? evalChild.scores.reduce((a, b) => a + (Number(b) || 0), 0)\n              : undefined;\n          } catch {}\n        }\n      }\n\n      // Strict acceptance on minibatch sum (parity with source)\n      const parentMiniArr = await evalOnSetScalar(\n        candidates[parentIdx]!.cfg,\n        mini as any\n      );\n      const childMiniArr = await evalOnSetScalar(proposedCfg, mini as any);\n      const parentMiniSum = parentMiniArr.reduce((a, b) => a + b, 0);\n      const childMiniSum = childMiniArr.reduce((a, b) => a + b, 0);\n\n      this.currentRound = t + 1;\n      await this.updateOptimizationProgress(\n        this.currentRound,\n        childMiniSum,\n        {\n          modules: nodes.length,\n          mutatedModule: module.name,\n          totalRounds: this.numTrials,\n        },\n        'GEPA-Flow',\n        { strategy, paretoSetSize: paretoSet.length },\n        childMiniSum,\n        { idx: parentIdx },\n        { ...(options ?? {}), maxIterations: this.numTrials }\n      );\n\n      const accepted =\n        childMiniSum > parentMiniSum + this.tieEpsilon &&\n        (adapterParentSum === undefined ||\n          adapterChildSum === undefined ||\n          adapterChildSum > adapterParentSum + this.tieEpsilon);\n      if (!accepted) {\n        if (++stagnation >= this.earlyStoppingTrials) break;\n        continue;\n      }\n\n      // Full evaluation on validation set and archive update\n      const childVec = await evalOnSet(proposedCfg, paretoSet);\n      candidates.push({\n        cfg: proposedCfg,\n        parent: parentIdx,\n        scores: childVec,\n      });\n      // Store per-instance scalar scores for Algorithm 2 selection\n      perInstanceScores.push(await evalOnSetScalar(proposedCfg, paretoSet));\n\n      const beforeSize = archive.length;\n      const hvBefore =\n        hypervolume2D(archive.map((idx) => candidates[idx]!.scores)) ?? 0;\n      archive = buildParetoFront(\n        candidates.map((c, idx) => ({ idx, scores: c.scores })),\n        this.tieEpsilon\n      ).map((p) => p.idx);\n      const hvAfter =\n        hypervolume2D(archive.map((idx) => candidates[idx]!.scores)) ?? 0;\n\n      if (archive.length > beforeSize || hvAfter > hvBefore + 1e-6) {\n        stagnation = 0;\n      } else {\n        stagnation++;\n        if (stagnation >= this.earlyStoppingTrials) break;\n      }\n      // Schedule merge attempt for next iteration (parity)\n      this.lastIterFoundNewProgram = true;\n      if (this.mergeMax > 0 && this.totalMergesTested < this.mergeMax) {\n        this.mergesDue += 1;\n      }\n    }\n\n    // Build Pareto frontier and metrics\n    const pareto = buildParetoFront(\n      candidates.map((c, idx) => ({ idx, scores: c.scores })),\n      this.tieEpsilon\n    );\n    const bestScore =\n      pareto.length > 0\n        ? Math.max(...pareto.map((p) => scalarize(p.scores)))\n        : 0;\n    const hv = hypervolume2D(pareto.map((p) => p.scores));\n\n    this.stats.convergenceInfo.converged = true;\n    this.recordParetoMetrics(pareto.length, candidates.length, 'GEPA-Flow', hv);\n\n    return {\n      demos: [],\n      stats: this.stats,\n      bestScore,\n      paretoFront: pareto.map((p) => ({\n        demos: [],\n        scores: p.scores,\n        configuration: { candidate: p.idx },\n        dominatedSolutions: p.dominated,\n      })),\n      paretoFrontSize: pareto.length,\n      hypervolume: hv,\n      finalConfiguration: {\n        strategy: 'gepa_flow_pareto',\n        candidates: candidates.length,\n      },\n    } as AxParetoResult<OUT>;\n  }\n\n  // === Helpers ===\n  private async getBaseInstruction(program: any): Promise<string> {\n    try {\n      const sig = program?.getSignature?.();\n      if (\n        sig &&\n        typeof sig.instruction === 'string' &&\n        sig.instruction.length > 0\n      )\n        return sig.instruction as string;\n    } catch {}\n    return 'Follow the task precisely. Be concise, correct, and consistent.';\n  }\n\n  private async evaluateOnSet<OUT extends AxGenOut>(\n    flow: Readonly<AxFlow<any, OUT>>,\n    cfg: Readonly<Record<string, string>>,\n    set: readonly AxTypedExample<any>[],\n    metricFn: AxMetricFn\n  ): Promise<number[]> {\n    const out: number[] = [];\n    for (const ex of set) {\n      const s = await this.evaluateOne(flow, cfg, ex, metricFn);\n      out.push(s);\n    }\n    return out;\n  }\n\n  private async evaluateAvg<OUT extends AxGenOut>(\n    flow: Readonly<AxFlow<any, OUT>>,\n    cfg: Readonly<Record<string, string>>,\n    set: readonly AxTypedExample<any>[],\n    metricFn: AxMetricFn\n  ): Promise<number> {\n    const arr = await this.evaluateOnSet(flow, cfg, set, metricFn);\n    return arr.length > 0 ? average(arr) : 0;\n  }\n\n  private async evaluateOne<OUT extends AxGenOut>(\n    flow: Readonly<AxFlow<any, OUT>>,\n    cfg: Readonly<Record<string, string>>,\n    example: Readonly<AxTypedExample<any>>,\n    metricFn: AxMetricFn\n  ): Promise<number> {\n    try {\n      (flow as any).setAllNodeInstructions?.(cfg);\n      const prediction = await (flow as any).forward(\n        this.studentAI,\n        example as any,\n        {\n          sampleCount: this.sampleCount,\n        }\n      );\n      this.stats.totalCalls += 1;\n      const score = await metricFn({\n        prediction,\n        example: example as AxExample,\n      });\n      if (typeof score === 'number' && !Number.isNaN(score)) {\n        if (\n          typeof this.targetScore === 'number'\n            ? score >= this.targetScore\n            : score >= 0.5\n        )\n          this.stats.successfulDemos += 1;\n        return score;\n      }\n      return 0;\n    } catch {\n      return 0;\n    }\n  }\n\n  private async reflectModuleInstruction<OUT extends AxGenOut>(\n    moduleName: string,\n    currentInstruction: string,\n    flow: Readonly<AxFlow<any, OUT>>,\n    _nodes: ReadonlyArray<{ name: string; program: any }>,\n    cfg: Record<string, string>,\n    minibatch: readonly AxTypedExample<any>[],\n    metricFn: AxMetricFn,\n    options?: AxCompileOptions\n  ): Promise<string> {\n    // tuples unused but left for parity with single-module version\n    const _tuples: Array<{\n      input: AxExample;\n      prediction: unknown;\n      score: number;\n    }>[] = [] as any;\n    const local: Array<{\n      input: AxExample;\n      prediction: unknown;\n      score: number;\n    }> = [];\n\n    for (const ex of minibatch) {\n      try {\n        cfg[moduleName] = currentInstruction;\n        (flow as any).setAllNodeInstructions?.(cfg);\n        const pred = await (flow as any).forward(this.studentAI, ex as any, {\n          sampleCount: this.sampleCount,\n        });\n        this.stats.totalCalls += 1;\n        const score = await metricFn({\n          prediction: pred,\n          example: ex as AxExample,\n        });\n        local.push({\n          input: ex as AxExample,\n          prediction: pred,\n          score: typeof score === 'number' ? score : 0,\n        });\n      } catch {\n        local.push({ input: ex as AxExample, prediction: {}, score: 0 });\n      }\n    }\n\n    const aiToUse: AxAIService =\n      options?.overrideTeacherAI ?? this.teacherAI ?? this.studentAI;\n\n    const critic = ax(\n      `moduleName:string \"Target module\", minibatch:json \"Array of {input,prediction,score}\", evalFeedback?:string[] \"Evaluator feedback when available\" -> feedbackSummary:string \"Concise module-focused feedback\"`\n    );\n\n    // Optional external feedback\n    const external: string[] = [];\n    const feedbackFn = (options as any)?.feedbackFn as\n      | ((\n          arg: Readonly<{ prediction: any; example: AxExample }>\n        ) => string | string[] | undefined)\n      | undefined;\n    if (typeof feedbackFn === 'function') {\n      for (const t of local) {\n        const fb = feedbackFn({ prediction: t.prediction, example: t.input });\n        if (fb) Array.isArray(fb) ? external.push(...fb) : external.push(fb);\n      }\n    }\n\n    let feedbackSummary = '';\n    try {\n      const out = (await critic.forward(aiToUse, {\n        moduleName,\n        minibatch: local,\n        evalFeedback: external,\n      } as any)) as any;\n      feedbackSummary =\n        (out?.feedbackSummary as string | undefined)?.trim() || '';\n    } catch {}\n\n    const refl = ax(\n      `moduleName:string \"Target module\", currentInstruction:string \"Current instruction\", feedbackSummary?:string \"Summarized feedback\", minibatch:json \"Array of {input,prediction,score}\" -> newInstruction:string \"Improved instruction (1-6 sentences) for the module\"`\n    );\n\n    try {\n      const out = (await refl.forward(aiToUse, {\n        moduleName,\n        currentInstruction,\n        feedbackSummary,\n        minibatch: local,\n      } as any)) as any;\n      const instr = (out?.newInstruction as string | undefined)?.trim();\n      if (instr && instr.length > 16) return instr;\n    } catch {}\n\n    return `${currentInstruction.trim()} Focus on step-by-step, module-specific reasoning and factual grounding.`.slice(\n      0,\n      2000\n    );\n  }\n\n  private updateSamplerShuffled(trainSize: number): void {\n    const ids = Array.from({ length: trainSize }, (_, i) => i);\n    for (let i = ids.length - 1; i > 0; i--) {\n      const j = Math.floor(this.rand() * (i + 1));\n      [ids[i], ids[j]] = [ids[j]!, ids[i]!];\n    }\n    for (const i of ids)\n      this.samplerState.freq.set(i, (this.samplerState.freq.get(i) ?? 0) + 1);\n    const mb = this.minibatchSize;\n    const mod = trainSize % mb;\n    const numToPad = mod === 0 ? 0 : mb - mod;\n    const candidates = Array.from({ length: trainSize }, (_, i) => i).sort(\n      (a, b) =>\n        (this.samplerState.freq.get(a) ?? 0) -\n        (this.samplerState.freq.get(b) ?? 0)\n    );\n    const padded = [...ids];\n    for (let k = 0; k < numToPad; k++) {\n      const id = candidates[k % candidates.length]!;\n      padded.push(id);\n      this.samplerState.freq.set(id, (this.samplerState.freq.get(id) ?? 0) + 1);\n    }\n    this.samplerState.shuffled = padded;\n    this.samplerState.epoch += 1;\n  }\n\n  private nextMinibatchIndices(trainSize: number, iteration: number): number[] {\n    if (this.samplerState.epoch === -1) {\n      this.samplerState.epoch = 0;\n      this.updateSamplerShuffled(trainSize);\n    }\n    const mb = this.minibatchSize;\n    const blocksPerEpoch = Math.max(\n      1,\n      Math.floor(this.samplerState.shuffled.length / mb)\n    );\n    const currEpoch = Math.floor(iteration / blocksPerEpoch);\n    while (currEpoch >= this.samplerState.epoch) {\n      this.updateSamplerShuffled(trainSize);\n    }\n    const base = (iteration * mb) % this.samplerState.shuffled.length;\n    return this.samplerState.shuffled.slice(base, base + mb);\n  }\n\n  private systemAwareMergeWithSig(\n    candidates: ReadonlyArray<{ cfg: Record<string, string>; parent?: number }>,\n    i: number,\n    j: number,\n    pickBetter: (idxA: number, idxB: number) => number\n  ): { cfg: Record<string, string>; descSig: string } {\n    const ancestors = (idx: number): number[] => {\n      const path: number[] = [];\n      let cur: number | undefined = idx;\n      while (cur !== undefined) {\n        path.push(cur);\n        cur = candidates[cur]?.parent;\n      }\n      return path;\n    };\n    const Ai = ancestors(i);\n    const Aj = ancestors(j);\n    const common = Ai.find((x) => Aj.includes(x));\n    const a = common ?? i;\n\n    const cfgA = candidates[a]!.cfg;\n    const cfgI = candidates[i]!.cfg;\n    const cfgJ = candidates[j]!.cfg;\n\n    const merged: Record<string, string> = {};\n    const picks: ('i' | 'j')[] = [];\n    const allKeys = Array.from(\n      new Set([\n        ...Object.keys(cfgA),\n        ...Object.keys(cfgI),\n        ...Object.keys(cfgJ),\n      ])\n    ).sort();\n    for (const k of allKeys) {\n      const pa = cfgA[k];\n      const pi = cfgI[k];\n      const pj = cfgJ[k];\n      if (pi === pa && pj !== pi) {\n        merged[k] = pj!;\n        picks.push('j');\n      } else if (pj === pa && pi !== pj) {\n        merged[k] = pi!;\n        picks.push('i');\n      } else if (pi !== pj && pi !== pa && pj !== pa) {\n        const pick = pickBetter(i, j);\n        merged[k] = pick === i ? pi! : pj!;\n        picks.push(pick === i ? 'i' : 'j');\n      } else {\n        merged[k] = pi ?? pj ?? pa!;\n        picks.push('i');\n      }\n    }\n    return { cfg: merged, descSig: picks.join('|') };\n  }\n\n  private rand(): number {\n    // xorshift32\n    this.rngState ^= this.rngState << 13;\n    this.rngState ^= this.rngState >>> 17;\n    this.rngState ^= this.rngState << 5;\n    return ((this.rngState >>> 0) as number) / 4294967296;\n  }\n\n  private systemAwareMerge(\n    candidates: ReadonlyArray<{ cfg: Record<string, string>; parent?: number }>,\n    i: number,\n    j: number,\n    pickBetter: (idxA: number, idxB: number) => number\n  ): Record<string, string> {\n    // Trace ancestors\n    const ancestors = (idx: number): number[] => {\n      const path: number[] = [];\n      let cur: number | undefined = idx;\n      while (cur !== undefined) {\n        path.push(cur);\n        cur = candidates[cur]?.parent;\n      }\n      return path;\n    };\n    const Ai = ancestors(i);\n    const Aj = ancestors(j);\n    const common = Ai.find((x) => Aj.includes(x));\n    const a = common ?? i; // fallback\n\n    const cfgA = candidates[a]!.cfg;\n    const cfgI = candidates[i]!.cfg;\n    const cfgJ = candidates[j]!.cfg;\n\n    const merged: Record<string, string> = {};\n    const allKeys = new Set([\n      ...Object.keys(cfgA),\n      ...Object.keys(cfgI),\n      ...Object.keys(cfgJ),\n    ]);\n    for (const k of allKeys) {\n      const pa = cfgA[k];\n      const pi = cfgI[k];\n      const pj = cfgJ[k];\n      if (pi === pa && pj !== pi) {\n        merged[k] = pj!;\n      } else if (pj === pa && pi !== pj) {\n        merged[k] = pi!;\n      } else if (pi !== pj && pi !== pa && pj !== pa) {\n        const pick = pickBetter(i, j);\n        merged[k] = pick === i ? pi! : pj!;\n      } else {\n        merged[k] = pi ?? pj ?? pa!;\n      }\n    }\n    return merged;\n  }\n}\n","import type { AxLoggerFunction } from '../../ai/types.js';\n\n// Python optimizer service API types\nexport interface PythonOptimizationParameter {\n  name: string;\n  type: 'float' | 'int' | 'categorical';\n  low?: number;\n  high?: number;\n  choices?: (string | number | boolean)[];\n  step?: number;\n  log?: boolean;\n}\n\nexport interface PythonOptimizationRequest {\n  study_name?: string;\n  parameters: PythonOptimizationParameter[];\n  objective: {\n    name: string;\n    direction: 'minimize' | 'maximize';\n  };\n  n_trials: number;\n  timeout?: number;\n  sampler?: string;\n  pruner?: string;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface PythonOptimizationJob {\n  job_id: string;\n  study_name: string;\n  status: 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';\n  created_at: string;\n}\n\nexport interface PythonJobStatus {\n  job_id: string;\n  study_name: string;\n  status: 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';\n  created_at: string;\n  started_at?: string;\n  completed_at?: string;\n  error?: string;\n  result?: PythonOptimizationResult;\n}\n\nexport interface PythonTrial {\n  number: number;\n  value?: number;\n  params: Record<string, string | number | boolean>;\n  state: string;\n  datetime_start?: string;\n  datetime_complete?: string;\n  duration?: number;\n}\n\nexport interface PythonOptimizationResult {\n  study_name: string;\n  best_trial?: PythonTrial;\n  best_value?: number;\n  best_params?: Record<string, string | number | boolean>;\n  trials: PythonTrial[];\n  n_trials: number;\n  direction: 'minimize' | 'maximize';\n}\n\nexport interface PythonParameterSuggestion {\n  trial_number: number;\n  params: Record<string, string | number | boolean>;\n}\n\nexport interface PythonEvaluationRequest {\n  study_name: string;\n  trial_number: number;\n  value: number;\n  intermediate_values?: Record<number, number>;\n}\n\nexport interface PythonOptimizerClientOptions {\n  endpoint: string;\n  timeout?: number;\n  retryAttempts?: number;\n  retryDelay?: number;\n  logger?: AxLoggerFunction;\n}\n\n/**\n * HTTP client for the Python optimizer service\n */\nexport class PythonOptimizerClient {\n  private endpoint: string;\n  private timeout: number;\n  private retryAttempts: number;\n  private retryDelay: number;\n  private logger?: AxLoggerFunction;\n\n  constructor(options: PythonOptimizerClientOptions) {\n    this.endpoint = options.endpoint.replace(/\\/$/, ''); // Remove trailing slash\n    this.timeout = options.timeout ?? 30000; // 30 seconds default\n    this.retryAttempts = options.retryAttempts ?? 3;\n    this.retryDelay = options.retryDelay ?? 1000; // 1 second\n    this.logger = options.logger;\n  }\n\n  /**\n   * Check if the optimizer service is healthy\n   */\n  async healthCheck(): Promise<boolean> {\n    try {\n      const response = await this.fetchWithRetry('/health', {\n        method: 'GET',\n      });\n      return response.ok;\n    } catch (error) {\n      this.logger?.({\n        name: 'Notification',\n        id: 'health_check_failed',\n        value: `Health check failed: ${error}`,\n      });\n      return false;\n    }\n  }\n\n  /**\n   * Create a new optimization job\n   */\n  async createOptimizationJob(\n    request: PythonOptimizationRequest\n  ): Promise<PythonOptimizationJob> {\n    const response = await this.fetchWithRetry('/optimize', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(request),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to create optimization job: ${error}`);\n    }\n\n    return response.json() as Promise<PythonOptimizationJob>;\n  }\n\n  /**\n   * Get job status and results\n   */\n  async getJobStatus(jobId: string): Promise<PythonJobStatus> {\n    const response = await this.fetchWithRetry(`/jobs/${jobId}`, {\n      method: 'GET',\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to get job status: ${error}`);\n    }\n\n    return response.json() as Promise<PythonJobStatus>;\n  }\n\n  /**\n   * Cancel a job\n   */\n  async cancelJob(jobId: string): Promise<void> {\n    const response = await this.fetchWithRetry(`/jobs/${jobId}`, {\n      method: 'DELETE',\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to cancel job: ${error}`);\n    }\n  }\n\n  /**\n   * Get parameter suggestions for the next trial\n   */\n  async suggestParameters(\n    studyName: string\n  ): Promise<PythonParameterSuggestion> {\n    const response = await this.fetchWithRetry(\n      `/studies/${studyName}/suggest`,\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      }\n    );\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to suggest parameters: ${error}`);\n    }\n\n    return response.json() as Promise<PythonParameterSuggestion>;\n  }\n\n  /**\n   * Report trial evaluation result\n   */\n  async evaluateTrial(request: PythonEvaluationRequest): Promise<void> {\n    const response = await this.fetchWithRetry(\n      `/studies/${request.study_name}/evaluate`,\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(request),\n      }\n    );\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to evaluate trial: ${error}`);\n    }\n  }\n\n  /**\n   * Get optimization results for a study\n   */\n  async getStudyResults(studyName: string): Promise<PythonOptimizationResult> {\n    const response = await this.fetchWithRetry(\n      `/studies/${studyName}/results`,\n      {\n        method: 'GET',\n      }\n    );\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to get study results: ${error}`);\n    }\n\n    return response.json() as Promise<PythonOptimizationResult>;\n  }\n\n  /**\n   * Delete a study\n   */\n  async deleteStudy(studyName: string): Promise<void> {\n    const response = await this.fetchWithRetry(`/studies/${studyName}`, {\n      method: 'DELETE',\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to delete study: ${error}`);\n    }\n  }\n\n  /**\n   * List all studies\n   */\n  async listStudies(): Promise<string[]> {\n    const response = await this.fetchWithRetry('/studies', {\n      method: 'GET',\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to list studies: ${error}`);\n    }\n\n    return response.json() as Promise<string[]>;\n  }\n\n  /**\n   * Wait for job completion with polling\n   */\n  async waitForJobCompletion(\n    jobId: string,\n    pollInterval: number = 2000,\n    maxWaitTime: number = 300000 // 5 minutes default\n  ): Promise<PythonJobStatus> {\n    const startTime = Date.now();\n\n    while (Date.now() - startTime < maxWaitTime) {\n      const status = await this.getJobStatus(jobId);\n\n      if (['completed', 'failed', 'cancelled'].includes(status.status)) {\n        return status;\n      }\n\n      this.logger?.({\n        name: 'Notification',\n        id: 'job_status',\n        value: `Job ${jobId} status: ${status.status}, waiting...`,\n      });\n      await this.sleep(pollInterval);\n    }\n\n    throw new Error(`Job ${jobId} did not complete within ${maxWaitTime}ms`);\n  }\n\n  /**\n   * Fetch with retry logic\n   */\n  private async fetchWithRetry(\n    path: string,\n    options: RequestInit\n  ): Promise<Response> {\n    const url = `${this.endpoint}${path}`;\n    let lastError: Error | null = null;\n\n    for (let attempt = 0; attempt < this.retryAttempts; attempt++) {\n      try {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n        const response = await fetch(url, {\n          ...options,\n          signal: controller.signal,\n        });\n\n        clearTimeout(timeoutId);\n        return response;\n      } catch (error) {\n        lastError = error as Error;\n        this.logger?.({\n          name: 'Notification',\n          id: 'retry_attempt',\n          value: `Attempt ${attempt + 1} failed: ${error}`,\n        });\n\n        if (attempt < this.retryAttempts - 1) {\n          await this.sleep(this.retryDelay * Math.pow(2, attempt)); // Exponential backoff\n        }\n      }\n    }\n\n    throw new Error(\n      `Request failed after ${this.retryAttempts} attempts: ${lastError?.message}`\n    );\n  }\n\n  /**\n   * Sleep utility\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n","import type { AxAIService } from '../../ai/types.js';\nimport type {\n  AxCompileOptions,\n  AxExample,\n  AxMetricFn,\n  AxOptimizerArgs,\n  AxTypedExample,\n} from '../common_types.js';\nimport { AxGen } from '../generate.js';\nimport type { AxOptimizerResult } from '../optimizer.js';\nimport {\n  AxBaseOptimizer,\n  type AxOptimizedProgram,\n  AxOptimizedProgramImpl,\n} from '../optimizer.js';\nimport { ax } from '../template.js';\nimport type {\n  AxGenOut,\n  AxProgramDemos,\n  AxResultPickerFunction,\n} from '../types.js';\n\nimport { AxBootstrapFewShot } from './bootstrapFewshot.js';\nimport {\n  PythonOptimizerClient,\n  type PythonOptimizerClientOptions,\n} from './pythonOptimizerClient.js';\n\ninterface ConfigType extends Record<string, unknown> {\n  instruction: string;\n  bootstrappedDemos: number;\n  labeledExamples: number;\n}\n\n// Extended result interface to include the optimized AxGen and unified optimization result\nexport interface AxMiPROResult<IN, OUT extends AxGenOut>\n  extends AxOptimizerResult<OUT> {\n  optimizedGen?: AxGen<IN, OUT>;\n  optimizedProgram?: AxOptimizedProgram<OUT>;\n}\n\nexport class AxMiPRO extends AxBaseOptimizer {\n  // MiPRO-specific options\n  private maxBootstrappedDemos: number;\n  private maxLabeledDemos: number;\n  private numCandidates: number;\n  private initTemperature: number;\n  private numTrials: number;\n  private minibatch: boolean;\n  private minibatchSize: number;\n  private minibatchFullEvalSteps: number;\n  private programAwareProposer: boolean;\n  private dataAwareProposer: boolean;\n  private viewDataBatchSize: number;\n  private tipAwareProposer: boolean;\n  private fewshotAwareProposer: boolean;\n  private earlyStoppingTrials: number;\n  private minImprovementThreshold: number;\n  private bayesianOptimization: boolean;\n  private acquisitionFunction:\n    | 'expected_improvement'\n    | 'upper_confidence_bound'\n    | 'probability_improvement';\n  private explorationWeight: number;\n  private optimizeTopP: boolean;\n\n  // Self-consistency / multiple sampling\n  private sampleCount: number;\n\n  // JS Bayesian optimizer removed  Python service is required\n\n  // Python optimizer integration\n  private pythonClient?: PythonOptimizerClient;\n  // Local histories for result object (base keeps its own private copies)\n  private localScoreHistory: number[] = [];\n  private localConfigurationHistory: Record<string, unknown>[] = [];\n  // Optional custom result picker passed via optimizer args\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private readonly customResultPicker?: AxResultPickerFunction<any>;\n\n  constructor(args: Readonly<AxOptimizerArgs>) {\n    // Call parent constructor with base args\n    super(args);\n\n    // MiPRO-specific options with proper defaults - now from top-level args\n    this.numCandidates = args.numCandidates ?? 5;\n    this.initTemperature = args.initTemperature ?? 0.7;\n    this.maxBootstrappedDemos = args.maxBootstrappedDemos ?? 3;\n    this.maxLabeledDemos = args.maxLabeledDemos ?? 4;\n    this.numTrials = args.numTrials ?? 30;\n    this.minibatch = args.minibatch ?? true;\n    this.minibatchSize = args.minibatchSize ?? 25;\n    this.minibatchFullEvalSteps = args.minibatchFullEvalSteps ?? 10;\n    this.programAwareProposer = args.programAwareProposer ?? true;\n    this.dataAwareProposer = args.dataAwareProposer ?? true;\n    this.viewDataBatchSize = args.viewDataBatchSize ?? 10;\n    this.tipAwareProposer = args.tipAwareProposer ?? true;\n    this.fewshotAwareProposer = args.fewshotAwareProposer ?? true;\n    this.earlyStoppingTrials = args.earlyStoppingTrials ?? 5;\n    this.minImprovementThreshold = args.minImprovementThreshold ?? 0.01;\n    this.bayesianOptimization = args.bayesianOptimization ?? true;\n    this.acquisitionFunction =\n      args.acquisitionFunction ?? 'expected_improvement';\n    this.explorationWeight = args.explorationWeight ?? 0.1;\n    this.optimizeTopP = args.optimizeTopP ?? false;\n\n    // Self-consistency options\n    this.sampleCount = args.sampleCount ?? 1;\n    // Optional custom picker\n    this.customResultPicker = args.resultPicker as\n      | AxResultPickerFunction<any>\n      | undefined;\n\n    // Initialize Python client if configured - use top-level args instead of nested options\n    if (args.optimizerEndpoint) {\n      const clientOptions: PythonOptimizerClientOptions = {\n        endpoint: args.optimizerEndpoint,\n        timeout: args.optimizerTimeout ?? 30000,\n        retryAttempts: args.optimizerRetries ?? 3,\n        logger: (msg) => {\n          this.logger?.({\n            name: 'Notification',\n            id: 'python_client',\n            value: typeof msg === 'string' ? msg : JSON.stringify(msg),\n          });\n        },\n      };\n      this.pythonClient = new PythonOptimizerClient(clientOptions);\n    }\n\n    // Update convergence threshold in stats\n    this.stats.convergenceInfo.convergenceThreshold =\n      this.minImprovementThreshold;\n  }\n\n  /**\n   * Default result picker used when sampleCount > 1 and no custom picker is provided.\n   * Strategy:\n   * - Function results: pick first non-error result, else index 0\n   * - Field results: majority vote by JSON stringified output; ties  first seen\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private readonly defaultResultPicker: AxResultPickerFunction<any> = async (\n    data: Parameters<AxResultPickerFunction<any>>[0]\n  ) => {\n    if (data.type === 'function') {\n      const idx = data.results.findIndex((r) => !r.isError);\n      return idx >= 0 ? idx : 0;\n    }\n    const counts = new Map<string, { count: number; firstIndex: number }>();\n    for (const r of data.results) {\n      const key = JSON.stringify(r.sample ?? {});\n      const entry = counts.get(key);\n      if (entry) {\n        entry.count += 1;\n      } else {\n        counts.set(key, { count: 1, firstIndex: r.index });\n      }\n    }\n    let bestKey = '';\n    let best = { count: -1, firstIndex: 0 };\n    for (const [k, v] of counts.entries()) {\n      if (v.count > best.count) {\n        best = v;\n        bestKey = k;\n      }\n    }\n    return counts.get(bestKey)?.firstIndex ?? 0;\n  };\n\n  /**\n   * Configures the optimizer for light, medium, or heavy optimization\n   * @param level The optimization level: \"light\", \"medium\", or \"heavy\"\n   */\n  public configureAuto(level: 'light' | 'medium' | 'heavy'): void {\n    switch (level) {\n      case 'light':\n        this.numCandidates = 3;\n        this.numTrials = 10;\n        this.minibatch = true;\n        this.minibatchSize = 20;\n        break;\n      case 'medium':\n        this.numCandidates = 5;\n        this.numTrials = 20;\n        this.minibatch = true;\n        this.minibatchSize = 25;\n        break;\n      case 'heavy':\n        this.numCandidates = 7;\n        this.numTrials = 30;\n        this.minibatch = true;\n        this.minibatchSize = 30;\n        break;\n    }\n  }\n\n  /**\n   * Generates creative tips for instruction generation\n   */\n  private generateTips(): string[] {\n    return [\n      'Be very specific and detailed in your instructions.',\n      'Focus on step-by-step reasoning in your instructions.',\n      'Provide clear constraints and guidelines in your instructions.',\n      'Keep your instructions concise and to the point.',\n      'Emphasize accuracy and precision in your instructions.',\n      'Include examples of good outputs in your instructions.',\n      'Focus on handling edge cases in your instructions.',\n      'Explicitly outline the reasoning process in your instructions.',\n    ];\n  }\n\n  /**\n   * Generates program summary for context-aware instruction generation\n   */\n  private async generateProgramSummary<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>,\n    ai: Readonly<AxAIService>\n  ): Promise<string> {\n    // Extract program structure information\n    const signature = program.getSignature();\n\n    // Create program summary prompt based on paper's Appendix C.5\n    const summaryPrompt = `\nAnalyze this language model program and provide a concise summary of its purpose and structure.\n\nProgram Signature: ${signature}\n\nProvide a 2-3 sentence summary focusing on:\n1. The main task or purpose of this program\n2. The input-output relationship\n3. Any special constraints or requirements\n\nSummary:`;\n\n    try {\n      const response = await ai.chat({\n        chatPrompt: [{ role: 'user', content: summaryPrompt }],\n      });\n      if ('results' in response) {\n        return (\n          response.results[0]?.content?.trim() ||\n          'General language model program'\n        );\n      }\n      return 'General language model program';\n    } catch {\n      return 'General language model program';\n    }\n  }\n\n  /**\n   * Generates dataset summary for context-aware instruction generation\n   */\n  private async generateDatasetSummary(\n    examples: readonly AxExample[],\n    ai: Readonly<AxAIService>\n  ): Promise<string> {\n    if (examples.length === 0) return 'No examples available';\n\n    // Sample a few examples for analysis (based on paper's approach)\n    const sampleSize = Math.min(this.viewDataBatchSize, examples.length);\n    const sampledExamples = examples.slice(0, sampleSize);\n\n    // Create dataset summary prompt based on paper's Appendix C.3\n    const exampleTexts = sampledExamples\n      .map((ex, i) => `Example ${i + 1}: ${JSON.stringify(ex)}`)\n      .join('\\n');\n\n    const summaryPrompt = `\nAnalyze this dataset and provide a concise summary of its characteristics.\n\nSample Examples:\n${exampleTexts}\n\nProvide a 2-3 sentence summary focusing on:\n1. The type of data and domain\n2. Common patterns or structures in the examples\n3. Key challenges or requirements for processing this data\n\nDataset Summary:`;\n\n    try {\n      const response = await ai.chat({\n        chatPrompt: [{ role: 'user', content: summaryPrompt }],\n      });\n      if ('results' in response) {\n        return response.results[0]?.content?.trim() || 'General dataset';\n      }\n      return 'General dataset';\n    } catch {\n      return 'General dataset';\n    }\n  }\n\n  /**\n   * Enhanced instruction generation using AI with program and data awareness\n   */\n  private async generateInstruction({\n    tip,\n    candidateIndex,\n    ai,\n    programSummary,\n    datasetSummary,\n    previousInstructions = [],\n  }: Readonly<{\n    tip: string | undefined;\n    candidateIndex: number;\n    ai: Readonly<AxAIService>;\n    programSummary?: string;\n    datasetSummary?: string;\n    previousInstructions?: string[];\n  }>): Promise<string> {\n    // Build context-aware instruction generation prompt based on paper\n    let contextInfo = '';\n\n    if (this.programAwareProposer && programSummary) {\n      contextInfo += `\\nProgram Context: ${programSummary}`;\n    }\n\n    if (this.dataAwareProposer && datasetSummary) {\n      contextInfo += `\\nDataset Context: ${datasetSummary}`;\n    }\n\n    if (this.fewshotAwareProposer && previousInstructions.length > 0) {\n      contextInfo += `\\nPrevious Instructions (avoid repeating): ${previousInstructions\n        .slice(-3)\n        .join('; ')}`;\n    }\n\n    // Core instruction generation prompt inspired by paper's Appendix C.1\n    const _instructionPrompt = `\nGenerate a high-quality instruction for a language model program.\n\n${contextInfo}\n\n${tip ? `Tip: ${tip}` : ''}\n\nRequirements:\n1. Be specific and actionable\n2. Focus on accuracy and clarity\n3. Consider the program's purpose and data characteristics\n4. Make the instruction distinct from previous ones\n5. Keep it concise but comprehensive\n\nGenerate a single, well-crafted instruction:\nInstruction:`;\n\n    try {\n      const gen = ax(\n        'programSummary?:string \"Program context\" , datasetSummary?:string \"Dataset context\" , tip?:string \"Generation tip\" -> instructionText:string \"Well-crafted instruction for the program\"'\n      );\n      const out = await gen.forward(ai, {\n        programSummary: programSummary ?? '',\n        datasetSummary: datasetSummary ?? '',\n        tip: tip ?? '',\n      });\n      const instruction = (out as any).instructionText as string | undefined;\n      if (instruction && instruction.trim().length > 10) {\n        return instruction.trim();\n      }\n    } catch (_error) {\n      // AI instruction generation failed, will use fallback templates\n    }\n\n    // Fallback to enhanced templates if AI generation fails\n    const enhancedTemplates = [\n      'Analyze the input systematically and provide a precise, well-reasoned response.',\n      'Think through this step-by-step, considering all relevant factors before responding.',\n      'Examine the input carefully and generate an accurate, detailed answer.',\n      'Process the information methodically and deliver a clear, comprehensive response.',\n      'Consider the context thoroughly and provide a thoughtful, accurate answer.',\n    ];\n\n    let instruction =\n      enhancedTemplates[candidateIndex % enhancedTemplates.length] ||\n      enhancedTemplates[0]!;\n\n    if (tip) {\n      instruction = `${instruction} ${tip}`;\n    }\n\n    return instruction;\n  }\n\n  /**\n   * Generates instruction candidates using enhanced AI-powered generation\n   * @param options Optional compile options that may override teacher AI\n   * @returns Array of generated instruction candidates\n   */\n  private async proposeInstructionCandidates<IN, OUT extends AxGenOut>(\n    _program: Readonly<AxGen<IN, OUT>>,\n    options?: AxCompileOptions,\n    examples: readonly AxTypedExample<IN>[] = []\n  ): Promise<string[]> {\n    const instructions: string[] = [];\n    const aiToUse = this.getTeacherOrStudentAI(options);\n\n    // Generate contextual information if enabled\n    let programSummary: string | undefined;\n    let datasetSummary: string | undefined;\n\n    if (this.programAwareProposer) {\n      programSummary = await this.generateProgramSummary(_program, aiToUse);\n    }\n\n    if (this.dataAwareProposer) {\n      datasetSummary = await this.generateDatasetSummary(\n        [...examples] as AxExample[],\n        aiToUse\n      );\n    }\n\n    // Generate creative tips for tip-aware proposing\n    const tips = this.tipAwareProposer ? this.generateTips() : [];\n\n    // Generate instructions for each candidate\n    for (let i = 0; i < this.numCandidates; i++) {\n      const tipIndex = tips.length > 0 ? i % tips.length : -1;\n      const tipToUse = tipIndex >= 0 ? tips[tipIndex] : undefined;\n\n      const instruction = await this.generateInstruction({\n        tip: tipToUse,\n        candidateIndex: i,\n        ai: aiToUse,\n        programSummary,\n        datasetSummary,\n        previousInstructions: instructions, // Pass previous instructions for diversity\n      });\n\n      instructions.push(instruction);\n    }\n\n    return instructions;\n  }\n\n  /**\n   * Bootstraps few-shot examples for the program\n   */\n  private async bootstrapFewShotExamples<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>,\n    metricFn: AxMetricFn,\n    examples: readonly AxTypedExample<IN>[]\n  ): Promise<AxProgramDemos<any, OUT>[]> {\n    // Initialize the bootstrapper for this program\n    const bootstrapper = new AxBootstrapFewShot({\n      studentAI: this.studentAI,\n      options: {\n        maxDemos: this.maxBootstrappedDemos,\n        maxRounds: 3,\n        verboseMode: this.verbose ?? false,\n      },\n    });\n\n    const result = await bootstrapper.compile(program, examples, metricFn, {\n      maxDemos: this.maxBootstrappedDemos,\n    });\n\n    return (result.demos || []) as AxProgramDemos<any, OUT>[];\n  }\n\n  /**\n   * Selects labeled examples directly from the training set\n   */\n  private selectLabeledExamples<IN>(\n    examples: readonly AxTypedExample<IN>[]\n  ): AxTypedExample<IN>[] {\n    const selectedExamples: AxTypedExample<IN>[] = [];\n\n    // Random sampling from the training set\n    const indices = new Set<number>();\n    while (\n      indices.size < this.maxLabeledDemos &&\n      indices.size < examples.length\n    ) {\n      const idx = Math.floor(Math.random() * examples.length);\n      if (!indices.has(idx)) {\n        indices.add(idx);\n        const example = examples[idx];\n        if (example) {\n          selectedExamples.push(example);\n        }\n      }\n    }\n\n    return selectedExamples;\n  }\n\n  /**\n   * Runs optimization to find the best combination of few-shot examples and instructions\n   */\n  // Local JS optimization loop removed\n\n  // Local JS config evaluation removed\n\n  // Shuffle utility removed\n\n  private applyConfigToProgram<_IN, OUT extends AxGenOut>(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    program: any,\n    config: Readonly<ConfigType>,\n    bootstrappedDemos: readonly AxProgramDemos<any, OUT>[],\n    labeledExamples: readonly AxExample[]\n  ): void {\n    // Set instruction if the program supports it\n    if (program.setInstruction) {\n      program.setInstruction(config.instruction);\n    }\n\n    // Set demos if needed\n    if (config.bootstrappedDemos > 0 && program.setDemos) {\n      program.setDemos(bootstrappedDemos.slice(0, config.bootstrappedDemos));\n    }\n\n    // Set examples if needed\n    if (config.labeledExamples > 0 && program.setExamples) {\n      program.setExamples(labeledExamples.slice(0, config.labeledExamples));\n    }\n  }\n\n  /**\n   * The main compile method to run MIPROv2 optimization\n   */\n  public async compile<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>,\n    examples: readonly AxTypedExample<IN>[],\n    metricFn: AxMetricFn,\n    options?: AxCompileOptions\n  ): Promise<AxMiPROResult<IN, OUT>> {\n    const _startTime = Date.now();\n\n    // Validate examples meet minimum requirements\n    this.validateExamples(examples);\n\n    // Initialize random seed if provided\n    this.setupRandomSeed();\n\n    // Configure auto settings if provided\n    if (options?.auto) {\n      this.configureAuto(options.auto);\n    }\n\n    // Python optimizer is REQUIRED for MiPRO v2\n    if (!this.pythonClient) {\n      throw new Error(\n        'AxMiPRO v2 requires the Python optimizer service. Please configure optimizerEndpoint.'\n      );\n    }\n\n    const isHealthy = await this.pythonClient.healthCheck();\n    if (!isHealthy) {\n      throw new Error('Python optimizer service is not available or unhealthy');\n    }\n\n    return await this.compilePython(program, examples, metricFn, options);\n  }\n\n  /**\n   * Applies a configuration to an AxGen instance\n   */\n  private applyConfigToAxGen<IN, OUT extends AxGenOut>(\n    axgen: Readonly<AxGen<IN, OUT>>,\n    config: Readonly<ConfigType>,\n    bootstrappedDemos: readonly AxProgramDemos<any, OUT>[],\n    labeledExamples: readonly AxExample[]\n  ): void {\n    // Set instruction if the AxGen supports it\n    if (\n      'setInstruction' in axgen &&\n      typeof axgen.setInstruction === 'function'\n    ) {\n      axgen.setInstruction(config.instruction);\n    }\n\n    // Set demos if needed\n    if (config.bootstrappedDemos > 0) {\n      axgen.setDemos(bootstrappedDemos.slice(0, config.bootstrappedDemos));\n    }\n\n    // Set examples if needed\n    if (config.labeledExamples > 0) {\n      axgen.setExamples(\n        labeledExamples.slice(\n          0,\n          config.labeledExamples\n        ) as unknown as readonly (OUT & IN)[]\n      );\n    }\n  }\n\n  /**\n   * Get optimizer-specific configuration\n   * @returns Current optimizer configuration\n   */\n  public getConfiguration(): Record<string, unknown> {\n    return {\n      numCandidates: this.numCandidates,\n      initTemperature: this.initTemperature,\n      maxBootstrappedDemos: this.maxBootstrappedDemos,\n      maxLabeledDemos: this.maxLabeledDemos,\n      numTrials: this.numTrials,\n      minibatch: this.minibatch,\n      minibatchSize: this.minibatchSize,\n      minibatchFullEvalSteps: this.minibatchFullEvalSteps,\n      programAwareProposer: this.programAwareProposer,\n      dataAwareProposer: this.dataAwareProposer,\n      tipAwareProposer: this.tipAwareProposer,\n      fewshotAwareProposer: this.fewshotAwareProposer,\n      earlyStoppingTrials: this.earlyStoppingTrials,\n      minImprovementThreshold: this.minImprovementThreshold,\n      bayesianOptimization: this.bayesianOptimization,\n      acquisitionFunction: this.acquisitionFunction,\n      explorationWeight: this.explorationWeight,\n      sampleCount: this.sampleCount,\n    };\n  }\n\n  /**\n   * Update optimizer configuration\n   * @param config New configuration to merge with existing\n   */\n  public updateConfiguration(config: Readonly<Record<string, unknown>>): void {\n    if (config.numCandidates !== undefined) {\n      this.numCandidates = config.numCandidates as number;\n    }\n    if (config.initTemperature !== undefined) {\n      this.initTemperature = config.initTemperature as number;\n    }\n    if (config.maxBootstrappedDemos !== undefined) {\n      this.maxBootstrappedDemos = config.maxBootstrappedDemos as number;\n    }\n    if (config.maxLabeledDemos !== undefined) {\n      this.maxLabeledDemos = config.maxLabeledDemos as number;\n    }\n    if (config.numTrials !== undefined) {\n      this.numTrials = config.numTrials as number;\n    }\n    if (config.minibatch !== undefined) {\n      this.minibatch = config.minibatch as boolean;\n    }\n    if (config.minibatchSize !== undefined) {\n      this.minibatchSize = config.minibatchSize as number;\n    }\n    if (config.earlyStoppingTrials !== undefined) {\n      this.earlyStoppingTrials = config.earlyStoppingTrials as number;\n    }\n    if (config.minImprovementThreshold !== undefined) {\n      this.minImprovementThreshold = config.minImprovementThreshold as number;\n    }\n    if (config.sampleCount !== undefined) {\n      this.sampleCount = config.sampleCount as number;\n    }\n    // Note: verbose is now handled by the base class and cannot be updated here\n  }\n\n  /**\n   * Reset optimizer state for reuse with different programs\n   */\n  public override reset(): void {\n    super.reset();\n    this.stats.convergenceInfo.convergenceThreshold =\n      this.minImprovementThreshold;\n  }\n\n  /**\n   * Validate that the optimizer can handle the given program\n   * @param program Program to validate\n   * @returns Validation result with any issues found\n   */\n  public validateProgram<IN, OUT extends AxGenOut>(\n    _program: Readonly<AxGen<IN, OUT>>\n  ): {\n    isValid: boolean;\n    issues: string[];\n    suggestions: string[];\n  } {\n    // Start with empty validation result\n    const issues: string[] = [];\n    const suggestions: string[] = [];\n\n    // Add MiPRO-specific validation\n\n    // Validation is now handled in the compile() method\n\n    return {\n      isValid: issues.length === 0,\n      issues,\n      suggestions,\n    };\n  }\n\n  // JS surrogate model and acquisition functions removed\n\n  /**\n   * Python-based compilation method\n   *\n   * This is a simplified implementation that demonstrates integration\n   * with the Python optimizer service. For now, it focuses on basic\n   * parameter optimization rather than full MiPRO functionality.\n   */\n  private async compilePython<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>,\n    examples: readonly AxTypedExample<IN>[],\n    metricFn: AxMetricFn,\n    _options?: AxCompileOptions\n  ): Promise<AxMiPROResult<IN, OUT>> {\n    if (!this.pythonClient) {\n      throw new Error('Python client not initialized');\n    }\n\n    // Track optimization wall time\n    const startTime = Date.now();\n\n    // Reset local histories for this run\n    this.localScoreHistory = [];\n    this.localConfigurationHistory = [];\n\n    const studyName = `mipro_${Date.now()}_${Math.random()\n      .toString(36)\n      .substr(2, 9)}`;\n\n    // Create optimization request - simplified parameter set for now\n    const optimizationRequest = {\n      study_name: studyName,\n      parameters: [\n        {\n          name: 'temperature',\n          type: 'float' as const,\n          low: 0.1,\n          high: 2.0,\n        },\n        {\n          name: 'bootstrappedDemos',\n          type: 'int' as const,\n          low: 0,\n          high: this.maxBootstrappedDemos,\n        },\n        // Optionally include topP as a conservative sampling knob\n        ...(this.optimizeTopP\n          ? ([\n              {\n                name: 'topP',\n                type: 'float' as const,\n                low: 0.7,\n                high: 1.0,\n              },\n            ] as const)\n          : ([] as const)),\n      ],\n      objective: {\n        name: 'score',\n        direction: 'maximize' as const,\n      },\n      n_trials: this.numTrials,\n      sampler: 'TPESampler',\n      pruner: this.minibatch ? 'MedianPruner' : undefined,\n    };\n\n    // Create the optimization job\n    const job =\n      await this.pythonClient.createOptimizationJob(optimizationRequest);\n\n    const optLogger = this.getOptimizerLogger();\n    optLogger?.({\n      name: 'OptimizationStart',\n      value: {\n        optimizerType: 'MiPRO (Python)',\n        exampleCount: examples.length,\n        validationCount: 0,\n        config: { jobId: job.job_id, numTrials: this.numTrials },\n      },\n    });\n\n    let bestScore = Number.NEGATIVE_INFINITY;\n    let bestConfiguration: Record<string, unknown> | undefined;\n    let totalTrials = 0;\n    let stagnationRounds = 0;\n\n    // Run optimization trials\n    for (let trial = 0; trial < this.numTrials; trial++) {\n      try {\n        // Get parameter suggestion from Python service\n        const suggestion = await this.pythonClient.suggestParameters(studyName);\n\n        // Apply the suggested parameters - throw error if missing\n        const temperature = suggestion.params.temperature as number;\n        const bootstrappedDemos = suggestion.params.bootstrappedDemos as number;\n        const topP = this.optimizeTopP\n          ? (suggestion.params.topP as number | undefined)\n          : undefined;\n\n        if (temperature === undefined) {\n          throw new Error(\n            `Missing temperature parameter in suggestion: ${JSON.stringify(\n              suggestion\n            )}`\n          );\n        }\n        if (bootstrappedDemos === undefined) {\n          throw new Error(\n            `Missing bootstrappedDemos parameter in suggestion: ${JSON.stringify(\n              suggestion\n            )}`\n          );\n        }\n\n        // Choose evaluation set: minibatch vs full\n        const useFullEval =\n          !this.minibatch ||\n          (this.minibatchFullEvalSteps > 0 &&\n            trial % this.minibatchFullEvalSteps ===\n              this.minibatchFullEvalSteps - 1);\n\n        // Random minibatch to reduce bias\n        const evalSet = useFullEval\n          ? [...examples]\n          : (() => {\n              const size = Math.min(this.minibatchSize, examples.length);\n              const indices = new Set<number>();\n              while (indices.size < size) {\n                indices.add(Math.floor(Math.random() * examples.length));\n              }\n              return Array.from(indices).map((i) => examples[i]!);\n            })();\n\n        // Evaluate with the suggested parameters\n        const score = await this.evaluateConfiguration(\n          program,\n          metricFn,\n          { temperature, bootstrappedDemos, topP },\n          evalSet\n        );\n\n        totalTrials++;\n\n        // Report the result back to Python optimizer\n        await this.pythonClient.evaluateTrial({\n          study_name: studyName,\n          trial_number: suggestion.trial_number,\n          value: score,\n        });\n\n        // Update best result and early stopping accounting\n        if (score > bestScore + this.minImprovementThreshold) {\n          bestScore = score;\n          bestConfiguration = {\n            temperature,\n            bootstrappedDemos,\n            ...(topP !== undefined ? { topP } : {}),\n            trialNumber: suggestion.trial_number,\n          };\n          stagnationRounds = 0;\n        } else {\n          stagnationRounds += 1;\n        }\n\n        // Update the current round for progress tracking\n        this.currentRound = trial + 1;\n\n        // Persist histories locally and via base helper (also emits logger + checkpoints)\n        const configuration = {\n          temperature,\n          bootstrappedDemos,\n          ...(topP !== undefined ? { topP } : {}),\n          trialNumber: suggestion.trial_number,\n        };\n        this.localScoreHistory.push(score);\n        this.localConfigurationHistory.push(configuration);\n        await this.updateOptimizationProgress(\n          this.currentRound,\n          score,\n          configuration,\n          'MiPRO (Python)',\n          { sampler: 'TPESampler' },\n          bestScore,\n          bestConfiguration\n        );\n\n        // Report progress\n        this.onProgress?.({\n          round: trial + 1,\n          totalRounds: this.numTrials,\n          currentScore: score,\n          bestScore,\n          tokensUsed: this.stats.estimatedTokenUsage,\n          timeElapsed: Date.now() - startTime,\n          successfulExamples: totalTrials,\n          totalExamples: examples.length,\n        });\n\n        // Early stopping check\n        if (\n          this.earlyStoppingTrials > 0 &&\n          stagnationRounds >= this.earlyStoppingTrials\n        ) {\n          const optLogger = this.getOptimizerLogger();\n          optLogger?.({\n            name: 'EarlyStopping',\n            value: {\n              reason: `No improvement  ${this.minImprovementThreshold} for ${this.earlyStoppingTrials} trials`,\n              finalScore: bestScore,\n              round: this.currentRound,\n            },\n          });\n          this.onEarlyStop?.(\n            `No improvement for ${this.earlyStoppingTrials} trials`,\n            this.stats\n          );\n          break;\n        }\n      } catch (_error) {\n        // Continue with next trial - skip failed trials\n      }\n    }\n\n    // Get final results from Python optimizer\n    let finalBestScore = bestScore;\n    let finalBestConfig = {};\n    let bestDemos: AxProgramDemos<any, OUT>[] = [];\n\n    try {\n      const studyResults = await this.pythonClient.getStudyResults(studyName);\n      finalBestScore = studyResults.best_value || bestScore;\n      finalBestConfig = studyResults.best_params || {};\n\n      // If we got a good configuration from Python, generate demos for it\n      if (finalBestConfig && Object.keys(finalBestConfig).length > 0) {\n        const bootstrappedDemos =\n          (finalBestConfig as any).bootstrappedDemos || 0;\n        if (bootstrappedDemos > 0) {\n          // Generate demos using the best configuration\n          bestDemos = await this.bootstrapFewShotExamples(\n            program,\n            metricFn,\n            examples.slice(0, Math.floor(examples.length * 0.8)) // Use training split\n          );\n          bestDemos = bestDemos.slice(0, bootstrappedDemos);\n        }\n      }\n    } catch (_error) {\n      // Failed to get study results - use local tracking\n    }\n\n    // Build MiPRO-specific explanation using ax()\n    let explanation:\n      | {\n          humanExplanation: string;\n          recommendations: string[];\n          performanceAssessment: string;\n        }\n      | undefined;\n    try {\n      const explainer = ax(\n        'optimizerType:string \"Optimizer name\" , bestScore:number \"Final best score\" , totalCalls:number \"Total eval calls\" , successfulDemos:number \"Successful evals\" , bestConfig:json \"Best configuration\" -> humanExplanation:string \"Readable summary\", recommendations:string[] \"Next steps\", performanceAssessment:string \"Performance notes\"'\n      );\n      const out = await explainer.forward(this.studentAI, {\n        optimizerType: 'MiPRO (Python)',\n        bestScore: finalBestScore,\n        totalCalls: this.stats.totalCalls,\n        successfulDemos: this.stats.successfulDemos,\n        bestConfig: finalBestConfig || {},\n      });\n      explanation = {\n        humanExplanation: (out as any).humanExplanation ?? '',\n        recommendations: ((out as any).recommendations ?? []) as string[],\n        performanceAssessment: (out as any).performanceAssessment ?? '',\n      };\n    } catch {}\n\n    // Log human-readable completion message\n    await this.logOptimizationComplete(\n      'MiPRO (Python)',\n      finalBestScore,\n      finalBestConfig,\n      _options,\n      explanation\n    );\n\n    // Cleanup\n    try {\n      await this.pythonClient.deleteStudy(studyName);\n    } catch (_error) {\n      // Ignore cleanup errors\n    }\n\n    // Update stats with final best score; per-eval accounting is handled in evaluateConfiguration\n    this.stats.bestScore = finalBestScore;\n\n    // Create optimized generator with best configuration\n    const optimizedGen = new AxGen(program.getSignature());\n    if (bestDemos.length > 0) {\n      optimizedGen.setDemos(bestDemos);\n    }\n    if ((finalBestConfig as any).temperature) {\n      // Store temperature in optimized generator - it will be used in forward calls via model config\n      (optimizedGen as any)._optimizedModelConfig = {\n        temperature: (finalBestConfig as any).temperature,\n      };\n    }\n\n    // Create unified optimization result for Python path\n    const optimizedProgram = new AxOptimizedProgramImpl<OUT>({\n      bestScore: finalBestScore,\n      stats: this.stats,\n      instruction: undefined, // Python path doesn't optimize instructions yet\n      demos: bestDemos,\n      examples: [],\n      modelConfig: {\n        temperature: (finalBestConfig as any).temperature,\n        // Add other model config parameters as they are optimized\n      },\n      optimizerType: 'MiPRO (Python)',\n      optimizationTime: Date.now() - startTime,\n      totalRounds: this.numTrials,\n      converged: this.stats.convergenceInfo.converged,\n      scoreHistory: [...this.localScoreHistory],\n      configurationHistory: [...this.localConfigurationHistory],\n    });\n\n    // Generate optimization insights report\n    this.generateOptimizationReport(finalBestScore, bestDemos.length);\n\n    return {\n      bestScore: finalBestScore,\n      demos: bestDemos,\n      stats: this.stats,\n      optimizedGen,\n      optimizedProgram,\n      finalConfiguration: {\n        temperature: (finalBestConfig as any).temperature,\n        bootstrappedDemos: (finalBestConfig as any).bootstrappedDemos || 0,\n        ...finalBestConfig,\n      },\n    };\n  }\n\n  private generateOptimizationReport(\n    bestScore: number | undefined,\n    demosCount: number\n  ): void {\n    console.log('\\n MiPRO Optimization Complete!\\n');\n\n    console.log(' Improvements:');\n    if (bestScore !== undefined && bestScore > 0) {\n      console.log(` Best score achieved: ${bestScore.toFixed(3)}`);\n    }\n    if (demosCount > 0) {\n      console.log(` Generated ${demosCount} optimized demonstrations`);\n    }\n    console.log(' Systematic prompt and example optimization');\n    console.log(' Automated instruction refinement process\\n');\n\n    console.log(' Limitations:');\n    if (this.stats.totalCalls < 50) {\n      console.log(' Relatively few optimization trials performed');\n    }\n    if (demosCount < 5) {\n      console.log(' Limited number of demonstrations generated');\n    }\n    console.log(' Results depend on teacher model quality');\n    console.log(' Optimization time increases with example complexity\\n');\n\n    console.log(' Key Issues:');\n    if (bestScore !== undefined && bestScore < 0.7) {\n      console.log(' Final performance may still have room for improvement');\n    }\n    if (this.stats.convergenceInfo?.converged === false) {\n      console.log(' Optimization may not have fully converged');\n    }\n    console.log(' Evaluation metrics may need domain-specific tuning');\n    console.log(' Bootstrap quality depends on initial examples\\n');\n\n    console.log(' What This Means:');\n    console.log(' MiPRO successfully automated prompt engineering');\n    console.log(\n      ' Optimized instructions and examples improve model performance'\n    );\n    console.log(' Framework reduces manual prompt engineering effort');\n    console.log(\n      ' More training data and iterations would likely improve results'\n    );\n  }\n\n  /**\n   * Simplified evaluation method for Python optimization\n   */\n  private async evaluateConfiguration<IN, OUT extends AxGenOut>(\n    program: Readonly<AxGen<IN, OUT>>,\n    metricFn: AxMetricFn,\n    config: { temperature: number; bootstrappedDemos: number; topP?: number },\n    examples: readonly AxExample[]\n  ): Promise<number> {\n    let totalScore = 0;\n    let validResults = 0;\n    let successCount = 0;\n\n    // Use provided examples set (already mini-batched/full-selected by caller)\n    const evaluationExamples = examples as readonly AxTypedExample<IN>[];\n\n    // Optional: Pre-bootstrap demos once and reuse for this configuration\n    let demosForConfig: AxProgramDemos<any, OUT>[] = [];\n    if (config.bootstrappedDemos > 0) {\n      try {\n        const bootstrapped = await this.bootstrapFewShotExamples(\n          program,\n          metricFn,\n          evaluationExamples\n        );\n        demosForConfig = bootstrapped.slice(0, config.bootstrappedDemos);\n      } catch {\n        // If bootstrap fails, continue without demos\n        demosForConfig = [];\n      }\n    }\n\n    for (const example of evaluationExamples) {\n      try {\n        // Apply bootstrapped demos for this configuration if any were generated\n        if (demosForConfig.length > 0) {\n          // Best-effort application; program is Readonly in type but supports runtime mutation\n          (program as any).setDemos?.(demosForConfig);\n        }\n\n        // Apply the optimized configuration (temperature) during evaluation\n        const prediction = await program.forward(\n          this.studentAI,\n          example as IN,\n          {\n            modelConfig: {\n              temperature: config.temperature,\n              ...(config.topP !== undefined ? { topP: config.topP } : {}),\n            },\n            // Enable self-consistency if configured\n            sampleCount: this.sampleCount,\n            resultPicker:\n              this.sampleCount > 1\n                ? (this.customResultPicker ?? this.defaultResultPicker)\n                : undefined,\n          }\n        );\n        this.stats.totalCalls += 1;\n\n        const score = await metricFn({ prediction, example });\n\n        if (typeof score === 'number' && !Number.isNaN(score)) {\n          totalScore += score;\n          validResults++;\n          const threshold =\n            typeof this.targetScore === 'number' ? this.targetScore : 0.5;\n          if (score >= threshold) {\n            successCount++;\n          }\n        }\n      } catch (_error) {\n        // Use base logger if available\n        const logger = this.getLogger();\n        logger?.({\n          name: 'Notification',\n          id: 'mipro_evaluate',\n          value: typeof _error === 'string' ? _error : String(_error),\n        });\n        // Continue with other examples\n      }\n    }\n\n    this.stats.successfulDemos += successCount;\n    return validResults > 0 ? totalScore / validResults : 0;\n  }\n}\n\n// Local JS result picker removed\n","/**\n * Analyzes mapping functions to extract state dependencies.\n *\n * This class is crucial for the automatic parallelization feature of AxFlow.\n * It determines which fields in the state object a mapping function accesses,\n * which allows the execution planner to understand dependencies between steps\n * and optimize execution by running independent steps in parallel.\n *\n * The analyzer uses two complementary approaches:\n * 1. Static analysis of the function source code\n * 2. Dynamic proxy-based tracking as a fallback\n *\n * This dual approach ensures robust dependency detection even for complex\n * mapping functions that might use destructuring, computed property access,\n * or other advanced JavaScript patterns.\n */\nexport class AxFlowDependencyAnalyzer {\n  /**\n   * Analyzes a mapping function to determine which state fields it depends on.\n   *\n   * This method is called for every execute step to understand what data\n   * the step needs from the current state. This information is used to:\n   * - Build the dependency graph for parallel execution\n   * - Ensure steps execute in the correct order\n   * - Optimize performance by identifying independent operations\n   *\n   * The analysis process:\n   * 1. First tries static analysis by parsing the function source\n   * 2. Falls back to proxy-based tracking for complex cases\n   * 3. Returns a list of field names that the mapping function accesses\n   *\n   * @param mapping - The mapping function that transforms state to node inputs\n   * @param _nodeName - The name of the node (currently unused but kept for future use)\n   * @returns Array of field names that the mapping function depends on\n   *\n   * @example\n   * ```typescript\n   * // For a mapping like: state => ({ query: state.userInput, context: state.previousResult })\n   * // This would return: ['userInput', 'previousResult']\n   * ```\n   */\n  analyzeMappingDependencies(\n    mapping: (state: any) => any,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _nodeName: string\n  ): string[] {\n    // Handle null/undefined mapping functions\n    if (!mapping || typeof mapping !== 'function') {\n      return [];\n    }\n\n    const dependencies: string[] = [];\n\n    try {\n      // Method 1: Static analysis of function source\n      // This approach parses the function's source code to find property access patterns\n      // It's fast and works for most common cases like state.fieldName\n      const source = mapping.toString();\n      const stateAccessMatches = Array.from(source.matchAll(/state\\.(\\w+)/g));\n      for (const match of stateAccessMatches) {\n        if (match[1] && !dependencies.includes(match[1])) {\n          dependencies.push(match[1]);\n        }\n      }\n\n      // Method 2: Proxy-based tracking (fallback for complex cases)\n      // This approach actually calls the mapping function with a proxy object\n      // that tracks all property access, catching cases that static analysis might miss\n      // Examples: destructuring, computed properties, nested access patterns\n      if (dependencies.length === 0) {\n        try {\n          const tracker = this.createDependencyTracker(dependencies);\n          mapping(tracker);\n        } catch {\n          // Expected - we're just tracking access patterns, not executing the logic\n          // The function may throw errors when called with our proxy, but that's OK\n        }\n      }\n    } catch (error) {\n      // If any error occurs during analysis, return empty dependencies\n      console.debug('Dependency analysis failed:', error);\n    }\n\n    return dependencies;\n  }\n\n  /**\n   * Creates a tracking proxy for dependency analysis.\n   *\n   * This is a public method that creates a proxy to track property access patterns.\n   * It's used for testing and advanced dependency analysis scenarios.\n   *\n   * @param target - The target object to wrap with a proxy\n   * @param accessed - Array to collect accessed property names\n   * @returns Proxy object that tracks property access\n   */\n  createTrackingProxy(target: any, accessed: string[]): any {\n    const self = this;\n    return new Proxy(target, {\n      get(obj, prop) {\n        if (typeof prop === 'string' && !accessed.includes(prop)) {\n          accessed.push(prop);\n        }\n\n        const value = obj[prop];\n\n        // Return nested proxies for objects to track deeper access\n        if (value && typeof value === 'object') {\n          return self.createTrackingProxy(value, accessed);\n        }\n\n        return value;\n      },\n\n      has(obj, prop) {\n        if (typeof prop === 'string' && !accessed.includes(prop)) {\n          accessed.push(prop);\n        }\n        return prop in obj;\n      },\n    });\n  }\n\n  /**\n   * Parses function source code to extract state dependencies using static analysis.\n   *\n   * This method analyzes the source code of a function to find patterns like\n   * `state.fieldName` and extracts the field names as dependencies.\n   *\n   * @param functionSource - The source code of the function to analyze\n   * @returns Array of field names found in the source code\n   */\n  parseStaticDependencies(functionSource: string): string[] {\n    const dependencies: string[] = [];\n\n    try {\n      // Match state.fieldName patterns\n      const stateAccessMatches = Array.from(\n        functionSource.matchAll(/state\\.(\\w+)/g)\n      );\n      for (const match of stateAccessMatches) {\n        if (match[1] && !dependencies.includes(match[1])) {\n          dependencies.push(match[1]);\n        }\n      }\n\n      // Match template literal patterns ${state.fieldName}\n      const templateMatches = Array.from(\n        functionSource.matchAll(/\\$\\{state\\.(\\w+)\\}/g)\n      );\n      for (const match of templateMatches) {\n        if (match[1] && !dependencies.includes(match[1])) {\n          dependencies.push(match[1]);\n        }\n      }\n\n      // Match destructuring patterns\n      const destructureMatches = Array.from(\n        functionSource.matchAll(/\\{\\s*(\\w+)(?:\\s*,\\s*(\\w+))*\\s*\\}\\s*=\\s*state/g)\n      );\n      for (const match of destructureMatches) {\n        for (let i = 1; i < match.length; i++) {\n          if (match[i] && !dependencies.includes(match[i])) {\n            dependencies.push(match[i]);\n          }\n        }\n      }\n    } catch (error) {\n      // If parsing fails, return empty array\n      console.debug('Static dependency parsing failed:', error);\n    }\n\n    return dependencies;\n  }\n\n  /**\n   * Creates a proxy object that tracks property access for dependency analysis.\n   *\n   * This proxy intercepts all property access on the state object and records\n   * which fields are being accessed. It's used as a fallback when static analysis\n   * can't determine dependencies (e.g., for destructuring or computed properties).\n   *\n   * The proxy works by:\n   * 1. Intercepting all property access via the 'get' trap\n   * 2. Recording accessed property names in the dependencies array\n   * 3. Returning nested proxies for chained property access\n   *\n   * This allows detection of complex access patterns like:\n   * - Destructuring: const { field1, field2 } = state\n   * - Computed properties: state[dynamicKey]\n   * - Nested access: state.nested.field\n   *\n   * @param dependencies - Array to collect dependency names (modified in place)\n   * @returns Proxy object that tracks property access\n   */\n  private createDependencyTracker(dependencies: string[]): any {\n    return new Proxy(\n      {},\n      {\n        get(_target, prop) {\n          // Record this property access if it's a string and not already recorded\n          if (typeof prop === 'string' && !dependencies.includes(prop)) {\n            dependencies.push(prop);\n          }\n\n          // Return another proxy for nested access patterns\n          // This allows tracking of chained property access like state.nested.field\n          return new Proxy(\n            {},\n            {\n              get: () => undefined, // Always return undefined for nested access\n            }\n          );\n        },\n      }\n    );\n  }\n}\n","/**\n * Utility functions for batch processing in parallel operations\n */\n\n/**\n * Processes an array of promises in batches with concurrency control\n *\n * @param items - Array of items to process\n * @param processor - Function that converts item to promise\n * @param batchSize - Number of items to process in each batch (default: unlimited)\n * @returns Promise that resolves to array of results in original order\n */\nexport async function processBatches<T, R>(\n  items: T[],\n  processor: (item: T, index: number) => Promise<R>,\n  batchSize?: number\n): Promise<R[]> {\n  // If no batch size specified, process all at once\n  if (!batchSize || batchSize <= 0 || batchSize >= items.length) {\n    const promises = items.map((item, index) => processor(item, index));\n    return Promise.all(promises);\n  }\n\n  const results: R[] = new Array(items.length);\n\n  // Process items in batches\n  for (let i = 0; i < items.length; i += batchSize) {\n    const batch = items.slice(i, i + batchSize);\n    const batchPromises = batch.map((item, batchIndex) => {\n      const originalIndex = i + batchIndex;\n      return processor(item, originalIndex).then((result) => ({\n        result,\n        originalIndex,\n      }));\n    });\n\n    const batchResults = await Promise.all(batchPromises);\n\n    // Place results in correct positions\n    for (const { result, originalIndex } of batchResults) {\n      results[originalIndex] = result;\n    }\n  }\n\n  return results;\n}\n\n/**\n * Chunks an array into smaller arrays of specified size\n *\n * @param array - Array to chunk\n * @param chunkSize - Size of each chunk\n * @returns Array of chunks\n */\nexport function chunk<T>(array: T[], chunkSize: number): T[][] {\n  if (chunkSize <= 0) {\n    return [array];\n  }\n\n  const chunks: T[][] = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    chunks.push(array.slice(i, i + chunkSize));\n  }\n  return chunks;\n}\n","import { processBatches } from './batchUtil.js';\nimport { AxFlowDependencyAnalyzer } from './dependencyAnalyzer.js';\nimport type {\n  AxFlowExecutionStep,\n  AxFlowParallelGroup,\n  AxFlowStepFunction,\n} from './types.js';\n\n/**\n * Builds and manages the execution plan with automatic parallelization.\n *\n * This class is the core of AxFlow's performance optimization system.\n * It analyzes the dependency relationships between steps and creates\n * an optimized execution plan that maximizes parallelism while ensuring\n * correct execution order.\n *\n * Key responsibilities:\n * 1. **Dependency Analysis**: Tracks what fields each step depends on and produces\n * 2. **Parallel Grouping**: Groups independent steps that can run simultaneously\n * 3. **Execution Optimization**: Creates optimized execution functions that\n *    run parallel groups concurrently\n * 4. **Signature Inference**: Provides data for automatic signature generation\n *\n * The planner works by building a directed acyclic graph (DAG) of dependencies\n * and then creating execution levels where all steps in a level can run in parallel.\n */\nexport class AxFlowExecutionPlanner {\n  private steps: AxFlowExecutionStep[] = [];\n  private parallelGroups: AxFlowParallelGroup[] = [];\n  private readonly analyzer = new AxFlowDependencyAnalyzer();\n  private initialFields: Set<string> = new Set();\n\n  /**\n   * Adds an execution step to the plan for analysis and optimization.\n   *\n   * This method is called for every operation in the flow (execute, map, merge, etc.)\n   * and performs dependency analysis to understand what the step needs and produces.\n   * This information is crucial for building the parallel execution plan.\n   *\n   * The method handles different types of steps:\n   * - **Execute steps**: LLM node operations that depend on specific state fields\n   * - **Map steps**: Transformations that modify the state object\n   * - **Merge steps**: Operations that combine results from branches or parallel operations\n   * - **Other steps**: Generic operations that don't fit other categories\n   *\n   * @param stepFunction - The actual function to execute for this step\n   * @param nodeName - Name of the node (for execute steps)\n   * @param mapping - Function that maps state to node inputs (for execute steps)\n   * @param stepType - Type of step for specialized analysis\n   * @param mapTransform - Transformation function (for map steps)\n   * @param mergeOptions - Options for merge operations (result key, merge function)\n   */\n  addExecutionStep(\n    stepFunction: AxFlowStepFunction,\n    nodeName?: string,\n    mapping?: (state: any) => any,\n    stepType?:\n      | 'execute'\n      | 'map'\n      | 'merge'\n      | 'parallel-map'\n      | 'parallel'\n      | 'derive',\n    mapTransform?: (state: any) => any,\n    mergeOptions?: {\n      resultKey?: string;\n      mergeFunction?: (...args: any[]) => any;\n    },\n    deriveOptions?: {\n      inputFieldName: string;\n      outputFieldName: string;\n      batchSize?: number;\n    }\n  ): void {\n    let dependencies: string[] = [];\n    let produces: string[] = [];\n    let type:\n      | 'execute'\n      | 'map'\n      | 'merge'\n      | 'parallel-map'\n      | 'parallel'\n      | 'derive' = stepType || 'map';\n\n    if (nodeName && mapping) {\n      type = 'execute';\n      dependencies = this.analyzer.analyzeMappingDependencies(\n        mapping,\n        nodeName\n      );\n      // For execute steps, we know the result will be stored as `${nodeName}Result`\n      produces = [`${nodeName}Result`];\n    } else if (type === 'map' && mapTransform) {\n      // Analyze map transformation to determine what fields it produces\n      const mapOutputFields = this.analyzeMapTransformation(mapTransform);\n      produces = mapOutputFields;\n      dependencies = this.getAllProducedFields();\n    } else if (type === 'parallel-map') {\n      // Parallel map operations produce fields from all transforms\n      if (Array.isArray(mapTransform)) {\n        // Multiple transforms - analyze each one\n        const allFields = new Set<string>();\n        for (const transform of mapTransform) {\n          const fields = this.analyzeMapTransformation(transform);\n          fields.forEach((f) => allFields.add(f));\n        }\n        produces = Array.from(allFields);\n      } else if (mapTransform) {\n        // Single transform\n        produces = this.analyzeMapTransformation(mapTransform);\n      } else {\n        // No transform provided, use default\n        produces = ['_parallelMapResult'];\n      }\n      dependencies = this.getAllProducedFields();\n    } else if (type === 'merge') {\n      // Merge operations produce their result key or merge all previous results\n      if (mergeOptions?.resultKey) {\n        produces = [mergeOptions.resultKey];\n      } else {\n        // Branch merge - analyze what fields the branches produce\n        const branchFields = this.analyzeBranchMergeFields();\n        produces = branchFields.length > 0 ? branchFields : ['_mergedResult'];\n      }\n\n      // Check if this is a parallel merge step by looking at the function code\n      const funcCode = stepFunction.toString();\n      if (funcCode.includes('_parallelResults')) {\n        dependencies = ['_parallelResults'];\n      } else {\n        dependencies = this.getAllProducedFields();\n      }\n    } else if (type === 'parallel') {\n      // Parallel operations produce _parallelResults for merge step\n      produces = ['_parallelResults'];\n      dependencies = this.getAllProducedFields();\n    } else if (type === 'derive') {\n      // Derive operations produce the specified output field and depend on the input field\n      if (deriveOptions?.outputFieldName && deriveOptions?.inputFieldName) {\n        produces = [deriveOptions.outputFieldName];\n        // Also analyze the transform function for other dependencies\n        const otherDependencies = mapTransform\n          ? this.analyzer.analyzeMappingDependencies(mapTransform, 'derive')\n          : [];\n        dependencies = [\n          deriveOptions.inputFieldName,\n          ...otherDependencies,\n        ].filter((v, i, a) => a.indexOf(v) === i); // Ensure uniqueness\n      } else {\n        // Fallback if options not provided properly\n        produces = ['_deriveResult'];\n        dependencies = this.getAllProducedFields();\n      }\n    } else if (stepFunction.toString().includes('transform(')) {\n      type = 'map';\n      // Fallback: Map steps are harder to analyze statically, assume they depend on all previous steps\n      dependencies = this.getAllProducedFields();\n      produces = ['_mapResult'];\n    } else if (stepFunction.toString().includes('_parallelResults')) {\n      // This is likely a parallel step that produces _parallelResults\n      produces = ['_parallelResults'];\n      dependencies = this.getAllProducedFields();\n    }\n\n    // Infer initial fields from dependencies\n    // A field is an initial field if it's consumed by a step but not produced by any previous step\n    for (const dep of dependencies) {\n      if (!this.getAllProducedFields().includes(dep)) {\n        this.initialFields.add(dep);\n      }\n    }\n\n    const step: AxFlowExecutionStep = {\n      type,\n      nodeName,\n      dependencies,\n      produces,\n      stepFunction,\n      stepIndex: this.steps.length,\n    };\n\n    this.steps.push(step);\n    // Don't rebuild parallel groups during construction - only after initial fields are set\n    // this.rebuildParallelGroups()\n  }\n\n  /**\n   * Analyzes a step function to determine what fields it produces.\n   *\n   * This method analyzes the step function to understand what new fields\n   * it adds to the state. It uses a mock state approach:\n   * 1. Creates a mock state with sample data\n   * 2. Runs the step function on the mock state\n   * 3. Compares the result to see what fields were added\n   *\n   * @param stepFunction - The step function to analyze\n   * @returns Array of field names that the step function produces\n   */\n  private analyzeStepFunctionProduction(\n    stepFunction: AxFlowStepFunction\n  ): string[] {\n    // For step functions, we should primarily rely on source analysis\n    // since they might contain complex AI operations that we can't mock safely\n    try {\n      const sourceAnalysis = this.analyzeStepFunctionSource(stepFunction);\n      if (\n        sourceAnalysis.length > 0 &&\n        !sourceAnalysis.includes('_stepResult')\n      ) {\n        return sourceAnalysis;\n      }\n    } catch (error) {\n      console.debug('Step function source analysis failed:', error);\n    }\n\n    // Only try dynamic analysis for simple functions\n    try {\n      const mockState = this.createMockState();\n      const originalKeys = Object.keys(mockState);\n\n      // Create a mock context for the step function\n      const mockContext = {\n        mainAi: {\n          getOptions: () => ({ trace: false }),\n          forward: () => Promise.resolve({ text: 'mock' }),\n        } as any,\n        mainOptions: undefined,\n      };\n\n      const result = stepFunction(mockState, mockContext);\n\n      // Handle async functions\n      if (result && typeof result === 'object' && 'then' in result) {\n        // For async functions, we can't easily determine the output\n        // Fall back to analyzing the function source code\n        return this.analyzeStepFunctionSource(stepFunction);\n      }\n\n      if (result && typeof result === 'object' && !Array.isArray(result)) {\n        const newKeys = Object.keys(result);\n        const addedFields = newKeys.filter(\n          (key) => !originalKeys.includes(key)\n        );\n        if (addedFields.length > 0) {\n          return addedFields;\n        }\n      }\n    } catch (error) {\n      // If analysis fails, fall back to source analysis\n      console.debug('Step function dynamic analysis failed:', error);\n    }\n\n    return this.analyzeStepFunctionSource(stepFunction);\n  }\n\n  /**\n   * Analyzes step function source code to determine what fields it produces.\n   *\n   * @param stepFunction - The step function to analyze\n   * @returns Array of field names that the step function produces\n   */\n  private analyzeStepFunctionSource(\n    stepFunction: AxFlowStepFunction\n  ): string[] {\n    try {\n      const source = stepFunction.toString();\n\n      // Look for patterns like: { ...state, fieldName: value }\n      const fieldAssignments = source.match(\n        /\\{\\s*\\.\\.\\.state\\s*,\\s*(\\w+)\\s*:/g\n      );\n      if (fieldAssignments) {\n        const fields = fieldAssignments\n          .map((assignment) => {\n            const match = assignment.match(/(\\w+)\\s*:/);\n            return match ? match[1] : null;\n          })\n          .filter(Boolean);\n\n        if (fields.length > 0) {\n          return fields as string[];\n        }\n      }\n\n      // Look for direct property assignments like: state.fieldName = value\n      const propertyAssignments = source.match(/state\\.(\\w+)\\s*=/g);\n      if (propertyAssignments) {\n        const fields = propertyAssignments\n          .map((assignment) => {\n            const match = assignment.match(/state\\.(\\w+)\\s*=/);\n            return match ? match[1] : null;\n          })\n          .filter(Boolean);\n\n        if (fields.length > 0) {\n          return fields as string[];\n        }\n      }\n    } catch (error) {\n      console.debug('Step function source analysis failed:', error);\n    }\n\n    // Fallback to a generic field name\n    return ['_stepResult'];\n  }\n\n  /**\n   * Analyzes a map transformation function to determine what fields it produces.\n   *\n   * This is a challenging problem because map transformations can produce arbitrary\n   * new fields based on complex logic. The method uses a mock state approach:\n   * 1. Creates a mock state with sample data\n   * 2. Runs the transformation on the mock state\n   * 3. Analyzes the result to see what fields were produced\n   *\n   * This approach works for most common transformation patterns but may miss\n   * edge cases where the transformation behavior depends on specific data values.\n   *\n   * @param mapTransform - The map transformation function to analyze\n   * @returns Array of field names that the transformation produces\n   */\n  private analyzeMapTransformation(\n    mapTransform: (state: any) => any\n  ): string[] {\n    // Never execute user transforms here to avoid side effects during planning.\n    // Fallback to source analysis which is safe and conservative.\n    try {\n      const src = mapTransform.toString();\n      const _fields = src\n        .split(/\\{[\\s\\S]*?\\}/) // crude block split\n        .flatMap(() => []);\n      // If we cant infer safely, return generic field to keep planner robust\n    } catch {\n      /* ignore */\n    }\n    return ['_mapResult'];\n  }\n\n  /**\n   * Creates a mock state with sample data for transformation analysis.\n   *\n   * This method builds a representative state object that includes:\n   * - Initial fields from the flow input\n   * - Result fields from previous steps with realistic structure\n   * - Sample data that allows transformations to execute\n   *\n   * The mock state is used to run map transformations in a controlled\n   * environment to determine what fields they produce.\n   *\n   * @returns Mock state object with sample data\n   */\n  private createMockState(): any {\n    const mockState: any = {};\n\n    // Add initial fields\n    for (const field of this.initialFields) {\n      mockState[field] = this.createMockValue(field);\n    }\n\n    // Add produced fields from previous steps\n    for (const step of this.steps) {\n      for (const field of step.produces) {\n        if (field.endsWith('Result')) {\n          mockState[field] = {\n            // Add common result field patterns\n            text: 'mockText',\n            value: 'mockValue',\n            result: 'mockResult',\n            data: 'mockData',\n            // Add specific field names that tests might expect\n            processedText: 'mockProcessedText',\n            sentimentValue: 'mockSentiment',\n            confidenceScore: 0.8,\n            isComplex: false,\n            mockValue: 'mockValue',\n            responseText: 'mockResponseText',\n            inputText: 'mockInputText',\n          };\n        } else {\n          mockState[field] = this.createMockValue(field);\n        }\n      }\n    }\n\n    return mockState;\n  }\n\n  /**\n   * Creates appropriate mock values based on field names and patterns.\n   */\n  private createMockValue(fieldName: string): any {\n    // Handle array fields\n    if (\n      fieldName.includes('List') ||\n      fieldName.includes('Array') ||\n      fieldName.endsWith('s')\n    ) {\n      return ['mockItem1', 'mockItem2'];\n    }\n\n    // Handle numeric fields\n    if (\n      fieldName.includes('count') ||\n      fieldName.includes('Count') ||\n      fieldName.includes('index') ||\n      fieldName.includes('Index')\n    ) {\n      return 0;\n    }\n\n    // Handle boolean fields\n    if (\n      fieldName.includes('is') ||\n      fieldName.includes('has') ||\n      fieldName.includes('can')\n    ) {\n      return false;\n    }\n\n    // Default to string\n    return 'mockValue';\n  }\n\n  /**\n   * Analyzes what fields are produced by conditional merge operations.\n   *\n   * Conditional merges are complex because they don't transform data like map operations,\n   * but instead select which branch's results to use based on a condition.\n   * The challenge is determining what fields will be available after the merge\n   * without knowing which branch will be taken at runtime.\n   *\n   * This method uses heuristics to determine the likely output fields:\n   * 1. Look at recent execute steps (likely branch operations)\n   * 2. If found, use their output fields as potential merge results\n   * 3. Fallback to all execute step fields if no recent pattern is found\n   *\n   * The analysis assumes that branches in a conditional merge will produce\n   * similar types of fields, so we can use any branch's fields as representative\n   * of what the merge might produce.\n   *\n   * @returns string[] - Array of field names that the merge operation might produce\n   */\n  private analyzeBranchMergeFields(): string[] {\n    // Look at the last few steps to find execute steps that would be merged\n    // We focus on recent steps because they're more likely to be part of the\n    // current branch structure being merged\n    const recentExecuteSteps = this.steps\n      .slice(-5) // Look at last 5 steps\n      .filter((step) => step.type === 'execute' && step.nodeName)\n      .flatMap((step) => step.produces);\n\n    if (recentExecuteSteps.length > 0) {\n      return recentExecuteSteps;\n    }\n\n    // Fallback: return all execute step fields\n    // This is a broader approach when we can't identify recent branch patterns\n    // It includes all possible fields that could be produced by any node\n    return this.steps\n      .filter((step) => step.type === 'execute' && step.nodeName)\n      .flatMap((step) => step.produces);\n  }\n\n  /**\n   * Sets the initial fields and triggers parallel group rebuilding.\n   *\n   * This method is called once the flow knows what input fields are available.\n   * It triggers the parallel group analysis which determines the optimal\n   * execution strategy for the entire flow.\n   *\n   * @param fields - Array of field names available at the start of execution\n   */\n  setInitialFields(fields: string[]): void {\n    this.initialFields = new Set(fields);\n    this.rebuildParallelGroups();\n  }\n\n  /**\n   * Rebuilds the parallel execution groups based on step dependencies.\n   *\n   * This is the core algorithm that creates the parallel execution plan.\n   * It uses a level-by-level approach:\n   *\n   * 1. **Level 0**: Steps with no dependencies (can run immediately)\n   * 2. **Level 1**: Steps that depend only on Level 0 outputs\n   * 3. **Level N**: Steps that depend on outputs from previous levels\n   *\n   * Steps within the same level can run in parallel because they don't\n   * depend on each other's outputs.\n   *\n   * The algorithm ensures:\n   * - Correct execution order (dependencies are satisfied)\n   * - Maximum parallelism (independent steps run simultaneously)\n   * - Deadlock prevention (circular dependencies are detected)\n   *\n   * Time complexity: O(n) where n is the number of steps\n   * Space complexity: O(n) for tracking processed steps and available fields\n   */\n  private rebuildParallelGroups(): void {\n    this.parallelGroups = [];\n    const processedSteps = new Set<number>();\n    const availableFields = new Set<string>(this.initialFields);\n    let currentLevel = 0;\n\n    while (processedSteps.size < this.steps.length) {\n      const currentLevelSteps: AxFlowExecutionStep[] = [];\n\n      // Find all steps that can run at this level\n      for (const step of this.steps) {\n        if (processedSteps.has(step.stepIndex)) continue;\n\n        // Check if all dependencies are available\n        const canRun =\n          step.dependencies.length === 0 ||\n          step.dependencies.every((dep) => availableFields.has(dep));\n\n        if (canRun) {\n          // Special handling for merge steps - they should run in their own group\n          // to ensure they see the results from the previous parallel step\n          if (step.type === 'merge' && currentLevelSteps.length > 0) {\n            // Don't add merge step to current level if there are already steps\n            // It will be picked up in the next iteration\n            continue;\n          }\n\n          currentLevelSteps.push(step);\n          processedSteps.add(step.stepIndex);\n\n          // If this is a merge step, don't add any more steps to this level\n          if (step.type === 'merge') {\n            break;\n          }\n        }\n      }\n\n      if (currentLevelSteps.length > 0) {\n        // Add all produced fields from this level to available fields\n        for (const step of currentLevelSteps) {\n          step.produces.forEach((field) => availableFields.add(field));\n        }\n\n        this.parallelGroups.push({\n          level: currentLevel,\n          steps: currentLevelSteps,\n        });\n        currentLevel++;\n      } else {\n        // No progress made - try to add steps that haven't been processed yet\n        // This handles cases where dependencies might not be perfectly resolved\n        const remainingSteps = this.steps.filter(\n          (step) => !processedSteps.has(step.stepIndex)\n        );\n\n        if (remainingSteps.length > 0) {\n          // Add the first remaining step to make progress\n          const nextStep = remainingSteps[0];\n          processedSteps.add(nextStep.stepIndex);\n\n          // Add produced fields to available fields\n          nextStep.produces.forEach((field) => availableFields.add(field));\n\n          this.parallelGroups.push({\n            level: currentLevel,\n            steps: [nextStep],\n          });\n          currentLevel++;\n        } else {\n          // No remaining steps, we're done\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets all fields produced by previous steps.\n   *\n   * This is used by steps that depend on \"everything produced so far\"\n   * such as map transformations and merge operations.\n   *\n   * @returns Array of all field names produced by previous steps\n   */\n  private getAllProducedFields(): string[] {\n    const fields: string[] = [];\n    for (const step of this.steps) {\n      fields.push(...step.produces);\n    }\n    return fields;\n  }\n\n  /**\n   * Creates optimized execution functions that implement the parallel execution plan.\n   *\n   * This method converts the parallel groups into actual executable functions.\n   * It creates a series of steps where:\n   * - Single-step groups execute directly\n   * - Multi-step groups execute in parallel with batch size control\n   * - Results are properly merged to maintain state consistency\n   *\n   * The optimized execution can significantly improve performance for flows\n   * with independent operations, especially I/O-bound operations like LLM calls.\n   *\n   * Performance benefits:\n   * - Reduces total execution time for independent operations\n   * - Maximizes CPU and I/O utilization\n   * - Maintains correctness through dependency management\n   * - Controls resource usage through batch size limiting\n   *\n   * @param batchSize - Maximum number of concurrent operations (optional)\n   * @returns Array of optimized step functions ready for execution\n   */\n  createOptimizedExecution(batchSize?: number): AxFlowStepFunction[] {\n    const optimizedSteps: AxFlowStepFunction[] = [];\n\n    for (const group of this.parallelGroups) {\n      if (group.steps.length === 1) {\n        // Single step - execute directly\n        const step = group.steps[0];\n        if (step) {\n          optimizedSteps.push(step.stepFunction);\n        }\n      } else if (group.steps.length > 1) {\n        // Multiple steps - execute in parallel with batch size control\n        const parallelStep: AxFlowStepFunction = async (state, context) => {\n          const results = await processBatches(\n            group.steps,\n            async (step) => {\n              return await step.stepFunction(state, context);\n            },\n            batchSize\n          );\n\n          // Check if any step produces _parallelResults (indicates this is a parallel flow)\n          const hasParallelResults = results.some(\n            (result) =>\n              result &&\n              typeof result === 'object' &&\n              '_parallelResults' in result\n          );\n\n          if (hasParallelResults) {\n            // Find the step that produced _parallelResults and return it directly\n            const parallelResult = results.find(\n              (result) =>\n                result &&\n                typeof result === 'object' &&\n                '_parallelResults' in result\n            );\n            if (parallelResult) {\n              // Return the parallel result directly - the merge step will handle cleanup\n              return parallelResult;\n            }\n            return state;\n          }\n\n          // Merge all results for regular parallel execution\n          let mergedState = state;\n          for (const result of results) {\n            mergedState = { ...mergedState, ...result };\n          }\n\n          return mergedState;\n        };\n\n        optimizedSteps.push(parallelStep);\n      }\n    }\n\n    return optimizedSteps;\n  }\n\n  /**\n   * Gets optimized execution steps for the flow.\n   *\n   * This method provides the optimized execution steps that can be used\n   * to execute the flow with maximum parallelism while maintaining\n   * dependency order.\n   *\n   * @returns Array of optimized step functions ready for execution\n   */\n  getOptimizedExecutionSteps(): AxFlowStepFunction[] {\n    // If parallel groups haven't been built yet, build them with empty initial fields\n    if (this.parallelGroups.length === 0 && this.steps.length > 0) {\n      this.rebuildParallelGroups();\n    }\n    return this.createOptimizedExecution();\n  }\n\n  /**\n   * Gets detailed execution plan information for debugging and analysis.\n   *\n   * This method provides comprehensive information about the execution plan,\n   * including step counts, parallel grouping details, and the complete\n   * dependency structure. It's particularly useful for:\n   * - Debugging execution flow issues\n   * - Performance analysis and optimization\n   * - Understanding parallelization effectiveness\n   * - Monitoring execution plan complexity\n   *\n   * @returns Object containing detailed execution plan metrics and data\n   */\n  getExecutionPlan(): {\n    totalSteps: number;\n    parallelGroups: number;\n    maxParallelism: number;\n    steps: AxFlowExecutionStep[];\n    groups: AxFlowParallelGroup[];\n  } {\n    // If parallel groups haven't been built yet, build them with empty initial fields\n    if (this.parallelGroups.length === 0 && this.steps.length > 0) {\n      this.rebuildParallelGroups();\n    }\n\n    return {\n      totalSteps: this.steps.length,\n      parallelGroups: this.parallelGroups.length,\n      maxParallelism:\n        this.steps.length === 0\n          ? 1\n          : Math.max(...this.parallelGroups.map((g) => g.steps.length), 0),\n      steps: this.steps,\n      groups: this.parallelGroups,\n    };\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any, functional/prefer-immutable-types */\n\nimport type { Meter, Tracer } from '@opentelemetry/api';\nimport {\n  context,\n  type Context as OtelContext,\n  SpanKind,\n  trace,\n} from '@opentelemetry/api';\nimport type { AxAIService } from '../ai/types.js';\nimport type { AxGen } from '../dsp/generate.js';\nimport type { AxOptimizedProgram } from '../dsp/optimizer.js';\nimport { AxProgram } from '../dsp/program.js';\nimport type { AxFieldType } from '../dsp/sig.js';\nimport { type AxField, AxSignature, f } from '../dsp/sig.js';\nimport { ax } from '../dsp/template.js';\nimport type {\n  AxGenIn,\n  AxGenOut,\n  AxGenStreamingOut,\n  AxMessage,\n  AxProgramDemos,\n  AxProgramExamples,\n  AxProgramForwardOptions,\n  AxProgramForwardOptionsWithModels,\n  AxProgrammable,\n  AxProgramStreamingForwardOptionsWithModels,\n  AxProgramTrace,\n  AxProgramUsage,\n  AxSetExamplesOptions,\n} from '../dsp/types.js';\nimport { mergeProgramUsage } from '../dsp/util.js';\nimport { processBatches } from './batchUtil.js';\nimport { AxFlowExecutionPlanner } from './executionPlanner.js';\nimport {\n  type AxFlowLoggerFunction,\n  axCreateFlowColorLogger,\n  createTimingLogger,\n} from './logger.js';\nimport { AxFlowSubContextImpl } from './subContext.js';\nimport type {\n  AddNodeResult,\n  AxFlowAutoParallelConfig,\n  AxFlowable,\n  AxFlowBranchContext,\n  AxFlowDynamicContext,\n  AxFlowExecutionStep,\n  AxFlowNodeDefinition,\n  AxFlowParallelBranch,\n  AxFlowParallelGroup,\n  AxFlowState,\n  AxFlowStepFunction,\n  AxFlowSubContext,\n  AxFlowTypedParallelBranch,\n  AxFlowTypedSubContext,\n  GetGenIn,\n  GetGenOut,\n  InferAxGen,\n} from './types.js';\n\n/**\n * AxFlow - A fluent, chainable API for building and orchestrating complex, stateful AI programs.\n *\n * Now with advanced type-safe chaining where each method call evolves the type information,\n * providing compile-time type safety and superior IntelliSense.\n *\n * @example\n * ```\n * const flow = new AxFlow<{ topic: string }, { finalAnswer: string }>()\n *   .node('summarizer', 'text:string -> summary:string')\n *   .node('critic', 'summary:string -> critique:string')\n *   .execute('summarizer', state => ({ text: `About ${state.topic}` })) // state is { topic: string }\n *   .execute('critic', state => ({ summary: state.summarizerResult.summary })) // state evolves!\n *   .map(state => ({ finalAnswer: state.criticResult.critique })) // fully typed!\n *\n * const result = await flow.forward(ai, { topic: \"AI safety\" })\n * ```\n */\nexport class AxFlow<\n  IN extends Record<string, any>,\n  OUT,\n  // NOTE: The `any` here is necessary because TNodes must accommodate AxProgrammable instances with various input/output types\n  TNodes extends Record<string, AxProgrammable<any, any>> = Record<\n    string,\n    never\n  >, // Node registry for type tracking\n  TState extends AxFlowState = IN, // Current evolving state type\n> implements AxFlowable<IN, OUT>\n{\n  private static _ctorWarned = false;\n  private readonly nodes: Map<string, AxFlowNodeDefinition> = new Map();\n  private readonly flowDefinition: AxFlowStepFunction[] = [];\n  private readonly nodeGenerators: Map<\n    string,\n    AxProgrammable<any, any, unknown>\n  > = new Map();\n  private readonly loopStack: number[] = [];\n  private readonly stepLabels: Map<string, number> = new Map();\n  private branchContext: AxFlowBranchContext | null = null;\n\n  // Automatic parallelization components\n  private readonly autoParallelConfig: AxFlowAutoParallelConfig;\n  private readonly executionPlanner = new AxFlowExecutionPlanner();\n\n  // Program field that gets initialized when something is added to the graph\n  private program?: AxProgram<IN, OUT>;\n\n  // Node-level usage tracking\n  private nodeUsage: Map<string, AxProgramUsage[]> = new Map();\n\n  // Node-level trace tracking\n  private nodeTraces: Map<string, AxProgramTrace<any, any>[]> = new Map();\n\n  // Verbose logging support\n  private readonly flowLogger?: AxFlowLoggerFunction;\n  private readonly timingLogger?: ReturnType<typeof createTimingLogger>;\n\n  // Default AI options to propagate to node forwards (e.g., tracer, meter)\n  private readonly defaultAIOptions?: Readonly<{\n    tracer?: Tracer;\n    meter?: Meter;\n  }>;\n\n  /**\n   * Converts a string to camelCase for valid field names\n   */\n  private toCamelCase(str: string): string {\n    return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());\n  }\n\n  /**\n   * Executes a list of steps with comprehensive logging\n   */\n  private async executeStepsWithLogging(\n    steps: AxFlowStepFunction[],\n    initialState: AxFlowState,\n    context: Readonly<{\n      mainAi: AxAIService;\n      mainOptions?: AxProgramForwardOptions<string>;\n    }>,\n    _isOptimized: boolean\n  ): Promise<{ finalState: AxFlowState; stepsExecuted: number }> {\n    let state = { ...initialState };\n    let stepsExecuted = 0;\n\n    for (let i = 0; i < steps.length; i++) {\n      const step = steps[i];\n      if (!step) continue;\n\n      // Determine step type and metadata for logging\n      const stepType = this.getStepType(step, i);\n      const stepMetadata = this.getStepMetadata(step, i);\n\n      const previousFields = Object.keys(state);\n\n      // Log step start\n      if (this.flowLogger) {\n        this.flowLogger({\n          name: 'StepStart',\n          timestamp: Date.now(),\n          stepIndex: i,\n          stepType: stepType,\n          nodeName: stepMetadata.nodeName,\n          dependencies: stepMetadata.dependencies,\n          produces: stepMetadata.produces,\n          state: { ...state },\n        });\n      }\n\n      // Execute step with timing\n      const stepStartTime = Date.now();\n      this.timingLogger?.startTiming(`step-${i}`);\n\n      try {\n        const result = await step(state, context);\n        state = result;\n        stepsExecuted++;\n\n        // Calculate execution time\n        const executionTime =\n          this.timingLogger?.endTiming(`step-${i}`) ??\n          Date.now() - stepStartTime;\n\n        // Identify new fields\n        const currentFields = Object.keys(state);\n        const newFields = currentFields.filter(\n          (field) => !previousFields.includes(field)\n        );\n\n        // Extract result for execute steps with node names\n        let nodeResult: any;\n        if (\n          stepType === 'execute' &&\n          stepMetadata.nodeName &&\n          newFields.length > 0\n        ) {\n          // For execute steps, try to find the result field that matches the node name\n          const resultFieldName = `${stepMetadata.nodeName}Result`;\n          nodeResult = state[resultFieldName];\n        }\n\n        // Log step completion\n        if (this.flowLogger) {\n          this.flowLogger({\n            name: 'StepComplete',\n            timestamp: Date.now(),\n            stepIndex: i,\n            stepType: stepType,\n            nodeName: stepMetadata.nodeName,\n            executionTime,\n            state: { ...state },\n            newFields,\n            result: nodeResult,\n          });\n        }\n      } catch (error) {\n        // Log step error\n        if (this.flowLogger) {\n          this.flowLogger({\n            name: 'FlowError',\n            timestamp: Date.now(),\n            error: error instanceof Error ? error.message : String(error),\n            stepIndex: i,\n            stepType: stepType,\n            nodeName: stepMetadata.nodeName,\n            state: { ...state },\n          });\n        }\n        throw error;\n      }\n    }\n\n    return { finalState: state, stepsExecuted };\n  }\n\n  /**\n   * Determines the type of a step function for logging purposes\n   */\n  private getStepType(\n    step: AxFlowStepFunction,\n    _index: number\n  ):\n    | 'execute'\n    | 'map'\n    | 'merge'\n    | 'parallel-map'\n    | 'parallel'\n    | 'derive'\n    | 'branch'\n    | 'feedback'\n    | 'while'\n    | 'other' {\n    const source = step.toString();\n\n    // Check for execute steps (contain nodeName references)\n    if (source.includes('nodeName') || source.includes('nodeProgram')) {\n      return 'execute';\n    }\n\n    // Check for parallel operations\n    if (\n      source.includes('_parallelResults') ||\n      source.includes('processBatches')\n    ) {\n      return 'parallel';\n    }\n\n    // Check for merge operations\n    if (\n      source.includes('branchValue') ||\n      source.includes('branches.get') ||\n      source.includes('mergeFunction')\n    ) {\n      return 'merge';\n    }\n\n    // Check for map operations\n    if (source.includes('transform(') || source.includes('...state,')) {\n      return 'map';\n    }\n\n    // Check for derive operations\n    if (source.includes('inputValue') && source.includes('transformFn')) {\n      return 'derive';\n    }\n\n    // Check for control flow operations\n    if (source.includes('condition(') && source.includes('iterations')) {\n      if (source.includes('while')) {\n        return 'while';\n      }\n      return 'feedback';\n    }\n\n    // Check for branch operations\n    if (source.includes('branchSteps') || source.includes('currentState')) {\n      return 'branch';\n    }\n\n    return 'other';\n  }\n\n  /**\n   * Gets metadata about a step for logging purposes\n   */\n  private getStepMetadata(\n    step: AxFlowStepFunction,\n    index: number\n  ): {\n    nodeName?: string;\n    dependencies: string[];\n    produces: string[];\n  } {\n    // Try to get metadata from execution planner if available\n    const executionPlan = this.executionPlanner.getExecutionPlan();\n    const stepInfo = executionPlan.steps.find((s) => s.stepIndex === index);\n\n    if (stepInfo) {\n      return {\n        nodeName: stepInfo.nodeName,\n        dependencies: stepInfo.dependencies,\n        produces: stepInfo.produces,\n      };\n    }\n\n    // Fallback to source analysis\n    const source = step.toString();\n    const nodeName = this.extractNodeNameFromSource(source);\n\n    return {\n      nodeName,\n      dependencies: [],\n      produces: [],\n    };\n  }\n\n  /**\n   * Extracts node name from step function source code\n   */\n  private extractNodeNameFromSource(source: string): string | undefined {\n    // Look for patterns like 'nodeName' variable references\n    const nodeNameMatch = source.match(/nodeName['\"]?\\s*[=:]\\s*['\"](\\w+)['\"]/);\n    if (nodeNameMatch) {\n      return nodeNameMatch[1];\n    }\n\n    // Look for patterns in node execution\n    const nodeExecMatch = source.match(/nodeProgram\\.get\\(['\"](\\w+)['\"]\\)/);\n    if (nodeExecMatch) {\n      return nodeExecMatch[1];\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Infers the signature of the flow based on the execution plan and node definitions.\n   * This is the core method that determines what input/output fields the flow should have\n   * based on the nodes and operations defined in the flow.\n   *\n   * The inference process follows these steps:\n   * 1. If no nodes are defined, return a default signature\n   * 2. Analyze the execution plan to find all produced and consumed fields\n   * 3. Determine input fields (consumed but not produced by any step)\n   * 4. Determine output fields with special handling for final map/merge operations\n   * 5. If no clear pattern is found, create a comprehensive signature from all nodes\n   *\n   * Special handling for final operations:\n   * - Map operations: Use the fields produced by the map transformation\n   * - Merge operations: Use fields from the merged branches or merge result\n   * - Conditional merges: Analyze what fields the branches actually produce\n   *\n   * @returns AxSignature - The inferred signature for this flow\n   */\n  private inferSignatureFromFlow(): AxSignature {\n    // Get execution plan to identify dependencies and field flow\n    const executionPlan = this.executionPlanner.getExecutionPlan();\n\n    // If no nodes are defined AND no execution steps, return a default signature\n    if (this.nodeGenerators.size === 0 && executionPlan.steps.length === 0) {\n      // Create a default signature for flows without nodes or steps\n      return f()\n        .input('userInput', f.string('User input to the flow'))\n        .output('flowOutput', f.string('Output from the flow'))\n        .build();\n    }\n\n    // This gives us a structured view of what each step consumes and produces\n    const allProducedFields = new Set<string>();\n    const allConsumedFields = new Set<string>();\n\n    // Collect all produced and consumed fields from the execution plan\n    // This helps us understand the data flow through the entire workflow\n    for (const step of executionPlan.steps) {\n      step.produces.forEach((field) => allProducedFields.add(field));\n      step.dependencies.forEach((field) => allConsumedFields.add(field));\n    }\n\n    // Find input fields (consumed but not produced by any step)\n    // These are fields that the flow needs from external input\n    const inputFieldNames = new Set<string>();\n    for (const consumed of Array.from(allConsumedFields)) {\n      if (!allProducedFields.has(consumed)) {\n        inputFieldNames.add(consumed);\n      }\n    }\n\n    // Find output fields (produced but not consumed by subsequent steps)\n    // These are the final results that the flow produces\n    const outputFieldNames = new Set<string>();\n\n    // Special handling for final map/merge operations\n    // When a flow ends with a transformation or merge, we want to use those results\n    // as the output rather than intermediate node results\n    // Note: For derive operations, use standard logic to handle multiple derives properly\n    const lastStep = executionPlan.steps[executionPlan.steps.length - 1];\n    if (lastStep && (lastStep.type === 'map' || lastStep.type === 'merge')) {\n      // If the last step is a map/merge, use its produced fields as outputs\n      lastStep.produces.forEach((field) => {\n        // Skip internal fields like _mapResult, _mergedResult\n        if (!field.startsWith('_')) {\n          outputFieldNames.add(field);\n        }\n      });\n\n      // For conditional merges that produce _mergedResult,\n      // use all fields from previous steps as potential outputs\n      // This handles cases where the merge doesn't transform the data\n      // but just selects which branch's results to use\n      if (\n        lastStep.type === 'merge' &&\n        lastStep.produces.includes('_mergedResult')\n      ) {\n        // Find all node result fields from previous steps\n        for (const step of executionPlan.steps) {\n          if (step.type === 'execute' && step.produces.length > 0) {\n            step.produces.forEach((field) => outputFieldNames.add(field));\n          }\n        }\n      }\n    } else {\n      // Standard logic: fields produced but not consumed by subsequent steps\n      // This finds the \"leaf\" fields that aren't used by any other step\n      for (const produced of Array.from(allProducedFields)) {\n        // Check if this field is consumed by any step\n        let isConsumed = false;\n        for (const step of executionPlan.steps) {\n          if (step.dependencies.includes(produced)) {\n            isConsumed = true;\n            break;\n          }\n        }\n        if (!isConsumed) {\n          // If this is a node result field (ends with \"Result\"), extract the actual output field names\n          if (produced.endsWith('Result')) {\n            const nodeName = produced.replace('Result', '');\n            const nodeGen = this.nodeGenerators.get(nodeName);\n            if (nodeGen) {\n              const sig = nodeGen.getSignature();\n              const outputFields = sig.getOutputFields();\n\n              // Add the actual output field names from the node signature\n              for (const field of outputFields) {\n                outputFieldNames.add(field.name);\n              }\n            } else {\n              // Fallback to the original field name if node not found\n              outputFieldNames.add(produced);\n            }\n          } else {\n            outputFieldNames.add(produced);\n          }\n        }\n      }\n    }\n\n    // If no clear input/output pattern, create a comprehensive signature\n    // This is a fallback that includes all possible fields from all nodes\n    // It's used when the execution plan analysis doesn't give clear results\n    if (inputFieldNames.size === 0 && outputFieldNames.size === 0) {\n      // Extract fields from node signatures\n      const inputFields: AxField[] = [];\n      const outputFields: AxField[] = [];\n\n      // Go through each node and extract its input/output fields\n      for (const [nodeName, nodeGen] of Array.from(this.nodeGenerators)) {\n        const sig = nodeGen.getSignature();\n\n        // Add node's input fields as potential flow inputs\n        // These are prefixed with the node name to avoid conflicts\n        for (const field of sig.getInputFields()) {\n          // Convert to camelCase to avoid validation issues\n          const camelCaseName = this.toCamelCase(`${nodeName}_${field.name}`);\n          inputFields.push({\n            name: camelCaseName,\n            type: field.type,\n            description: field.description,\n            isOptional: field.isOptional,\n            isInternal: field.isInternal,\n          });\n        }\n\n        // Add node's output fields as potential flow outputs\n        // These are also prefixed with the node name\n        for (const field of sig.getOutputFields()) {\n          // Convert to camelCase to avoid validation issues\n          const camelCaseName = this.toCamelCase(`${nodeName}_${field.name}`);\n          outputFields.push({\n            name: camelCaseName,\n            type: field.type,\n            description: field.description,\n            isOptional: field.isOptional,\n            isInternal: field.isInternal,\n          });\n        }\n      }\n\n      // Create signature from collected fields\n      const inferredSignature = new AxSignature();\n\n      // Add input fields or default\n      if (inputFields.length > 0) {\n        inferredSignature.setInputFields(inputFields);\n      } else {\n        inferredSignature.addInputField({\n          name: 'userInput',\n          type: { name: 'string' },\n          description: 'User input to the flow',\n        });\n      }\n\n      // Add output fields or default\n      if (outputFields.length > 0) {\n        inferredSignature.setOutputFields(outputFields);\n      } else {\n        inferredSignature.addOutputField({\n          name: 'flowOutput',\n          type: { name: 'string' },\n          description: 'Output from the flow',\n        });\n      }\n\n      return inferredSignature;\n    }\n\n    // Build signature from identified input/output fields\n    // This is the main path when we have clear input/output patterns\n    const inferredSignature = new AxSignature();\n\n    // Add input fields\n    const inputFields: AxField[] = [];\n    for (const fieldName of Array.from(inputFieldNames)) {\n      inputFields.push({\n        name: fieldName,\n        type: { name: 'string' },\n        description: `Input field: ${fieldName}`,\n      });\n    }\n\n    // Add default input if none found\n    if (inputFields.length === 0) {\n      inputFields.push({\n        name: 'userInput',\n        type: { name: 'string' },\n        description: 'User input to the flow',\n      });\n    }\n\n    // Add output fields\n    const outputFields: AxField[] = [];\n    for (const fieldName of Array.from(outputFieldNames)) {\n      // Skip internal fields that start with underscore\n      if (fieldName.startsWith('_')) {\n        continue;\n      }\n      outputFields.push({\n        name: fieldName,\n        type: { name: 'string' },\n        description: `Output field: ${fieldName}`,\n      });\n    }\n\n    // Add default output if none found\n    if (outputFields.length === 0) {\n      outputFields.push({\n        name: 'flowOutput',\n        type: { name: 'string' },\n        description: 'Output from the flow',\n      });\n    }\n\n    inferredSignature.setInputFields(inputFields);\n    inferredSignature.setOutputFields(outputFields);\n\n    return inferredSignature;\n  }\n\n  constructor(options?: {\n    autoParallel?: boolean;\n    batchSize?: number;\n    logger?: AxFlowLoggerFunction;\n    debug?: boolean;\n    tracer?: Tracer;\n    meter?: Meter;\n  }) {\n    if (!AxFlow._ctorWarned) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        '[AxFlow] new AxFlow() is deprecated. Use flow() factory instead.'\n      );\n      AxFlow._ctorWarned = true;\n    }\n    // Initialize configuration with defaults\n    this.autoParallelConfig = {\n      enabled: options?.autoParallel !== false, // Default to true\n      batchSize: options?.batchSize || 10, // Default batch size of 10\n    };\n\n    // Initialize logging based on options\n    if (options?.logger) {\n      // Explicit logger provided\n      this.flowLogger = options.logger;\n    } else if (options?.debug === true) {\n      // Debug mode enabled - use default color logger\n      this.flowLogger = axCreateFlowColorLogger();\n    } else {\n      // No logging\n      this.flowLogger = undefined;\n    }\n\n    this.timingLogger = this.flowLogger\n      ? createTimingLogger(this.flowLogger)\n      : undefined;\n\n    // Capture default AI options to propagate to node executions\n    if (options?.tracer || options?.meter) {\n      this.defaultAIOptions = {\n        tracer: options.tracer,\n        meter: options.meter,\n      };\n    }\n  }\n\n  /**\n   * Static factory method to create a new AxFlow instance with proper type safety\n   * @param options - Optional configuration for the flow\n   * @returns New AxFlow instance with type-safe defaults\n   */\n  public static create<\n    IN extends Record<string, any> = Record<string, never>,\n    OUT = {},\n    TNodes extends Record<string, AxProgrammable<any, any>> = Record<\n      string,\n      never\n    >,\n    TState extends AxFlowState = IN,\n  >(options?: {\n    autoParallel?: boolean;\n    batchSize?: number;\n    logger?: AxFlowLoggerFunction;\n    debug?: boolean;\n  }): AxFlow<IN, OUT, TNodes, TState> {\n    return new AxFlow<IN, OUT, TNodes, TState>(options);\n  }\n\n  /**\n   * Initializes the program field every time something is  added to the graph\n   */\n  private ensureProgram(): void {\n    const signature = this.inferSignatureFromFlow();\n    if (!this.program) {\n      this.program = new AxProgram<IN, OUT>(signature);\n      for (const [_nodeName, nodeProgram] of Array.from(this.nodeGenerators)) {\n        this.program.register(nodeProgram as any);\n      }\n      return;\n    }\n    this.program.setSignature(signature);\n  }\n\n  public setExamples(\n    examples: Readonly<AxProgramExamples<IN, OUT>>,\n    options?: Readonly<AxSetExamplesOptions>\n  ): void {\n    this.ensureProgram();\n    this.program!.setExamples(examples, options);\n  }\n\n  public setId(id: string): void {\n    this.ensureProgram();\n    this.program!.setId(id);\n  }\n\n  public setParentId(parentId: string): void {\n    this.ensureProgram();\n    this.program!.setParentId(parentId);\n  }\n\n  public getTraces(): AxProgramTrace<IN, OUT>[] {\n    // Collect traces from all nodes\n    const allTraces: AxProgramTrace<IN, OUT>[] = [];\n\n    for (const [_nodeName, nodeTraces] of Array.from(this.nodeTraces)) {\n      // Cast the traces to the expected type since they should be compatible\n      allTraces.push(...(nodeTraces as AxProgramTrace<IN, OUT>[]));\n    }\n\n    return allTraces;\n  }\n\n  public setDemos(demos: readonly AxProgramDemos<IN, OUT>[]): void {\n    this.ensureProgram();\n    this.program!.setDemos(demos);\n  }\n\n  public getUsage(): AxProgramUsage[] {\n    // Collect usage from all nodes and merge\n    const allUsage: AxProgramUsage[] = [];\n\n    for (const [_nodeName, nodeUsage] of Array.from(this.nodeUsage)) {\n      allUsage.push(...nodeUsage);\n    }\n\n    return mergeProgramUsage(allUsage);\n  }\n\n  public resetUsage(): void {\n    // Clear node-level usage tracking\n    this.nodeUsage.clear();\n\n    // Also reset usage on all node generators\n    for (const [_nodeName, nodeProgram] of Array.from(this.nodeGenerators)) {\n      if (nodeProgram && 'resetUsage' in nodeProgram) {\n        nodeProgram.resetUsage();\n      }\n    }\n  }\n\n  /**\n   * Resets trace tracking for the flow.\n   * This is called automatically on each forward/streamingForward call.\n   */\n  public resetTraces(): void {\n    // Clear node-level trace tracking\n    this.nodeTraces.clear();\n\n    // Note: Individual node programs don't have resetTraces method,\n    // so we only clear the flow-level trace collection\n  }\n\n  /**\n   * Gets a detailed usage report broken down by node name.\n   * This provides visibility into which nodes are consuming the most tokens.\n   *\n   * @returns Object mapping node names to their usage statistics\n   */\n  public getUsageReport(): Record<string, AxProgramUsage[]> {\n    const report: Record<string, AxProgramUsage[]> = {};\n\n    for (const [nodeName, nodeUsage] of Array.from(this.nodeUsage)) {\n      report[nodeName] = mergeProgramUsage(nodeUsage);\n    }\n\n    return report;\n  }\n\n  /**\n   * Expose node programs for system-level operations (optimization, inspection)\n   */\n  public getNodePrograms(): ReadonlyArray<{\n    name: string;\n    program: AxProgrammable<any, any>;\n  }> {\n    return Array.from(this.nodeGenerators).map(([name, program]) => ({\n      name,\n      program,\n    }));\n  }\n\n  /**\n   * Attempt to set instruction on a node if supported (AxGen.\n   * setInstruction is optional; returns true if applied)\n   */\n  public setNodeInstruction(name: string, instruction: string): boolean {\n    const prog = this.nodeGenerators.get(name);\n    if (!prog) return false;\n    const anyProg = prog as any;\n    if (typeof anyProg.setInstruction === 'function') {\n      try {\n        anyProg.setInstruction(instruction);\n        return true;\n      } catch {\n        return false;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Bulk-apply instructions to nodes; ignores names that dont exist or nodes without instruction setter\n   */\n  public setAllNodeInstructions(map: Readonly<Record<string, string>>): void {\n    for (const [name, instr] of Object.entries(map)) {\n      this.setNodeInstruction(name, instr);\n    }\n  }\n\n  /**\n   * Gets a detailed trace report broken down by node name.\n   * This provides visibility into the execution traces for each node.\n   *\n   * @returns Object mapping node names to their trace data\n   */\n  public getTracesReport(): Record<string, AxProgramTrace<any, any>[]> {\n    const report: Record<string, AxProgramTrace<any, any>[]> = {};\n\n    for (const [nodeName, nodeTraces] of Array.from(this.nodeTraces)) {\n      report[nodeName] = nodeTraces;\n    }\n\n    return report;\n  }\n\n  public async *streamingForward<T extends Readonly<AxAIService>>(\n    ai: T,\n    values: IN | AxMessage<IN>[],\n    options?: Readonly<AxProgramStreamingForwardOptionsWithModels<T>>\n  ): AxGenStreamingOut<OUT> {\n    // For now, we'll implement streaming by converting the regular forward result\n    // This is a simplified implementation - full streaming would require more work\n    // Note: forward() will handle the resetUsage() call\n    const result = await this.forward(ai, values, options);\n\n    // Yield the final result with correct AxGenDeltaOut structure\n    yield {\n      version: 1,\n      index: 0,\n      delta: result,\n    };\n  }\n\n  /**\n   * Executes the flow with the given AI service and input values.\n   *\n   * This is the main execution method that orchestrates the entire flow execution.\n   * It handles several complex aspects:\n   *\n   * 1. **Dynamic Signature Inference**: If the flow was created with a default signature\n   *    but has nodes defined, it will infer the actual signature from the flow structure.\n   *\n   * 2. **Execution Mode Selection**: Chooses between optimized parallel execution\n   *    (when auto-parallel is enabled) or sequential execution based on configuration.\n   *\n   * 3. **State Management**: Maintains the evolving state object as it flows through\n   *    each step, accumulating results and transformations.\n   *\n   * 4. **Performance Optimization**: Uses the execution planner to identify\n   *    independent operations that can run in parallel, reducing total execution time.\n   *\n   * Execution Flow:\n   * - Initialize state with input values\n   * - Infer signature if needed (based on nodes and current signature)\n   * - Choose execution strategy (parallel vs sequential)\n   * - Execute all steps while maintaining state consistency\n   * - Return final state cast to expected output type\n   *\n   * @param ai - The AI service to use as the default for all steps\n   * @param values - The input values for the flow\n   * @param options - Optional forward options to use as defaults (includes autoParallel override)\n   * @returns Promise that resolves to the final output\n   */\n  public async forward<T extends Readonly<AxAIService>>(\n    ai: T,\n    values: IN | AxMessage<IN>[],\n    options?: Readonly<\n      AxProgramForwardOptionsWithModels<T> & { autoParallel?: boolean }\n    >\n  ): Promise<OUT> {\n    // Start flow timing\n    const flowStartTime = Date.now();\n    this.timingLogger?.startTiming('flow-execution');\n\n    // Initialize state early so it's accessible in catch block\n    let state: AxFlowState = {};\n\n    try {\n      // Reset usage and trace tracking at the start of each forward call\n      this.resetUsage();\n      this.resetTraces();\n\n      // Extract values from input - handle both IN and AxMessage<IN>[] cases\n      let inputValues: IN;\n      if (Array.isArray(values)) {\n        // If values is an array of messages, find the most recent user message\n        const lastUserMessage = values\n          .filter((msg) => msg.role === 'user')\n          .pop();\n        if (!lastUserMessage) {\n          throw new Error('No user message found in values array');\n        }\n        inputValues = lastUserMessage.values;\n      } else {\n        // If values is a single IN object\n        inputValues = values;\n      }\n\n      // Dynamic signature inference - only if using default signature and have nodes\n      // This allows flows to be created with a simple signature and then have it\n      // automatically refined based on the actual nodes and operations defined\n      if (this.nodeGenerators.size > 0) {\n        // Initialize program with inferred signature\n        this.ensureProgram();\n      }\n\n      // Initialize state with input values\n      // This creates the initial state object that will flow through all steps\n      state = { ...inputValues };\n\n      // Log flow start\n      if (this.flowLogger) {\n        const executionPlan = this.getExecutionPlan();\n        this.flowLogger({\n          name: 'FlowStart',\n          timestamp: flowStartTime,\n          inputFields: Object.keys(inputValues),\n          totalSteps: executionPlan.totalSteps,\n          parallelGroups: executionPlan.parallelGroups,\n          maxParallelism: executionPlan.maxParallelism,\n          autoParallelEnabled: executionPlan.autoParallelEnabled,\n        });\n      }\n\n      // Determine tracer and create a parent span/context if available\n      const tracer: Tracer | undefined =\n        (options as any)?.tracer ?? this.defaultAIOptions?.tracer;\n      const providedCtx: OtelContext | undefined = (options as any)\n        ?.traceContext;\n\n      let parentSpan:\n        | ReturnType<NonNullable<typeof tracer>['startSpan']>\n        | undefined;\n      let parentCtx: OtelContext | undefined = providedCtx;\n      if (tracer) {\n        const execPlan = this.getExecutionPlan();\n        const spanName = (options as any)?.traceLabel\n          ? `AxFlow > ${(options as any).traceLabel}`\n          : 'AxFlow';\n        parentSpan = tracer.startSpan(spanName, {\n          kind: SpanKind.INTERNAL,\n          attributes: {\n            total_steps: execPlan.totalSteps,\n            parallel_groups: execPlan.parallelGroups,\n            max_parallelism: execPlan.maxParallelism,\n            auto_parallel_enabled: execPlan.autoParallelEnabled,\n          },\n        });\n        const baseCtx = providedCtx ?? context.active();\n        parentCtx = trace.setSpan(baseCtx, parentSpan);\n      }\n\n      // Create execution context object\n      // This provides consistent access to AI service and options for all steps\n      const execContext = {\n        mainAi: ai,\n        mainOptions: ((): AxProgramForwardOptions<string> | undefined => {\n          const merged: AxProgramForwardOptions<string> = {\n            ...(this.defaultAIOptions ?? {}),\n            ...(options as any),\n          } as AxProgramForwardOptions<string>;\n          if ((options as any)?.model)\n            merged.model = String((options as any).model);\n          if (tracer) merged.tracer = tracer;\n          if (parentCtx) (merged as any).traceContext = parentCtx;\n          // If nothing to merge and no defaults, return undefined\n          return Object.keys(merged).length > 0 ? merged : undefined;\n        })(),\n      } as const;\n\n      // Determine execution strategy based on configuration\n      // Auto-parallel can be disabled globally or overridden per execution\n      const useAutoParallel =\n        options?.autoParallel !== false && this.autoParallelConfig.enabled;\n\n      let stepsExecuted = 0;\n      if (useAutoParallel) {\n        // OPTIMIZED PARALLEL EXECUTION PATH\n        // This path uses the execution planner to identify independent operations\n        // and execute them in parallel for better performance\n\n        // Set initial fields for dependency analysis\n        // This tells the planner what fields are available at the start\n        this.executionPlanner.setInitialFields(Object.keys(inputValues));\n\n        // Get optimized execution plan with parallel groups and batch size control\n        const optimizedSteps = this.executionPlanner.createOptimizedExecution(\n          this.autoParallelConfig.batchSize\n        );\n\n        // Execute optimized steps with logging\n        const result = await this.executeStepsWithLogging(\n          optimizedSteps,\n          state,\n          execContext,\n          true\n        );\n        state = result.finalState;\n        stepsExecuted = result.stepsExecuted;\n      } else {\n        // SEQUENTIAL EXECUTION PATH\n        // This path executes all steps in the order they were defined\n        // It's simpler but potentially slower for independent operations\n\n        // Execute all steps sequentially with logging\n        const result = await this.executeStepsWithLogging(\n          this.flowDefinition,\n          state,\n          execContext,\n          false\n        );\n        state = result.finalState;\n        stepsExecuted = result.stepsExecuted;\n      }\n\n      // Log flow completion\n      if (this.flowLogger) {\n        const totalExecutionTime =\n          this.timingLogger?.endTiming('flow-execution') ??\n          Date.now() - flowStartTime;\n        this.flowLogger({\n          name: 'FlowComplete',\n          timestamp: Date.now(),\n          totalExecutionTime,\n          finalState: state,\n          outputFields: Object.keys(state),\n          stepsExecuted,\n        });\n      }\n\n      // End parent span if created\n      if (parentSpan) parentSpan.end();\n\n      // Return the final state cast to the expected output type\n      // The type system ensures this is safe based on the signature inference\n      return state as any;\n    } catch (error) {\n      // Log flow error\n      if (this.flowLogger) {\n        this.flowLogger({\n          name: 'FlowError',\n          timestamp: Date.now(),\n          error: error instanceof Error ? error.message : String(error),\n          state,\n        });\n      }\n      // End parent span on error (if created)\n      // @ts-expect-error runtime-scoped variable defined above\n      if (typeof parentSpan !== 'undefined' && parentSpan) parentSpan.end();\n      throw error;\n    }\n  }\n\n  /**\n   * Declares a reusable computational node using a signature string.\n   * Returns a new AxFlow type that tracks this node in the TNodes registry.\n   *\n   * @param name - The name of the node\n   * @param signature - Signature string in the same format as AxSignature\n   * @returns New AxFlow instance with updated TNodes type\n   *\n   * @example\n   * ```\n   * flow.node('summarizer', 'text:string -> summary:string')\n   * flow.node('analyzer', 'text:string -> analysis:string, confidence:number', { debug: true })\n   * ```\n   */\n  public node<TName extends string, TSig extends string>(\n    name: TName,\n    signature: TSig\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes & { [K in TName]: InferAxGen<TSig> }, // Add new node to registry\n    TState // State unchanged\n  >;\n\n  /**\n   * Declares a reusable computational node using an AxSignature instance.\n   * This allows using pre-configured signatures in the flow.\n   *\n   * @param name - The name of the node\n   * @param signature - AxSignature instance to use for this node\n   * @returns New AxFlow instance with updated TNodes type\n   *\n   * @example\n   * ```\n   * const sig = s('text:string -> summary:string')\n   * flow.node('summarizer', sig, { temperature: 0.1 })\n   * ```\n   */\n  public node<TName extends string>(\n    name: TName,\n    signature: AxSignature\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes & { [K in TName]: AxGen<AxGenIn, AxGenOut> }, // Add new node to registry\n    TState // State unchanged\n  >;\n\n  /**\n   * Declares a reusable computational node using a class that extends AxProgram.\n   * This allows using custom program classes in the flow.\n   *\n   * @param name - The name of the node\n   * @param programClass - Class that extends AxProgram to use for this node\n   * @returns New AxFlow instance with updated TNodes type\n   *\n   * @example\n   * ```\n   * class CustomProgram extends AxProgram<{ input: string }, { output: string }> {\n   *   async forward(ai, values) { return { output: values.input.toUpperCase() } }\n   * }\n   * flow.node('custom', CustomProgram)\n   * ```\n   */\n  public node<\n    TName extends string,\n    TProgram extends new () => AxProgrammable<any, any>,\n  >(\n    name: TName,\n    programClass: TProgram\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes & { [K in TName]: InstanceType<TProgram> }, // Add new node to registry with exact type\n    TState // State unchanged\n  >;\n\n  /**\n   * Declares a reusable computational node using an AxProgrammable instance.\n   * This allows using pre-configured AxGen instances or other programmable objects in the flow.\n   *\n   * @param name - The name of the node\n   * @param programInstance - The AxProgrammable instance to use for this node\n   * @returns New AxFlow instance with updated TNodes type\n   */\n  public node<TName extends string, TProgram extends AxProgrammable<any, any>>(\n    name: TName,\n    programInstance: TProgram\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes & { [K in TName]: TProgram }, // Add new node to registry with exact type\n    TState // State unchanged\n  >;\n\n  // Implementation\n  public node<TName extends string>(\n    name: TName,\n    nodeValue:\n      | string\n      | AxSignature\n      | AxProgrammable<any, any>\n      | (new () => AxProgrammable<any, any>)\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes & { [K in TName]: any }, // Using any here as the implementation handles all cases\n    TState\n  > {\n    if (typeof nodeValue === 'string' || nodeValue instanceof AxSignature) {\n      // Using signature string (original behavior)\n      const signature = nodeValue;\n\n      // Validate that signature is provided\n      if (!signature) {\n        throw new Error(\n          `Invalid signature for node '${name}': signature cannot be empty`\n        );\n      }\n\n      // Store node definition (simplified since we're using standard signatures)\n      this.nodes.set(name, {\n        inputs: {},\n        outputs: {},\n      });\n\n      // Create and store the AxGen instance for this node with the same arguments as AxGen\n      const nodeGenerator = ax(signature as string);\n      this.nodeGenerators.set(name, nodeGenerator);\n\n      // Register the node with the program after program is initialized\n      this.ensureProgram();\n      this.program!.register(nodeGenerator as any);\n    } else if (typeof nodeValue === 'function') {\n      // Using program class\n      this.nodes.set(name, {\n        inputs: {},\n        outputs: {},\n      });\n\n      // Create an instance of the program class and store it directly\n      const programInstance = new nodeValue() as AxProgrammable<any, any>;\n      this.nodeGenerators.set(name, programInstance);\n\n      // Register the node with the program after program is initialized\n      this.ensureProgram();\n      this.program!.register(programInstance as any);\n    } else if (\n      nodeValue &&\n      typeof nodeValue === 'object' &&\n      'forward' in nodeValue\n    ) {\n      // Using existing AxGen instance or AxProgrammable instance\n      this.nodes.set(name, {\n        inputs: {},\n        outputs: {},\n      });\n\n      // Store the existing AxGen instance\n      const nodeGenerator = nodeValue as AxProgrammable<any, any>;\n      this.nodeGenerators.set(name, nodeGenerator);\n\n      // Register the node with the program after program is initialized\n      this.ensureProgram();\n      this.program!.register(nodeGenerator as any);\n    } else {\n      // Invalid argument type\n      throw new Error(\n        `Invalid second argument for node '${name}': expected string, AxSignature, AxProgrammable instance, or constructor function`\n      );\n    }\n\n    // NOTE: This type assertion is necessary for the type-level programming pattern\n    // The runtime value is the same object, but TypeScript can't track the evolving generic types\n    return this as any;\n  }\n\n  /**\n   * Short alias for node() - supports signature strings, AxSignature instances, AxGen instances, and program classes\n   */\n  public n<TName extends string, TSig extends string>(\n    name: TName,\n    signature: TSig\n  ): AxFlow<IN, OUT, TNodes & { [K in TName]: InferAxGen<TSig> }, TState>;\n\n  public n<TName extends string>(\n    name: TName,\n    signature: AxSignature\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes & { [K in TName]: AxGen<AxGenIn, AxGenOut> },\n    TState\n  >;\n\n  public n<\n    TName extends string,\n    TProgram extends new () => AxProgrammable<any, any>,\n  >(\n    name: TName,\n    programClass: TProgram\n  ): AxFlow<IN, OUT, TNodes & { [K in TName]: InstanceType<TProgram> }, TState>;\n\n  public n<TName extends string, TProgram extends AxProgrammable<any, any>>(\n    name: TName,\n    programInstance: TProgram\n  ): AxFlow<IN, OUT, TNodes & { [K in TName]: TProgram }, TState>;\n\n  public n<TName extends string>(\n    name: TName,\n    signatureOrAxGenOrClass:\n      | string\n      | AxSignature\n      | AxProgrammable<any, any>\n      | (new () => AxProgrammable<any, any>)\n  ): any {\n    return this.node(name, signatureOrAxGenOrClass as any);\n  }\n\n  /**\n   * Applies a synchronous transformation to the state object.\n   * Returns a new AxFlow type with the evolved state.\n   *\n   * @param transform - Function that takes the current state and returns a new state\n   * @returns New AxFlow instance with updated TState type\n   *\n   * @example\n   * ```\n   * flow.map(state => ({ ...state, processedText: state.text.toLowerCase() }))\n   * ```\n   */\n  public map<TNewState extends AxFlowState>(\n    transform: (_state: TState) => TNewState\n  ): AxFlow<IN, OUT, TNodes, TNewState>;\n\n  /**\n   * Applies an asynchronous transformation to the state object.\n   * Returns a new AxFlow type with the evolved state.\n   *\n   * @param transform - Async function that takes the current state and returns a promise of new state\n   * @returns New AxFlow instance with updated TState type\n   *\n   * @example\n   * ```\n   * flow.map(async state => ({\n   *   ...state,\n   *   apiResult: await fetchDataFromAPI(state.query)\n   * }))\n   * ```\n   */\n  public map<TNewState extends AxFlowState>(\n    transform: (_state: TState) => Promise<TNewState>\n  ): AxFlow<IN, OUT, TNodes, TNewState>;\n\n  /**\n   * Applies a transformation to the state object with optional parallel execution.\n   * When parallel is enabled, the transform function should prepare data for parallel processing.\n   * The actual parallel processing happens with the array of transforms provided.\n   *\n   * @param transforms - Array of transformation functions to apply in parallel\n   * @param options - Options including parallel execution configuration\n   * @returns New AxFlow instance with updated TState type\n   *\n   * @example\n   * ```\n   * // Parallel map with multiple transforms\n   * flow.map([\n   *   state => ({ ...state, result1: processA(state.data) }),\n   *   state => ({ ...state, result2: processB(state.data) }),\n   *   state => ({ ...state, result3: processC(state.data) })\n   * ], { parallel: true })\n   * ```\n   */\n  public map<TNewState extends AxFlowState>(\n    transforms: Array<(_state: TState) => TNewState>,\n    options: { parallel: true }\n  ): AxFlow<IN, OUT, TNodes, TNewState>;\n\n  /**\n   * Applies async transformations to the state object with optional parallel execution.\n   * When parallel is enabled, all async transforms are executed concurrently.\n   *\n   * @param transforms - Array of async transformation functions to apply in parallel\n   * @param options - Options including parallel execution configuration\n   * @returns New AxFlow instance with updated TState type\n   *\n   * @example\n   * ```\n   * // Parallel async map with multiple transforms\n   * flow.map([\n   *   async state => ({ ...state, result1: await apiCall1(state.data) }),\n   *   async state => ({ ...state, result2: await apiCall2(state.data) }),\n   *   async state => ({ ...state, result3: await apiCall3(state.data) })\n   * ], { parallel: true })\n   * ```\n   */\n  public map<TNewState extends AxFlowState>(\n    transforms: Array<(_state: TState) => Promise<TNewState>>,\n    options: { parallel: true }\n  ): AxFlow<IN, OUT, TNodes, TNewState>;\n\n  public map<TNewState extends AxFlowState>(\n    transform: (_state: TState) => TNewState | Promise<TNewState>,\n    options?: { parallel?: boolean }\n  ): AxFlow<IN, OUT, TNodes, TNewState>;\n\n  public map<TNewState extends AxFlowState>(\n    transformOrTransforms: any,\n    options?: { parallel?: boolean }\n  ): AxFlow<IN, OUT, TNodes, TNewState> {\n    // Check if parallel processing is requested\n    if (options?.parallel) {\n      // Determine if we have an array of transforms or a single transform\n      const transforms = Array.isArray(transformOrTransforms)\n        ? transformOrTransforms\n        : [transformOrTransforms];\n\n      const parallelMapStep = async (state: AxFlowState) => {\n        const orderedResults = await processBatches(\n          transforms,\n          async (transform, _index) => {\n            const result = transform(state as TState);\n            return Promise.resolve(result);\n          },\n          this.autoParallelConfig.batchSize\n        );\n        const merged = orderedResults.reduce<AxFlowState>(\n          (acc, res) => ({ ...acc, ...res }),\n          state\n        );\n        return merged;\n      };\n\n      // Add the parallel step to the flow\n      if (this.branchContext?.currentBranchValue !== undefined) {\n        const currentBranch =\n          this.branchContext.branches.get(\n            this.branchContext.currentBranchValue\n          ) || [];\n        currentBranch.push(parallelMapStep);\n        this.branchContext.branches.set(\n          this.branchContext.currentBranchValue,\n          currentBranch\n        );\n      } else {\n        this.flowDefinition.push(parallelMapStep);\n\n        if (this.autoParallelConfig.enabled) {\n          this.executionPlanner.addExecutionStep(\n            parallelMapStep,\n            undefined,\n            undefined,\n            'parallel-map',\n            transforms as any\n          );\n        }\n      }\n    } else {\n      // Regular map operation (supports both sync and async)\n      const step = async (state: AxFlowState) => {\n        // For non-parallel mode, only single transforms are supported\n        if (Array.isArray(transformOrTransforms)) {\n          throw new Error('Array of transforms requires parallel: true option');\n        }\n\n        // Handle both sync and async transforms\n        const result = transformOrTransforms(state as TState);\n        // If the result is a promise, await it; otherwise return it directly\n        return Promise.resolve(result);\n      };\n\n      if (this.branchContext?.currentBranchValue !== undefined) {\n        const currentBranch =\n          this.branchContext.branches.get(\n            this.branchContext.currentBranchValue\n          ) || [];\n        currentBranch.push(step);\n        this.branchContext.branches.set(\n          this.branchContext.currentBranchValue,\n          currentBranch\n        );\n      } else {\n        this.flowDefinition.push(step);\n\n        // Add to execution planner for automatic parallelization\n        if (this.autoParallelConfig.enabled) {\n          this.executionPlanner.addExecutionStep(\n            step,\n            undefined,\n            undefined,\n            'map',\n            transformOrTransforms\n          );\n        }\n      }\n    }\n\n    // Initialize program when flow structure is updated (only if we have nodes)\n    if (this.nodeGenerators.size > 0) {\n      this.ensureProgram();\n    }\n\n    // NOTE: This type assertion is necessary for the type-level programming pattern\n    return this as unknown as AxFlow<IN, OUT, TNodes, TNewState>;\n  }\n\n  /**\n   * Short alias for map() - supports parallel option and async functions\n   */\n  public m<TNewState extends AxFlowState>(\n    transform: (_state: TState) => TNewState\n  ): AxFlow<IN, OUT, TNodes, TNewState>;\n\n  public m<TNewState extends AxFlowState>(\n    transform: (_state: TState) => Promise<TNewState>\n  ): AxFlow<IN, OUT, TNodes, TNewState>;\n\n  public m<TNewState extends AxFlowState>(\n    transforms: Array<(_state: TState) => TNewState>,\n    options: { parallel: true }\n  ): AxFlow<IN, OUT, TNodes, TNewState>;\n\n  public m<TNewState extends AxFlowState>(\n    transforms: Array<(_state: TState) => Promise<TNewState>>,\n    options: { parallel: true }\n  ): AxFlow<IN, OUT, TNodes, TNewState>;\n\n  public m<TNewState extends AxFlowState>(\n    transformOrTransforms:\n      | ((_state: TState) => TNewState | Promise<TNewState>)\n      | Array<(_state: TState) => TNewState | Promise<TNewState>>,\n    options?: { parallel?: boolean }\n  ): AxFlow<IN, OUT, TNodes, TNewState> {\n    return this.map(transformOrTransforms as any, options);\n  }\n\n  /**\n   * Terminal transformation that sets the final output type of the flow.\n   * Use this as the last transformation to get proper type inference for the flow result.\n   *\n   * @param transform - Function that transforms the current state to the final output\n   * @returns A new flow with the output type set to the transform result\n   *\n   * @example\n   * ```typescript\n   * const flow = flow<{ input: string }>()\n   *   .map(state => ({ ...state, processed: true }))\n   *   .returns(state => ({\n   *     result: state.processed ? \"done\" : \"pending\"\n   *   })) // TypeScript now knows the output is { result: string }\n   * ```\n   */\n  public returns<TNewOut extends Record<string, unknown>>(\n    transform: (_state: TState) => TNewOut\n  ): AxFlow<IN, TNewOut, TNodes, TState> {\n    // Add the transformation to the flow definition\n    // Note: We need to ensure the result extends AxFlowState (Record<string, unknown>)\n    const step: AxFlowStepFunction = async (state: AxFlowState) => {\n      const result = transform(state as TState);\n      return Promise.resolve(result as AxFlowState);\n    };\n\n    if (this.branchContext?.currentBranchValue !== undefined) {\n      const currentBranch =\n        this.branchContext.branches.get(\n          this.branchContext.currentBranchValue\n        ) || [];\n      currentBranch.push(step);\n      this.branchContext.branches.set(\n        this.branchContext.currentBranchValue,\n        currentBranch\n      );\n    } else {\n      this.flowDefinition.push(step);\n\n      // Add to execution planner for automatic parallelization\n      if (this.autoParallelConfig.enabled) {\n        this.executionPlanner.addExecutionStep(\n          step,\n          undefined,\n          undefined,\n          'map', // Treat returns as a special map operation\n          transform\n        );\n      }\n    }\n\n    // Initialize program when flow structure is updated (only if we have nodes)\n    if (this.nodeGenerators.size > 0) {\n      this.ensureProgram();\n    }\n\n    // Return a new flow with the updated output type\n    return this as unknown as AxFlow<IN, TNewOut, TNodes, TState>;\n  }\n\n  /**\n   * Short alias for returns() - r() is to returns() as m() is to map()\n   *\n   * @param transform - Function that transforms the current state to the final output\n   * @returns A new flow with the output type set to the transform result\n   */\n  public r<TNewOut extends Record<string, unknown>>(\n    transform: (_state: TState) => TNewOut\n  ): AxFlow<IN, TNewOut, TNodes, TState> {\n    return this.returns(transform);\n  }\n\n  /**\n   * Labels a step for later reference (useful for feedback loops).\n   *\n   * @param label - The label to assign to the current step position\n   * @returns this (for chaining, no type change)\n   *\n   * @example\n   * ```typescript\n   * flow.label('retry-point')\n   *   .execute('queryGen', ...)\n   * ```\n   */\n  public label(label: string): this {\n    if (this.branchContext?.currentBranchValue !== undefined) {\n      throw new Error('Cannot create labels inside branch blocks');\n    }\n    this.stepLabels.set(label, this.flowDefinition.length);\n    return this;\n  }\n\n  /**\n   * Short alias for label()\n   */\n  public l(label: string): this {\n    return this.label(label);\n  }\n\n  /**\n   * Executes a previously defined node with full type safety.\n   * The node name must exist in TNodes, and the mapping function is typed based on the node's signature.\n   *\n   * @param nodeName - The name of the node to execute (must exist in TNodes)\n   * @param mapping - Typed function that takes the current state and returns the input for the node\n   * @param dynamicContext - Optional object to override the AI service or options for this specific step\n   * @returns New AxFlow instance with TState augmented with the node's result\n   *\n   * @example\n   * ```typescript\n   * flow.execute('summarizer', state => ({ text: state.originalText }), { ai: cheapAI })\n   * ```\n   */\n  public execute<\n    TNodeName extends keyof TNodes & string,\n    TAI extends Readonly<AxAIService>,\n  >(\n    nodeName: TNodeName,\n    mapping: (_state: TState) => GetGenIn<TNodes[TNodeName]>,\n    dynamicContext?: AxFlowDynamicContext<TAI>\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes,\n    AddNodeResult<TState, TNodeName, GetGenOut<TNodes[TNodeName]>>\n  > {\n    if (!this.nodes.has(nodeName)) {\n      throw new Error(\n        `Node '${nodeName}' not found. Make sure to define it with .node() first.`\n      );\n    }\n\n    const nodeProgram = this.nodeGenerators.get(nodeName);\n    if (!nodeProgram) {\n      throw new Error(`Node program for '${nodeName}' not found.`);\n    }\n\n    const step = async (\n      state: AxFlowState,\n      context: Readonly<{\n        mainAi: AxAIService;\n        mainOptions?: AxProgramForwardOptions<string>;\n      }>\n    ) => {\n      // Determine AI service and options using fallback logic\n      const ai = dynamicContext?.ai ?? context.mainAi;\n      const options = {\n        ...(context.mainOptions ?? {}),\n        ...(dynamicContext?.options ?? {}),\n      } as AxProgramForwardOptions<string> | undefined;\n\n      // Map the state to node inputs (with type safety)\n      const nodeInputs = mapping(state as TState);\n\n      // Create trace label for the node execution\n      const traceLabel = options?.traceLabel\n        ? `Node:${nodeName} (${options.traceLabel})`\n        : `Node:${nodeName}`;\n\n      // Execute the node with updated trace label\n      // Handle both AxGen and AxProgram types\n      let result: any;\n      if (\n        'forward' in nodeProgram &&\n        typeof nodeProgram.forward === 'function'\n      ) {\n        result = await nodeProgram.forward(ai, nodeInputs, {\n          ...options,\n          traceLabel,\n        });\n\n        // Collect usage from the node after execution\n        if (\n          'getUsage' in nodeProgram &&\n          typeof nodeProgram.getUsage === 'function'\n        ) {\n          const nodeUsage = nodeProgram.getUsage();\n          if (nodeUsage && nodeUsage.length > 0) {\n            // Store usage for this node\n            const existingUsage = this.nodeUsage.get(nodeName) || [];\n            this.nodeUsage.set(nodeName, [...existingUsage, ...nodeUsage]);\n          }\n        }\n\n        // Collect traces from the node after execution\n        if (\n          'getTraces' in nodeProgram &&\n          typeof nodeProgram.getTraces === 'function'\n        ) {\n          const nodeTraces = nodeProgram.getTraces();\n          if (nodeTraces && nodeTraces.length > 0) {\n            // Store traces for this node\n            const existingTraces = this.nodeTraces.get(nodeName) || [];\n            this.nodeTraces.set(nodeName, [...existingTraces, ...nodeTraces]);\n          }\n        }\n      } else {\n        throw new Error(\n          `Node program for '${nodeName}' does not have a forward method`\n        );\n      }\n\n      // Merge result back into state under a key like `${nodeName}Result`\n      return {\n        ...state,\n        [`${nodeName}Result`]: result,\n      };\n    };\n\n    if (this.branchContext?.currentBranchValue !== undefined) {\n      // We're inside a branch - add to current branch\n      const currentBranch =\n        this.branchContext.branches.get(\n          this.branchContext.currentBranchValue\n        ) || [];\n      currentBranch.push(step);\n      this.branchContext.branches.set(\n        this.branchContext.currentBranchValue,\n        currentBranch\n      );\n    } else {\n      // Normal execution - add to main flow\n      this.flowDefinition.push(step);\n\n      // Add to execution planner for automatic parallelization\n      if (this.autoParallelConfig.enabled) {\n        this.executionPlanner.addExecutionStep(step, nodeName, mapping);\n      }\n    }\n\n    // Initialize program when flow structure is updated\n    this.ensureProgram();\n\n    // NOTE: This type assertion is necessary for the type-level programming pattern\n    return this as AxFlow<\n      IN,\n      OUT,\n      TNodes,\n      AddNodeResult<TState, TNodeName, GetGenOut<TNodes[TNodeName]>>\n    >;\n  }\n\n  /**\n   * Apply optimized configuration to this flow and all node programs.\n   */\n  public applyOptimization(optimizedProgram: AxOptimizedProgram<any>): void {\n    // Apply to underlying program if created\n    if (this.program && 'applyOptimization' in this.program) {\n      (this.program as any).applyOptimization(optimizedProgram);\n    }\n\n    // Propagate to all registered node generators\n    for (const [_nodeName, nodeProgram] of Array.from(this.nodeGenerators)) {\n      if (\n        nodeProgram &&\n        'applyOptimization' in nodeProgram &&\n        typeof (nodeProgram as any).applyOptimization === 'function'\n      ) {\n        (nodeProgram as any).applyOptimization(optimizedProgram);\n      }\n    }\n  }\n\n  /**\n   * Short alias for execute()\n   */\n  public e<\n    TNodeName extends keyof TNodes & string,\n    TAI extends Readonly<AxAIService>,\n  >(\n    nodeName: TNodeName,\n    mapping: (_state: TState) => GetGenIn<TNodes[TNodeName]>,\n    dynamicContext?: AxFlowDynamicContext<TAI>\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes,\n    AddNodeResult<TState, TNodeName, GetGenOut<TNodes[TNodeName]>>\n  > {\n    return this.execute(nodeName, mapping, dynamicContext);\n  }\n\n  /**\n   * Starts a conditional branch based on a predicate function.\n   *\n   * @param predicate - Function that takes state and returns a value to branch on\n   * @returns this (for chaining)\n   *\n   * @example\n   * ```typescript\n   * flow.branch(state => state.qualityResult.needsMoreInfo)\n   *   .when(true)\n   *     .execute('queryGen', ...)\n   *   .when(false)\n   *     .execute('answer', ...)\n   *   .merge()\n   * ```\n   */\n  public branch(predicate: (_state: TState) => unknown): this {\n    if (this.branchContext) {\n      throw new Error('Nested branches are not supported');\n    }\n\n    this.branchContext = {\n      predicate: (state: AxFlowState) => predicate(state as TState),\n      branches: new Map(),\n      currentBranchValue: undefined,\n    };\n\n    return this;\n  }\n\n  /**\n   * Short alias for branch()\n   */\n  public b(predicate: (_state: TState) => unknown): this {\n    return this.branch(predicate);\n  }\n\n  /**\n   * Defines a branch case for the current branch context.\n   *\n   * @param value - The value to match against the branch predicate result\n   * @returns this (for chaining)\n   */\n  public when(value: unknown): this {\n    if (!this.branchContext) {\n      throw new Error('when() called without matching branch()');\n    }\n\n    this.branchContext.currentBranchValue = value;\n    this.branchContext.branches.set(value, []);\n\n    return this;\n  }\n\n  /**\n   * Short alias for when()\n   */\n  public w(value: unknown): this {\n    return this.when(value);\n  }\n\n  /**\n   * Merges the results of conditional branches into a single execution path.\n   *\n   * This method is called after defining conditional branches with branch() and when() methods.\n   * It creates a merge point where the flow continues with the results from whichever\n   * branch was executed based on the branch condition.\n   *\n   * How conditional merging works:\n   * 1. The branch predicate is evaluated against the current state\n   * 2. The matching branch's steps are executed sequentially\n   * 3. If no branch matches, the state is returned unchanged\n   * 4. The merged result becomes the new state for subsequent steps\n   *\n   * Type safety note:\n   * The TMergedState generic allows for type-level tracking of what fields\n   * will be available after the merge, though runtime behavior depends on\n   * which branch actually executes.\n   *\n   * @returns AxFlow with updated state type reflecting the merged result\n   *\n   * @example\n   * ```typescript\n   * flow\n   *   .branch(state => state.complexity > 0.5)\n   *   .when(true)\n   *     .execute('complexProcessor', state => ({ input: state.text }))\n   *   .when(false)\n   *     .execute('simpleProcessor', state => ({ input: state.text }))\n   *   .merge() // Combines results from either branch\n   * ```\n   */\n  public merge<TMergedState extends AxFlowState = TState>(): AxFlow<\n    IN,\n    OUT,\n    TNodes,\n    TMergedState\n  > {\n    if (!this.branchContext) {\n      throw new Error('merge() called without matching branch()');\n    }\n\n    // Capture the branch context before clearing it\n    const branchContext = this.branchContext;\n    this.branchContext = null;\n\n    // Create the merge step that will execute at runtime\n    const mergeStep = async (state: AxFlowState, context: any) => {\n      // Evaluate the branch predicate to determine which branch to execute\n      const branchValue = branchContext.predicate(state);\n      const branchSteps = branchContext.branches.get(branchValue);\n\n      if (this.flowLogger) {\n        this.flowLogger({\n          name: 'BranchEvaluation',\n          timestamp: Date.now(),\n          branchValue,\n          hasMatchingBranch: !!branchSteps,\n          branchStepsCount: branchSteps?.length ?? 0,\n        } as any);\n      }\n\n      if (!branchSteps) {\n        // No matching branch found - return state unchanged\n        // This can happen if the predicate returns a value that wasn't\n        // defined with a when() clause\n        return state;\n      }\n\n      // Execute all steps in the matched branch sequentially\n      // Each step receives the output of the previous step as input\n      let currentState = state;\n      for (const step of branchSteps) {\n        currentState = await step(currentState, context);\n      }\n\n      return currentState;\n    };\n\n    // Add the merge step to the main flow execution\n    this.flowDefinition.push(mergeStep);\n\n    // Register with execution planner for automatic parallelization\n    // This helps with signature inference and dependency analysis\n    if (this.autoParallelConfig.enabled) {\n      this.executionPlanner.addExecutionStep(\n        mergeStep,\n        undefined,\n        undefined,\n        'merge'\n      );\n    }\n\n    // Initialize program when flow structure is updated\n    this.ensureProgram();\n\n    // Type-level cast to update the state type while preserving the runtime object\n    // This allows TypeScript to track what fields should be available after the merge\n    return this as unknown as AxFlow<IN, OUT, TNodes, TMergedState>;\n  }\n\n  /**\n   * Short alias for merge()\n   */\n  public mg<TMergedState extends AxFlowState = TState>(): AxFlow<\n    IN,\n    OUT,\n    TNodes,\n    TMergedState\n  > {\n    return this.merge<TMergedState>();\n  }\n\n  /**\n   * Executes multiple operations in parallel and provides a merge method for combining results.\n   *\n   * This method enables true parallel execution of independent operations, which is particularly\n   * useful for operations like:\n   * - Multiple document retrievals\n   * - Parallel processing of different data sources\n   * - Independent LLM calls that can run simultaneously\n   *\n   * How parallel execution works:\n   * 1. Each branch function receives a sub-context for defining operations\n   * 2. All branches are executed simultaneously using Promise.all()\n   * 3. Results are stored in _parallelResults for the merge operation\n   * 4. The merge function combines the results into a single field\n   *\n   * Performance benefits:\n   * - Reduces total execution time for independent operations\n   * - Maximizes throughput for I/O-bound operations (like LLM calls)\n   * - Maintains type safety through the merge operation\n   *\n   * @param branches - Array of functions that define parallel operations\n   * @returns Object with merge method for combining results\n   *\n   * @example\n   * ```typescript\n   * flow.parallel([\n   *   subFlow => subFlow.execute('retrieve1', state => ({ query: state.query1 })),\n   *   subFlow => subFlow.execute('retrieve2', state => ({ query: state.query2 })),\n   *   subFlow => subFlow.execute('retrieve3', state => ({ query: state.query3 }))\n   * ]).merge('documents', (docs1, docs2, docs3) => [...docs1, ...docs2, ...docs3])\n   * ```\n   */\n  public parallel(\n    branches: (\n      | AxFlowParallelBranch\n      | AxFlowTypedParallelBranch<TNodes, TState>\n    )[]\n  ): {\n    merge<T, TResultKey extends string>(\n      resultKey: TResultKey,\n      mergeFunction: (..._results: unknown[]) => T\n    ): AxFlow<IN, OUT, TNodes, TState & { [K in TResultKey]: T }>;\n  } {\n    // Create the parallel execution step\n    const parallelStep = async (\n      state: AxFlowState,\n      context: Readonly<{\n        mainAi: AxAIService;\n        mainOptions?: AxProgramForwardOptions<string>;\n      }>\n    ) => {\n      // Execute branches with batch size control\n      const results = await processBatches(\n        branches,\n        async (branchFn, _index) => {\n          // Create a sub-context for this branch\n          // This isolates each branch's operations from the others\n          const subContext = new AxFlowSubContextImpl(this.nodeGenerators);\n\n          // Type assertion needed because we support both typed and untyped branch functions\n          // The runtime behavior is the same, but TypeScript needs this for type checking\n          const populatedSubContext = branchFn(\n            subContext as AxFlowSubContext &\n              AxFlowTypedSubContext<TNodes, TState>\n          );\n\n          // Execute the sub-context steps and return the result\n          return await populatedSubContext.executeSteps(state, context);\n        },\n        this.autoParallelConfig.batchSize\n      );\n\n      // Store results in a special field for the merge operation\n      // This is a temporary storage that will be cleaned up by the merge\n      return {\n        ...state,\n        _parallelResults: results,\n      };\n    };\n\n    // Add the parallel step to the main flow execution\n    this.flowDefinition.push(parallelStep);\n\n    // Register with execution planner (marked as 'other' since it's a special case)\n    if (this.autoParallelConfig.enabled) {\n      this.executionPlanner.addExecutionStep(\n        parallelStep,\n        undefined,\n        undefined,\n        'parallel',\n        undefined,\n        undefined\n      );\n    }\n\n    // Initialize program when flow structure is updated\n    this.ensureProgram();\n\n    // Return an object with the merge method for combining parallel results\n    return {\n      /**\n       * Merges the results of parallel operations into a single field.\n       *\n       * @param resultKey - Name of the field to store the merged result\n       * @param mergeFunction - Function that combines the parallel results\n       * @returns AxFlow with the merged result added to the state\n       */\n      merge: <T, TResultKey extends string>(\n        resultKey: TResultKey,\n        mergeFunction: (...results: unknown[]) => T\n      ): AxFlow<IN, OUT, TNodes, TState & { [K in TResultKey]: T }> => {\n        // Create the merge step that combines parallel results\n        const parallelMergeStep = (state: AxFlowState) => {\n          const results = state._parallelResults;\n          if (!Array.isArray(results)) {\n            throw new Error('No parallel results found for merge');\n          }\n\n          // Apply the merge function to combine all parallel results\n          const mergedValue = mergeFunction(...results);\n\n          // Create new state with the merged result and clean up temporary storage\n          const newState = { ...state };\n          delete newState._parallelResults; // Properly delete temporary field\n          newState[resultKey] = mergedValue;\n\n          return newState;\n        };\n\n        // Add the merge step to the main flow execution\n        this.flowDefinition.push(parallelMergeStep);\n\n        // Register with execution planner for signature inference\n        if (this.autoParallelConfig.enabled) {\n          this.executionPlanner.addExecutionStep(\n            parallelMergeStep,\n            undefined,\n            undefined,\n            'merge',\n            undefined,\n            { resultKey, mergeFunction }\n          );\n        }\n\n        // Initialize program when flow structure is updated\n        this.ensureProgram();\n\n        // Type-level cast to include the new merged field in the state type\n        return this as AxFlow<\n          IN,\n          OUT,\n          TNodes,\n          TState & { [K in TResultKey]: T }\n        >;\n      },\n    };\n  }\n\n  /**\n   * Short alias for parallel()\n   */\n  public p(\n    branches: (\n      | AxFlowParallelBranch\n      | AxFlowTypedParallelBranch<TNodes, TState>\n    )[]\n  ): {\n    merge<T, TResultKey extends string>(\n      resultKey: TResultKey,\n      mergeFunction: (..._results: unknown[]) => T\n    ): AxFlow<IN, OUT, TNodes, TState & { [K in TResultKey]: T }>;\n  } {\n    return this.parallel(branches);\n  }\n\n  /**\n   * Creates a feedback loop that jumps back to a labeled step if a condition is met.\n   *\n   * @param condition - Function that returns true to trigger the feedback loop\n   * @param targetLabel - The label to jump back to\n   * @param maxIterations - Maximum number of iterations to prevent infinite loops (default: 10)\n   * @returns this (for chaining)\n   *\n   * @example\n   * ```typescript\n   * flow.label('retry-point')\n   *   .execute('answer', ...)\n   *   .execute('qualityCheck', ...)\n   *   .feedback(state => state.qualityCheckResult.confidence < 0.7, 'retry-point')\n   * ```\n   */\n  public feedback(\n    condition: (_state: TState) => boolean,\n    targetLabel: string,\n    maxIterations = 10\n  ): this {\n    if (!this.stepLabels.has(targetLabel)) {\n      throw new Error(\n        `Label '${targetLabel}' not found. Make sure to define it with .label() before the feedback point.`\n      );\n    }\n\n    const targetIndex = this.stepLabels.get(targetLabel)!;\n\n    // Capture the current flow definition length before adding the feedback step\n    // This prevents the feedback step from executing itself recursively\n    const feedbackStepIndex = this.flowDefinition.length;\n\n    this.flowDefinition.push(async (state, context) => {\n      let currentState = state;\n      let iterations = 1; // Start at 1 since we've already executed once before reaching feedback\n\n      // Add iteration tracking to state if not present\n      const iterationKey = `_feedback_${targetLabel}_iterations`;\n      if (typeof currentState[iterationKey] !== 'number') {\n        currentState = { ...currentState, [iterationKey]: 1 }; // Initial execution counts as iteration 1\n      }\n\n      // Check if we should loop back (iterations < maxIterations since initial execution counts as 1)\n      while (condition(currentState as TState) && iterations < maxIterations) {\n        iterations++;\n        currentState = { ...currentState, [iterationKey]: iterations };\n\n        // Execute steps from target index to just before the feedback step\n        // Use feedbackStepIndex to avoid including the feedback step itself\n        for (let i = targetIndex; i < feedbackStepIndex; i++) {\n          const step = this.flowDefinition[i];\n          if (step) {\n            currentState = await step(currentState, context);\n          }\n        }\n      }\n\n      return currentState;\n    });\n\n    // Initialize program when flow structure is updated (only if we have nodes)\n    if (this.nodeGenerators.size > 0) {\n      this.ensureProgram();\n    }\n\n    return this;\n  }\n\n  /**\n   * Short alias for feedback()\n   */\n  public fb(\n    condition: (_state: TState) => boolean,\n    targetLabel: string,\n    maxIterations = 10\n  ): this {\n    return this.feedback(condition, targetLabel, maxIterations);\n  }\n\n  /**\n   * Marks the beginning of a loop block.\n   *\n   * @param condition - Function that takes the current state and returns a boolean\n   * @param maxIterations - Maximum number of iterations to prevent infinite loops (default: 100)\n   * @returns this (for chaining)\n   *\n   * @example\n   * ```typescript\n   * flow.while(state => state.iterations < 3, 10)\n   *   .map(state => ({ ...state, iterations: (state.iterations || 0) + 1 }))\n   *   .endWhile()\n   * ```\n   */\n  public while(\n    condition: (state: TState) => boolean,\n    maxIterations = 100\n  ): this {\n    // Store the condition and mark the start of the loop\n    const loopStartIndex = this.flowDefinition.length;\n    this.loopStack.push(loopStartIndex);\n\n    // Add a placeholder step that will be replaced in endWhile()\n    // We store the condition and maxIterations in the placeholder for later use\n    interface LoopPlaceholder extends AxFlowStepFunction {\n      _condition: (state: TState) => boolean;\n      _maxIterations: number;\n      _isLoopStart: boolean;\n    }\n\n    const placeholderStep: LoopPlaceholder = Object.assign(\n      (state: AxFlowState) => state,\n      {\n        _condition: condition,\n        _maxIterations: maxIterations,\n        _isLoopStart: true,\n      }\n    );\n\n    this.flowDefinition.push(placeholderStep);\n\n    // Initialize program when flow structure is updated (only if we have nodes)\n    if (this.nodeGenerators.size > 0) {\n      this.ensureProgram();\n    }\n\n    return this;\n  }\n\n  /**\n   * Short alias for while()\n   */\n  public wh(condition: (_state: TState) => boolean, maxIterations = 100): this {\n    return this.while(condition, maxIterations);\n  }\n\n  /**\n   * Marks the end of a loop block.\n   *\n   * @returns this (for chaining)\n   */\n  public endWhile(): this {\n    if (this.loopStack.length === 0) {\n      throw new Error('endWhile() called without matching while()');\n    }\n\n    const loopStartIndex = this.loopStack.pop()!;\n\n    // Get the condition from the placeholder step\n    const placeholderStep = this.flowDefinition[loopStartIndex];\n    if (!placeholderStep || !('_isLoopStart' in placeholderStep)) {\n      throw new Error('Loop start step not found or invalid');\n    }\n\n    const condition = (\n      placeholderStep as unknown as {\n        _condition: (state: TState) => boolean;\n        _maxIterations: number;\n      }\n    )._condition;\n\n    const maxIterations = (\n      placeholderStep as unknown as {\n        _condition: (state: TState) => boolean;\n        _maxIterations: number;\n      }\n    )._maxIterations;\n\n    // Extract the loop body steps (everything between while and endWhile)\n    const loopBodySteps = this.flowDefinition.splice(loopStartIndex + 1);\n\n    // Replace the placeholder with the actual loop implementation\n    this.flowDefinition[loopStartIndex] = async (state, context) => {\n      let currentState = state;\n      let iterations = 0;\n\n      // Execute the loop while condition is true and within iteration limit\n      while (condition(currentState as TState) && iterations < maxIterations) {\n        iterations++;\n\n        // Execute all steps in the loop body\n        for (const step of loopBodySteps) {\n          currentState = await step(currentState, context);\n        }\n      }\n\n      // Check if we exceeded the maximum iterations\n      if (iterations >= maxIterations && condition(currentState as TState)) {\n        throw new Error(\n          `While loop exceeded maximum iterations (${maxIterations}). Consider increasing maxIterations or ensuring the loop condition eventually becomes false.`\n        );\n      }\n\n      return currentState;\n    };\n\n    // Initialize program when flow structure is updated (only if we have nodes)\n    if (this.nodeGenerators.size > 0) {\n      this.ensureProgram();\n    }\n\n    return this;\n  }\n\n  /**\n   * Short alias for endWhile()\n   */\n  public end(): this {\n    return this.endWhile();\n  }\n\n  /**\n   * Derives a new field from an existing field by applying a transform function.\n   *\n   * If the input field contains an array, the transform function is applied to each\n   * array element in parallel with batch size control. If the input field contains\n   * a scalar value, the transform function is applied directly.\n   *\n   * @param outputFieldName - Name of the field to store the result\n   * @param inputFieldName - Name of the existing field to transform\n   * @param transformFn - Function to apply to each element (for arrays) or the value directly (for scalars)\n   * @param options - Options including batch size for parallel processing\n   * @returns this (for chaining)\n   *\n   * @example\n   * ```typescript\n   * // Parallel processing of array items\n   * flow.derive('processedItems', 'items', (item, index) => processItem(item), { batchSize: 5 })\n   *\n   * // Direct transformation of scalar value\n   * flow.derive('upperText', 'text', (text) => text.toUpperCase())\n   * ```\n   */\n  public derive<T>(\n    outputFieldName: string,\n    inputFieldName: string,\n    transformFn: (value: any, index?: number, state?: TState) => T,\n    options?: { batchSize?: number }\n  ): this {\n    const step = async (state: AxFlowState) => {\n      const inputValue = state[inputFieldName];\n\n      if (inputValue === undefined) {\n        throw new Error(`Input field '${inputFieldName}' not found in state`);\n      }\n\n      let result: T | T[];\n\n      if (Array.isArray(inputValue)) {\n        // Array input - use parallel processing with batch control\n        if (this.autoParallelConfig.enabled) {\n          const batchSize =\n            options?.batchSize || this.autoParallelConfig.batchSize;\n          result = await processBatches(\n            inputValue,\n            async (item, index) => {\n              return transformFn(item, index, state as TState);\n            },\n            batchSize\n          );\n        } else {\n          // Sequential processing when parallel is disabled\n          result = inputValue.map((item: any, index: number) =>\n            transformFn(item, index, state as TState)\n          );\n        }\n      } else {\n        // Scalar input - apply transform directly\n        result = transformFn(inputValue, undefined, state as TState);\n      }\n\n      return {\n        ...state,\n        [outputFieldName]: result,\n      };\n    };\n\n    if (this.branchContext?.currentBranchValue !== undefined) {\n      // We're inside a branch - add to current branch\n      const currentBranch =\n        this.branchContext.branches.get(\n          this.branchContext.currentBranchValue\n        ) || [];\n      currentBranch.push(step);\n      this.branchContext.branches.set(\n        this.branchContext.currentBranchValue,\n        currentBranch\n      );\n    } else {\n      // Normal execution - add to main flow\n      this.flowDefinition.push(step);\n\n      // Register with execution planner for signature inference and automatic parallelization\n      if (this.autoParallelConfig.enabled) {\n        this.executionPlanner.addExecutionStep(\n          step,\n          undefined,\n          undefined,\n          'derive',\n          transformFn as any,\n          undefined,\n          {\n            inputFieldName,\n            outputFieldName,\n            batchSize: options?.batchSize,\n          }\n        );\n      }\n    }\n\n    // Initialize program when flow structure is updated\n    this.ensureProgram();\n\n    return this;\n  }\n\n  /**\n   * Gets execution plan information for debugging automatic parallelization\n   *\n   * @returns Object with execution plan details\n   */\n  public getExecutionPlan(): {\n    totalSteps: number;\n    parallelGroups: number;\n    maxParallelism: number;\n    autoParallelEnabled: boolean;\n    steps?: AxFlowExecutionStep[];\n    groups?: AxFlowParallelGroup[];\n  } {\n    const planInfo = this.executionPlanner.getExecutionPlan();\n    return {\n      totalSteps: planInfo.totalSteps,\n      parallelGroups: planInfo.parallelGroups,\n      maxParallelism: planInfo.maxParallelism,\n      autoParallelEnabled: this.autoParallelConfig.enabled,\n      steps: planInfo.steps,\n      groups: planInfo.groups,\n    };\n  }\n\n  public getSignature(): AxSignature {\n    this.ensureProgram();\n    return this.program!.getSignature();\n  }\n\n  /**\n   * Creates a new AxFlow node from an existing signature by extending it with additional fields.\n   *\n   * @param name - The name of the new node\n   * @param baseSignature - The base signature to extend (string or AxSignature)\n   * @param extensions - Object defining how to extend the signature\n   * @returns New AxFlow instance with the extended node\n   *\n   * @example\n   * ```typescript\n   * // Create a chain-of-thought node\n   * flow.nodeExtended('reasoner', 'question:string -> answer:string', {\n   *   prependOutputs: [\n   *     { name: 'reasoning', type: f.internal(f.string('Step-by-step reasoning')) }\n   *   ]\n   * })\n   *\n   * // Create a node with context and confidence\n   * flow.nodeExtended('analyzer', 'input:string -> output:string', {\n   *   appendInputs: [{ name: 'context', type: f.optional(f.string('Context')) }],\n   *   appendOutputs: [{ name: 'confidence', type: f.number('Confidence score') }]\n   * })\n   * ```\n   */\n  public nodeExtended<TName extends string>(\n    name: TName,\n    baseSignature: string | AxSignature,\n    extensions: {\n      prependInputs?: Array<{ name: string; type: AxFieldType }>;\n      appendInputs?: Array<{ name: string; type: AxFieldType }>;\n      prependOutputs?: Array<{ name: string; type: AxFieldType }>;\n      appendOutputs?: Array<{ name: string; type: AxFieldType }>;\n    }\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes & { [K in TName]: AxGen<AxGenIn, AxGenOut> },\n    TState\n  > {\n    // Create base signature\n    const sig =\n      typeof baseSignature === 'string'\n        ? AxSignature.create(baseSignature)\n        : baseSignature;\n\n    // Apply extensions in the specified order\n    let extendedSig = sig;\n\n    // Apply prepend inputs first\n    if (extensions.prependInputs) {\n      for (const input of extensions.prependInputs) {\n        extendedSig = extendedSig.prependInputField(input.name, input.type);\n      }\n    }\n\n    // Apply append inputs\n    if (extensions.appendInputs) {\n      for (const input of extensions.appendInputs) {\n        extendedSig = extendedSig.appendInputField(input.name, input.type);\n      }\n    }\n\n    // Apply prepend outputs\n    if (extensions.prependOutputs) {\n      for (const output of extensions.prependOutputs) {\n        extendedSig = extendedSig.prependOutputField(output.name, output.type);\n      }\n    }\n\n    // Apply append outputs\n    if (extensions.appendOutputs) {\n      for (const output of extensions.appendOutputs) {\n        extendedSig = extendedSig.appendOutputField(output.name, output.type);\n      }\n    }\n\n    // Create the node using the extended signature\n    return this.node(name, extendedSig);\n  }\n\n  /**\n   * Short alias for nodeExtended() - creates nodes with extended signatures\n   */\n  public nx<TName extends string>(\n    name: TName,\n    baseSignature: string | AxSignature,\n    extensions: {\n      prependInputs?: Array<{ name: string; type: AxFieldType }>;\n      appendInputs?: Array<{ name: string; type: AxFieldType }>;\n      prependOutputs?: Array<{ name: string; type: AxFieldType }>;\n      appendOutputs?: Array<{ name: string; type: AxFieldType }>;\n    }\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes & { [K in TName]: AxGen<AxGenIn, AxGenOut> },\n    TState\n  > {\n    return this.nodeExtended(name, baseSignature, extensions);\n  }\n\n  /**\n   * Applies a final transformation to the state object that updates both state and output type.\n   * This is specifically designed for terminal transformations that shape the final output.\n   *\n   * @param transform - Function that takes the current state and returns the final output\n   * @returns New AxFlow instance with updated OUT and TState types\n   *\n   * @example\n   * ```\n   * const result = await flow\n   *   .node('analyzer', 'userQuestion:string -> analysisResult:string')\n   *   .execute('analyzer', state => ({ userQuestion: state.userQuestion }))\n   *   .mapOutput(state => ({\n   *     // Note: Node results are typed as AxFieldValue, so you may need to cast\n   *     finalAnswer: state.analyzerResult.analysisResult as string\n   *   }))\n   *   .forward(ai, { userQuestion: 'test' });\n   *\n   * // result is typed as { finalAnswer: string }\n   * ```\n   */\n  public mapOutput<TOutput>(\n    transform: (_state: TState) => TOutput\n  ): AxFlow<IN, TOutput, TNodes, TOutput & TState> {\n    // Add the transformation as a regular map step\n    const step = async (state: AxFlowState) => {\n      const result = transform(state as TState);\n      return { ...state, ...result };\n    };\n\n    if (this.branchContext?.currentBranchValue !== undefined) {\n      const currentBranch =\n        this.branchContext.branches.get(\n          this.branchContext.currentBranchValue\n        ) || [];\n      currentBranch.push(step);\n      this.branchContext.branches.set(\n        this.branchContext.currentBranchValue,\n        currentBranch\n      );\n    } else {\n      this.flowDefinition.push(step);\n\n      // Add to execution planner for automatic parallelization\n      if (this.autoParallelConfig.enabled) {\n        this.executionPlanner.addExecutionStep(\n          step,\n          undefined,\n          undefined,\n          'map',\n          transform\n        );\n      }\n    }\n\n    // Initialize program when flow structure is updated (only if we have nodes)\n    if (this.nodeGenerators.size > 0) {\n      this.ensureProgram();\n    }\n\n    // Return with updated OUT type\n    return this as unknown as AxFlow<IN, TOutput, TNodes, TOutput & TState>;\n  }\n\n  /**\n   * Short alias for mapOutput()\n   */\n  public mo<TOutput>(\n    transform: (_state: TState) => TOutput\n  ): AxFlow<IN, TOutput, TNodes, TOutput & TState> {\n    return this.mapOutput(transform);\n  }\n}\n\n/**\n * Factory function to create a new AxFlow instance\n * Similar to ai() for AI services, this creates a fluent flow\n *\n * @param options - Optional configuration for the flow\n * @returns New AxFlow instance\n *\n * @example\n * ```typescript\n * // Input type is required - provides type safety throughout the flow\n * const workflow = flow<{ userInput: string }>()\n *   .node('summarizer', 'documentText:string -> summaryText:string')\n *   .execute('summarizer', state => ({ documentText: state.userInput }));\n *\n * // Complex input types work great for multi-field workflows\n * const complexFlow = flow<{ userQuestion: string; context: string }>()\n *   .map(state => ({\n *     ...state,\n *     processedQuestion: state.userQuestion.toUpperCase() // TypeScript knows this exists!\n *   }));\n * ```\n */\n/**\n * Creates a new AxFlow instance with required input type specification.\n *\n * The input type must be specified upfront to enable proper type inference\n * throughout the flow construction and execution.\n *\n * @example\n * ```typescript\n * //  Define input type upfront for better type safety\n * const workflow = flow<{ userInput: string, options?: any }>()\n *   .map(state => ({ ...state, processedInput: state.userInput.toUpperCase() }))\n *   .node('analyzer', 'processedInput:string -> result:string')\n *\n * //  Simple input types work too\n * const simpleFlow = flow<{ documentText: string }>()\n *   .node('summarizer', 'documentText:string -> summary:string')\n * ```\n */\nexport function flow<\n  TInput extends Record<string, any>,\n  TOutput = {},\n>(options?: {\n  autoParallel?: boolean;\n  batchSize?: number;\n  logger?: AxFlowLoggerFunction;\n  debug?: boolean;\n}): AxFlow<TInput, TOutput, {}, TInput> {\n  return AxFlow.create<TInput, TOutput, {}, TInput>(options);\n}\n","import { ColorLog } from '../util/log.js';\nimport type { AxFlowState } from './types.js';\n\n/**\n * Data types for different AxFlow logging events\n */\nexport interface AxFlowLoggerData {\n  name: string;\n  timestamp: number;\n  [key: string]: unknown;\n}\n\nexport interface AxFlowStartData extends AxFlowLoggerData {\n  name: 'FlowStart';\n  inputFields: string[];\n  totalSteps: number;\n  parallelGroups: number;\n  maxParallelism: number;\n  autoParallelEnabled: boolean;\n}\n\nexport interface AxFlowStepStartData extends AxFlowLoggerData {\n  name: 'StepStart';\n  stepIndex: number;\n  stepType:\n    | 'execute'\n    | 'map'\n    | 'merge'\n    | 'parallel-map'\n    | 'parallel'\n    | 'derive'\n    | 'branch'\n    | 'feedback'\n    | 'while'\n    | 'other';\n  nodeName?: string;\n  dependencies: string[];\n  produces: string[];\n  state: AxFlowState;\n}\n\nexport interface AxFlowStepCompleteData extends AxFlowLoggerData {\n  name: 'StepComplete';\n  stepIndex: number;\n  stepType:\n    | 'execute'\n    | 'map'\n    | 'merge'\n    | 'parallel-map'\n    | 'parallel'\n    | 'derive'\n    | 'branch'\n    | 'feedback'\n    | 'while'\n    | 'other';\n  nodeName?: string;\n  executionTime: number;\n  state: AxFlowState;\n  newFields?: string[];\n  result?: any;\n}\n\nexport interface AxFlowParallelGroupStartData extends AxFlowLoggerData {\n  name: 'ParallelGroupStart';\n  groupLevel: number;\n  stepsCount: number;\n  stepTypes: string[];\n}\n\nexport interface AxFlowParallelGroupCompleteData extends AxFlowLoggerData {\n  name: 'ParallelGroupComplete';\n  groupLevel: number;\n  stepsCount: number;\n  executionTime: number;\n}\n\nexport interface AxFlowBranchEvaluationData extends AxFlowLoggerData {\n  name: 'BranchEvaluation';\n  branchValue: unknown;\n  hasMatchingBranch: boolean;\n  branchStepsCount: number;\n}\n\nexport interface AxFlowCompleteData extends AxFlowLoggerData {\n  name: 'FlowComplete';\n  totalExecutionTime: number;\n  finalState: AxFlowState;\n  outputFields: string[];\n  stepsExecuted: number;\n}\n\nexport interface AxFlowErrorData extends AxFlowLoggerData {\n  name: 'FlowError';\n  error: string;\n  stepIndex?: number;\n  stepType?: string;\n  nodeName?: string;\n  state?: AxFlowState;\n}\n\nexport type AxFlowLogData =\n  | AxFlowStartData\n  | AxFlowStepStartData\n  | AxFlowStepCompleteData\n  | AxFlowParallelGroupStartData\n  | AxFlowParallelGroupCompleteData\n  | AxFlowBranchEvaluationData\n  | AxFlowCompleteData\n  | AxFlowErrorData;\n\n/**\n * Function type for AxFlow logging\n */\nexport type AxFlowLoggerFunction = (data: AxFlowLogData) => void;\n\n// Default output function that writes to stdout\nconst defaultOutput = (message: string): void => {\n  console.log(message);\n};\n\n/**\n * Formats state object for display, truncating large values\n */\nconst formatState = (state: AxFlowState, hideContent = false): string => {\n  if (hideContent) return '[State hidden]';\n\n  const formatted: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(state)) {\n    if (typeof value === 'string' && value.length > 100) {\n      formatted[key] = `${value.substring(0, 100)}...`;\n    } else if (Array.isArray(value) && value.length > 3) {\n      formatted[key] = [...value.slice(0, 3), `... (${value.length - 3} more)`];\n    } else if (typeof value === 'object' && value !== null) {\n      const objStr = JSON.stringify(value);\n      if (objStr.length > 200) {\n        formatted[key] = `${objStr.substring(0, 200)}...`;\n      } else {\n        formatted[key] = value;\n      }\n    } else {\n      formatted[key] = value;\n    }\n  }\n  return JSON.stringify(formatted, null, 2);\n};\n\n/**\n * Formats execution time for display\n */\nconst formatTime = (ms: number): string => {\n  if (ms < 1000) return `${ms.toFixed(1)}ms`;\n  if (ms < 60000) return `${(ms / 1000).toFixed(2)}s`;\n  return `${(ms / 60000).toFixed(2)}min`;\n};\n\n/**\n * Factory function to create a colorized AxFlow logger\n */\nexport const axCreateFlowColorLogger = (\n  output: (message: string) => void = defaultOutput\n): AxFlowLoggerFunction => {\n  const cl = new ColorLog();\n  const divider = cl.gray(`${''.repeat(80)}\\n`);\n  const smallDivider = cl.gray(`${''.repeat(40)}\\n`);\n\n  return (data: AxFlowLogData) => {\n    let formattedMessage = '';\n\n    switch (data.name) {\n      case 'FlowStart':\n        formattedMessage = `\\n${cl.blueBright(' [ AXFLOW START ]')}\\n${divider}`;\n        formattedMessage += `${cl.white('Input Fields:')} ${cl.cyan(data.inputFields.join(', '))}\\n`;\n        formattedMessage += `${cl.white('Total Steps:')} ${cl.yellow(data.totalSteps.toString())}\\n`;\n        formattedMessage += `${cl.white('Parallel Groups:')} ${cl.yellow(data.parallelGroups.toString())}\\n`;\n        formattedMessage += `${cl.white('Max Parallelism:')} ${cl.yellow(data.maxParallelism.toString())}\\n`;\n        formattedMessage += `${cl.white('Auto-Parallel:')} ${data.autoParallelEnabled ? cl.green('enabled') : cl.red('disabled')}\\n`;\n        formattedMessage += divider;\n        break;\n\n      case 'StepStart': {\n        const stepIcon =\n          data.stepType === 'execute'\n            ? ''\n            : data.stepType === 'map'\n              ? ''\n              : data.stepType === 'merge'\n                ? ''\n                : data.stepType === 'parallel'\n                  ? ''\n                  : '';\n        formattedMessage = `${cl.greenBright(`${stepIcon} [ STEP ${data.stepIndex} START ]`)} ${cl.white(`(${data.stepType})`)}`;\n        if (data.nodeName) {\n          formattedMessage += ` ${cl.cyanBright(`Node: ${data.nodeName}`)}`;\n        }\n        formattedMessage += '\\n';\n        if (data.dependencies.length > 0) {\n          formattedMessage += `${cl.white('Dependencies:')} ${cl.gray(data.dependencies.join(', '))}\\n`;\n        }\n        if (data.produces.length > 0) {\n          formattedMessage += `${cl.white('Produces:')} ${cl.cyan(data.produces.join(', '))}\\n`;\n        }\n        formattedMessage += `${cl.white('State:')} ${cl.gray(formatState(data.state, true))}\\n`;\n        formattedMessage += smallDivider;\n        break;\n      }\n\n      case 'StepComplete': {\n        const completeIcon =\n          data.stepType === 'execute'\n            ? ''\n            : data.stepType === 'map'\n              ? ''\n              : data.stepType === 'merge'\n                ? ''\n                : data.stepType === 'parallel'\n                  ? ''\n                  : '';\n        formattedMessage = `${cl.greenBright(`${completeIcon} [ STEP ${data.stepIndex} COMPLETE ]`)} ${cl.white(`(${data.stepType})`)}`;\n        if (data.nodeName) {\n          formattedMessage += ` ${cl.cyanBright(`Node: ${data.nodeName}`)}`;\n        }\n        formattedMessage += ` ${cl.magenta(`in ${formatTime(data.executionTime)}`)}\\n`;\n        if (data.newFields && data.newFields.length > 0) {\n          formattedMessage += `${cl.white('New Fields:')} ${cl.green(data.newFields.join(', '))}\\n`;\n        }\n        if (data.result && data.nodeName) {\n          formattedMessage += `${cl.white('Result:')} ${cl.yellow(JSON.stringify(data.result, null, 2))}\\n`;\n        }\n        formattedMessage += smallDivider;\n        break;\n      }\n\n      case 'ParallelGroupStart':\n        formattedMessage = `${cl.blueBright(' [ PARALLEL GROUP START ]')} ${cl.white(`Level ${data.groupLevel}`)}\\n`;\n        formattedMessage += `${cl.white('Steps:')} ${cl.yellow(data.stepsCount.toString())} ${cl.gray(`(${data.stepTypes.join(', ')})`)}\\n`;\n        formattedMessage += smallDivider;\n        break;\n\n      case 'ParallelGroupComplete':\n        formattedMessage = `${cl.blueBright(' [ PARALLEL GROUP COMPLETE ]')} ${cl.white(`Level ${data.groupLevel}`)}`;\n        formattedMessage += ` ${cl.magenta(`in ${formatTime(data.executionTime)}`)}\\n`;\n        formattedMessage += `${cl.white('Steps Executed:')} ${cl.yellow(data.stepsCount.toString())}\\n`;\n        formattedMessage += smallDivider;\n        break;\n\n      case 'BranchEvaluation':\n        formattedMessage = `${cl.yellow(' [ BRANCH EVALUATION ]')}\\n`;\n        formattedMessage += `${cl.white('Branch Value:')} ${cl.cyan(JSON.stringify(data.branchValue))}\\n`;\n        formattedMessage += `${cl.white('Has Matching Branch:')} ${data.hasMatchingBranch ? cl.green('yes') : cl.red('no')}\\n`;\n        if (data.hasMatchingBranch) {\n          formattedMessage += `${cl.white('Branch Steps:')} ${cl.yellow(data.branchStepsCount.toString())}\\n`;\n        }\n        formattedMessage += smallDivider;\n        break;\n\n      case 'FlowComplete':\n        formattedMessage = `\\n${cl.greenBright(' [ AXFLOW COMPLETE ]')}\\n${divider}`;\n        formattedMessage += `${cl.white('Total Time:')} ${cl.magenta(formatTime(data.totalExecutionTime))}\\n`;\n        formattedMessage += `${cl.white('Steps Executed:')} ${cl.yellow(data.stepsExecuted.toString())}\\n`;\n        formattedMessage += `${cl.white('Output Fields:')} ${cl.green(data.outputFields.join(', '))}\\n`;\n        formattedMessage += `${cl.white('Final State:')} ${cl.gray(formatState(data.finalState, true))}\\n`;\n        formattedMessage += divider;\n        break;\n\n      case 'FlowError':\n        formattedMessage = `\\n${cl.redBright(' [ AXFLOW ERROR ]')}\\n${divider}`;\n        if (data.stepIndex !== undefined) {\n          formattedMessage += `${cl.white('Step:')} ${cl.yellow(data.stepIndex.toString())}`;\n          if (data.stepType)\n            formattedMessage += ` ${cl.gray(`(${data.stepType})`)}`;\n          if (data.nodeName)\n            formattedMessage += ` ${cl.cyan(`Node: ${data.nodeName}`)}`;\n          formattedMessage += '\\n';\n        }\n        formattedMessage += `${cl.white('Error:')} ${cl.red(data.error)}\\n`;\n        if (data.state) {\n          formattedMessage += `${cl.white('State:')} ${cl.gray(formatState(data.state, true))}\\n`;\n        }\n        formattedMessage += divider;\n        break;\n\n      default:\n        formattedMessage = cl.gray(JSON.stringify(data, null, 2));\n    }\n\n    output(formattedMessage);\n  };\n};\n\n/**\n * Factory function to create a text-only AxFlow logger (no colors)\n */\nexport const axCreateFlowTextLogger = (\n  output: (message: string) => void = defaultOutput\n): AxFlowLoggerFunction => {\n  const divider = '='.repeat(80);\n  const smallDivider = '-'.repeat(40);\n\n  return (data: AxFlowLogData) => {\n    let formattedMessage = '';\n\n    switch (data.name) {\n      case 'FlowStart':\n        formattedMessage = `\\n[ AXFLOW START ]\\n${divider}\\n`;\n        formattedMessage += `Input Fields: ${data.inputFields.join(', ')}\\n`;\n        formattedMessage += `Total Steps: ${data.totalSteps}\\n`;\n        formattedMessage += `Parallel Groups: ${data.parallelGroups}\\n`;\n        formattedMessage += `Max Parallelism: ${data.maxParallelism}\\n`;\n        formattedMessage += `Auto-Parallel: ${data.autoParallelEnabled ? 'enabled' : 'disabled'}\\n`;\n        formattedMessage += `${divider}\\n`;\n        break;\n\n      case 'StepStart':\n        formattedMessage = `[ STEP ${data.stepIndex} START ] (${data.stepType})`;\n        if (data.nodeName) {\n          formattedMessage += ` Node: ${data.nodeName}`;\n        }\n        formattedMessage += '\\n';\n        if (data.dependencies.length > 0) {\n          formattedMessage += `Dependencies: ${data.dependencies.join(', ')}\\n`;\n        }\n        if (data.produces.length > 0) {\n          formattedMessage += `Produces: ${data.produces.join(', ')}\\n`;\n        }\n        formattedMessage += `State: ${formatState(data.state, true)}\\n`;\n        formattedMessage += `${smallDivider}\\n`;\n        break;\n\n      case 'StepComplete':\n        formattedMessage = `[ STEP ${data.stepIndex} COMPLETE ] (${data.stepType})`;\n        if (data.nodeName) {\n          formattedMessage += ` Node: ${data.nodeName}`;\n        }\n        formattedMessage += ` in ${formatTime(data.executionTime)}\\n`;\n        if (data.newFields && data.newFields.length > 0) {\n          formattedMessage += `New Fields: ${data.newFields.join(', ')}\\n`;\n        }\n        if (data.result && data.nodeName) {\n          formattedMessage += `Result: ${JSON.stringify(data.result, null, 2)}\\n`;\n        }\n        formattedMessage += `${smallDivider}\\n`;\n        break;\n\n      case 'ParallelGroupStart':\n        formattedMessage = `[ PARALLEL GROUP START ] Level ${data.groupLevel}\\n`;\n        formattedMessage += `Steps: ${data.stepsCount} (${data.stepTypes.join(', ')})\\n`;\n        formattedMessage += `${smallDivider}\\n`;\n        break;\n\n      case 'ParallelGroupComplete':\n        formattedMessage = `[ PARALLEL GROUP COMPLETE ] Level ${data.groupLevel} in ${formatTime(data.executionTime)}\\n`;\n        formattedMessage += `Steps Executed: ${data.stepsCount}\\n`;\n        formattedMessage += `${smallDivider}\\n`;\n        break;\n\n      case 'BranchEvaluation':\n        formattedMessage = `[ BRANCH EVALUATION ]\\n`;\n        formattedMessage += `Branch Value: ${JSON.stringify(data.branchValue)}\\n`;\n        formattedMessage += `Has Matching Branch: ${data.hasMatchingBranch ? 'yes' : 'no'}\\n`;\n        if (data.hasMatchingBranch) {\n          formattedMessage += `Branch Steps: ${data.branchStepsCount}\\n`;\n        }\n        formattedMessage += `${smallDivider}\\n`;\n        break;\n\n      case 'FlowComplete':\n        formattedMessage = `\\n[ AXFLOW COMPLETE ]\\n${divider}\\n`;\n        formattedMessage += `Total Time: ${formatTime(data.totalExecutionTime)}\\n`;\n        formattedMessage += `Steps Executed: ${data.stepsExecuted}\\n`;\n        formattedMessage += `Output Fields: ${data.outputFields.join(', ')}\\n`;\n        formattedMessage += `Final State: ${formatState(data.finalState, true)}\\n`;\n        formattedMessage += `${divider}\\n`;\n        break;\n\n      case 'FlowError':\n        formattedMessage = `\\n[ AXFLOW ERROR ]\\n${divider}\\n`;\n        if (data.stepIndex !== undefined) {\n          formattedMessage += `Step: ${data.stepIndex}`;\n          if (data.stepType) formattedMessage += ` (${data.stepType})`;\n          if (data.nodeName) formattedMessage += ` Node: ${data.nodeName}`;\n          formattedMessage += '\\n';\n        }\n        formattedMessage += `Error: ${data.error}\\n`;\n        if (data.state) {\n          formattedMessage += `State: ${formatState(data.state, true)}\\n`;\n        }\n        formattedMessage += `${divider}\\n`;\n        break;\n\n      default:\n        formattedMessage = JSON.stringify(data, null, 2);\n    }\n\n    output(formattedMessage);\n  };\n};\n\n/**\n * Default AxFlow logger with colors\n */\nexport const axDefaultFlowLogger: AxFlowLoggerFunction =\n  axCreateFlowColorLogger();\n\n/**\n * Helper function to create a timing wrapper around the logger\n */\nexport const createTimingLogger = (logger: AxFlowLoggerFunction) => {\n  const timingData = new Map<string, number>();\n\n  return {\n    logger,\n    startTiming: (key: string) => {\n      timingData.set(key, Date.now());\n    },\n    endTiming: (key: string): number => {\n      const start = timingData.get(key);\n      if (!start) return 0;\n      const duration = Date.now() - start;\n      timingData.delete(key);\n      return duration;\n    },\n    getCurrentTime: () => Date.now(),\n  };\n};\n","import type { AxAIService } from '../ai/types.js';\nimport type { AxGen } from '../dsp/generate.js';\nimport type { AxProgram } from '../dsp/program.js';\nimport type {\n  AxFieldValue,\n  AxForwardable,\n  AxGenIn,\n  AxGenOut,\n  AxProgramForwardOptions,\n  AxTunable,\n  AxUsable,\n} from '../dsp/types.js';\nimport type {\n  AddNodeResult,\n  AxFlowDynamicContext,\n  AxFlowState,\n  AxFlowStepFunction,\n  AxFlowSubContext,\n  AxFlowTypedSubContext,\n  GetGenIn,\n  GetGenOut,\n} from './types.js';\n\n/**\n * Implementation of the sub-context for parallel execution\n */\nexport class AxFlowSubContextImpl implements AxFlowSubContext {\n  private readonly steps: AxFlowStepFunction[] = [];\n\n  constructor(\n    private readonly nodeGenerators: Map<\n      string,\n      AxForwardable<AxGenIn, AxGenOut, string> &\n        AxTunable<AxGenIn, AxGenOut> &\n        AxUsable\n    >\n  ) {}\n\n  execute<TAI extends Readonly<AxAIService>>(\n    nodeName: string,\n    mapping: (state: AxFlowState) => Record<string, AxFieldValue>,\n    dynamicContext?: AxFlowDynamicContext<TAI>\n  ): this {\n    const nodeProgram = this.nodeGenerators.get(nodeName);\n    if (!nodeProgram) {\n      throw new Error(`Node program for '${nodeName}' not found.`);\n    }\n\n    this.steps.push(async (state, context) => {\n      const ai = dynamicContext?.ai ?? context.mainAi;\n      const options = dynamicContext?.options ?? context.mainOptions;\n      const nodeInputs = mapping(state);\n\n      // Create trace label for the node execution\n      const traceLabel = options?.traceLabel\n        ? `Node:${nodeName} (${options.traceLabel})`\n        : `Node:${nodeName}`;\n\n      // Execute the node with updated trace label\n      // Handle both AxGen and AxProgram types\n      let result: any;\n      if (\n        'forward' in nodeProgram &&\n        typeof nodeProgram.forward === 'function'\n      ) {\n        result = await nodeProgram.forward(ai, nodeInputs, {\n          ...options,\n          traceLabel,\n        });\n      } else {\n        throw new Error(\n          `Node program for '${nodeName}' does not have a forward method`\n        );\n      }\n\n      return {\n        ...state,\n        [`${nodeName}Result`]: result,\n      };\n    });\n\n    return this;\n  }\n\n  map(transform: (state: AxFlowState) => AxFlowState): this {\n    this.steps.push((state) => transform(state));\n    return this;\n  }\n\n  async executeSteps(\n    initialState: AxFlowState,\n    context: Readonly<{\n      mainAi: AxAIService;\n      mainOptions?: AxProgramForwardOptions<string>;\n    }>\n  ): Promise<AxFlowState> {\n    let currentState = initialState;\n\n    for (const step of this.steps) {\n      currentState = await step(currentState, context);\n    }\n\n    return currentState;\n  }\n}\n\n/**\n * Typed implementation of the sub-context for parallel execution with full type safety\n */\n// This class is used by the type system but not directly instantiated in this file\n// NOTE: The `any` here is necessary for the same reason as in the interfaces above\nexport class AxFlowTypedSubContextImpl<\n  TNodes extends Record<string, AxGen<any, any>>,\n  TState extends AxFlowState,\n> implements AxFlowTypedSubContext<TNodes, TState>\n{\n  private readonly steps: AxFlowStepFunction[] = [];\n\n  constructor(\n    private readonly nodeGenerators: Map<\n      string,\n      AxGen<AxGenIn, AxGenOut> | AxProgram<AxGenIn, AxGenOut>\n    >\n  ) {}\n\n  execute<\n    TNodeName extends keyof TNodes & string,\n    TAI extends Readonly<AxAIService>,\n  >(\n    nodeName: TNodeName,\n    mapping: (state: TState) => GetGenIn<TNodes[TNodeName]>,\n    dynamicContext?: AxFlowDynamicContext<TAI>\n  ): AxFlowTypedSubContext<\n    TNodes,\n    AddNodeResult<TState, TNodeName, GetGenOut<TNodes[TNodeName]>>\n  > {\n    const nodeProgram = this.nodeGenerators.get(nodeName);\n    if (!nodeProgram) {\n      throw new Error(`Node program for '${nodeName}' not found.`);\n    }\n\n    this.steps.push(async (state, context) => {\n      const ai = dynamicContext?.ai ?? context.mainAi;\n      const options = dynamicContext?.options ?? context.mainOptions;\n      const nodeInputs = mapping(state as TState);\n\n      // Create trace label for the node execution\n      const traceLabel = options?.traceLabel\n        ? `Node:${nodeName} (${options.traceLabel})`\n        : `Node:${nodeName}`;\n\n      // Execute the node with updated trace label\n      // Handle both AxGen and AxProgram types\n      let result: any;\n      if (\n        'forward' in nodeProgram &&\n        typeof nodeProgram.forward === 'function'\n      ) {\n        result = await nodeProgram.forward(ai, nodeInputs, {\n          ...options,\n          traceLabel,\n        });\n      } else {\n        throw new Error(\n          `Node program for '${nodeName}' does not have a forward method`\n        );\n      }\n\n      return {\n        ...state,\n        [`${nodeName}Result`]: result,\n      };\n    });\n\n    // NOTE: This type assertion is necessary for the type-level programming pattern\n    return this as AxFlowTypedSubContext<\n      TNodes,\n      AddNodeResult<TState, TNodeName, GetGenOut<TNodes[TNodeName]>>\n    >;\n  }\n\n  map<TNewState extends AxFlowState>(\n    transform: (state: TState) => TNewState\n  ): AxFlowTypedSubContext<TNodes, TNewState> {\n    this.steps.push((state) => transform(state as TState));\n    // NOTE: This type assertion is necessary for the type-level programming pattern\n    return this as unknown as AxFlowTypedSubContext<TNodes, TNewState>;\n  }\n\n  async executeSteps(\n    initialState: TState,\n    context: Readonly<{\n      mainAi: AxAIService;\n      mainOptions?: AxProgramForwardOptions<string>;\n    }>\n  ): Promise<AxFlowState> {\n    let currentState: AxFlowState = initialState;\n\n    for (const step of this.steps) {\n      currentState = await step(currentState, context);\n    }\n\n    return currentState;\n  }\n}\n","import type { AxFunction } from '../ai/types.js';\n\nexport interface AxDockerContainer {\n  Id: string;\n  Names: string[];\n  Image: string;\n  ImageID: string;\n  Command: string;\n  Created: number;\n  State: {\n    Status: string;\n    Running: boolean;\n    Paused: boolean;\n    Restarting: boolean;\n    OOMKilled: boolean;\n    Dead: boolean;\n    Pid: number;\n    ExitCode: number;\n    Error: string;\n    StartedAt: Date;\n    FinishedAt: Date;\n  };\n  Status: string;\n  Ports: Array<{\n    IP: string;\n    PrivatePort: number;\n    PublicPort: number;\n    Type: string;\n  }>;\n  Labels: { [key: string]: string };\n  SizeRw: number;\n  SizeRootFs: number;\n  HostConfig: {\n    NetworkMode: string;\n  };\n  NetworkSettings: {\n    Networks: {\n      [key: string]: {\n        IPAddress: string;\n        IPPrefixLen: number;\n        Gateway: string;\n        MacAddress: string;\n      };\n    };\n  };\n  Mounts: Array<{\n    Type: string;\n    Source: string;\n    Destination: string;\n    Mode: string;\n    RW: boolean;\n    Propagation: string;\n  }>;\n}\n\nexport class AxDockerSession {\n  private readonly apiUrl: string;\n  private containerId: string | null = null;\n\n  constructor(apiUrl = 'http://localhost:2375') {\n    this.apiUrl = apiUrl;\n  }\n\n  async pullImage(imageName: string): Promise<void> {\n    const response = await this.fetchDockerAPI(\n      `/images/create?fromImage=${encodeURIComponent(imageName)}`,\n      {\n        method: 'POST',\n      }\n    );\n\n    if (!response.ok) {\n      throw new Error(`Failed to pull image: ${response.statusText}`);\n    }\n\n    // Wait for the pull to complete\n    await response.text();\n  }\n\n  async createContainer({\n    imageName,\n    volumes = [],\n    doNotPullImage,\n    tag,\n  }: Readonly<{\n    imageName: string;\n    volumes?: Array<{ hostPath: string; containerPath: string }>;\n    doNotPullImage?: boolean;\n    tag?: string;\n  }>) {\n    const binds = volumes.map((v) => `${v.hostPath}:${v.containerPath}`);\n\n    if (!doNotPullImage) {\n      await this.pullImage(imageName);\n    }\n\n    const containerConfig = {\n      Image: imageName,\n      Tty: true,\n      OpenStdin: false,\n      AttachStdin: false,\n      AttachStdout: false,\n      AttachStderr: false,\n      HostConfig: { Binds: binds },\n      Labels: {} as Record<string, string>,\n    };\n\n    if (tag) {\n      containerConfig.Labels['com.example.tag'] = tag;\n    }\n\n    const response = await this.fetchDockerAPI('/containers/create', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(containerConfig),\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to create container: ${response.statusText}`);\n    }\n\n    const data = (await response.json()) as { Id: string };\n    this.containerId = data.Id;\n\n    return data;\n  }\n\n  async findOrCreateContainer({\n    imageName,\n    volumes = [],\n    doNotPullImage,\n    tag,\n  }: Readonly<{\n    imageName: string;\n    volumes?: Array<{ hostPath: string; containerPath: string }>;\n    doNotPullImage?: boolean;\n    tag: string;\n  }>): Promise<{ Id: string; isNew: boolean }> {\n    // First, try to find existing containers with the given tag\n    const existingContainers = await this.listContainers(true);\n    const matchingContainers = existingContainers.filter(\n      (container) =>\n        container.Labels && container.Labels['com.example.tag'] === tag\n    );\n\n    if (matchingContainers && matchingContainers.length > 0) {\n      // Randomly select a container from the matching ones\n      const randomIndex = Math.floor(Math.random() * matchingContainers.length);\n      const selectedContainer = matchingContainers[randomIndex];\n\n      if (selectedContainer) {\n        // Connect to the selected container\n        await this.connectToContainer(selectedContainer.Id);\n        return { Id: selectedContainer.Id, isNew: false };\n      }\n    }\n\n    // If no container with the tag exists, create a new one\n    const newContainer = await this.createContainer({\n      imageName,\n      volumes,\n      doNotPullImage,\n      tag,\n    });\n\n    return { Id: newContainer.Id, isNew: true };\n  }\n\n  async startContainer(): Promise<void> {\n    if (!this.containerId) {\n      throw new Error('No container created or connected');\n    }\n\n    const response = await this.fetchDockerAPI(\n      `/containers/${this.containerId}/start`,\n      {\n        method: 'POST',\n      }\n    );\n\n    if (!response.ok) {\n      throw new Error(`Failed to start container: ${response.statusText}`);\n    }\n  }\n\n  async connectToContainer(containerId: string): Promise<void> {\n    const response = await this.fetchDockerAPI(\n      `/containers/${containerId}/json`\n    );\n\n    if (!response.ok) {\n      throw new Error(`Failed to connect to container: ${response.statusText}`);\n    }\n\n    this.containerId = containerId;\n  }\n\n  async stopContainers({\n    tag,\n    remove,\n    timeout = 10,\n  }: Readonly<{ tag?: string; remove?: boolean; timeout?: number }>): Promise<\n    Array<{ Id: string; Action: 'stopped' | 'removed' }>\n  > {\n    const results: Array<{ Id: string; Action: 'stopped' | 'removed' }> = [];\n\n    // List all containers\n    const containers = await this.listContainers(true);\n\n    // Filter containers by tag if provided\n    const targetContainers = tag\n      ? containers.filter(\n          (container) => container.Labels['com.example.tag'] === tag\n        )\n      : containers;\n\n    for (const container of targetContainers) {\n      // Stop the container if it's running\n      if (container.State.Status === 'running') {\n        const stopResponse = await this.fetchDockerAPI(\n          `/containers/${container.Id}/stop?t=${timeout}`,\n          { method: 'POST' }\n        );\n\n        if (!stopResponse.ok) {\n          console.warn(\n            `Failed to stop container ${container.Id}: ${stopResponse.statusText}`\n          );\n          continue;\n        }\n\n        results.push({ Id: container.Id, Action: 'stopped' });\n      }\n\n      // Remove the container if the remove flag is set\n      if (remove) {\n        const removeResponse = await this.fetchDockerAPI(\n          `/containers/${container.Id}`,\n          { method: 'DELETE' }\n        );\n\n        if (!removeResponse.ok) {\n          console.warn(\n            `Failed to remove container ${container.Id}: ${removeResponse.statusText}`\n          );\n          continue;\n        }\n\n        results.push({ Id: container.Id, Action: 'removed' });\n      }\n    }\n\n    return results;\n  }\n\n  async listContainers(all = false): Promise<AxDockerContainer[]> {\n    const response = await this.fetchDockerAPI(`/containers/json?all=${all}`, {\n      method: 'GET',\n    });\n    return response.json() as Promise<AxDockerContainer[]>;\n  }\n\n  async getContainerLogs(): Promise<string> {\n    if (!this.containerId) {\n      throw new Error('No container created or connected');\n    }\n    const response = await this.fetchDockerAPI(\n      `/containers/${this.containerId}/logs?stdout=true&stderr=true`,\n      { method: 'GET' }\n    );\n    return response.text();\n  }\n\n  async executeCommand(command: string) {\n    if (!this.containerId) {\n      throw new Error('No container created or connected');\n    }\n\n    // Check container state\n    const containerInfo = await this.getContainerInfo(this.containerId);\n\n    if (containerInfo.State.Status !== 'running') {\n      await this.startContainer();\n\n      // Wait for the container to be in the \"running\" state\n      await this.waitForContainerToBeRunning(this.containerId);\n    }\n\n    // Create exec instance\n    const createResponse = await this.fetchDockerAPI(\n      `/containers/${this.containerId}/exec`,\n      {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          Cmd: ['sh', '-c', command],\n          AttachStdout: true,\n          AttachStderr: true,\n        }),\n      }\n    );\n\n    if (!createResponse.ok) {\n      throw new Error(\n        `Failed to create exec instance: ${createResponse.statusText}`\n      );\n    }\n\n    const execData = (await createResponse.json()) as { Id: string };\n\n    // Start exec instance\n    const startResponse = await this.fetchDockerAPI(\n      `/exec/${execData.Id}/start`,\n      {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          Detach: false,\n          Tty: false,\n        }),\n      }\n    );\n\n    if (!startResponse.ok) {\n      throw new Error(\n        `Failed to start exec instance: ${startResponse.statusText}`\n      );\n    }\n\n    // Return the output\n    return await startResponse.text();\n  }\n\n  // Add these new methods to the class:\n\n  private async getContainerInfo(\n    containerId: string\n  ): Promise<AxDockerContainer> {\n    const response = await this.fetchDockerAPI(\n      `/containers/${containerId}/json`\n    );\n    if (!response.ok) {\n      throw new Error(`Failed to get container info: ${response.statusText}`);\n    }\n    return response.json() as Promise<AxDockerContainer>;\n  }\n\n  private async waitForContainerToBeRunning(\n    containerId: string,\n    timeout = 30000\n  ): Promise<void> {\n    const startTime = Date.now();\n    while (Date.now() - startTime < timeout) {\n      const containerInfo = await this.getContainerInfo(containerId);\n      if (containerInfo.State.Status === 'running') {\n        return;\n      }\n      await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait for 1 second before checking again\n    }\n    throw new Error('Timeout waiting for container to start');\n  }\n\n  private async fetchDockerAPI(\n    endpoint: string,\n    options?: Readonly<RequestInit>\n  ): Promise<Response> {\n    const url = new URL(endpoint, this.apiUrl).toString();\n    return await fetch(url, options);\n  }\n\n  public toFunction(): AxFunction {\n    return {\n      name: 'commandExecution',\n      description:\n        'Use this function to execute shell commands, scripts, and programs. This function enables interaction with the file system, running system utilities, and performing tasks that require a shell interface.',\n      parameters: {\n        type: 'object',\n        properties: {\n          command: {\n            type: 'string',\n            description:\n              'Shell command to execute. eg. `ls -l` or `echo \"Hello, World!\"`.',\n          },\n        },\n        required: ['command'],\n      },\n\n      func: async ({ command }: Readonly<{ command: string }>) =>\n        await this.executeCommand(command),\n    };\n  }\n}\n","import type {\n  AxAIService,\n  AxAIServiceOptions,\n  AxFunction,\n} from '../ai/types.js';\n\nexport class AxEmbeddingAdapter {\n  private aiService: AxAIService;\n  private info: {\n    name: string;\n    description: string;\n    argumentDescription: string;\n  };\n  private func: (\n    args: readonly number[],\n    extra?: Readonly<AxAIServiceOptions>\n  ) => Promise<unknown>;\n\n  constructor({\n    ai,\n    info,\n    func,\n  }: Readonly<{\n    ai: AxAIService;\n    info: Readonly<{\n      name: string;\n      description: string;\n      argumentDescription: string;\n    }>;\n    func: (\n      args: readonly number[],\n      extra?: Readonly<AxAIServiceOptions>\n    ) => Promise<unknown>;\n  }>) {\n    this.aiService = ai;\n    this.info = info;\n    this.func = func;\n  }\n\n  private async embedAdapter(\n    text: string,\n    extra?: Readonly<AxAIServiceOptions>\n  ): Promise<unknown> {\n    const embedRes = await this.aiService.embed(\n      { texts: [text] },\n      {\n        sessionId: extra?.sessionId,\n        abortSignal: extra?.abortSignal,\n      }\n    );\n    const embeds = embedRes.embeddings.at(0);\n\n    if (!embeds) {\n      throw new Error('Failed to embed text');\n    }\n\n    return this.func.length === 2\n      ? this.func(embeds, extra)\n      : this.func(embeds);\n  }\n\n  public toFunction(): AxFunction {\n    return {\n      name: this.info.name,\n      description: this.info.description,\n      parameters: {\n        type: 'object',\n        properties: {\n          text: {\n            type: 'string',\n            description: this.info.argumentDescription,\n          },\n        },\n        required: ['text'],\n      },\n      func: ({ text }: Readonly<{ text: string }>, options) =>\n        this.embedAdapter(text, options),\n    };\n  }\n}\n","import type {\n  AxFunction,\n  AxLoggerData,\n  AxLoggerFunction,\n} from '../ai/types.js';\nimport { randomUUID } from '../util/crypto.js';\n\nimport type { AxMCPTransport } from './transport.js';\nimport type {\n  AxMCPInitializeParams,\n  AxMCPInitializeResult,\n  AxMCPJSONRPCNotification,\n  AxMCPJSONRPCRequest,\n  AxMCPToolsListResult,\n} from './types.js';\n\n/**\n * Configuration for overriding function properties\n */\ninterface FunctionOverride {\n  /** Original function name to override */\n  name: string;\n  /** Updates to apply to the function */\n  updates: {\n    /** Alternative name for the function */\n    name?: string;\n    /** Alternative description for the function */\n    description?: string;\n  };\n}\n\n/**\n * Options for the MCP client\n */\ninterface AxMCPClientOptions {\n  /** Enable debug logging */\n  debug?: boolean;\n  /** Logger function for debug output */\n  logger?: AxLoggerFunction;\n  /**\n   * List of function overrides\n   * Use this to provide alternative names and descriptions for functions\n   * while preserving their original functionality\n   *\n   * Example:\n   * ```\n   * functionOverrides: [\n   *   {\n   *     name: \"original-function-name\",\n   *     updates: {\n   *       name: \"new-function-name\",\n   *       description: \"New function description\"\n   *     }\n   *   }\n   * ]\n   * ```\n   */\n  functionOverrides?: FunctionOverride[];\n}\n\nexport class AxMCPClient {\n  private functions: AxFunction[] = [];\n  private activeRequests: Map<string, { reject: (reason: unknown) => void }> =\n    new Map();\n  private capabilities: {\n    tools?: boolean;\n    resources?: boolean;\n    prompts?: boolean;\n  } = {};\n  private logger: AxLoggerFunction;\n\n  constructor(\n    private readonly transport: AxMCPTransport,\n    private readonly options: Readonly<AxMCPClientOptions> = {}\n  ) {\n    this.logger =\n      options.logger ??\n      ((message: string | AxLoggerData) => {\n        if (typeof message === 'string') {\n          console.log(message);\n        } else {\n          console.log(JSON.stringify(message, null, 2));\n        }\n      });\n  }\n\n  async init(): Promise<void> {\n    if ('connect' in this.transport) {\n      await this.transport.connect?.();\n    }\n\n    const { result: res } = await this.sendRequest<\n      AxMCPInitializeParams,\n      AxMCPInitializeResult\n    >('initialize', {\n      protocolVersion: '2024-11-05',\n      capabilities: {\n        roots: { listChanged: true },\n        sampling: {},\n      },\n      clientInfo: {\n        name: 'AxMCPClient',\n        version: '1.0.0',\n      },\n    });\n\n    const expectedProtocolVersion = '2024-11-05';\n    if (res.protocolVersion !== expectedProtocolVersion) {\n      throw new Error(\n        `Protocol version mismatch. Expected ${expectedProtocolVersion} but got ${res.protocolVersion}`\n      );\n    }\n\n    if (res.capabilities.tools) {\n      this.capabilities.tools = true;\n    }\n\n    if (res.capabilities.resources) {\n      this.capabilities.resources = true;\n    }\n\n    if (res.capabilities.prompts) {\n      this.capabilities.prompts = true;\n    }\n\n    await this.sendNotification('notifications/initialized');\n\n    await this.discoverFunctions();\n  }\n\n  private async discoverFunctions(): Promise<void> {\n    if (!this.capabilities.tools) {\n      throw new Error('Tools are not supported');\n    }\n\n    const { result: res } = await this.sendRequest<\n      undefined,\n      AxMCPToolsListResult\n    >('tools/list');\n\n    this.functions = res.tools.map((fn): AxFunction => {\n      // Check if there's an override for this function\n      const override = this.options.functionOverrides?.find(\n        (o) => o.name === fn.name\n      );\n\n      const parameters = fn.inputSchema.properties\n        ? {\n            properties: fn.inputSchema.properties,\n            required: fn.inputSchema.required ?? [],\n            type: fn.inputSchema.type,\n          }\n        : undefined;\n\n      return {\n        name: override?.updates.name ?? fn.name,\n        description: override?.updates.description ?? fn.description,\n        parameters,\n        func: async (args) => {\n          // Always use original name when calling the function\n          const { result } = await this.sendRequest<{\n            name: string;\n            // eslint-disable-next-line functional/functional-parameters\n            arguments: unknown;\n          }>('tools/call', { name: fn.name, arguments: args });\n          return result;\n        },\n      };\n    });\n  }\n\n  async ping(timeout = 3000): Promise<void> {\n    const pingPromise = this.sendRequest('ping');\n    const timeoutPromise = new Promise((_, reject) =>\n      setTimeout(\n        () => reject(new Error('Ping response timeout exceeded')),\n        timeout\n      )\n    );\n    const response = (await Promise.race([pingPromise, timeoutPromise])) as {\n      result: unknown;\n    };\n    const { result } = response;\n    if (\n      typeof result !== 'object' ||\n      result === null ||\n      Object.keys(result).length !== 0\n    ) {\n      throw new Error(`Unexpected ping response: ${JSON.stringify(result)}`);\n    }\n  }\n\n  toFunction(): AxFunction[] {\n    return this.functions;\n  }\n\n  cancelRequest(id: string): void {\n    if (this.activeRequests.has(id)) {\n      this.sendNotification('notifications/cancelled', {\n        requestId: id,\n        reason: 'Client cancelled request',\n      });\n      const entry = this.activeRequests.get(id);\n      if (entry) {\n        entry.reject(new Error(`Request ${id} cancelled`));\n      }\n      this.activeRequests.delete(id);\n    }\n  }\n\n  private async sendRequest<T = unknown, R = unknown>(\n    method: string,\n    params: T = {} as T\n  ): Promise<{ id: string; result: R }> {\n    const requestId = randomUUID();\n    const request: AxMCPJSONRPCRequest<T> = {\n      jsonrpc: '2.0',\n      id: requestId,\n      method,\n      params,\n    };\n\n    const responsePromise = new Promise<{ result: R }>((resolve, reject) => {\n      this.activeRequests.set(requestId, { reject });\n      this.transport\n        .send(request)\n        .then((res: unknown) => {\n          this.activeRequests.delete(requestId);\n          if (res !== null && typeof res === 'object' && 'error' in res) {\n            const errorObj = res as {\n              error: { code: number; message: string };\n            };\n            reject(\n              new Error(\n                `RPC Error ${errorObj.error.code}: ${errorObj.error.message}`\n              )\n            );\n          } else if (\n            res !== null &&\n            typeof res === 'object' &&\n            'result' in res\n          ) {\n            resolve({ result: (res as { result: R }).result });\n          } else {\n            reject(new Error('Invalid response no result or error'));\n          }\n        })\n        .catch((err: unknown) => {\n          this.activeRequests.delete(requestId);\n          reject(err);\n        });\n    });\n\n    const { result } = await responsePromise;\n    return { id: requestId, result };\n  }\n\n  private async sendNotification(\n    method: string,\n    params: Record<string, unknown> = {}\n  ): Promise<void> {\n    const notification: AxMCPJSONRPCNotification = {\n      jsonrpc: '2.0',\n      method,\n      params,\n    };\n\n    const { debug } = this.options;\n    if (debug) {\n      const loggerData: AxLoggerData = {\n        name: 'Notification',\n        id: 'mcp_notification',\n        value: `Sending notification: ${JSON.stringify(notification, null, 2)}`,\n      };\n      this.logger(loggerData);\n    }\n\n    await this.transport.sendNotification(notification);\n  }\n}\n","import { getCrypto, randomUUID } from '../../util/crypto.js';\n\n/**\n * Converts a byte array to a base64url-encoded string.\n * Base64url encoding is like base64 but uses URL-safe characters and removes padding.\n * @param bytes - The byte array to encode\n * @returns The base64url-encoded string\n */\nexport function base64url(bytes: Uint8Array): string {\n  if (typeof Buffer !== 'undefined') {\n    return Buffer.from(bytes)\n      .toString('base64')\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n      .replace(/=+$/g, '');\n  }\n  let binary = '';\n  for (let i = 0; i < bytes.length; i++)\n    binary += String.fromCharCode(bytes[i]!);\n  // @ts-ignore - btoa may or may not exist depending on environment\n  const b64: string = typeof btoa === 'function' ? btoa(binary) : '';\n  return b64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/g, '');\n}\n\n/**\n * Computes the SHA-256 hash of a string and returns it as a byte array.\n * @param input - The string to hash\n * @returns A promise that resolves to the SHA-256 hash as a Uint8Array\n */\nexport async function sha256Bytes(input: string): Promise<Uint8Array> {\n  const enc = new TextEncoder();\n  const data = enc.encode(input);\n  const digest = await getCrypto().subtle.digest('SHA-256', data);\n  return new Uint8Array(digest);\n}\n\n/**\n * Generates a new PKCE code verifier string.\n * Creates a cryptographically secure random string by combining a UUID with additional randomness,\n * then hashing and encoding the result.\n * @returns A promise that resolves to a base64url-encoded code verifier\n */\nexport async function newCodeVerifier(): Promise<string> {\n  // random seed via UUID + random; then SHA-256 and base64url\n  return base64url(\n    await sha256Bytes(randomUUID() + Math.random().toString(36))\n  );\n}\n\n/**\n * Generates a PKCE code challenge from a code verifier.\n * The challenge is the SHA-256 hash of the verifier, base64url-encoded.\n * @param verifier - The code verifier string\n * @returns A promise that resolves to the corresponding code challenge\n */\nexport async function newCodeChallenge(verifier: string): Promise<string> {\n  return base64url(await sha256Bytes(verifier));\n}\n","export async function fetchJSON<T>(\n  url: string,\n  headers?: Record<string, string>\n): Promise<T> {\n  const res = await fetch(url, { headers });\n  if (!res.ok)\n    throw new Error(`HTTP ${res.status} fetching ${url}: ${res.statusText}`);\n  return (await res.json()) as T;\n}\n\nexport function toQuery(params: Record<string, string | undefined>): string {\n  const usp = new URLSearchParams();\n  for (const [k, v] of Object.entries(params)) {\n    if (v !== undefined) usp.set(k, v);\n  }\n  return usp.toString();\n}\n\nexport function stripTrailingSlash(url: string): string {\n  return url.endsWith('/') ? url.slice(0, -1) : url;\n}\n","import { fetchJSON, stripTrailingSlash } from '../util/http.js';\n\nexport function parseWWWAuthenticateForResourceMetadata(\n  www: string | null\n): string | null {\n  if (!www) return null;\n  const match =\n    www.match(/resource_metadata\\s*=\\s*\"([^\"]+)\"/i) ||\n    www.match(/resource_metadata\\s*=\\s*([^,\\s]+)/i);\n  return match ? match[1] : null;\n}\n\nexport async function discoverResourceAndAS(\n  requestedUrl: string,\n  wwwAuthenticate: string | null\n): Promise<{ resource: string; issuers: string[] }> {\n  const headerUrl = parseWWWAuthenticateForResourceMetadata(wwwAuthenticate);\n\n  if (headerUrl) {\n    const rsMeta = await fetchJSON<any>(headerUrl);\n    const expectedResource = stripTrailingSlash(\n      new URL(requestedUrl).toString().split('?')[0]!\n    );\n    const rsResource = stripTrailingSlash(rsMeta.resource ?? '');\n    if (!rsResource || rsResource !== expectedResource) {\n      throw new Error(\n        `Protected resource metadata 'resource' mismatch. Expected ${expectedResource} but got ${rsResource}`\n      );\n    }\n    const issuers: string[] = Array.isArray(rsMeta.authorization_servers)\n      ? rsMeta.authorization_servers\n      : [];\n    if (issuers.length === 0) {\n      throw new Error(\n        'No authorization_servers advertised by protected resource'\n      );\n    }\n    return { resource: expectedResource, issuers };\n  }\n\n  // No header param; attempt well-known derivations with and without path component\n  const u = new URL(requestedUrl);\n  const trimmedPath = u.pathname.replace(/\\/+$/, '');\n  const candidates: Array<{ url: string; expected: string }> = [];\n  if (trimmedPath && trimmedPath !== '/') {\n    candidates.push({\n      url: `${u.origin}/.well-known/oauth-protected-resource${trimmedPath}`,\n      expected: `${u.origin}${trimmedPath}`,\n    });\n  }\n  candidates.push({\n    url: `${u.origin}/.well-known/oauth-protected-resource`,\n    expected: `${u.origin}`,\n  });\n\n  let lastErr: unknown;\n  for (const c of candidates) {\n    try {\n      const meta = await fetchJSON<any>(c.url);\n      const rsResource = stripTrailingSlash(meta.resource ?? '');\n      const exp = stripTrailingSlash(c.expected);\n      if (!rsResource || rsResource !== exp) {\n        throw new Error(\n          `Protected resource metadata 'resource' mismatch. Expected ${exp} but got ${rsResource}`\n        );\n      }\n      const issuers: string[] = Array.isArray(meta.authorization_servers)\n        ? meta.authorization_servers\n        : [];\n      if (issuers.length === 0) {\n        throw new Error(\n          'No authorization_servers advertised by protected resource'\n        );\n      }\n      return { resource: exp, issuers };\n    } catch (err) {\n      lastErr = err;\n    }\n  }\n  throw new Error(\n    `Failed to resolve protected resource metadata via well-known endpoints. Last error: ${String(lastErr)}`\n  );\n}\n\nexport async function discoverASMetadata(issuer: string): Promise<any> {\n  const u = new URL(issuer);\n  const path = u.pathname.replace(/^\\/+/, '');\n  const endpoints: string[] = [];\n  if (path) {\n    endpoints.push(\n      `${u.origin}/.well-known/oauth-authorization-server/${path}`\n    );\n    endpoints.push(`${u.origin}/.well-known/openid-configuration/${path}`);\n    endpoints.push(\n      `${u.origin}/${path.replace(/\\/+$/, '')}/.well-known/openid-configuration`\n    );\n  } else {\n    endpoints.push(`${u.origin}/.well-known/oauth-authorization-server`);\n    endpoints.push(`${u.origin}/.well-known/openid-configuration`);\n  }\n\n  let lastErr: unknown;\n  for (const e of endpoints) {\n    try {\n      const meta = await fetchJSON<any>(e);\n      if (!meta.authorization_endpoint || !meta.token_endpoint) {\n        throw new Error('AS metadata missing endpoints');\n      }\n      const methods: string[] | undefined =\n        meta.code_challenge_methods_supported;\n      if (!methods || !methods.includes('S256')) {\n        throw new Error(\n          'Authorization server does not advertise PKCE S256 support'\n        );\n      }\n      return meta;\n    } catch (err) {\n      lastErr = err;\n    }\n  }\n  throw new Error(\n    `Failed to discover AS metadata for ${issuer}: ${String(lastErr)}`\n  );\n}\n","import { newCodeChallenge, newCodeVerifier } from './pkce.js';\nimport { toQuery } from '../util/http.js';\nimport { discoverASMetadata, discoverResourceAndAS } from './discovery.js';\nimport type { AxMCPOAuthOptions, TokenSet } from './types.js';\n\nexport class OAuthHelper {\n  private tokenCache = new Map<string, TokenSet>(); // key: resource::issuer\n  private asMetaCache = new Map<string, any>();\n\n  constructor(private readonly oauth?: AxMCPOAuthOptions) {}\n\n  private key(resource: string, issuer: string) {\n    return `${resource}::${issuer}`;\n  }\n\n  private async getStoredToken(\n    resource: string,\n    issuer: string\n  ): Promise<TokenSet | null> {\n    const k = this.key(resource, issuer);\n    if (this.tokenCache.has(k)) return this.tokenCache.get(k)!;\n    const t = await this.oauth?.tokenStore?.getToken?.(k);\n    if (t) this.tokenCache.set(k, t);\n    return t ?? null;\n  }\n\n  private async setStoredToken(\n    resource: string,\n    issuer: string,\n    token: TokenSet\n  ): Promise<void> {\n    const k = this.key(resource, issuer);\n    this.tokenCache.set(k, token);\n    await this.oauth?.tokenStore?.setToken?.(k, token);\n  }\n\n  private async clearStoredToken(\n    resource: string,\n    issuer: string\n  ): Promise<void> {\n    const k = this.key(resource, issuer);\n    this.tokenCache.delete(k);\n    await this.oauth?.tokenStore?.clearToken?.(k);\n  }\n\n  private isExpired(ts?: number): boolean {\n    if (!ts) return false;\n    return Date.now() > ts - 60_000;\n  }\n\n  private async getASMeta(issuer: string): Promise<any> {\n    if (this.asMetaCache.has(issuer)) return this.asMetaCache.get(issuer);\n    const meta = await discoverASMetadata(issuer);\n    this.asMetaCache.set(issuer, meta);\n    return meta;\n  }\n\n  async ensureAccessToken(options: {\n    requestedUrl: string;\n    wwwAuthenticate: string | null;\n    currentToken?: TokenSet | null;\n  }): Promise<{\n    token: TokenSet;\n    issuer: string;\n    asMeta: any;\n    resource: string;\n  } | null> {\n    if (!this.oauth) return null;\n\n    const { resource, issuers } = await discoverResourceAndAS(\n      options.requestedUrl,\n      options.wwwAuthenticate\n    );\n    const issuer = this.oauth.selectAuthorizationServer\n      ? await this.oauth.selectAuthorizationServer(issuers, {})\n      : issuers[0]!;\n    const asMeta = await this.getASMeta(issuer);\n\n    const existing =\n      options.currentToken ?? (await this.getStoredToken(resource, issuer));\n    if (existing?.accessToken && !this.isExpired(existing.expiresAt)) {\n      return { token: existing, issuer, asMeta, resource };\n    }\n\n    if (existing?.refreshToken) {\n      try {\n        const refreshed = await this.refreshToken(\n          existing.refreshToken,\n          resource,\n          issuer,\n          asMeta\n        );\n        await this.setStoredToken(resource, issuer, refreshed);\n        return { token: refreshed, issuer, asMeta, resource };\n      } catch {\n        await this.clearStoredToken(resource, issuer);\n      }\n    }\n\n    const redirectUri =\n      this.oauth.redirectUri ?? 'http://localhost:8787/callback';\n    const client: { client_id: string; client_secret?: string } = this.oauth\n      .clientId\n      ? {\n          client_id: this.oauth.clientId,\n          client_secret: this.oauth.clientSecret,\n        }\n      : await this.dynamicClientRegistration(asMeta, redirectUri);\n\n    const codeVerifier = await newCodeVerifier();\n    const codeChallenge = await newCodeChallenge(codeVerifier);\n    const state = await newCodeVerifier();\n\n    const scopes = this.oauth.scopes?.join(' ');\n    const authUrl = `${asMeta.authorization_endpoint}?${toQuery({\n      response_type: 'code',\n      client_id: client.client_id,\n      redirect_uri: redirectUri,\n      scope: scopes,\n      state,\n      code_challenge: codeChallenge,\n      code_challenge_method: 'S256',\n      resource,\n    })}`;\n\n    if (!this.oauth.onAuthCode) {\n      throw new Error(\n        `Authorization required. Provide oauth.onAuthCode to complete the flow. Navigate to: ${authUrl}`\n      );\n    }\n\n    const { code, redirectUri: maybeRedirect } =\n      await this.oauth.onAuthCode(authUrl);\n    const usedRedirectUri = maybeRedirect ?? redirectUri;\n\n    const token = await this.exchangeCodeForToken({\n      asMeta,\n      code,\n      codeVerifier,\n      client,\n      redirectUri: usedRedirectUri,\n      resource,\n    });\n\n    await this.setStoredToken(resource, issuer, token);\n    return { token, issuer, asMeta, resource };\n  }\n\n  private async dynamicClientRegistration(\n    asMeta: any,\n    redirectUri: string\n  ): Promise<{ client_id: string; client_secret?: string }> {\n    if (!asMeta.registration_endpoint) {\n      throw new Error(\n        'Authorization server does not support dynamic client registration and no clientId was provided.'\n      );\n    }\n    const appType = redirectUri.startsWith('http://localhost')\n      ? 'native'\n      : 'web';\n    const body = {\n      application_type: appType,\n      client_name: 'Ax MCP Client',\n      redirect_uris: [redirectUri],\n      grant_types: ['authorization_code', 'refresh_token'],\n      response_types: ['code'],\n      token_endpoint_auth_method: 'none',\n    };\n    const res = await fetch(asMeta.registration_endpoint, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(body),\n    });\n    if (!res.ok)\n      throw new Error(\n        `Dynamic client registration failed: ${res.status} ${res.statusText}`\n      );\n    const json = (await res.json()) as {\n      client_id: string;\n      client_secret?: string;\n    };\n    if (!json.client_id)\n      throw new Error('Dynamic client registration did not return client_id');\n    return json;\n  }\n\n  private async exchangeCodeForToken(args: {\n    asMeta: any;\n    code: string;\n    codeVerifier: string;\n    client: { client_id: string; client_secret?: string };\n    redirectUri: string;\n    resource: string;\n  }): Promise<TokenSet> {\n    const body = new URLSearchParams();\n    body.set('grant_type', 'authorization_code');\n    body.set('code', args.code);\n    body.set('redirect_uri', args.redirectUri);\n    body.set('client_id', args.client.client_id);\n    body.set('code_verifier', args.codeVerifier);\n    body.set('resource', args.resource);\n    if (args.client.client_secret)\n      body.set('client_secret', args.client.client_secret);\n\n    const res = await fetch(args.asMeta.token_endpoint, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n      body: body.toString(),\n    });\n    if (!res.ok)\n      throw new Error(`Token exchange failed: ${res.status} ${res.statusText}`);\n    const json = (await res.json()) as {\n      access_token: string;\n      refresh_token?: string;\n      expires_in?: number;\n    };\n    if (!json.access_token)\n      throw new Error('No access_token in token response');\n    const expiresAt = json.expires_in\n      ? Date.now() + json.expires_in * 1000\n      : undefined;\n    return {\n      accessToken: json.access_token,\n      refreshToken: json.refresh_token,\n      expiresAt,\n    };\n  }\n\n  private async refreshToken(\n    refreshToken: string,\n    resource: string,\n    _issuer: string,\n    asMeta: any\n  ): Promise<TokenSet> {\n    const body = new URLSearchParams();\n    body.set('grant_type', 'refresh_token');\n    body.set('refresh_token', refreshToken);\n    body.set('resource', resource);\n    if (this.oauth?.clientId) body.set('client_id', this.oauth.clientId);\n    if (this.oauth?.clientSecret)\n      body.set('client_secret', this.oauth.clientSecret);\n\n    const res = await fetch(asMeta.token_endpoint, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n      body: body.toString(),\n    });\n    if (!res.ok)\n      throw new Error(`Token refresh failed: ${res.status} ${res.statusText}`);\n    const json = (await res.json()) as {\n      access_token: string;\n      refresh_token?: string;\n      expires_in?: number;\n    };\n    if (!json.access_token)\n      throw new Error('No access_token in refresh response');\n    const expiresAt = json.expires_in\n      ? Date.now() + json.expires_in * 1000\n      : undefined;\n    return {\n      accessToken: json.access_token,\n      refreshToken: json.refresh_token ?? refreshToken,\n      expiresAt,\n    };\n  }\n}\n","import type { AxMCPTransport } from '../transport.js';\nimport type {\n  AxMCPJSONRPCNotification,\n  AxMCPJSONRPCRequest,\n  AxMCPJSONRPCResponse,\n} from '../types.js';\nimport type { AxMCPStreamableHTTPTransportOptions } from './options.js';\nimport { OAuthHelper } from '../oauth/oauthHelper.js';\n\nexport class AxMCPStreambleHTTPTransport implements AxMCPTransport {\n  private mcpEndpoint: string;\n  private sessionId?: string;\n  private eventSource?: EventSource;\n  private pendingRequests = new Map<\n    string | number,\n    {\n      resolve: (value: AxMCPJSONRPCResponse<unknown>) => void;\n      reject: (reason: unknown) => void;\n    }\n  >();\n  private messageHandler?: (\n    message: AxMCPJSONRPCRequest<unknown> | AxMCPJSONRPCNotification\n  ) => void;\n  private customHeaders: Record<string, string>;\n  private oauthHelper: OAuthHelper;\n  private currentToken?: AxMCPJSONRPCResponse<unknown> | null;\n  private currentIssuer?: string;\n\n  constructor(\n    mcpEndpoint: string,\n    options?: AxMCPStreamableHTTPTransportOptions\n  ) {\n    this.mcpEndpoint = mcpEndpoint;\n    this.customHeaders = { ...(options?.headers ?? {}) };\n    if (options?.authorization)\n      this.customHeaders.Authorization = options.authorization;\n    this.oauthHelper = new OAuthHelper(options?.oauth);\n  }\n\n  setHeaders(headers: Record<string, string>): void {\n    this.customHeaders = { ...headers };\n  }\n\n  setAuthorization(authorization: string): void {\n    this.customHeaders.Authorization = authorization;\n  }\n\n  getHeaders(): Record<string, string> {\n    return { ...this.customHeaders };\n  }\n\n  private buildHeaders(\n    baseHeaders: Record<string, string>\n  ): Record<string, string> {\n    const headers = { ...this.customHeaders, ...baseHeaders };\n    if (this.sessionId) headers['Mcp-Session-Id'] = this.sessionId;\n    return headers;\n  }\n\n  setMessageHandler(\n    handler: (\n      message: AxMCPJSONRPCRequest<unknown> | AxMCPJSONRPCNotification\n    ) => void\n  ): void {\n    this.messageHandler = handler;\n  }\n\n  async connect(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  async openListeningStream(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const headers = this.buildHeaders({ Accept: 'text/event-stream' });\n      const url = new URL(this.mcpEndpoint);\n      if (Object.keys(this.customHeaders).length > 0) {\n        this.openListeningStreamWithFetch(headers).then(resolve).catch(reject);\n        return;\n      }\n      this.eventSource = new EventSource(url.toString());\n      this.eventSource.onopen = () => resolve();\n      this.eventSource.onmessage = (event) => {\n        try {\n          const message = JSON.parse(event.data);\n          if (this.messageHandler) this.messageHandler(message);\n        } catch (error) {\n          console.error('Failed to parse SSE message:', error);\n        }\n      };\n      this.eventSource.onerror = () =>\n        reject(new Error('Failed to establish SSE connection'));\n    });\n  }\n\n  private async openListeningStreamWithFetch(\n    headers: Record<string, string>\n  ): Promise<void> {\n    const response = await fetch(this.mcpEndpoint, { method: 'GET', headers });\n    if (response.status === 401) {\n      const www = response.headers.get('WWW-Authenticate');\n      const ensured = await this.oauthHelper.ensureAccessToken({\n        requestedUrl: this.mcpEndpoint,\n        wwwAuthenticate: www,\n        currentToken: null,\n      });\n      if (!ensured) throw new Error(`HTTP 401: Unauthorized`);\n      this.customHeaders.Authorization = `Bearer ${ensured.token.accessToken}`;\n      return this.openListeningStreamWithFetch(\n        this.buildHeaders({ Accept: 'text/event-stream' })\n      );\n    }\n    if (!response.ok)\n      throw new Error(\n        `Failed to open SSE stream: ${response.status} ${response.statusText}`\n      );\n    if (!response.body)\n      throw new Error('No response body available for SSE stream');\n\n    const reader = response.body.getReader();\n    const decoder = new TextDecoder();\n    let buffer = '';\n\n    const processStream = async (): Promise<void> => {\n      try {\n        const { done, value } = await reader.read();\n        if (done) {\n          reader.releaseLock();\n          return;\n        }\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop() || '';\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            const data = line.slice(6);\n            if (data === '[DONE]') return;\n            try {\n              const message = JSON.parse(data);\n              if (this.messageHandler) this.messageHandler(message);\n            } catch (error) {\n              console.error('Failed to parse SSE data:', error);\n            }\n          }\n        }\n        await processStream();\n      } catch (error) {\n        reader.releaseLock();\n        throw error;\n      }\n    };\n\n    await processStream();\n  }\n\n  async send(\n    message: Readonly<AxMCPJSONRPCRequest<unknown>>\n  ): Promise<AxMCPJSONRPCResponse<unknown>> {\n    const headers = this.buildHeaders({\n      'Content-Type': 'application/json',\n      Accept: 'application/json, text/event-stream',\n    });\n    const body = JSON.stringify(message);\n\n    let response = await fetch(this.mcpEndpoint, {\n      method: 'POST',\n      headers,\n      body,\n    });\n    if (response.status === 401) {\n      const www = response.headers.get('WWW-Authenticate');\n      const ensured = await this.oauthHelper.ensureAccessToken({\n        requestedUrl: this.mcpEndpoint,\n        wwwAuthenticate: www,\n        currentToken: null,\n      });\n      if (!ensured) throw new Error(`HTTP 401: Unauthorized`);\n      this.customHeaders.Authorization = `Bearer ${ensured.token.accessToken}`;\n      response = await fetch(this.mcpEndpoint, {\n        method: 'POST',\n        headers: this.buildHeaders({\n          'Content-Type': 'application/json',\n          Accept: 'application/json, text/event-stream',\n        }),\n        body,\n      });\n    }\n\n    if (!response.ok) {\n      if (response.status === 404 && this.sessionId) {\n        this.sessionId = undefined;\n        throw new Error('Session expired. Please reinitialize.');\n      }\n      throw new Error(`HTTP error ${response.status}: ${response.statusText}`);\n    }\n\n    const sessionIdHeader = response.headers.get('Mcp-Session-Id');\n    if (sessionIdHeader) this.sessionId = sessionIdHeader;\n\n    const contentType = response.headers.get('Content-Type');\n    if (contentType?.includes('text/event-stream'))\n      return this.handleSSEResponse(response, message.id);\n    if (contentType?.includes('application/json'))\n      return response.json() as Promise<AxMCPJSONRPCResponse<unknown>>;\n    throw new Error(`Unexpected content type: ${contentType}`);\n  }\n\n  private async handleSSEResponse(\n    response: Response,\n    requestId: string | number\n  ): Promise<AxMCPJSONRPCResponse<unknown>> {\n    return new Promise((resolve, reject) => {\n      const reader = response.body?.getReader();\n      if (!reader) {\n        reject(new Error('No response body reader available'));\n        return;\n      }\n      const decoder = new TextDecoder();\n      let buffer = '';\n      const processChunk = async (): Promise<void> => {\n        try {\n          const { done, value } = await reader.read();\n          if (done) {\n            reader.releaseLock();\n            return;\n          }\n          buffer += decoder.decode(value, { stream: true });\n          const lines = buffer.split('\\n');\n          buffer = lines.pop() || '';\n          for (const line of lines) {\n            if (line.startsWith('data: ')) {\n              const data = line.slice(6);\n              if (data === '[DONE]') return;\n              try {\n                const message = JSON.parse(data);\n                if ('id' in message && message.id === requestId) {\n                  resolve(message as AxMCPJSONRPCResponse<unknown>);\n                  return;\n                }\n                if (this.messageHandler) this.messageHandler(message);\n              } catch (error) {\n                console.error('Failed to parse SSE data:', error);\n              }\n            }\n          }\n          await processChunk();\n        } catch (error) {\n          reader.releaseLock();\n          reject(error);\n        }\n      };\n      processChunk().catch(reject);\n    });\n  }\n\n  async sendNotification(\n    message: Readonly<AxMCPJSONRPCNotification>\n  ): Promise<void> {\n    const headers = this.buildHeaders({\n      'Content-Type': 'application/json',\n      Accept: 'application/json, text/event-stream',\n    });\n    const body = JSON.stringify(message);\n\n    let response = await fetch(this.mcpEndpoint, {\n      method: 'POST',\n      headers,\n      body,\n    });\n    if (response.status === 401) {\n      const www = response.headers.get('WWW-Authenticate');\n      const ensured = await this.oauthHelper.ensureAccessToken({\n        requestedUrl: this.mcpEndpoint,\n        wwwAuthenticate: www,\n        currentToken: null,\n      });\n      if (!ensured) throw new Error(`HTTP 401: Unauthorized`);\n      this.customHeaders.Authorization = `Bearer ${ensured.token.accessToken}`;\n      response = await fetch(this.mcpEndpoint, {\n        method: 'POST',\n        headers: this.buildHeaders({\n          'Content-Type': 'application/json',\n          Accept: 'application/json, text/event-stream',\n        }),\n        body,\n      });\n    }\n\n    if (!response.ok) {\n      if (response.status === 404 && this.sessionId) {\n        this.sessionId = undefined;\n        throw new Error('Session expired. Please reinitialize.');\n      }\n      throw new Error(`HTTP error ${response.status}: ${response.statusText}`);\n    }\n\n    if (response.status !== 202)\n      console.warn(`Unexpected status for notification: ${response.status}`);\n  }\n\n  async terminateSession(): Promise<void> {\n    if (!this.sessionId) return;\n    try {\n      const headers = this.buildHeaders({});\n      const response = await fetch(this.mcpEndpoint, {\n        method: 'DELETE',\n        headers,\n      });\n      if (response.status === 405)\n        console.info('Server does not support explicit session termination');\n    } catch (error) {\n      console.error('Failed to terminate session:', error);\n    } finally {\n      this.sessionId = undefined;\n    }\n  }\n\n  close(): void {\n    if (this.eventSource) {\n      this.eventSource.close();\n      this.eventSource = undefined;\n    }\n  }\n}\n","import type { AxMCPTransport } from '../transport.js';\nimport type {\n  AxMCPJSONRPCNotification,\n  AxMCPJSONRPCRequest,\n  AxMCPJSONRPCResponse,\n} from '../types.js';\nimport type { AxMCPStreamableHTTPTransportOptions } from './options.js';\nimport { OAuthHelper } from '../oauth/oauthHelper.js';\n\nexport class AxMCPHTTPSSETransport implements AxMCPTransport {\n  private endpoint: string | null = null;\n  private sseUrl: string;\n  private eventSource?: EventSource;\n  private customHeaders: Record<string, string> = {};\n  private oauthHelper: OAuthHelper;\n  private currentToken?: AxMCPJSONRPCResponse<unknown> | null;\n  private currentIssuer?: string;\n  private sseAbort?: AbortController;\n  private pendingRequests = new Map<\n    string | number,\n    {\n      resolve: (value: AxMCPJSONRPCResponse<unknown>) => void;\n      reject: (reason: unknown) => void;\n    }\n  >();\n  private messageHandler?: (\n    message: AxMCPJSONRPCRequest<unknown> | AxMCPJSONRPCNotification\n  ) => void;\n  private endpointReady?: { resolve: () => void; promise: Promise<void> };\n\n  constructor(sseUrl: string, options?: AxMCPStreamableHTTPTransportOptions) {\n    this.sseUrl = sseUrl;\n    this.customHeaders = { ...(options?.headers ?? {}) };\n    if (options?.authorization)\n      this.customHeaders.Authorization = options.authorization;\n    this.oauthHelper = new OAuthHelper(options?.oauth);\n  }\n\n  private buildHeaders(base: Record<string, string>): Record<string, string> {\n    return { ...this.customHeaders, ...base };\n  }\n\n  private async openSSEWithFetch(\n    headers: Record<string, string>\n  ): Promise<void> {\n    const ac = new AbortController();\n    this.sseAbort = ac;\n    const res = await fetch(this.sseUrl, {\n      method: 'GET',\n      headers,\n      signal: ac.signal,\n    });\n\n    if (res.status === 401) {\n      const www = res.headers.get('WWW-Authenticate');\n      const ensured = await this.oauthHelper.ensureAccessToken({\n        requestedUrl: this.sseUrl,\n        wwwAuthenticate: www,\n        currentToken: null,\n      });\n      if (!ensured) throw new Error(`HTTP 401: Unauthorized`);\n      this.customHeaders.Authorization = `Bearer ${ensured.token.accessToken}`;\n      return this.openSSEWithFetch(\n        this.buildHeaders({ Accept: 'text/event-stream' })\n      );\n    }\n\n    if (!res.ok) throw new Error('Failed to establish SSE connection');\n\n    const ready = this.createEndpointReady();\n    void this.consumeSSEStream(res);\n    await ready;\n  }\n\n  private createEndpointReady(): Promise<void> {\n    if (!this.endpointReady) {\n      let resolver!: () => void;\n      const promise = new Promise<void>((resolve) => {\n        resolver = resolve;\n      });\n      this.endpointReady = { resolve: resolver, promise };\n    }\n    return this.endpointReady.promise;\n  }\n\n  private async consumeSSEStream(response: Response): Promise<void> {\n    if (!response.body)\n      throw new Error('No response body available for SSE stream');\n    const reader = response.body.getReader();\n    const decoder = new TextDecoder();\n    let buffer = '';\n    let eventType: string | null = null;\n\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n      buffer += decoder.decode(value, { stream: true });\n      const lines = buffer.split('\\n');\n      buffer = lines.pop() || '';\n      for (const line of lines) {\n        if (line.startsWith('event: ')) {\n          eventType = line.slice(7).trim();\n        } else if (line.startsWith('data: ')) {\n          const data = line.slice(6);\n          if (eventType === 'endpoint') {\n            const raw = data.trim();\n            let uri: string | undefined;\n            try {\n              const parsed = JSON.parse(raw);\n              if (typeof parsed === 'string') uri = parsed;\n              else if (parsed && typeof parsed === 'object' && 'uri' in parsed)\n                uri = (parsed as { uri?: string }).uri;\n            } catch {\n              uri = raw;\n            }\n            if (!uri) throw new Error('Endpoint URI missing in SSE event data');\n            if (!/^https?:\\/\\//i.test(uri)) {\n              const base = new URL(this.sseUrl);\n              uri = base.origin + (uri.startsWith('/') ? uri : `/${uri}`);\n            }\n            this.endpoint = uri;\n            if (this.endpointReady) {\n              this.endpointReady.resolve();\n              this.endpointReady = undefined;\n            }\n          } else {\n            const raw = data.trim();\n            try {\n              const msg = JSON.parse(raw);\n              if (msg && typeof msg === 'object' && 'id' in msg) {\n                const id = (msg as { id: string | number }).id;\n                const entry = this.pendingRequests.get(id);\n                if (entry) {\n                  entry.resolve(msg as AxMCPJSONRPCResponse<unknown>);\n                  this.pendingRequests.delete(id);\n                } else if (this.messageHandler) {\n                  this.messageHandler(msg);\n                }\n              } else if (this.messageHandler) {\n                this.messageHandler(msg);\n              }\n            } catch {\n              // ignore non-JSON lines\n            }\n          }\n        } else if (line.trim() === '') {\n          eventType = null;\n        }\n      }\n    }\n  }\n\n  async connect(): Promise<void> {\n    const headers = this.buildHeaders({ Accept: 'text/event-stream' });\n    await this.openSSEWithFetch(headers);\n  }\n\n  async send(\n    message: Readonly<AxMCPJSONRPCRequest<unknown>>\n  ): Promise<AxMCPJSONRPCResponse<unknown>> {\n    if (!this.endpoint)\n      throw new Error(\n        'HTTPTransport endpoint is not initialized. Call connect() first.'\n      );\n\n    const baseHeaders = this.buildHeaders({\n      'Content-Type': 'application/json',\n    });\n    const body = JSON.stringify(message);\n\n    const pending = new Promise<AxMCPJSONRPCResponse<unknown>>(\n      (resolve, reject) => {\n        this.pendingRequests.set(message.id, { resolve, reject });\n      }\n    );\n\n    let res = await fetch(this.endpoint, {\n      method: 'POST',\n      headers: baseHeaders,\n      body,\n    });\n\n    if (res.status === 401) {\n      const www = res.headers.get('WWW-Authenticate');\n      const ensured = await this.oauthHelper.ensureAccessToken({\n        requestedUrl: this.sseUrl,\n        wwwAuthenticate: www,\n        currentToken: null,\n      });\n      if (!ensured) throw new Error(`HTTP 401: Unauthorized`);\n      this.customHeaders.Authorization = `Bearer ${ensured.token.accessToken}`;\n      res = await fetch(this.endpoint, {\n        method: 'POST',\n        headers: this.buildHeaders({ 'Content-Type': 'application/json' }),\n        body,\n      });\n    }\n\n    if (!res.ok) {\n      this.pendingRequests.delete(message.id);\n      throw new Error(`HTTP error ${res.status}: ${res.statusText}`);\n    }\n\n    const contentType = res.headers.get('Content-Type');\n    if (contentType?.includes('application/json')) {\n      const json = (await res.json()) as AxMCPJSONRPCResponse<unknown>;\n      this.pendingRequests.delete(message.id);\n      return json;\n    }\n\n    return pending;\n  }\n\n  async sendNotification(\n    message: Readonly<AxMCPJSONRPCNotification>\n  ): Promise<void> {\n    if (!this.endpoint)\n      throw new Error(\n        'HTTPTransport endpoint is not initialized. Call connect() first.'\n      );\n\n    const baseHeaders = this.buildHeaders({\n      'Content-Type': 'application/json',\n    });\n    const body = JSON.stringify(message);\n\n    let res = await fetch(this.endpoint, {\n      method: 'POST',\n      headers: baseHeaders,\n      body,\n    });\n\n    if (res.status === 401) {\n      const www = res.headers.get('WWW-Authenticate');\n      const ensured = await this.oauthHelper.ensureAccessToken({\n        requestedUrl: this.sseUrl,\n        wwwAuthenticate: www,\n        currentToken: null,\n      });\n      if (!ensured) throw new Error(`HTTP 401: Unauthorized`);\n      this.customHeaders.Authorization = `Bearer ${ensured.token.accessToken}`;\n      res = await fetch(this.endpoint, {\n        method: 'POST',\n        headers: this.buildHeaders({ 'Content-Type': 'application/json' }),\n        body,\n      });\n    }\n\n    if (!res.ok) throw new Error(`HTTP error ${res.status}: ${res.statusText}`);\n    if (res.status !== 202)\n      console.warn(`Unexpected status for notification: ${res.status}`);\n  }\n\n  close(): void {\n    if (this.eventSource) {\n      this.eventSource.close();\n      this.eventSource = undefined;\n    }\n    if (this.sseAbort) {\n      this.sseAbort.abort();\n      this.sseAbort = undefined;\n    }\n  }\n}\n","import type {\n  AxAIModelList,\n  AxAIService,\n  AxFunction,\n  AxFunctionHandler,\n  AxFunctionJSONSchema,\n} from '../ai/types.js';\nimport type { AxInputFunctionType } from '../dsp/functions.js';\nimport { AxGen } from '../dsp/generate.js';\nimport { AxSignature } from '../dsp/sig.js';\nimport type { ParseSignature } from '../dsp/sigtypes.js';\nimport type {\n  AxGenIn,\n  AxGenOut,\n  AxGenStreamingOut,\n  AxMessage,\n  AxProgramDemos,\n  AxProgramExamples,\n  AxProgramForwardOptions,\n  AxProgramForwardOptionsWithModels,\n  AxProgrammable,\n  AxProgramStreamingForwardOptionsWithModels,\n  AxSetExamplesOptions,\n  AxTunable,\n  AxUsable,\n} from '../dsp/types.js';\n\n/**\n * Interface for agents that can be used as child agents.\n * Provides methods to get the agent's function definition and features.\n */\nexport interface AxAgentic<IN extends AxGenIn, OUT extends AxGenOut>\n  extends AxProgrammable<IN, OUT> {\n  getFunction(): AxFunction;\n  getFeatures(): AxAgentFeatures;\n}\n\nexport type AxAgentOptions = Omit<\n  AxProgramForwardOptions<string>,\n  'functions'\n> & {\n  disableSmartModelRouting?: boolean;\n  /** List of field names that should not be automatically passed from parent to child agents */\n  excludeFieldsFromPassthrough?: string[];\n  debug?: boolean;\n};\n\nexport interface AxAgentFeatures {\n  /** Whether this agent can use smart model routing (requires an AI service) */\n  canConfigureSmartModelRouting: boolean;\n  /** List of fields that this agent excludes from parent->child value passing */\n  excludeFieldsFromPassthrough: string[];\n}\n\n/**\n * Processes a child agent's function, applying model routing and input injection as needed.\n * Handles both the schema modifications and function wrapping.\n */\nfunction processChildAgentFunction<IN extends AxGenIn>(\n  childFunction: Readonly<AxFunction>,\n  parentValues: IN | AxMessage<IN>[],\n  parentInputKeys: string[],\n  modelList: AxAIModelList<string> | undefined,\n  options: Readonly<{\n    debug: boolean;\n    disableSmartModelRouting: boolean;\n    excludeFieldsFromPassthrough: string[];\n    canConfigureSmartModelRouting: boolean;\n  }>\n): AxFunction {\n  const processedFunction = { ...childFunction };\n\n  // Process input field injection\n  if (processedFunction.parameters) {\n    const childKeys = processedFunction.parameters.properties\n      ? Object.keys(processedFunction.parameters.properties)\n      : [];\n\n    // Find common keys between parent and child, excluding 'model' and specified exclusions\n    const commonKeys = parentInputKeys\n      .filter((key) => childKeys.includes(key))\n      .filter((key) => key !== 'model');\n    const injectionKeys = commonKeys.filter(\n      (key) => !options.excludeFieldsFromPassthrough.includes(key)\n    );\n\n    if (injectionKeys.length > 0) {\n      // Remove injected fields from child schema\n      processedFunction.parameters = removePropertiesFromSchema(\n        processedFunction.parameters,\n        injectionKeys\n      );\n\n      // Wrap function to inject parent values\n      const originalFunc = processedFunction.func;\n      // add debug logging if enabled\n      processedFunction.func = async (childArgs, funcOptions) => {\n        // Extract values from parentValues - handle both IN and AxMessage<IN>[] cases\n        let valuesToInject: Partial<IN> = {};\n        if (Array.isArray(parentValues)) {\n          // If parentValues is an array of messages, find the most recent user message\n          const lastUserMessage = parentValues\n            .filter((msg) => msg.role === 'user')\n            .pop();\n          if (lastUserMessage) {\n            valuesToInject = pick(\n              lastUserMessage.values,\n              injectionKeys as (keyof IN)[]\n            );\n          }\n        } else {\n          // If parentValues is a single IN object\n          valuesToInject = pick(parentValues, injectionKeys as (keyof IN)[]);\n        }\n\n        const updatedChildArgs = {\n          ...childArgs,\n          ...valuesToInject,\n        };\n\n        return await originalFunc(updatedChildArgs, funcOptions);\n      };\n    }\n\n    return processedFunction;\n  }\n\n  // Apply smart model routing if enabled\n  if (\n    modelList &&\n    !options.disableSmartModelRouting &&\n    options.canConfigureSmartModelRouting\n  ) {\n    processedFunction.parameters = addModelParameter(\n      processedFunction.parameters,\n      modelList\n    );\n  }\n\n  return processedFunction;\n}\n\nconst descriptionError = new Error(\n  'Agent description must be at least 20 characters (explain in detail what the agent does)'\n);\n\nconst definitionError = new Error(\n  'Agent definition is the prompt you give to the LLM for the agent. It must be detailed and at least 100 characters'\n);\n\n/**\n * An AI agent that can process inputs using an AI service and coordinate with child agents.\n * Supports features like smart model routing and automatic input field passing to child agents.\n *\n * @deprecated Use the `agent()` factory function instead of instantiating this class directly.\n * The factory function provides better type inference and cleaner syntax.\n * This class will be removed in v15.0.0.\n *\n * Migration timeline:\n * - v13.0.24+: Deprecation warnings (current)\n * - v14.0.0: Runtime console warnings\n * - v15.0.0: Complete removal\n *\n * @example\n * // Old (deprecated):\n * const myAgent = new AxAgent({\n *   name: 'myAgent',\n *   description: 'An agent that does something',\n *   signature: 'userInput:string -> responseText:string'\n * });\n *\n * // New (recommended):\n * const myAgent = agent('userInput:string -> responseText:string', {\n *   name: 'myAgent',\n *   description: 'An agent that does something'\n * });\n */\nexport class AxAgent<IN extends AxGenIn, OUT extends AxGenOut>\n  implements AxAgentic<IN, OUT>\n{\n  private ai?: AxAIService;\n  private program: AxGen<IN, OUT>;\n  private functions?: AxInputFunctionType;\n  private agents?: AxAgentic<IN, OUT>[];\n  private disableSmartModelRouting?: boolean;\n  private excludeFieldsFromPassthrough: string[];\n  private debug?: boolean;\n  private options?: Readonly<AxAgentOptions>;\n\n  private name: string;\n  //   private subAgentList?: string\n  private func: AxFunction;\n\n  constructor(\n    {\n      ai,\n      name,\n      description,\n      definition,\n      signature,\n      agents,\n      functions,\n    }: Readonly<{\n      ai?: Readonly<AxAIService>;\n      name: string;\n      description: string;\n      definition?: string;\n      signature: NonNullable<ConstructorParameters<typeof AxSignature>[0]>;\n      agents?: AxAgentic<IN, OUT>[];\n      functions?: AxInputFunctionType;\n    }>,\n    options?: Readonly<AxAgentOptions>\n  ) {\n    const { disableSmartModelRouting, excludeFieldsFromPassthrough, debug } =\n      options ?? {};\n\n    this.ai = ai;\n    this.agents = agents;\n    this.functions = functions;\n    this.disableSmartModelRouting = disableSmartModelRouting;\n    this.excludeFieldsFromPassthrough = excludeFieldsFromPassthrough ?? [];\n    this.debug = debug;\n    this.options = options;\n\n    if (!name || name.length < 5) {\n      throw new Error(\n        'Agent name must be at least 10 characters (more descriptive)'\n      );\n    }\n\n    if (!description || description.length < 20) {\n      throw descriptionError;\n    }\n\n    if (definition && definition.length < 100) {\n      throw definitionError;\n    }\n\n    this.program = new AxGen<IN, OUT>(signature, {\n      ...options,\n      description: definition ?? description,\n    });\n\n    for (const agent of agents ?? []) {\n      this.program.register(\n        agent as unknown as Readonly<AxTunable<IN, OUT> & AxUsable>\n      );\n    }\n\n    this.name = name;\n    // this.subAgentList = agents?.map((a) => a.getFunction().name).join(', ')\n\n    this.func = {\n      name: toCamelCase(this.name),\n      description,\n      parameters: this.program.getSignature().toJSONSchema(),\n      func: () => this.forward,\n    };\n\n    const mm = ai?.getModelList();\n    // Only add model parameter if smart routing is enabled and model list exists\n    if (mm && !this.disableSmartModelRouting) {\n      this.func.parameters = addModelParameter(this.func.parameters, mm);\n    }\n  }\n\n  /**\n   * Creates a new AxAgent instance with type-safe signature parsing.\n   * This is the recommended way to create agents with string-based signatures.\n   *\n   * @param signature - The signature string defining input/output fields\n   * @param config - Agent configuration including name, description, etc.\n   * @returns A new AxAgent instance with inferred types\n   *\n   * @example\n   * ```typescript\n   * const agent = AxAgent.create(\n   *   'userInput:string \"User question\" -> responseText:string \"Agent response\"',\n   *   {\n   *     name: 'helpfulAgent',\n   *     description: 'An agent that provides helpful responses to user questions',\n   *     definition: 'You are a helpful assistant that provides clear, accurate responses to user questions.',\n   *     ai: llm\n   *   }\n   * );\n   * ```\n   */\n  public static create<const T extends string>(\n    signature: T,\n    config: AxAgentConfig<\n      ParseSignature<T>['inputs'],\n      ParseSignature<T>['outputs']\n    >\n  ): AxAgent<ParseSignature<T>['inputs'], ParseSignature<T>['outputs']> {\n    const typedSignature = AxSignature.create(signature);\n    const { ai, name, description, definition, agents, functions, ...options } =\n      config;\n\n    return new AxAgent(\n      {\n        ai,\n        name,\n        description,\n        definition,\n        signature: typedSignature,\n        agents,\n        functions,\n      },\n      options\n    );\n  }\n\n  public setExamples(\n    examples: Readonly<AxProgramExamples<IN, OUT>>,\n    options?: Readonly<AxSetExamplesOptions>\n  ) {\n    this.program.setExamples(examples, options);\n  }\n\n  public setId(id: string) {\n    this.program.setId(id);\n  }\n\n  public setParentId(parentId: string) {\n    this.program.setParentId(parentId);\n  }\n\n  public getTraces() {\n    return this.program.getTraces();\n  }\n\n  public setDemos(demos: readonly AxProgramDemos<IN, OUT>[]) {\n    this.program.setDemos(demos);\n  }\n\n  public getUsage() {\n    return this.program.getUsage();\n  }\n\n  public resetUsage() {\n    this.program.resetUsage();\n  }\n\n  public getFunction(): AxFunction {\n    const boundFunc = this.forward.bind(this);\n\n    // Create a wrapper function that excludes the 'ai' parameter\n    const wrappedFunc: AxFunctionHandler = async (\n      valuesAndModel: IN & { model: string },\n      options?\n    ): Promise<string> => {\n      const { model, ...values } = valuesAndModel;\n\n      const ai = this.ai ?? options?.ai;\n      if (!ai) {\n        throw new Error('AI service is required to run the agent');\n      }\n      const ret = await boundFunc(ai, values as unknown as IN, {\n        ...options,\n        model,\n      });\n\n      const sig = this.program.getSignature();\n      const outFields = sig.getOutputFields();\n      const result = Object.keys(ret)\n        .map((k) => {\n          const field = outFields.find((f) => f.name === k);\n          if (field) {\n            return `${field.title}: ${ret[k]}`;\n          }\n          return `${k}: ${ret[k]}`;\n        })\n        .join('\\n');\n\n      return result;\n    };\n\n    return {\n      ...this.func,\n      func: wrappedFunc,\n    };\n  }\n\n  public getFeatures(): AxAgentFeatures {\n    return {\n      canConfigureSmartModelRouting: this.ai === undefined,\n      excludeFieldsFromPassthrough: this.excludeFieldsFromPassthrough,\n    };\n  }\n\n  /**\n   * Initializes the agent's execution context, processing child agents and their functions.\n   */\n  private init<T extends Readonly<AxAIService>>(\n    parentAi: T,\n    values: IN | AxMessage<IN>[],\n    options: Readonly<AxProgramForwardOptionsWithModels<T>> | undefined\n  ) {\n    const ai = this.ai ?? parentAi;\n    const mm = ai?.getModelList();\n\n    // Get parent's input schema and keys\n    const parentSchema = this.program.getSignature().getInputFields();\n    const parentKeys = parentSchema.map((p) => p.name);\n    const debug = this.getDebug<T>(ai, options);\n\n    // Process each child agent's function\n    const agentFuncs = this.agents?.map((agent) => {\n      const f = agent.getFeatures();\n\n      const processOptions = {\n        debug,\n        disableSmartModelRouting: !!this.disableSmartModelRouting,\n        excludeFieldsFromPassthrough: f.excludeFieldsFromPassthrough,\n        canConfigureSmartModelRouting: f.canConfigureSmartModelRouting,\n      };\n\n      return processChildAgentFunction(\n        agent.getFunction(),\n        values,\n        parentKeys,\n        mm,\n        processOptions\n      );\n    });\n\n    // Combine all functions\n    const functions: AxInputFunctionType = [\n      ...(options?.functions ?? this.functions ?? []),\n      ...(agentFuncs ?? []),\n    ];\n\n    return { ai, functions, debug };\n  }\n\n  public async forward<T extends Readonly<AxAIService>>(\n    parentAi: T,\n    values: IN | AxMessage<IN>[],\n    options?: Readonly<AxProgramForwardOptionsWithModels<T>>\n  ): Promise<OUT> {\n    const { ai, functions, debug } = this.init<T>(parentAi, values, options);\n    // Merge stored options with runtime options, with runtime taking precedence\n    const mergedOptions = {\n      ...this.options, // Agent-level options (like functionCallMode)\n      ...options, // Runtime options\n      debug,\n      functions,\n    };\n    return await this.program.forward(ai, values, mergedOptions);\n  }\n\n  public async *streamingForward<T extends Readonly<AxAIService>>(\n    parentAi: T,\n    values: IN | AxMessage<IN>[],\n    options?: Readonly<AxProgramStreamingForwardOptionsWithModels<T>>\n  ): AxGenStreamingOut<OUT> {\n    const { ai, functions, debug } = this.init<T>(parentAi, values, options);\n    // Merge stored options with runtime options, with runtime taking precedence\n    const mergedOptions = {\n      ...this.options, // Agent-level options (like functionCallMode)\n      ...options, // Runtime options\n      debug,\n      functions,\n    };\n    return yield* this.program.streamingForward(ai, values, mergedOptions);\n  }\n\n  /**\n   * Updates the agent's description.\n   * This updates both the stored description and the function's description.\n   *\n   * @param description - New description for the agent (must be at least 20 characters)\n   * @throws Error if description is too short\n   */\n  public setDescription(description: string): void {\n    if (!description || description.length < 20) {\n      throw descriptionError;\n    }\n\n    this.program.getSignature().setDescription(description);\n    this.func.description = description;\n  }\n\n  public setDefinition(definition: string): void {\n    if (!definition || definition.length < 100) {\n      throw definitionError;\n    }\n\n    this.program.setDescription(definition);\n    this.func.description = definition;\n  }\n\n  public getSignature(): AxSignature {\n    return this.program.getSignature();\n  }\n\n  public setSignature(\n    signature: NonNullable<ConstructorParameters<typeof AxSignature>[0]>\n  ) {\n    this.program.setSignature(signature);\n  }\n\n  public applyOptimization(optimizedProgram: any): void {\n    (this.program as any).applyOptimization?.(optimizedProgram);\n  }\n\n  private getDebug<T extends Readonly<AxAIService>>(\n    ai: AxAIService,\n    options?: Readonly<AxProgramForwardOptionsWithModels<T>>\n  ): boolean {\n    return options?.debug ?? this.debug ?? ai?.getOptions()?.debug ?? false;\n  }\n}\n\nfunction toCamelCase(inputString: string): string {\n  // Split the string by any non-alphanumeric character (including underscores, spaces, hyphens)\n  const words = inputString.split(/[^a-zA-Z0-9]/);\n\n  // Map through each word, capitalize the first letter of each word except the first word\n  const camelCaseString = words\n    .map((word, index) => {\n      // Lowercase the word to handle cases like uppercase letters in input\n      const lowerWord = word.toLowerCase();\n\n      // Capitalize the first letter of each word except the first one\n      if (index > 0 && lowerWord && lowerWord[0]) {\n        return lowerWord[0].toUpperCase() + lowerWord.slice(1);\n      }\n\n      return lowerWord;\n    })\n    .join('');\n\n  return camelCaseString;\n}\n\n/**\n * Adds a required model parameter to a JSON Schema definition based on provided model mappings.\n * The model parameter will be an enum with values from the model map keys.\n *\n * @param parameters - The original JSON Schema parameters definition (optional)\n * @param models - Array of model mappings containing keys, model names and descriptions\n * @returns Updated JSON Schema with added model parameter\n */\nexport function addModelParameter(\n  parameters: AxFunctionJSONSchema | undefined,\n  models: AxAIModelList<string>\n): AxFunctionJSONSchema {\n  // If parameters is undefined, create a base schema\n  const baseSchema: AxFunctionJSONSchema = parameters\n    ? structuredClone(parameters)\n    : {\n        type: 'object',\n        properties: {},\n        required: [],\n      };\n\n  // Check if model parameter already exists\n  if (baseSchema.properties?.model) {\n    return baseSchema;\n  }\n\n  // Create the model property schema\n  const modelProperty: AxFunctionJSONSchema & {\n    enum: string[];\n    description: string;\n  } = {\n    type: 'string',\n    enum: models.map((m) => m.key),\n    description: `The AI model to use for this function call. Available options: ${models\n      .map((m) => `\\`${m.key}\\` ${m.description}`)\n      .join(', ')}`,\n  };\n\n  // Create new properties object with model parameter\n  const newProperties = {\n    ...(baseSchema.properties ?? {}),\n    model: modelProperty,\n  };\n\n  // Add model to required fields\n  const newRequired = [...(baseSchema.required ?? []), 'model'];\n\n  // Return updated schema\n  return {\n    ...baseSchema,\n    properties: newProperties,\n    required: newRequired,\n  };\n}\n\n// New helper: removePropertiesFromSchema\n//    Clones a JSON schema and removes properties and required fields matching the provided keys.\nfunction removePropertiesFromSchema(\n  schema: Readonly<AxFunctionJSONSchema>,\n  keys: string[]\n): AxFunctionJSONSchema {\n  const newSchema = structuredClone(schema);\n  if (newSchema.properties) {\n    for (const key of keys) {\n      delete newSchema.properties[key];\n    }\n  }\n  if (Array.isArray(newSchema.required)) {\n    const filteredRequired = newSchema.required.filter(\n      (r: string) => !keys.includes(r)\n    );\n    Object.defineProperty(newSchema, 'required', {\n      value: filteredRequired,\n      writable: true,\n      configurable: true,\n    });\n  }\n  return newSchema;\n}\n\n// New helper: pick\n//    Returns an object composed of the picked object properties.\nfunction pick<T extends object, K extends keyof T>(\n  obj: T,\n  keys: K[]\n): Pick<T, K> {\n  const result = {} as Pick<T, K>;\n  for (const key of keys) {\n    if (key in obj) {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}\n\n/**\n * Configuration options for creating an agent using the agent() factory function.\n */\nexport interface AxAgentConfig<IN extends AxGenIn, OUT extends AxGenOut>\n  extends AxAgentOptions {\n  ai?: AxAIService;\n  name: string;\n  description: string;\n  definition?: string;\n  agents?: AxAgentic<IN, OUT>[];\n  functions?: AxInputFunctionType;\n}\n\n/**\n * Creates a strongly-typed AI agent from a signature.\n * This is the recommended way to create agents, providing better type inference and cleaner syntax.\n * Supports both string signatures and AxSignature objects.\n *\n * @param signature - The input/output signature as a string or AxSignature object\n * @param config - Configuration options for the agent\n * @returns A typed agent instance\n *\n * @example\n * ```typescript\n * // Using string signature\n * const myAgent = agent('userInput:string -> responseText:string', {\n *   name: 'myAgent',\n *   description: 'An agent that processes user input and returns a response',\n *   definition: 'You are a helpful assistant that responds to user queries...'\n * });\n *\n * // Using AxSignature object\n * const sig = s('userInput:string -> responseText:string');\n * const myAgent2 = agent(sig, {\n *   name: 'myAgent2',\n *   description: 'Same agent but using AxSignature object'\n * });\n *\n * // With child agents\n * const parentAgent = agent('taskDescription:string -> completedTask:string', {\n *   name: 'parentAgent',\n *   description: 'Coordinates child agents to complete tasks',\n *   agents: [childAgent1, childAgent2]\n * });\n *\n * // Type-safe usage\n * const result = await myAgent.forward(ai, { userInput: 'Hello!' });\n * console.log(result.responseText); // TypeScript knows this exists\n * ```\n */\nexport function agent<const T extends string>(\n  signature: T,\n  config: AxAgentConfig<\n    ParseSignature<T>['inputs'],\n    ParseSignature<T>['outputs']\n  >\n): AxAgent<ParseSignature<T>['inputs'], ParseSignature<T>['outputs']>;\nexport function agent<\n  TInput extends Record<string, any>,\n  TOutput extends Record<string, any>,\n>(\n  signature: AxSignature<TInput, TOutput>,\n  config: AxAgentConfig<TInput, TOutput>\n): AxAgent<TInput, TOutput>;\nexport function agent<\n  T extends string | AxSignature<any, any>,\n  TInput extends Record<string, any> = T extends string\n    ? ParseSignature<T>['inputs']\n    : T extends AxSignature<infer I, any>\n      ? I\n      : never,\n  TOutput extends Record<string, any> = T extends string\n    ? ParseSignature<T>['outputs']\n    : T extends AxSignature<any, infer O>\n      ? O\n      : never,\n>(\n  signature: T,\n  config: AxAgentConfig<TInput, TOutput>\n): AxAgent<TInput, TOutput> {\n  const typedSignature =\n    typeof signature === 'string'\n      ? AxSignature.create(signature)\n      : (signature as AxSignature<TInput, TOutput>);\n  const { ai, name, description, definition, agents, functions, ...options } =\n    config;\n\n  return new AxAgent(\n    {\n      ai,\n      name,\n      description,\n      definition,\n      signature: typedSignature,\n      agents,\n      functions,\n    },\n    options\n  );\n}\n","import { flow } from '../flow/flow.js';\nimport type { AxFlowLoggerFunction } from '../flow/logger.js';\n\n/**\n * Advanced Multi-hop RAG with iterative query refinement, context accumulation,\n * parallel sub-queries, and self-healing quality feedback loops\n *\n * @param queryFn - Function to execute search queries and return results\n * @param options - Configuration options\n * @returns AxFlow instance with advanced RAG capability\n */\nexport const axRAG = (\n  queryFn: (query: string) => Promise<string>,\n  options?: {\n    maxHops?: number;\n    qualityThreshold?: number;\n    maxIterations?: number;\n    qualityTarget?: number;\n    disableQualityHealing?: boolean;\n    logger?: AxFlowLoggerFunction;\n    debug?: boolean;\n  }\n) => {\n  const maxHops = options?.maxHops ?? 3;\n  const qualityThreshold = options?.qualityThreshold ?? 0.8;\n  const maxIterations = options?.maxIterations ?? 2;\n  const qualityTarget = options?.qualityTarget ?? 0.85;\n  const disableQualityHealing = options?.disableQualityHealing ?? false;\n\n  return (\n    flow<{ originalQuestion: string }>({\n      logger: options?.logger,\n      debug: options?.debug,\n    })\n      // Define nodes for comprehensive RAG pipeline\n      .node(\n        'queryGenerator',\n        'originalQuestion:string, previousContext?:string -> searchQuery:string, queryReasoning:string'\n      )\n      .node(\n        'contextualizer',\n        'retrievedDocument:string, accumulatedContext?:string -> enhancedContext:string'\n      )\n      .node(\n        'qualityAssessor',\n        'currentContext:string, originalQuestion:string -> completenessScore:number, missingAspects:string[]'\n      )\n      .node(\n        'questionDecomposer',\n        'complexQuestion:string -> subQuestions:string[], decompositionReason:string'\n      )\n      .node(\n        'evidenceSynthesizer',\n        'collectedEvidence:string[], originalQuestion:string -> synthesizedEvidence:string, evidenceGaps:string[]'\n      )\n      .node(\n        'gapAnalyzer',\n        'synthesizedEvidence:string, evidenceGaps:string[], originalQuestion:string -> needsMoreInfo:boolean, focusedQueries:string[]'\n      )\n      .node(\n        'answerGenerator',\n        'finalContext:string, originalQuestion:string -> comprehensiveAnswer:string, confidenceLevel:number'\n      )\n      .node(\n        'queryRefiner',\n        'originalQuestion:string, currentContext:string, missingAspects:string[] -> refinedQuery:string'\n      )\n      .node(\n        'qualityValidator',\n        'generatedAnswer:string, userQuery:string -> qualityScore:number, issues:string[]'\n      )\n      .node(\n        'answerHealer',\n        'originalAnswer:string, healingDocument:string, issues?:string[] -> healedAnswer:string'\n      )\n\n      // Initialize comprehensive state\n      .map((state) => ({\n        ...state,\n        maxHops,\n        qualityThreshold,\n        maxIterations,\n        qualityTarget,\n        disableQualityHealing,\n        currentHop: 0,\n        accumulatedContext: '',\n        retrievedContexts: [] as string[],\n        completenessScore: 0,\n        searchQuery: state.originalQuestion,\n        shouldContinue: true,\n        iteration: 0,\n        allEvidence: [] as string[],\n        evidenceSources: [] as string[],\n        needsMoreInfo: true,\n        healingAttempts: 0,\n        currentQuality: 0,\n        shouldContinueHealing: true,\n        currentAnswer: '',\n        currentIssues: [] as string[],\n      }))\n\n      // Phase 1: Multi-hop retrieval with iterative refinement\n      .while(\n        (state) =>\n          state.currentHop < state.maxHops &&\n          state.completenessScore < state.qualityThreshold &&\n          state.shouldContinue\n      )\n      // Increment hop counter\n      .map((state) => ({\n        ...state,\n        currentHop: state.currentHop + 1,\n      }))\n\n      // Generate search query\n      .execute('queryGenerator', (state) => ({\n        originalQuestion: state.originalQuestion,\n        previousContext: state.accumulatedContext || undefined,\n      }))\n\n      // Use the provided queryFn for actual retrieval\n      .map(async (state) => {\n        const searchQuery =\n          (state.queryGeneratorResult?.searchQuery as string) ||\n          state.searchQuery ||\n          state.originalQuestion;\n        const retrievedDocument = await queryFn(searchQuery);\n        return {\n          ...state,\n          retrievalResult: {\n            retrievedDocument,\n            retrievalConfidence: 0.9, // Could extract from queryFn if supported\n          },\n        };\n      })\n\n      // Contextualize the retrieved document\n      .execute('contextualizer', (state) => ({\n        retrievedDocument: state.retrievalResult.retrievedDocument,\n        accumulatedContext: state.accumulatedContext || undefined,\n      }))\n\n      // Assess the quality and completeness of current context\n      .execute('qualityAssessor', (state) => ({\n        currentContext: state.contextualizerResult.enhancedContext,\n        originalQuestion: state.originalQuestion,\n      }))\n\n      // Update state with new information\n      .map((state) => ({\n        ...state,\n        accumulatedContext: state.contextualizerResult.enhancedContext,\n        retrievedContexts: [\n          ...state.retrievedContexts,\n          state.retrievalResult.retrievedDocument,\n        ],\n        completenessScore: state.qualityAssessorResult\n          .completenessScore as number,\n        searchQuery: state.queryGeneratorResult.searchQuery as string,\n        shouldContinue:\n          (state.qualityAssessorResult.completenessScore as number) <\n          state.qualityThreshold,\n      }))\n\n      // Refine query for next iteration if needed\n      .branch(\n        (state) => state.shouldContinue && state.currentHop < state.maxHops\n      )\n      .when(true)\n      .execute('queryRefiner', (state) => ({\n        originalQuestion: state.originalQuestion,\n        currentContext: state.accumulatedContext,\n        missingAspects: state.qualityAssessorResult.missingAspects,\n      }))\n      .map((state) => ({\n        ...state,\n        searchQuery:\n          state.queryRefinerResult?.refinedQuery || state.searchQuery,\n      }))\n      .when(false)\n      .map((state) => state) // No refinement needed\n      .merge()\n\n      .endWhile()\n\n      // Phase 2: Advanced parallel sub-query processing for complex questions\n      // Initialize allEvidence with retrieved contexts from Phase 1\n      .map((state) => ({\n        ...state,\n        allEvidence:\n          state.retrievedContexts.length > 0 ? state.retrievedContexts : [],\n      }))\n\n      .while(\n        (state) => state.iteration < state.maxIterations && state.needsMoreInfo\n      )\n      .map((state) => ({\n        ...state,\n        iteration: state.iteration + 1,\n      }))\n\n      // First iteration: decompose the complex question\n      .branch((state) => state.iteration === 1)\n      .when(true)\n      .execute('questionDecomposer', (state) => ({\n        complexQuestion: state.originalQuestion,\n      }))\n      .map((state) => ({\n        ...state,\n        currentQueries: state.questionDecomposerResult.subQuestions,\n      }))\n      .when(false)\n      // Use focused queries from gap analysis for subsequent iterations\n      .map((state) => ({\n        ...state,\n        currentQueries:\n          ((state as any).gapAnalyzerResult?.focusedQueries as string[]) || [],\n      }))\n      .merge()\n\n      // Parallel retrieval for current set of queries\n      .map(async (state) => {\n        const queries = state.currentQueries || [];\n        const retrievalResults =\n          queries.length > 0\n            ? await Promise.all(\n                queries.filter(Boolean).map((query: string) => queryFn(query))\n              )\n            : [];\n        return {\n          ...state,\n          retrievalResults,\n        };\n      })\n\n      // Synthesize evidence from current iteration\n      .execute('evidenceSynthesizer', (state) => {\n        const priorEvidence = Array.isArray(state.allEvidence)\n          ? state.allEvidence\n          : [];\n        const newRetrievals = Array.isArray((state as any).retrievalResults)\n          ? (state as any).retrievalResults\n          : [];\n        const evidence = [...priorEvidence, ...newRetrievals].filter(Boolean);\n\n        return {\n          collectedEvidence:\n            evidence.length > 0 ? evidence : ['No evidence collected yet'],\n          originalQuestion: state.originalQuestion,\n        };\n      })\n\n      // Analyze gaps and determine if more information is needed\n      .execute('gapAnalyzer', (state) => ({\n        synthesizedEvidence:\n          state.evidenceSynthesizerResult.synthesizedEvidence,\n        evidenceGaps: state.evidenceSynthesizerResult.evidenceGaps,\n        originalQuestion: state.originalQuestion,\n      }))\n\n      // Update state with new evidence and gap analysis\n      .map((state) => ({\n        ...state,\n        allEvidence: [\n          ...((Array.isArray(state.allEvidence)\n            ? state.allEvidence\n            : []) as string[]),\n          ...(Array.isArray((state as any).retrievalResults)\n            ? ((state as any).retrievalResults as string[])\n            : []),\n        ],\n        evidenceSources: [\n          ...((Array.isArray(state.evidenceSources)\n            ? state.evidenceSources\n            : []) as string[]),\n          `Iteration ${state.iteration} sources`,\n        ],\n        needsMoreInfo: state.gapAnalyzerResult.needsMoreInfo,\n        synthesizedEvidence:\n          state.evidenceSynthesizerResult.synthesizedEvidence,\n      }))\n\n      .endWhile()\n\n      // Phase 3: Generate initial comprehensive answer\n      .execute('answerGenerator', (state) => ({\n        finalContext: (() => {\n          const fromAccumulated = (state.accumulatedContext || '')\n            .toString()\n            .trim();\n          if (fromAccumulated.length > 0) return fromAccumulated;\n          const fromSynth = (state.synthesizedEvidence || '').toString().trim();\n          if (fromSynth.length > 0) return fromSynth;\n          const fromAll = Array.isArray(state.allEvidence)\n            ? (state.allEvidence as string[]).filter(Boolean).join('\\n')\n            : '';\n          const fallback = fromAll.toString().trim();\n          return fallback.length > 0 ? fallback : 'No context available.';\n        })(),\n        originalQuestion: state.originalQuestion,\n      }))\n\n      // Phase 4: Self-healing quality validation and improvement (conditional)\n      .branch((state) => !state.disableQualityHealing)\n      .when(true)\n      .execute('qualityValidator', (state) => ({\n        generatedAnswer: state.answerGeneratorResult.comprehensiveAnswer,\n        userQuery: state.originalQuestion,\n      }))\n      .map((state) => ({\n        ...state,\n        currentAnswer: state.answerGeneratorResult\n          .comprehensiveAnswer as string,\n        currentQuality: state.qualityValidatorResult.qualityScore as number,\n        currentIssues: state.qualityValidatorResult.issues as string[],\n        shouldContinueHealing:\n          (state.qualityValidatorResult.qualityScore as number) <\n          state.qualityTarget,\n      }))\n\n      // Healing loop for quality improvement\n      .while(\n        (state) => state.healingAttempts < 3 && state.shouldContinueHealing\n      )\n      .map((state) => ({\n        ...state,\n        healingAttempts: state.healingAttempts + 1,\n      }))\n\n      // Use queryFn for healing retrieval\n      .map(async (state) => {\n        const issues = (state.currentIssues as string[]) || [];\n        const healingQuery =\n          issues.length > 0\n            ? `${state.originalQuestion} addressing issues: ${issues.join(', ')}`\n            : `${state.originalQuestion} quality improvement`;\n        const healingDocument = await queryFn(healingQuery);\n        return {\n          ...state,\n          healingResult: { healingDocument },\n        };\n      })\n\n      .execute('answerHealer', (state) => ({\n        originalAnswer: state.currentAnswer,\n        healingDocument: state.healingResult.healingDocument,\n        issues: state.currentIssues,\n      }))\n\n      // Re-validate after healing\n      .execute('qualityValidator', (state) => ({\n        generatedAnswer: state.answerHealerResult.healedAnswer,\n        userQuery: state.originalQuestion,\n      }))\n      .map((state) => ({\n        ...state,\n        currentAnswer: state.answerHealerResult.healedAnswer as string,\n        currentQuality: state.qualityValidatorResult.qualityScore as number,\n        currentIssues: state.qualityValidatorResult.issues as string[],\n        shouldContinueHealing:\n          (state.qualityValidatorResult.qualityScore as number) <\n          state.qualityTarget,\n      }))\n\n      .endWhile()\n      .when(false)\n      // Skip quality healing - use answer directly from Phase 3\n      .map((state) => ({\n        ...state,\n        currentAnswer: state.answerGeneratorResult.comprehensiveAnswer,\n        currentQuality: 1.0, // Assume perfect quality when disabled\n        currentIssues: [] as string[],\n        shouldContinueHealing: false,\n      }))\n      .merge()\n\n      // Final output mapping\n      .returns((state) => ({\n        finalAnswer: state.currentAnswer,\n        totalHops: state.currentHop,\n        retrievedContexts: state.retrievedContexts,\n        iterationCount: state.iteration,\n        healingAttempts: state.healingAttempts,\n        qualityAchieved: state.currentQuality,\n      }))\n  );\n};\n"],"mappings":"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YACA,UACA,QACA,aACA,KACA,QACA,UACA,KACA,MACA,QACA,KACA,KACA,MACA,QACA,SACA,SACA,QACA,QACA,UACA,OACA,WACA,SACA,KACA,QACA,UACA,WACA,SACA,KACA,MACA,WACA,UACA,MACA,UACA,SACA,UACA,SACA,WACA,SACA,UACA,WACA,KACA,KACA,QACA,aACA,SACA,aACA,cACA,gBACA,KACA,MACA,OACA,QACA,SACA,QACA,SACA,KACA,MACA,QACA,MACA,SACA,aACA,KACA,KACA,OACA,KACA,YACA,KACA,OACA,UACA,KACA,KACA,KACA,IACA,KACA,KACA,KACA,KACA,OACA,KACA,KACA,KACA,SACA,UACA,SACA,UACA,WACA,OACA,SACA,aACA,QACA,YACA,aACA,SACA,SACA,QACA,UACA,QACA,SACA,UACA,OACA,SACA,UACA,SACA,KACA,OACA,OACA,KACA,KACA,KACA,KACA,OACA,SACA,KACA,KACA,QACA,UACA,KACA,KACA,KACA,MACA,KACA,KACA,IACA,KACA,KACA,KACA,KACA,OACA,OACA,MACA,SACA,OACA,QACA,QACA,SACA,KACA,KACA,KACA,UACA,YACA,KACA,KACA,KACA,UACA,KACA,MACA,KACA,KACA,UACA,KACA,QACA,KACA,KACA,MACA,OACA,QACA,MACA,aACA,eACA,WACA,cACA,UACA,aACA,WACA,gBACA,QACA,SACA,UACA,WACA,SACA,KACA,KACA,KACA,MACA,KACA,MACA,KACA,KACA,YACA,KACA,KACA,KACA,KACA,IACA,KACA,KACA,OACA,KACA,KACA,KACA,aACA,WACA,YACA,UACA,SACA,KACA,KACA,MACA,OACA,SACA,YACA,KACA,KACA,KACA,KACA,OACA,QACA,UACA,QACA,MACA,OACA,QACA,OACA,YACA,KACA,KACA,KACA,KACA,KACA,MACA,SACA,KACA,KACA,IACA,KACA,KACA,KACA,OACA,KACA,KACA,MACA,KACA,KACA,SACA,KACA,KACA,QACA,SACA,SACA,KACA,KACA,SACA,OACA,YACA,KACA,QACA,KACA,MACA,SACA,SACA,WACA,KACA,KACA,KACA,KACA,KACA,aACA,MACA,KACA,QACA,MACA,KACA,KACA,OACA,OACA,QACA,YACA,WACA,aACA,aACA,KACA,UACA,UACA,SACA,KACA,IACA,KACA,KACA,MACA,KACA,MACA,KACA,KACA,UACA,QACA,OACA,OACA,OACA,OACA,QACA,OACA,MACA,KACA,KACA,KACA,KACA,WACA,YACA,UACA,MACA,SACA,WACA,QACA,QACA,QACA,OACA,KACA,OACA,QACA,KACA,KACA,OACA,UACA,cACA,KACA,IACA,KACA,OACA,KACA,MACA,OACA,UACA,KACA,OACA,QACA,QACA,SACA,KACA,KACA,KACA,OACA,QACA,OACA,MACA,SACA,KACA,YACA,KACA,KACA,IACA,KACA,KACA,MACA,OACA,SACA,UACA,SACA,MACA,OACA,QACA,SACA,OACA,QACA,UACA,SACA,KACA,MACA,OACA,QACA,QACA,OACA,QACA,MACA,OACA,YACA,SACA,SACA,QACA,SACA,WACA,OACA,UACA,MACA,OACA,KACA,KACA,MACA,MACA,UACA,MACA,SACA,KACA,KACA,OACA,YACA,MACA,UACA,UACA,QACA,KACA,KACA,OACA,KACA,UACA,KACA,IACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,OACA,KACA,KACA,MACA,KACA,KACA,KACA,UACA,KACA,KACA,KACA,KACA,OACA,KACA,MACA,YACA,cACA,aACA,YACA,KACA,WACA,MACA,SACA,QACA,WACA,YACA,YACA,cACA,QACA,UACA,UACA,WACA,OACA,YACA,SACA,KACA,KACA,KACA,KACA,KACA,MACA,QACA,KACA,MACA,OACA,QACA,MACA,OACA,SACA,KACA,OACA,KACA,KACA,KACA,IACA,KACA,KACA,KACA,KACA,KACA,OACA,IACA,KACA,OACA,QACA,OACA,KACA,KACA,KACA,OACA,QACA,QACA,KACA,IACA,KACA,KACA,UACA,OACA,SACA,QACA,SACA,WACA,KACA,KACA,KACA,QACA,MACA,OACA,OACA,MACA,OACA,QACA,KACA,OACA,QACA,SACA,OACA,SACA,KACA,KACA,KACA,KACA,KACA,OACA,UACA,QACA,MACA,KACA,KACA,KACA,MACA,IACA,KACA,KACA,OACA,SACA,OACA,QACA,OACA,MACA,QACA,KACA,OACA,QACA,WACA,YACA,SACA,KACA,QACA,SACA,WACA,OACA,UACA,OACA,OACA,KACA,KACA,KACA,OACA,WACA,OACA,SACA,OACA,KACA,MACA,KACA,KACA,KACA,OACA,MACA,OACA,QACA,UACA,KACA,SACA,QACA,IACA,KACA,KACA,OACA,SACA,MACA,KACA,KACA,KACA,OACA,SACA,cACA,YACA,OACA,QACA,UACA,QACA,UACA,QACA,eACA,MACA,OACA,KACA,KACA,OACA,SACA,KACA,KACA,KACA,KACA,SACA,MACA,OACA,cACA,QACA,MACA,WACA,MACA,MACA,QACA,UACA,QACA,MACA,UACA,KACA,KACA,KACA,KACA,IACA,KACA,KACA,SACA,WACA,YACA,KACA,KACA,KACA,MACA,QACA,KACA,KACA,KACA,KACA,KACA,OACA,KACA,MACA,KACA,UACA,KACA,OACA,MACA,OACA,OACA,OACA,KACA,KACA,KACA,KACA,MACA,KACA,KACA,QACA,SACA,YACA,KACA,QACA,MACA,OACA,YACA,MACA,UACA,OACA,UACA,KACA,QACA,MACA,KACA,KACA,IACA,KACA,KACA,KACA,OACA,YACA,QACA,MACA,OACA,aACA,eACA,MACA,OACA,KACA,KACA,KACA,MACA,UACA,KACA,KACA,KACA,KACA,KACA,KACA,SACA,SACA,OACA,KACA,KACA,KACA,SACA,WACA,WACA,cACA,KACA,KACA,KACA,gBACA,UACA,aACA,aACA,YACA,WACA,WACA,QACA,WACA,KACA,KACA,KACA,MACA,KACA,IACA,KACA,KACA,MACA,UACA,QACA,KACA,IACA,KACA,KACA,MACA,SACA,KACA,KACA,KACA,UACA,SACA,aACA,SACA,WACA,MACA,OACA,YACA,aACA,UACA,UACA,aACA,WACA,kBACA,eACA,WACA,YACA,UACA,KACA,KACA,KACA,QACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,KACA,KACA,IACA,KACA,KACA,OACA,OACA,MACA,MACA,SACA,OACA,KACA,KACA,KACA,MACA,SACA,WACA,UACA,MACA,SACA,OACA,SACA,UACA,QACA,OACA,OACA,SACA,WACA,OACA,UACA,YACA,QACA,UACA,KACA,QACA,OACA,SACA,MACA,OACA,QACA,SACA,OACA,QACA,SACA,UACA,YACA,YACA,OACA,SACA,QACA,SACA,QACA,KACA,OACA,cACA,gBACA,UACA,YACA,QACA,UACA,MACA,QACA,KACA,KACA,WACA,KACA,KACA,KACA,OACA,WACA,UACA,UACA,WACA,YACA,WACA,YACA,WACA,YACA,OACA,QACA,KACA,eACA,YACA,UACA,aACA,KACA,KACA,KACA,KACA,QACA,OACA,WACA,MACA,gBACA,eACA,OACA,eACA,UACA,MACA,OACA,KACA,SACA,KACA,IACA,KACA,KACA,KACA,OACA,QACA,SACA,KACA,KACA,KACA,KACA,OACA,MACA,QACA,KACA,KACA,OACA,QACA,SACA,QACA,OACA,UACA,QACA,SACA,UACA,MACA,QACA,SACA,OACA,aACA,OACA,SACA,QACA,aACA,UACA,SACA,YACA,UACA,WACA,UACA,UACA,SACA,UACA,UACA,YACA,WACA,QACA,OACA,QACA,SACA,UACA,SACA,UACA,UACA,SACA,OACA,QACA,QACA,OACA,WACA,aACA,QACA,OACA,SACA,UACA,WACA,QACA,SACA,UACA,aACA,OACA,OACA,KACA,MACA,MACA,KACA,KACA,KACA,KACA,KACA,WACA,MACA,OACA,MACA,SACA,UACA,KACA,KACA,KACA,QACA,QACA,QACA,MACA,SACA,KACA,MACA,KACA,KACA,SACA,SACA,QACA,MACA,KACA,IACA,QACA,KACA,KACA,KACA,KACA,KACA,KACA,QACA,gBACA,SACA,SACA,WACA,QACA,OACA,KACA,KACA,OACA,MACA,KACA,KACA,MACA,OACA,SACA,WACA,aACA,OACA,QACA,UACA,KACA,IACA,KACA,QACA,UACA,KACA,KACA,KACA,OACA,MACA,MACA,KACA,KACA,MACA,OACA,YACA,KACA,KACA,KACA,KACA,IACA,KACA,OACA,QACA,MACA,OACA,QACA,SACA,MACA,KACA,MACA,OACA,UACA,OACA,QACA,SACA,OACA,OACA,QACA,QACA,SACA,UACA,QACA,OACA,WACA,UACA,QACA,SACA,OACA,SACA,WACA,SACA,QACA,aACA,UACA,UACA,UACA,SACA,UACA,YACA,WACA,UACA,QACA,QACA,OACA,UACA,MACA,OACA,UACA,QACA,SACA,OACA,WACA,OACA,QACA,QACA,MACA,QACA,KACA,SACA,OACA,UACA,OACA,OACA,SACA,UACA,KACA,MACA,SACA,OACA,QACA,QACA,QACA,QACA,SACA,UACA,WACA,MACA,IACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,IACA,KACA,MACA,MACA,KACA,KACA,MACA,OACA,QACA,SACA,OACA,QACA,SACA,QACA,WACA,aACA,SACA,KACA,KACA,KACA,IACA,OACA,KACA,KACA,MACF,CAAC,ECjoCD,SAASC,GACPC,EACAC,EACU,CACV,OAAOD,EAAO,OAAQE,GAAU,CAACD,EAAW,IAAIC,CAAK,CAAC,CACxD,CAYA,SAASC,GAAYH,EAAmD,CACtE,IAAMI,EAAkC,CAAC,EACzC,QAAWF,KAASF,EAClBI,EAAQF,CAAK,GAAKE,EAAQF,CAAK,GAAK,GAAK,EAE3C,OAAOE,CACT,CAYA,SAASC,GAAcC,EAAmB,CACxC,IAAIC,EAAaD,EAAE,UAAU,KAAK,EAClC,OAAAC,EAAaA,EAAW,QAAQ,kBAAmB,GAAG,EACtDA,EAAaA,EAAW,MAA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BA,EAAQ,QAIV,KAAK,SAAW,EACzB,CAKU,wBACRrC,EACAC,EACM,CACN,GAAK,KAAK,mBAGV,IAAIA,EAAkB,CAEpB,IAAMwB,GAAexB,EAAiB,MAAM,SAAS,GAAK,CAAC,GAAG,OACxDyB,GAAgBzB,EAAiB,MAAM,UAAU,GAAK,CAAC,GAAG,OAEhEuB,GACE,KAAK,mBACLC,EACAC,EACA,EACA,EACA1B,CACF,CACF,CAGA+B,GACE,KAAK,mBACL/B,EACA,KAAK,YACL,MACF,EACF,CAKU,2BACRF,EACAC,EACAC,EACAC,EACM,CACN,GAAI,CAAC,KAAK,mBAAoB,OAE9BL,GACE,KAAK,mBACLE,EACAC,EACAC,EACAC,CACF,EAEAa,GACE,KAAK,mBACLhB,EACAE,CACF,EAGA,IAAM0I,EAAc,KAAK,aAAa,eAAe,GAAK,EACpDC,EAAc,KAAK,aAAa,eAAe,GAAK,EAC1DjI,GACE,KAAK,mBACLiI,EACAD,EACA1I,CACF,CACF,CAKU,yBACRI,EACAC,EACAC,EACAC,EACAP,EACM,CACD,KAAK,oBAEVG,GACE,KAAK,mBACLC,EACAC,EACAC,EACAC,EACAP,CACF,CACF,CAKU,2BACRS,EACAT,EACM,CACD,KAAK,oBAEVQ,GAA0B,KAAK,mBAAoBC,EAAQT,CAAa,CAC1E,CAKU,4BACRgB,EACAC,EACAjB,EACM,CACD,KAAK,oBAEVe,GACE,KAAK,mBACLC,EACAC,EACAjB,CACF,CACF,CAKU,wBACRmB,EACAH,EACAjB,EACAC,EACM,CACD,KAAK,oBAEVkB,GACE,KAAK,mBACLC,EACAH,EACAjB,EACAC,CACF,CACF,CAKU,oBACRqB,EACAC,EACAtB,EACAuB,EACM,CACD,KAAK,oBAEVH,GACE,KAAK,mBACLC,EACAC,EACAtB,EACAuB,CACF,CACF,CAKU,yBACRO,EACAhC,EACAE,EACM,CACD,KAAK,oBAEV6B,GACE,KAAK,mBACLC,EACAhC,EACAE,CACF,CACF,CAGU,0BAA0BqC,EAAqC,CACvE,OAAO,KAAK,iBAAmBA,GAAS,SAAW,KAAK,SAAW,GACrE,CAEU,mBACRA,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","names":["index_exports","__export","AxACE","AxACEOptimizedProgram","AxAI","AxAIAnthropic","AxAIAnthropicModel","AxAIAnthropicVertexModel","AxAIAzureOpenAI","AxAICohere","AxAICohereEmbedModel","AxAICohereModel","AxAIDeepSeek","AxAIDeepSeekModel","AxAIGoogleGemini","AxAIGoogleGeminiEmbedModel","AxAIGoogleGeminiEmbedTypes","AxAIGoogleGeminiModel","AxAIGoogleGeminiSafetyCategory","AxAIGoogleGeminiSafetyThreshold","AxAIGrok","AxAIGrokEmbedModels","AxAIGrokModel","AxAIGroq","AxAIGroqModel","AxAIHuggingFace","AxAIHuggingFaceModel","AxAIMistral","AxAIMistralEmbedModels","AxAIMistralModel","AxAIOllama","AxAIOpenAI","AxAIOpenAIBase","AxAIOpenAIEmbedModel","AxAIOpenAIModel","AxAIOpenAIResponses","AxAIOpenAIResponsesBase","AxAIOpenAIResponsesImpl","AxAIOpenAIResponsesModel","AxAIOpenRouter","AxAIRefusalError","AxAIReka","AxAIRekaModel","AxAIServiceAbortedError","AxAIServiceAuthenticationError","AxAIServiceError","AxAIServiceNetworkError","AxAIServiceResponseError","AxAIServiceStatusError","AxAIServiceStreamTerminatedError","AxAIServiceTimeoutError","AxAITogether","AxAIWebLLM","AxAIWebLLMModel","AxAgent","AxApacheTika","AxAssertionError","AxBalancer","AxBaseAI","AxBaseOptimizer","AxBootstrapFewShot","AxContentProcessingError","AxDB","AxDBBase","AxDBCloudflare","AxDBManager","AxDBMemory","AxDBPinecone","AxDBWeaviate","AxDefaultCostTracker","AxDefaultResultReranker","AxDockerSession","AxEmbeddingAdapter","AxEvalUtil","AxFlow","AxFlowDependencyAnalyzer","AxFlowExecutionPlanner","AxFlowSubContextImpl","AxFlowTypedSubContextImpl","AxFluentFieldType","AxFunctionError","AxFunctionProcessor","AxGEPA","AxGEPAFlow","AxGen","AxGenerateError","AxHFDataLoader","AxInstanceRegistry","AxLLMRequestTypeValues","AxMCPClient","AxMCPHTTPSSETransport","AxMCPStreambleHTTPTransport","AxMediaNotSupportedError","AxMemory","AxMiPRO","AxMockAIService","AxMultiServiceRouter","AxOptimizedProgramImpl","AxProgram","AxPromptTemplate","AxProviderRouter","AxRateLimiterTokenUsage","AxSignature","AxSignatureBuilder","AxSimpleClassifier","AxSimpleClassifierClass","AxSpanKindValues","AxStopFunctionCallException","AxStringUtil","AxTestPrompt","agent","ai","ax","axAIAnthropicDefaultConfig","axAIAnthropicVertexDefaultConfig","axAIAzureOpenAIBestConfig","axAIAzureOpenAICreativeConfig","axAIAzureOpenAIDefaultConfig","axAIAzureOpenAIFastConfig","axAICohereCreativeConfig","axAICohereDefaultConfig","axAIDeepSeekCodeConfig","axAIDeepSeekDefaultConfig","axAIGoogleGeminiDefaultConfig","axAIGoogleGeminiDefaultCreativeConfig","axAIGrokBestConfig","axAIGrokDefaultConfig","axAIHuggingFaceCreativeConfig","axAIHuggingFaceDefaultConfig","axAIMistralBestConfig","axAIMistralDefaultConfig","axAIOllamaDefaultConfig","axAIOllamaDefaultCreativeConfig","axAIOpenAIBestConfig","axAIOpenAICreativeConfig","axAIOpenAIDefaultConfig","axAIOpenAIFastConfig","axAIOpenAIResponsesBestConfig","axAIOpenAIResponsesCreativeConfig","axAIOpenAIResponsesDefaultConfig","axAIOpenRouterDefaultConfig","axAIRekaBestConfig","axAIRekaCreativeConfig","axAIRekaDefaultConfig","axAIRekaFastConfig","axAITogetherDefaultConfig","axAIWebLLMCreativeConfig","axAIWebLLMDefaultConfig","axAnalyzeChatPromptRequirements","axAnalyzeRequestRequirements","axBaseAIDefaultConfig","axBaseAIDefaultCreativeConfig","axCheckMetricsHealth","axCreateDefaultColorLogger","axCreateDefaultOptimizerColorLogger","axCreateDefaultOptimizerTextLogger","axCreateDefaultTextLogger","axCreateFlowColorLogger","axCreateFlowTextLogger","axDefaultFlowLogger","axDefaultMetricsConfig","axDefaultOptimizerLogger","axDefaultOptimizerMetricsConfig","axGetCompatibilityReport","axGetFormatCompatibility","axGetMetricsConfig","axGetOptimizerMetricsConfig","axGetProvidersWithMediaSupport","axGlobals","axModelInfoAnthropic","axModelInfoCohere","axModelInfoDeepSeek","axModelInfoGoogleGemini","axModelInfoGrok","axModelInfoGroq","axModelInfoHuggingFace","axModelInfoMistral","axModelInfoOpenAI","axModelInfoOpenAIResponses","axModelInfoReka","axModelInfoTogether","axModelInfoWebLLM","axProcessContentForProvider","axRAG","axScoreProvidersForRequest","axSelectOptimalProvider","axSpanAttributes","axSpanEvents","axUpdateMetricsConfig","axUpdateOptimizerMetricsConfig","axValidateChatRequestMessage","axValidateChatResponseResult","axValidateProviderCapabilities","f","flow","s","__toCommonJS","getModelInfo","model","modelInfo","models","modelEntry","v","mappedModel","exactMatch","normalizedName","normalizedMatch","webCrypto","randomUUID","sha256","data","encoder","inputData","hashBuffer","b","Hash","chunk","encoding","hash","i","char","createHash","algorithm","getCrypto","SSEParser","options","chunk","controller","error","rawData","lines","line","colonIndex","field","value","retryValue","parsedData","e","TextDecodeTransformer","chunk","controller","text","TextDecoderStreamPolyfill","defaultRetryConfig","textDecoderStream","TextDecoderStreamPolyfill","AxAIServiceError","message","url","requestBody","responseBody","context","randomUUID","_depth","_options","AxAIServiceStatusError","status","statusText","AxAIServiceNetworkError","originalError","AxAIServiceResponseError","AxAIServiceStreamTerminatedError","lastChunk","AxAIServiceTimeoutError","timeoutMs","AxAIServiceAbortedError","reason","AxAIServiceAuthenticationError","AxAIRefusalError","refusalMessage","model","requestId","AxMediaNotSupportedError","mediaType","provider","fallbackAvailable","AxContentProcessingError","contentType","processingStep","safeReadResponseBody","response","calculateRetryDelay","attempt","config","createRequestMetrics","updateRetryMetrics","metrics","shouldRetry","error","apiCall","api","json","retryConfig","timeoutId","baseUrl","apiPath","apiUrl","originalUrl","combinedAbortController","userAbortHandler","originalAbort","res","delay","resolve","resJson","chunkCount","controller","reader","decoder","buffer","read","done","value","closed","events","event","lines","data","eventType","line","parsed","parseError","e","streamMetrics","trackingStream","chunk","SSEParser","import_api","axGlobals","result","ColorLog","text","colorCode","_colorLog","ColorLog","defaultOutput","message","formatChatMessage","msg","hideContent","cl","colorize","text","colorMethod","header","items","item","content","result","call","i","params","axCreateDefaultColorLogger","output","divider","typedData","formattedMessage","lines","thought","streamingContent","embedding","usage","citation","defaultLogger","axCreateDefaultTextLogger","textUsage","axSpanAttributes","axSpanEvents","AxLLMRequestTypeValues","AxSpanKindValues","TypeTransformer","transformFn","doneCallback","obj","controller","val","RespTransformStream","mergeFunctionCalls","functionCalls","functionCallDeltas","Fc","fc","logChatRequest","chatPrompt","step","logger","hideSystemPrompt","filteredPrompt","msg","logResponse","resp","logger","loggerData","logResponseStreamingResult","result","index","logResponseStreamingDoneResult","values","combinedResults","value","existing","mergeFunctionCalls","logFunctionResults","results","logFunctionError","error","fixingInstructions","logValidationError","logAssertionError","logRefusalError","logEmbedRequest","texts","embedModel","logger","logEmbedResponse","embeddings","sampleEmbeddings","embedding","loggerData","logResultPickerUsed","sampleCount","selectedIndex","latency","sanitizeLabels","labels","sanitized","key","value","stringValue","globalAIMetricsInstruments","getOrCreateAIMetricsInstruments","meter","createMetricsInstruments","createMetricsInstruments","meter","recordLatencyMetric","instruments","type","duration","aiService","model","labels","sanitizeLabels","error","recordLatencyStatsMetrics","meanLatency","p95Latency","p99Latency","recordErrorMetric","recordErrorRateMetric","errorRate","recordRequestMetric","recordTokenMetric","tokens","recordStreamingRequestMetric","isStreaming","recordFunctionCallMetric","functionName","latency","recordRequestSizeMetric","sizeBytes","recordResponseSizeMetric","recordModelConfigMetrics","temperature","maxTokens","recordEstimatedCostMetric","costUSD","recordPromptLengthMetric","lengthChars","recordContextWindowUsageMetric","usageRatio","recordTimeoutMetric","recordAbortMetric","recordThinkingBudgetUsageMetric","tokensUsed","recordMultimodalRequestMetric","hasImages","hasAudio","formatForMessage","v","raiseValidationError","issue","args","lines","axValidateChatRequestMessage","item","value","role","content","index","contentItem","contentType","text","image","mimeType","data","hasFileUri","hasData","fileUriValue","dataValue","url","functionCalls","hasNonEmptyContent","hasFunctionCalls","i","fc","funcObj","name","functionId","result","axValidateChatResponseResult","results","resultsArray","arrayIndex","tb","annotation","callIndex","functionCall","validFinishReasons","axBaseAIDefaultConfig","axBaseAIDefaultCreativeConfig","AxBaseAI","aiImpl","name","apiURL","headers","modelInfo","defaults","options","supportFor","models","axGlobals","randomUUID","model","embedModel","_validateModels","#debug","defaultLogger","getOrCreateAIMetricsInstruments","samples","percentile","sorted","a","b","index","type","duration","metrics","metricsInstruments","recordLatencyMetric","recordLatencyStatsMetrics","isError","recordRequestMetric","recordErrorMetric","recordErrorRateMetric","modelUsage","promptTokens","completionTokens","totalTokens","thoughtsTokens","recordTokenMetric","req","response","hasImages","hasAudio","message","part","totalLength","info","promptCostPer1M","completionCostPer1M","modelName","functionCalls","call","recordFunctionCallMetric","recordTimeoutMetric","recordAbortMetric","result","modelConfig","isStreaming","recordStreamingRequestMetric","recordMultimodalRequestMetric","promptLength","recordPromptLengthMetric","recordModelConfigMetrics","recordThinkingBudgetUsageMetric","requestSize","recordRequestSizeMetric","chatResponse","responseSize","recordResponseSizeMetric","chatResult","contextUsage","recordContextWindowUsageMetric","estimatedCost","recordEstimatedCostMetric","startTime","modelKeyEntry","modelKeyThinkingTokenBudget","mergedOptions","value","error","item","axValidateChatRequestMessage","selectedModelInfo","axSpanAttributes","span","fn","cleanFn","cleanParams","chatReq","debug","functions","logChatRequest","providerSupportsFunctions","requestedFunctionCallMode","effectiveReq","msg","content","cache","apiConfig","reqValue","setChatRequestEvents","apiCall","rt","rv","respFn","wrappedRespFn","state","resp","res","tokenUsage","setChatResponseEvents","logResponseStreamingResult","doneCb","values","logResponseStreamingDoneResult","sourceStream","transformState","transformedValues","abortSignal","controller","reader","onAbort","read","done","transformedValue","RespTransformStream","logResponse","embedReq","createEmbedReq","logEmbedRequest","resValue","axSpanEvents","logEmbedResponse","v","excludeContentFromTrace","userMessages","prompt","eventData","userEventData","thoughtsTokensEntry","toolCalls","validateAxMessageArray","keys","AxAIAnthropicModel","AxAIAnthropicVertexModel","axModelInfoAnthropic","cleanSchemaForAnthropic","schema","cleaned","key","value","axAIAnthropicDefaultConfig","axBaseAIDefaultConfig","axAIAnthropicVertexDefaultConfig","AxAIAnthropicImpl","config","isVertex","req","model","stream","apiConfig","toolsChoice","system","msg","otherMessages","functionToolsFromReq","v","configToolsCleaned","tool","tools","t","maxTokens","stopSequences","temperature","topP","topK","n","thinkingConfig","levels","_levels","messages","createMessages","m","reqValue","resp","AxAIRefusalError","finishReason","mapFinishReason","showThoughts","aggregatedContent","aggregatedThought","anyRedacted","lastSignature","aggregatedFunctionCalls","citations","block","c","result","results","state","sstate","error","index","message","contentBlock","annos","functionCalls","delta","id","usage","AxAIAnthropic","_AxAIAnthropic","AxBaseAI","options","apiKey","projectId","region","models","apiURL","headers","Config","aiImpl","supportFor","mi","getModelInfo","axModelInfoAnthropic","normalizedModels","item","anyItem","cfg","modelConfig","out","numericBudget","candidates","bestName","bestDiff","name","diff","chatPrompt","_thinkingEnabled","items","content","preservedThinkingBlocks","tb","input","merged","mergeAssistantMessages","trimAssistantStringContent","mergedMessages","i","cur","lastMessage","stopReason","AxAIOpenAIModel","AxAIOpenAIEmbedModel","AxAIOpenAIResponsesModel","axModelInfoOpenAI","axModelInfoOpenAIResponses","isOpenAIThinkingModel","model","thinkingModels","axAIOpenAIDefaultConfig","axBaseAIDefaultConfig","axAIOpenAIBestConfig","axAIOpenAICreativeConfig","axBaseAIDefaultCreativeConfig","axAIOpenAIFastConfig","AxAIOpenAIImpl","config","streamingUsage","chatReqUpdater","req","apiConfig","tools","v","toolsChoice","messages","createMessages","frequencyPenalty","stream","store","isThinkingModel","reqValue","resp","id","usage","choices","error","choice","AxAIRefusalError","finishReason","mapFinishReason","functionCalls","params","name","a","state","sstate","index","content","role","refusal","toolCalls","thought","annotations","oaiFinishReason","Id","data","msg","c","AxAIOpenAIBase","AxBaseAI","apiKey","options","apiURL","modelInfo","models","supportFor","aiImpl","AxAIOpenAI","axModelInfoOpenAI","mi","getModelInfo","normalizedModels","item","anyItem","cfg","modelConfig","stopSeq","out","numericBudget","candidates","bestName","bestDiff","value","diff","axAIAzureOpenAIDefaultConfig","axAIOpenAIDefaultConfig","axAIAzureOpenAICreativeConfig","axAIOpenAICreativeConfig","axAIAzureOpenAIFastConfig","axAIOpenAIFastConfig","axAIAzureOpenAIBestConfig","axAIOpenAIBestConfig","AxAIAzureOpenAI","AxAIOpenAIBase","apiKey","resourceName","deploymentName","version","config","options","models","modelInfo","Config","axModelInfoOpenAI","supportFor","model","mi","getModelInfo","host","AxBalancer","_AxBalancer","services","options","validateModels","cs","a","b","aMetrics","bMetrics","model","failure","retries","lastFailureTime","timeSinceLastFailure","backoffMs","gotNextService","req","response","e","AxAIServiceError","AxAIServiceAuthenticationError","AxAIServiceStatusError","AxAIServiceNetworkError","AxAIServiceResponseError","AxAIServiceStreamTerminatedError","AxAIServiceTimeoutError","serviceWithModel","service","referenceModelList","referenceKeys","i","modelList","serviceKeys","key","axAnalyzeRequestRequirements","request","hasImages","hasAudio","hasFiles","hasUrls","requiresFunctions","requiresStreaming","requiresCaching","contentTypes","estimatedTokens","message","part","axValidateProviderCapabilities","provider","requirements","features","missingCapabilities","warnings","alternatives","maxSize","maxDuration","axScoreProvidersForRequest","providers","validation","score","supportedCapabilities","a","b","axSelectOptimalProvider","availableProviders","options","scoredProviders","fullyCompatible","p","bestProvider","axGetCompatibilityReport","providerScores","recommendedProvider","totalRequirements","supportedRequirements","summary","axGetProvidersWithMediaSupport","mediaType","axGetFormatCompatibility","compatibility","mediaFeatures","format","AxAICohereModel","AxAICohereEmbedModel","axModelInfoCohere","axAICohereDefaultConfig","axBaseAIDefaultConfig","axAICohereCreativeConfig","axBaseAIDefaultCreativeConfig","AxAICohereImpl","config","req","model","lastChatMsg","restOfChat","message","chatHistory","createHistory","tools","v","props","key","value","toolResults","chat","fn","t","apiConfig","reqValue","resp","finishReason","functionCalls","state","ss","results","result","AxAICohere","AxBaseAI","apiKey","options","models","Config","aiImpl","normalizedModels","item","anyItem","cfg","modelConfig","out","axModelInfoCohere","chatPrompt","toolCalls","createToolCall","f","call","outputs","parameters","AxAIDeepSeekModel","axModelInfoDeepSeek","axAIDeepSeekDefaultConfig","axBaseAIDefaultConfig","axAIDeepSeekCodeConfig","axBaseAIDefaultCreativeConfig","AxAIDeepSeek","AxAIOpenAIBase","apiKey","config","options","models","modelInfo","Config","axModelInfoDeepSeek","AxAIGoogleGeminiModel","AxAIGoogleGeminiEmbedModel","AxAIGoogleGeminiSafetyCategory","AxAIGoogleGeminiSafetyThreshold","AxAIGoogleGeminiEmbedTypes","axModelInfoGoogleGemini","cleanSchemaForGemini","schema","cleaned","key","value","safetySettings","axAIGoogleGeminiDefaultConfig","axBaseAIDefaultConfig","axAIGoogleGeminiDefaultCreativeConfig","axBaseAIDefaultCreativeConfig","AxAIGoogleGeminiImpl","config","isVertex","endpointId","apiKey","options","req","model","stream","apiConfig","pf","keyValue","systemPrompts","p","systemInstruction","contents","msg","i","c","parts","f","args","tools","cleanedFunctions","fn","gm","mapsToolCfg","toolConfig","hasFunctionDeclarations","t","allowedFunctionNames","thinkingConfig","levels","generationConfig","reqValue","text","resp","mapsWidgetToken","results","candidate","result","AxAIRefusalError","part","randomUUID","cms","toIso","d","mapsCitations","ch","m","response","embeddings","prediction","embedding","AxAIGoogleGemini","_AxAIGoogleGemini","AxBaseAI","projectId","region","models","modelInfo","apiURL","headers","path","Config","aiImpl","axModelInfoGoogleGemini","supportFor","mi","getModelInfo","normalizedModels","item","anyItem","cfg","modelConfig","out","numericBudget","candidates","bestName","bestDiff","name","diff","colorLog","ColorLog","AxRateLimiterTokenUsage","maxTokens","refillRate","options","now","tokensToAdd","tokens","resolve","AxAIGroqModel","axModelInfoGroq","axAIGroqDefaultConfig","axBaseAIDefaultConfig","AxAIGroq","AxAIOpenAIBase","apiKey","config","options","models","modelInfo","Config","Options","axModelInfoGroq","supportFor","rateLimiter","tokensPerMin","rt","AxRateLimiterTokenUsage","func","info","totalTokens","axModelInfoHuggingFace","AxAIHuggingFaceModel","axAIHuggingFaceDefaultConfig","axBaseAIDefaultConfig","axAIHuggingFaceCreativeConfig","axBaseAIDefaultCreativeConfig","AxAIHuggingFaceImpl","config","req","model","functionsList","prompt","msg","fc","args","inputs","apiConfig","reqValue","resp","AxAIHuggingFace","AxBaseAI","apiKey","options","models","Config","aiImpl","axModelInfoHuggingFace","AxAIMistralModel","AxAIMistralEmbedModels","axModelInfoMistral","axAIMistralDefaultConfig","axBaseAIDefaultConfig","axAIMistralBestConfig","AxAIMistral","AxAIOpenAIBase","apiKey","config","options","models","modelInfo","Config","axModelInfoMistral","supportFor","chatReqUpdater","req","max_completion_tokens","messages","result","messagesUpdated","message","contentUpdated","item","AxMockAIService","config","randomUUID","_model","req","_options","resolve","options","message","type","latency","samples","a","b","sortedSamples","p95Index","p99Index","totalRequests","AxMultiServiceRouter","_AxMultiServiceRouter","services","index","item","service","description","isInternal","modelList","v","otherService","req","options","modelKey","_","reqWithoutModel","embedModelKey","reqWithoutEmbedModel","s","value","key","model","serviceInstance","firstServiceEntry","entry","axAIOllamaDefaultConfig","axBaseAIDefaultConfig","axAIOllamaDefaultCreativeConfig","axBaseAIDefaultCreativeConfig","AxAIOllama","AxAIOpenAIBase","apiKey","url","config","options","models","Config","isOpenAIResponsesThinkingModel","model","AxAIOpenAIResponsesImpl","config","streamingUsage","responsesReqUpdater","content","role","mappedParts","part","url","ExhaustiveCheck","chatPrompt","excludeSystemMessages","items","msg","mappedContent","assistantMessage","call","invalidRole","req","apiConfig","instructionsFromPrompt","systemMessageFoundAndUsed","item","finalInstructions","tools","v","includeFields","isThinkingModel","reasoningSummary","reasoningEffort","mutableReq","inputItems","currentReasoning","finalReqToProcess","resp","id","output","usage","currentResult","contentToText","extractAnnotationsFromContent","s","streamEvent","event","baseResult","remoteId","fileSearchItem","r","webSearchItem","computerItem","codeItem","imageItem","shellItem","mcpItem","anns","reqValue","responseId","refusalContent","c","refusalMessage","AxAIRefusalError","annos","p","a","axAIOpenAIResponsesDefaultConfig","axAIOpenAIResponsesBestConfig","axAIOpenAIResponsesCreativeConfig","AxAIOpenAIResponsesBase","AxBaseAI","apiKey","config","options","apiURL","modelInfo","models","responsesReqUpdater","supportFor","aiImpl","AxAIOpenAIResponsesImpl","normalizedModels","item","anyItem","cfg","modelConfig","stopSeq","out","numericBudget","candidates","bestName","bestDiff","name","value","diff","AxAIOpenAIResponses","axModelInfoOpenAIResponses","model","mi","getModelInfo","axAIOpenRouterDefaultConfig","axBaseAIDefaultConfig","AxAIOpenRouter","AxAIOpenAIBase","apiKey","config","options","models","modelInfo","referer","title","Config","supportFor","ModelInfo","headers","axProcessContentForProvider","content","provider","options","features","processedContent","item","description","error","AxContentProcessingError","AxMediaNotSupportedError","transcription","extractedText","fetchedContent","axAnalyzeChatPromptRequirements","chatPrompt","hasImages","hasAudio","hasFiles","hasUrls","message","part","AxAIRekaModel","axModelInfoReka","axAIRekaDefaultConfig","axBaseAIDefaultConfig","axAIRekaBestConfig","axAIRekaCreativeConfig","axBaseAIDefaultCreativeConfig","axAIRekaFastConfig","AxAIRekaImpl","config","req","model","apiConfig","messages","createMessages","frequencyPenalty","stream","reqValue","resp","id","usage","responses","res","index","finishReason","mapFinishReason","content","msg","c","AxAIReka","AxBaseAI","apiKey","options","apiURL","modelInfo","axModelInfoReka","models","Config","aiImpl","AxProviderRouter","config","request","options","routingResult","processedRequest","error","AxMediaNotSupportedError","provider","processingOptions","enhancedOptions","processedChatPrompt","message","processedContent","axProcessContentForProvider","item","requirements","axAnalyzeRequestRequirements","processingApplied","degradations","warnings","axSelectOptimalProvider","features","fallbackProviders","fallbackProvider","issues","recommendations","p","capabilityMatrix","name","axModelInfoTogether","axAITogetherDefaultConfig","axBaseAIDefaultConfig","AxAITogether","AxAIOpenAIBase","apiKey","config","options","models","modelInfo","Config","axModelInfoTogether","supportFor","AxAIWebLLMModel","axModelInfoWebLLM","axAIWebLLMDefaultConfig","axBaseAIDefaultConfig","axAIWebLLMCreativeConfig","axBaseAIDefaultCreativeConfig","AxAIWebLLMImpl","config","engine","req","model","messages","msg","content","item","baseMsg","fc","tools","fn","apiConfig","data","stream","response","controller","chunk","error","reqValue","_req","resp","choice","index","finishReason","functionCalls","toolCall","state","ss","deltaToolCall","existingCall","_resp","AxAIWebLLM","AxBaseAI","options","models","Config","aiImpl","axModelInfoWebLLM","_model","AxAIGrokModel","AxAIGrokEmbedModels","axModelInfoGrok","axAIGrokDefaultConfig","axBaseAIDefaultConfig","axAIGrokBestConfig","AxAIGrok","AxAIOpenAIBase","apiKey","config","options","models","modelInfo","Config","axModelInfoGrok","supportFor","model","mi","getModelInfo","chatReqUpdater","req","searchParams","source","ai","options","AxAI","_AxAI","AxAIOpenAI","AxAIOpenAIResponses","AxAIAzureOpenAI","AxAIGrok","AxAIHuggingFace","AxAIGroq","AxAITogether","AxAIOpenRouter","AxAICohere","AxAIGoogleGemini","AxAIAnthropic","AxAIMistral","AxAIDeepSeek","AxAIOllama","AxAIReka","AxAIWebLLM","model","req","import_api","AxDBBase","name","fetch","tracer","req","update","axSpanAttributes","span","baseURL","AxDBCloudflare","AxDBBase","apiKey","accountId","fetch","tracer","req","_update","options","res","apiCall","message","batchReq","update","table","id","score","values","metadata","AxDBMemory","AxDBBase","tracer","req","_update","_options","obj","batchReq","update","ids","res","table","matches","id","data","score","distance","a","b","state","dotProduct","normA","normB","zeroVectorA","zeroVectorB","vectorA","vectorB","i","sqrtNormA","sqrtNormB","createPineconeQueryRequest","req","AxDBPinecone","AxDBBase","apiKey","host","fetch","tracer","update","options","batchReq","_update","apiCall","id","values","metadata","score","AxDBWeaviate","AxDBBase","apiKey","host","fetch","tracer","req","update","options","res","apiCall","message","batchReq","objects","result","id","filter","resMatches","match","AxDB","args","AxDBWeaviate","AxDBPinecone","AxDBCloudflare","AxDBMemory","req","update","batchReq","table","AxDBManager","ai","db","config","text","options","chunkerInput","initialChunks","chunk","maxWordsPerChunk","minWordsPerChunk","chunks","processChunks","bs","i","batch","embeddings","embedding","index","v","error","query","topPercent","abortSignal","texts","rewrittenQuery","queries","values","queryResults","res","matches","m","score","metadata","tp","resultItems","getTopInPercent","rankedItems","item","items","r","currentChunk","currentWordCount","words","wordCount","remainingWords","slice","entries","percent","sortedEntries","a","b","topTenPercentCount","import_api","MemoryImpl","items","index","item","value","results","chat","lastItem","content","name","functionCalls","thought","thoughtBlock","v","existing","cur","merged","tagIndex","indices","acc","result","role","values","AxMemory","sessionId","axValidateChatRequestMessage","axValidateChatResponseResult","AxAssertionError","message","extraFields","_depth","_options","assertAssertions","asserts","values","assert","fn","res","assertStreamingAssertions","xstate","content","final","fieldAsserts","a","currValue","axDefaultMetricsConfig","globalGenMetricsInstruments","getOrCreateGenMetricsInstruments","meter","activeMeter","axGlobals","createGenMetricsInstruments","axCheckMetricsHealth","issues","axGlobals","globalGenMetricsInstruments","createGenMetricsInstruments","meter","currentMetricsConfig","axDefaultMetricsConfig","axUpdateMetricsConfig","config","axGetMetricsConfig","sanitizeLabels","labels","sanitized","key","value","stringValue","maxLength","recordGenerationMetric","instruments","duration","success","signatureName","aiService","model","error","recordMultiStepMetric","stepsUsed","maxSteps","recordValidationErrorMetric","errorType","recordRefusalErrorMetric","recordErrorCorrectionMetric","attempts","maxRetries","recordFunctionCallingMetric","functionsEnabled","functionsExecuted","hadFunctionCalls","functionErrorCorrection","recordFieldProcessingMetric","fieldProcessorsExecuted","streamingFieldProcessorsExecuted","recordStreamingMetric","isStreaming","deltasEmitted","finalizationDuration","recordSamplesMetric","samplesCount","resultPickerUsed","resultPickerLatency","recordSignatureComplexityMetrics","inputFields","outputFields","examplesCount","demosCount","recordPerformanceMetric","metricType","toFieldType","type","baseType","ValidationError","message","_depth","_options","createMissingRequiredFieldsError","fields","list","f","createExpectedRequiredFieldNotFoundError","field","createRequiredFieldMissingError","field","ValidationError","toFieldType","createInvalidJsonError","detail","createInvalidArrayError","createTypeValidationError","fieldValue","createInvalidDateError","dateStr","createInvalidDateTimeError","handleValidationErrorForGenerate","error","errCount","debug","logger","metricsInstruments","signatureName","span","errorFields","fixingInstructions","f","logValidationError","recordValidationErrorMetric","handleAssertionErrorForGenerate","logAssertionError","handleRefusalErrorForGenerate","logRefusalError","recordRefusalErrorMetric","validateJSONSchema","schema","errors","validateSchemaObject","path","validTypes","subSchema","index","key","value","requiredProp","errorMessage","error","parts","AxStopFunctionCallException","calls","c","AxFunctionError","fields","field","_depth","_options","FunctionError","func","funcId","fieldName","fieldSchema","description","bulletPoints","fieldError","schemaDescription","AxFunctionProcessor","funcList","fnSpec","options","args","e","opt","res","formatted","axGlobals","normalize","target","v","parseFunctions","newFuncs","existingFuncs","functions","f","fn","validateJSONSchema","processFunctions","ai","functionList","functionCalls","mem","sessionId","traceId","span","excludeContentFromTrace","index","functionResultFormatter","logger","debug","stopFunctionNames","funcProc","functionsExecuted","stopMatches","findFunctionSpec","name","s","spec","promises","tracer","toolSpan","rawResult","parsedArgs","eventData","result","errorEventData","logFunctionError","functionResults","r","successfulResults","logFunctionResults","parseFunctionCalls","_values","model","createFunctionConfig","definedFunctionCall","firstStep","functionCall","import_dayjs","import_customParseFormat","import_timezone","import_utc","dayjs","utc","timezone","customParseFormat","parseLLMFriendlyDate","field","dateStr","required","ParseLlmFriendlyDate","err","message","createInvalidDateError","parseLLMFriendlyDateTime","ParseLlmFriendlyDateTime","createInvalidDateTimeError","dateTimeStr","dateTimeRegex","match","dateTime","timeZone","format","date","formatDateWithTimezone","_colorLog","ColorLog","validateValue","field","value","ft","validateSingleValue","expectedType","val","validImage","msg","item","validAudio","validFile","hasData","hasFileUri","validUrl","isValid","gotType","mergeProgramUsage","usages","usageMap","usage","key","currentUsage","tokens","existing","incoming","seen","parseMarkdownList","input","listBullets","numberedListRegex","lines","list","line","trimmedLine","mergeDeltas","base","currentDelta","index","delta","version","target","b","baseValue","deltaValue","entry","LRUCache","maxSize","firstKey","globalPrefixCache","matchesContent","content","prefix","startIndex","prefixCache","exactMatchIndex","prefixes","_","i","longestPartialMatch","partialPrefix","extractValues","sig","values","content","options","strictMode","treatAllFieldsOptional","skipEarlyFail","xstate","streamingExtractValues","streamingExtractFinalValue","field","checkMissingRequiredFields","_xstate","outputFields","missingFields","createMissingRequiredFieldsError","fields","expectedField","doNotTry","candidates","f","i","index","chosenIndex","chosenField","e","prefixLen","prefix","match","matchesContent","firstRequiredField","createExpectedRequiredFieldNotFoundError","val","parsedValue","validateAndParseFieldValue","deferRequiredCheckForStreaming","forceFinalize","endIndex","otherField","nextFieldPattern","nextFieldIndex","parseMissedFieldsFromFullContent","streamingInProgress","start","valueStart","boundary","valueEnd","rawValue","lines","line","trimmedLine","fieldValue","convertValueToType","required","extractBlock","v","parseLLMFriendlyDate","parseLLMFriendlyDateTime","className","yieldDelta","s","fieldName","isInternal","fieldIsArray","fieldTypeName","pos","isFirstChunk","startIndex","d1","d2","d3","streamValues","prevField","key","value","createRequiredFieldMissingError","text","createInvalidJsonError","parseMarkdownList","createInvalidArrayError","item","createTypeValidationError","input","processFieldProcessors","fieldProcessors","values","mem","sessionId","processor","processFn","result","addToMemory","processStreamingFieldProcessors","content","xstate","done","value","field","resultText","_key","text","getFieldProcessingMessage","isCodeField","fieldTitle","processStreamingResponse","res","usage","states","debug","args","skipEarlyFail","lastChunkUsage","aggregatedCitations","reader","done","value","v","result","c","state","s","ProcessStreamingResponse","finalizeStreamingResponse","dedup","usageWithoutCitations","mem","sessionId","strictMode","treatAllFieldsOptional","signature","streamingFieldProcessors","thoughtFieldName","streamingAsserts","asserts","mergeFunctionCalls","streamingExtractValues","assertStreamingAssertions","processStreamingFieldProcessors","streamValues","assertAssertions","ai","model","functions","traceId","span","excludeContentFromTrace","fieldProcessors","functionResultFormatter","signatureToolCallingManager","logger","stopFunctionNames","funcs","parseFunctionCalls","fx","processFunctions","streamingExtractFinalValue","promptFuncs","fc","processFieldProcessors","processResponse","disableMemoryCleanup","results","citations","r","modelUsage","extractValues","functionCalls","e","values","field","outputFields","deltas","index","delta","shouldContinueSteps","stopFunction","lastMemItem","stopFunctionExecuted","isFunction","isProcessor","tag","AxInstanceRegistry","instance","items","i","SignatureValidationError","message","position","context","suggestion","SignatureParser","input","optionalDesc","inputs","outputs","remaining","error","errorMessage","signature","inputNames","field","outputNames","outputField","start","end","before","after","pointer","parseFieldFn","section","fields","name","isOptional","type","typeName","isArray","desc","isInternal","classNamesString","options","s","fieldType","axGlobals","suggestions","camelCaseRegex","snakeCaseRegex","types","foundType","currentWord","baseMessage","suggestionPart","fullMessage","match","invalidMatch","invalidId","quoteChars","quoteChar","content","escaped","startPos","char","partialString","strOrRegex","found","parseSignature","AxSignatureBuilder","name","fieldInfo","prepend","field","description","config","AxSignature","AxFluentFieldType","_AxFluentFieldType","fieldType","f","desc","options","language","convertFieldTypeToAxField","fieldType","AxSignatureValidationError","message","fieldName","suggestion","AxSignature","_AxSignature","signature","sig","parseSignature","e","v","error","field","title","desc","parsedField","validateField","existingField","outputField","inputField","fields","parsedFields","parsed","name","newSig","fieldToAdd","result","properties","required","f","type","createHash","renderSignature","inputNames","outputNames","renderField","description","inputFields","outputFields","descriptionPart","inputFieldsRendered","outputFieldsRendered","isValidCase","inputString","camelCaseRegex","snakeCaseRegex","context","axGlobals","suggestions","validateFieldType","option","trimmedOption","opt","AxProgram","signature","options","AxSignature","AxInstanceRegistry","description","prog","id","child","parentId","examples","traces","sig","fields","e","res","f","value","validateValue","Traces","usage","cu","mergeProgramUsage","demos","hasChildren","hasMatchingDemo","demo","v","optimizedProgram","functionCallInstructions","formattingRules","AxPromptTemplate","sig","options","fieldTemplates","task","inArgs","renderDescFields","outArgs","funcList","f","fn","formatDescription","inputFields","renderInputFields","outputFields","renderOutputFields","desc","text","values","renderedExamples","renderedDemos","examplesInSystemPrompt","completion","prompt","v","combineConsecutiveStrings","examples","demos","allTextExamples","allTextDemos","systemContent","combinedItems","systemPrompt","messages","history","firstItem","message","content","userContent","extraFields","groupedFields","acc","field","title","fields","valuesList","data","list","exampleContext","index","item","renderedInputItem","renderedOutputItem","renderedItem","demoContext","inputRenderedItems","outputRenderedItems","renderedItems","context","value","isEmptyValue","validateValue","processedValue","processValue","validateImage","result","validated","validateAudio","validateFile","hasData","hasFileUri","validateUrl","name","type","toFieldType","requiredMsg","description","formatDateWithTimezone","baseType","separator","current","previous","fieldType","str","checkForFunctionCalls","mem","sessionId","history","hasFunctionResults","msg","extractFunctionResults","results","assistantMessages","functionMessages","assistantMsg","funcCall","funcResult","selectFromSamples","buffer","options","resultPicker","functionResults","selectedIndex","fieldResults","b","index","selectFromSamplesInMemory","lastMemory","chat","SignatureToolRouter","tools","logger","tool","toolParamFieldMap","paramFieldMap","_generateToolParameterFields","results","_options","functionCalls","remainingFields","argsByTool","fieldMaps","toolName","key","value","fmap","path","args","_toolName","missing","ValidationError","fieldName","_","letter","name","map","walk","props","prefix","schema","full","sanitized","target","obj","i","k","next","fields","properties","required","processProperties","_parentRequired","fieldPath","fullName","fieldType","inferParameterType","sanitizeFieldName","formatParameterTitle","items","paramPath","injectToolFields","tools","signature","router","newSig","AxSignature","toolParamFieldMap","tool","paramFieldMap","field","f","fieldName","sanitizeFieldName","fieldType","inferToolFieldType","formatTitle","fields","generateToolParameterFields","properties","required","processProperties","props","prefix","_parentRequired","key","schema","fieldPath","fullName","inferParameterType","formatParameterTitle","items","toolName","paramPath","name","str","parameters","SignatureToolCallingManager","tools","SignatureToolRouter","signature","injected","injectToolFields","injectedNames","f","originalNames","n","results","options","functionCalls","AxGen","AxProgram","signature","options","promptTemplateOptions","AxPromptTemplate","parseFunctions","getOrCreateGenMetricsInstruments","meter","n","_","index","fn","message","fieldName","outputField","f","ft","streaming","field","ai","mem","traceContext","functions","functionCall","stepIndex","sessionId","model","rateLimiter","stream","thinkingTokenBudget","showThoughts","selectedIndex","selectFromSamplesInMemory","chatPrompt","modelConfig","debug","firstStep","logger","span","states","stopFunctionNames","functionList","functionResultFormatter","definedFunctionCall","signatureToolCallingManager","strictMode","usage","createFunctionConfig","res","processStreamingResponse","processResponse","values","rawStop","s","maxRetries","maxSteps","AxMemory","hasFunctions","functionCallMode","cacheSystemPrompt","SignatureToolCallingManager","err","lastError","promptTemplateClass","currentPromptTemplateOptions","prompt","promptRenderStart","validateAxMessageArray","promptRenderDuration","metricsInstruments","recordPerformanceMetric","memoryUpdateStart","memoryUpdateDuration","multiStepLoop","errCount","generator","stopFunctionTriggered","result","e","AxStopFunctionCallException","shouldContinueSteps","recordMultiStepMetric","allFunctionsExecuted","state","func","recordFunctionCallingMetric","recordFieldProcessingMetric","errorFields","signatureName","args","ValidationError","handleValidationErrorForGenerate","AxAssertionError","handleAssertionErrorForGenerate","AxAIRefusalError","handleRefusalErrorForGenerate","AxAIServiceStreamTerminatedError","enhanceError","recordErrorCorrectionMetric","stateCreationStart","stateCreationDuration","tracer","funcNames","attributes","traceLabel","spanName","currentContext","valuesList","startTime","isStreaming","success","errorCorrectionAttempts","resultPickerUsed","recordSignatureComplexityMetrics","buffer","currentVersion","deltasEmitted","delta","mergeDeltas","resultPickerStart","selectFromSamples","resultPickerLatency","baseTrace","logResultPickerUsed","recordSamplesMetric","recordStreamingMetric","error","duration","finalMetricsInstruments","recordGenerationMetric","selectedResult","examples","axGlobals","AxGenerateError","details","originalError","trimNonAlphaNum","str","splitIntoTwo","separator","index","matchResult","firstPart","secondPart","dedup","seq","seen","result","x","extractIdAndText","input","match","id","text","extractIndexPrefixedText","batchArray","arr","size","chunkedArr","i","AxStringUtil","AxDefaultResultReranker","AxGen","options","ai","input","rankedItems","sortedIndexes","item","index","AxStringUtil","_","originalIndex","AxApacheTika","args","Args","fileData","options","acceptValue","fetchOptions","res","error","files","results","bs","i","uploadPromises","batchResults","_colorLog","ColorLog","AxSimpleClassifierClass","name","context","AxSimpleClassifier","ai","AxDBMemory","state","classes","options","c","ret","text","embeddings","m","cutoff","matchedClass","stopwords","filterTokens","tokens","exclusions","token","countTokens","counter","normalizeText","s","normalized","emScore","prediction","groundTruth","f1Score","predictionTokens","groundTruthTokens","predictionCounts","groundTruthCounts","numSame","v1","v2","precision","recall","novelF1ScoreOptimized","history","returnRecall","historyTokens","stopwords","f1","AxEvalUtil","AxTestPrompt","ai","program","examples","metricFn","_st","total","sumOfScores","i","ex","res","score","error","averageScore","AxHFDataLoader","dataset","split","config","options","url","response","data","error","offset","length","ds","rows","count","fields","renameMap","item","result","field","keys","value","key","resultFieldName","v","defaultOutput","message","axCreateDefaultOptimizerColorLogger","output","cl","ColorLog","lightDivider","heavyDivider","data","formattedMessage","config","configParts","key","value","improvement","improvementStr","totalRounds","explanationSection","rec","idx","p","axCreateDefaultOptimizerTextLogger","divider","axDefaultOptimizerLogger","axDefaultOptimizerMetricsConfig","globalOptimizerMetricsInstruments","getOrCreateOptimizerMetricsInstruments","meter","createOptimizerMetricsInstruments","currentOptimizerMetricsConfig","axDefaultOptimizerMetricsConfig","axUpdateOptimizerMetricsConfig","config","axGetOptimizerMetricsConfig","createOptimizerMetricsInstruments","meter","sanitizeOptimizerLabels","labels","sanitized","key","value","stringValue","maxLength","recordOptimizationMetric","instruments","duration","success","optimizerType","programSignature","error","recordConvergenceMetric","rounds","currentScore","improvement","stagnationRounds","recordEarlyStoppingMetric","reason","recordResourceUsageMetric","tokensUsed","costIncurred","memoryUsage","recordOptimizationDurationMetric","recordTeacherStudentMetric","latency","scoreImprovement","recordCheckpointMetric","operation","recordParetoMetric","frontSize","solutionsGenerated","hypervolume","recordProgramComplexityMetric","inputFields","outputFields","examplesCount","validationSetSize","recordOptimizerPerformanceMetric","metricType","recordOptimizerConfigurationMetric","targetScore","maxRounds","AxOptimizedProgramImpl","program","AxDefaultCostTracker","options","count","model","totalCost","tokens","costPer1K","AxBaseOptimizer","args","costTracker","getOrCreateOptimizerMetricsInstruments","axGlobals","axDefaultOptimizerLogger","seed","startTime","bestScoreRound","examples","requireSplit","recommendedMin","preferTeacher","task","ai","metricFn","earlyStopReason","updateProgress","round","score","configuration","optimizerConfig","bestScore","bestConfiguration","optimizerState","onEarlyStop","_stats","onProgress","progress","compileResult","_optimizerType","solutions","constraintSolutions","allSolutions","paretoFront","sol","sampleExample","samplePrediction","sampleScores","objectives","weightCombinations","i","weights","weightedMetric","prediction","example","scores","weightedScore","objective","result","primaryObjective","constraintMetric","primaryScore","penalty","combinations","obj","equalWeights","obj1","obj2","w1","w2","obj3","testProgram","AxGen","_predictions","valSplitSize","valSet","allScores","evalSet","avgScores","sum","solutionA","isDominated","dominatedCount","j","solutionB","scoresA","scoresB","atLeastAsGood","strictlyBetter","scoreA","scoreB","firstSolution","sortedSolutions","a","b","prevScore2","solution","score1","score2","saveFn","checkpointId","checkpoint","loadFn","interval","currentCost","totalTokens","_options","converged","totalCalls","successRate","humanExplanation","recommendations","demos","performanceAssessment","explanation","optLogger","s","signature","AxSignature","ax","options","typedSignature","AxGen","import_node_crypto","createEmptyPlaybook","description","timestamp","clonePlaybook","playbook","estimateTokenCount","text","applyCuratorOperations","operations","options","updatedBullets","autoRemoved","maxSectionSize","allowDynamicSections","enableAutoPrune","protectedBulletIds","now","protectedIds","op","section","pruned","pruneSectionForAddition","id","generateBulletId","bullet","b","idx","removed","recomputePlaybookStats","updateBulletFeedback","bulletId","tag","renderPlaybook","header","sections","sectionName","bullets","body","normalized","randomHex","crypto","candidateIndex","candidateScore","index","helpful","harmful","netScore","recency","score","candidateBullet","candidateHelpful","candidateHarmful","candidateNet","candidateRecency","candidateVector","dedupePlaybookByContent","_similarityThreshold","seen","unique","key","existing","bulletCount","helpfulCount","harmfulCount","tokenEstimate","DEFAULT_CONFIG","AxACEOptimizedProgram","AxOptimizedProgramImpl","config","clonePlaybook","program","signature","combinedInstruction","renderPlaybook","block","AxACE","AxBaseOptimizer","args","options","createEmptyPlaybook","level","examples","metricFn","aceOptions","startTime","baseInstruction","originalDescription","bestScore","round","epochs","totalRoundsTarget","epoch","index","example","composedInstruction","prediction","score","predictedSeverity","expectedSeverity","generatorOutput","severityMismatch","reflection","rawCurator","operations","curatorResult","appliedDeltaIds","protectedIds","applicationResult","applyCuratorOperations","tag","updateBulletFeedback","dedupePlaybookByContent","feedbackEvent","numericScore","bestScoreForProgress","progressOptions","optimizationTime","artifact","optimizedProgram","result","playbook","part","reasoning","bulletIds","resolved","usedIds","op","id","sectionQueues","enqueueCandidate","bulletId","priority","located","queues","dequeueForSection","section","shift","list","candidate","operation","sectionBullets","bullet","entry","bullets","normalized","seen","typeRaw","typeUpper","type","sectionRaw","contentRaw","content","bulletIdRaw","key","normalizedEntry","metadataRaw","parsed","opsObj","addOperation","trimmed","feedback","rounds","previous","errorText","previousReflection","reflector","reflectorAI","expectedAnswer","error","curator","curatorAI","f","ax","AxBootstrapFewShot","AxBaseOptimizer","args","options","program","examples","roundIndex","metricFn","_st","maxDemos","aiOpt","examplesSample","randomSample","previousSuccessCount","i","batch","ex","exList","e","aiService","res","forwardOptions","error","improvement","maxRounds","demos","groupTracesByKeys","bestScore","programTraces","groupedTraces","programTrace","traces","programDemosArray","programId","array","n","clonedArray","j","caI","caJ","dominatesVectorEps","a","b","eps","keys","atLeastAsGood","strictlyBetter","k","va","vb","buildParetoFront","items","front","i","dominatedCount","isDominated","j","hypervolume2D","front","keys","k1","k2","sorted","b","hv","prevY","p","x","y","dy","average","a","s","v","avgVec","arrs","sums","counts","k","v","out","s","removeDominatedProgramsByInstanceFronts","fronts","scores","allPrograms","f","p","sorted","a","b","dominated","isDominated","y","others","front","found","o","progress","dominators","dominatorSet","nf","selectProgramCandidateFromInstanceFronts","rng","reduced","freq","sampling","pStr","count","r","idx","AxGEPA","AxBaseOptimizer","args","seedRaw","seedNum","argPareto","argCrossoverEvery","argTieEps","argFbMem","argMergeMax","program","examples","metricFn","options","_startTime","validationExamples","feedbackExamples","paretoSet","feedbackSet","evalOne","instruction","ex","prediction","evalOnSet","set","vecs","avgVec","baseInstruction","candidates","scalarize","v","key","fn","vals","a","b","perInstanceScores","evalOnSetScalar","out","vec","_selectParentIdx","nInst","instanceFronts","i","best","front","k","perProgScores","arr","average","selectProgramCandidateFromInstanceFronts","stagnation","archive","buildParetoFront","c","idx","p","_prevHypervolume","rolloutBudgetParetoRaw","rolloutBudgetPareto","t","ancestors","path","cur","rngPick","reducedFronts","removeDominatedProgramsByInstanceFronts","mergeCandidatesSet","f","mergeCandidates","picked","attempts","j","Ai","Aj","commons","x","weights","r","s","w","Sa","Si","Sj","instrA","instrI","instrJ","desirable","allowed","childInstrMerged","descSig","attempted","triKey","compKey","s1","s2","allIdx","_","z","p1","p2","p3","K","nEach","pickSome","used","chosen","rem","remaining","unused","idxs","subsample","newSum","id1Sum","id2Sum","childVec","beforeSize","hvBefore","hypervolume2D","hvAfter","parentIdx","mini","perfect","parentMiniScores","useMerge","childInstr","strategy","adapterParentSum","adapterChildSum","second","adapter","parentMap","evalParent","reflDs","proposedMap","proposedText","example","scores","evalChild","parentMiniArr","childMiniArr","parentMiniSum","childMiniSum","pareto","bestScore","bestCandidateIdx","maxS","hv","optimizationTime","optimizedProgram","AxOptimizedProgramImpl","level","sig","score","threshold","err","currentInstruction","minibatch","tuples","pred","aiToUse","critic","ax","externalFeedback","feedbackFn","fb","feedbackSummary","refl","instr","trainSize","ids","mb","mod","numToPad","padded","id","iteration","blocksPerEpoch","currEpoch","base","paretoFront","hypervolume","instructionA","instructionB","merger","AxGEPAFlow","AxBaseOptimizer","args","seedRaw","seedNum","argPareto","argMergeMax","level","program","examples","metricFn","options","_startTime","flow","nodes","validationExamples","feedbackExamples","paretoSet","feedbackSet","evalOne","cfg","ex","prediction","evalOnSet","set","vecs","avgVec","baseInstrs","n","candidates","scalarize","v","key","fn","vals","a","b","perInstanceScores","evalOnSetScalar","out","vec","archive","buildParetoFront","c","idx","p","stagnation","triedMerges","rolloutBudgetRaw","rolloutBudget","t","nInst","instanceFronts","i","best","front","k","perProgScores","arr","average","reducedFronts","removeDominatedProgramsByInstanceFronts","mergeCandidatesSet","f","mergeCandidates","ancestors","path","cur","rngPick","picked","attempts","j","Ai","Aj","commons","x","desirables","cfgA","cfgI","cfgJ","ok","allKeys","pa","pi","pj","weights","r","s","w","Sa","Si","Sj","triKey","mergedCfg","descSig","ia","ib","compKey","s1","s2","allIdx","_","z","p1","p2","p3","K","nEach","pickSome","used","chosen","rem","remaining","unused","idxs","subsample","newSum","id1Sum","id2Sum","childVec","beforeSize","hvBefore","hypervolume2D","hvAfter","parentIdx","selectProgramCandidateFromInstanceFronts","mini","perfect","parentMiniScores","useCrossover","proposedCfg","strategy","moduleIndex","module","adapterParentSum","adapterChildSum","second","common","doMerge","desirable","i0","j0","sa","sb","currentInstr","adapter","newInstr","evalParent","reflDs","proposedText","example","scores","evalChild","parentMiniArr","childMiniArr","parentMiniSum","childMiniSum","pareto","bestScore","hv","sig","score","moduleName","currentInstruction","_nodes","minibatch","_tuples","local","pred","aiToUse","critic","ax","external","feedbackFn","fb","feedbackSummary","refl","instr","trainSize","ids","mb","mod","numToPad","padded","id","iteration","blocksPerEpoch","currEpoch","base","pickBetter","merged","picks","pick","PythonOptimizerClient","options","error","request","response","jobId","studyName","pollInterval","maxWaitTime","startTime","status","path","url","lastError","attempt","controller","timeoutId","ms","resolve","AxMiPRO","AxBaseOptimizer","args","clientOptions","msg","PythonOptimizerClient","data","idx","r","counts","key","entry","bestKey","best","k","v","level","program","ai","summaryPrompt","response","examples","sampleSize","ex","i","tip","candidateIndex","programSummary","datasetSummary","previousInstructions","contextInfo","_instructionPrompt","instruction","ax","enhancedTemplates","_program","options","instructions","aiToUse","tips","tipIndex","tipToUse","metricFn","AxBootstrapFewShot","selectedExamples","indices","example","config","bootstrappedDemos","labeledExamples","_startTime","axgen","issues","suggestions","_options","startTime","studyName","optimizationRequest","job","bestScore","bestConfiguration","totalTrials","stagnationRounds","trial","suggestion","temperature","topP","evalSet","size","score","configuration","finalBestScore","finalBestConfig","bestDemos","studyResults","explanation","out","optimizedGen","AxGen","optimizedProgram","AxOptimizedProgramImpl","demosCount","totalScore","validResults","successCount","evaluationExamples","demosForConfig","prediction","threshold","_error","AxFlowDependencyAnalyzer","mapping","_nodeName","dependencies","source","stateAccessMatches","match","tracker","error","target","accessed","self","obj","prop","value","functionSource","templateMatches","destructureMatches","i","_target","processBatches","items","processor","batchSize","promises","item","index","results","i","batchPromises","batchIndex","originalIndex","result","batchResults","AxFlowExecutionPlanner","AxFlowDependencyAnalyzer","stepFunction","nodeName","mapping","stepType","mapTransform","mergeOptions","deriveOptions","dependencies","produces","type","allFields","transform","branchFields","otherDependencies","v","i","a","dep","step","sourceAnalysis","error","mockState","originalKeys","result","addedFields","key","source","fieldAssignments","fields","assignment","match","propertyAssignments","_fields","field","fieldName","recentExecuteSteps","processedSteps","availableFields","currentLevel","currentLevelSteps","remainingSteps","nextStep","batchSize","optimizedSteps","group","parallelStep","state","context","results","processBatches","parallelResult","mergedState","g","import_api","defaultOutput","message","formatState","state","hideContent","formatted","key","value","objStr","formatTime","ms","axCreateFlowColorLogger","output","cl","ColorLog","divider","smallDivider","data","formattedMessage","stepIcon","completeIcon","axCreateFlowTextLogger","axDefaultFlowLogger","createTimingLogger","logger","timingData","start","duration","AxFlowSubContextImpl","nodeGenerators","nodeName","mapping","dynamicContext","nodeProgram","state","context","ai","options","nodeInputs","traceLabel","result","transform","initialState","currentState","step","AxFlowTypedSubContextImpl","AxFlow","_AxFlow","AxFlowExecutionPlanner","str","_","letter","steps","initialState","context","_isOptimized","state","stepsExecuted","i","step","stepType","stepMetadata","previousFields","stepStartTime","executionTime","newFields","field","nodeResult","resultFieldName","error","_index","source","index","stepInfo","s","nodeNameMatch","nodeExecMatch","executionPlan","f","allProducedFields","allConsumedFields","inputFieldNames","consumed","outputFieldNames","lastStep","produced","isConsumed","nodeName","nodeGen","outputFields","inputFields","sig","camelCaseName","inferredSignature","AxSignature","fieldName","options","axCreateFlowColorLogger","createTimingLogger","signature","AxProgram","_nodeName","nodeProgram","examples","id","parentId","allTraces","nodeTraces","demos","allUsage","nodeUsage","mergeProgramUsage","report","name","program","instruction","prog","anyProg","map","instr","ai","values","flowStartTime","inputValues","lastUserMessage","msg","tracer","providedCtx","parentSpan","parentCtx","execPlan","spanName","baseCtx","execContext","merged","useAutoParallel","optimizedSteps","result","totalExecutionTime","nodeValue","nodeGenerator","ax","programInstance","signatureOrAxGenOrClass","transformOrTransforms","transforms","parallelMapStep","processBatches","transform","acc","res","currentBranch","label","mapping","dynamicContext","nodeInputs","traceLabel","existingUsage","existingTraces","optimizedProgram","predicate","value","branchContext","mergeStep","branchValue","branchSteps","currentState","branches","parallelStep","results","branchFn","subContext","AxFlowSubContextImpl","resultKey","mergeFunction","parallelMergeStep","mergedValue","newState","condition","targetLabel","maxIterations","targetIndex","feedbackStepIndex","iterations","iterationKey","loopStartIndex","placeholderStep","loopBodySteps","outputFieldName","inputFieldName","transformFn","inputValue","batchSize","item","planInfo","baseSignature","extensions","extendedSig","input","output","flow","AxDockerSession","apiUrl","imageName","response","volumes","doNotPullImage","tag","binds","v","containerConfig","data","matchingContainers","container","randomIndex","selectedContainer","containerId","remove","timeout","results","containers","targetContainers","stopResponse","removeResponse","all","command","createResponse","execData","startResponse","startTime","resolve","endpoint","options","url","AxEmbeddingAdapter","ai","info","func","text","extra","embeds","options","AxMCPClient","transport","options","message","res","expectedProtocolVersion","fn","override","parameters","args","result","timeout","pingPromise","timeoutPromise","_","reject","response","id","entry","method","params","requestId","randomUUID","request","responsePromise","resolve","errorObj","err","notification","debug","loggerData","base64url","bytes","binary","i","sha256Bytes","input","data","digest","getCrypto","newCodeVerifier","randomUUID","newCodeChallenge","verifier","fetchJSON","url","headers","res","toQuery","params","usp","k","v","stripTrailingSlash","parseWWWAuthenticateForResourceMetadata","www","match","discoverResourceAndAS","requestedUrl","wwwAuthenticate","headerUrl","rsMeta","fetchJSON","expectedResource","stripTrailingSlash","rsResource","issuers","u","trimmedPath","candidates","lastErr","c","meta","exp","err","discoverASMetadata","issuer","path","endpoints","e","methods","OAuthHelper","oauth","resource","issuer","k","t","token","ts","meta","discoverASMetadata","options","issuers","discoverResourceAndAS","asMeta","existing","refreshed","redirectUri","client","codeVerifier","newCodeVerifier","codeChallenge","newCodeChallenge","state","scopes","authUrl","toQuery","code","maybeRedirect","usedRedirectUri","body","res","json","args","expiresAt","refreshToken","_issuer","AxMCPStreambleHTTPTransport","mcpEndpoint","options","OAuthHelper","headers","authorization","baseHeaders","handler","resolve","reject","url","event","message","error","response","www","ensured","reader","decoder","buffer","processStream","done","value","lines","line","data","body","sessionIdHeader","contentType","requestId","processChunk","AxMCPHTTPSSETransport","sseUrl","options","OAuthHelper","base","headers","ac","res","www","ensured","ready","resolver","promise","resolve","response","reader","decoder","buffer","eventType","done","value","lines","line","data","raw","uri","parsed","msg","id","entry","message","baseHeaders","body","pending","reject","json","processChildAgentFunction","childFunction","parentValues","parentInputKeys","modelList","options","processedFunction","childKeys","injectionKeys","key","removePropertiesFromSchema","originalFunc","childArgs","funcOptions","valuesToInject","lastUserMessage","msg","pick","updatedChildArgs","addModelParameter","descriptionError","definitionError","AxAgent","_AxAgent","ai","name","description","definition","signature","agents","functions","disableSmartModelRouting","excludeFieldsFromPassthrough","debug","AxGen","agent","toCamelCase","mm","config","typedSignature","AxSignature","examples","id","parentId","demos","boundFunc","wrappedFunc","valuesAndModel","model","values","ret","outFields","k","field","f","parentAi","parentKeys","p","agentFuncs","processOptions","mergedOptions","optimizedProgram","inputString","word","index","lowerWord","parameters","models","baseSchema","modelProperty","m","newProperties","newRequired","schema","keys","newSchema","filteredRequired","obj","result","axRAG","queryFn","options","maxHops","qualityThreshold","maxIterations","qualityTarget","disableQualityHealing","flow","state","searchQuery","retrievedDocument","queries","retrievalResults","query","priorEvidence","newRetrievals","evidence","fromAccumulated","fromSynth","fallback","issues","healingQuery","healingDocument"]}