import { ai } from '@ax-llm/ax';
import { privateKeyToAccount } from 'viem/accounts';
import { wrapFetchWithPayment } from 'x402-fetch';
import { z } from 'zod';

// src/utils/x402.ts
var DEFAULT_MODEL = "gpt-5";
var DEFAULT_PROVIDER = "openai";
var DEFAULT_API_URL = "http://localhost:3030/v1";
var createX402Fetch = ({
  account,
  fetchImpl
}) => {
  if (!account) {
    throw new Error("[agent-kit] createX402Fetch requires an account");
  }
  const paymentFetch = wrapFetchWithPayment(
    fetchImpl ?? fetch,
    account
  );
  return Object.assign(
    (input, init) => paymentFetch(input, init ?? {}),
    {
      preconnect: paymentFetch.preconnect ?? (async () => {
      })
    }
  );
};
var accountFromPrivateKey = (privateKey) => {
  if (!privateKey || privateKey.trim().length === 0) {
    throw new Error(
      "[agent-kit] accountFromPrivateKey requires a non-empty private key"
    );
  }
  return privateKeyToAccount(privateKey);
};
var createX402LLM = (options = {}) => {
  const account = options.account ?? (options.privateKey ? accountFromPrivateKey(options.privateKey) : void 0);
  if (!account) {
    throw new Error(
      "[agent-kit] createX402LLM requires either an account or a private key"
    );
  }
  const paymentFetch = options.fetch ?? createX402Fetch({ account, fetchImpl: options.fetchImpl });
  const aiOverrides = options.ai ?? {};
  const {
    config: configOverridesRaw,
    options: optionOverridesRaw,
    apiKey: apiKeyOverrideRaw,
    apiURL: apiUrlOverrideRaw,
    name: nameOverrideRaw,
    ...restAiProps
  } = aiOverrides;
  const configOverrides = configOverridesRaw && typeof configOverridesRaw === "object" ? configOverridesRaw : void 0;
  const optionOverrides = optionOverridesRaw && typeof optionOverridesRaw === "object" ? optionOverridesRaw : void 0;
  const explicitApiKey = typeof apiKeyOverrideRaw === "string" && apiKeyOverrideRaw.trim().length > 0 ? apiKeyOverrideRaw : void 0;
  const nameOverride = typeof nameOverrideRaw === "string" && nameOverrideRaw.trim().length > 0 ? nameOverrideRaw : void 0;
  const apiUrlOverride = typeof apiUrlOverrideRaw === "string" && apiUrlOverrideRaw.trim().length > 0 ? apiUrlOverrideRaw : void 0;
  const apiKey = explicitApiKey ?? process.env.OPENAI_API_KEY;
  if (!apiKey) {
    throw new Error(
      "[agent-kit] createX402LLM requires an OpenAI API key (set options.ai.apiKey or OPENAI_API_KEY)"
    );
  }
  const baseConfig = {
    stream: true,
    model: options.model ?? DEFAULT_MODEL
  };
  const finalConfig = {
    ...baseConfig,
    ...configOverrides ?? {}
  };
  const finalOptions = {
    ...optionOverrides ?? {},
    fetch: paymentFetch
  };
  const aiArgs = {
    ...restAiProps,
    name: nameOverride ?? DEFAULT_PROVIDER,
    apiKey,
    apiURL: apiUrlOverride ?? DEFAULT_API_URL,
    config: finalConfig,
    options: finalOptions
  };
  return ai(aiArgs);
};
var x402LLM = ({
  privateKey = process.env.PRIVATE_KEY,
  model = DEFAULT_MODEL,
  apiURL = DEFAULT_API_URL
}) => createX402LLM({
  privateKey,
  model,
  ai: { apiURL }
});

// src/utils/axllm.ts
var DEFAULT_PROVIDER2 = "openai";
var DEFAULT_MODEL2 = "gpt-5";
function createAxLLMClient(options = {}) {
  const resolved = resolveOptions(options);
  const logger = options.logger;
  const axInstance = (() => {
    if (options.client) return options.client;
    const fromFactory = options.clientFactory?.();
    if (fromFactory) return fromFactory;
    try {
      return createX402LLM(buildCreateOptions(resolved, options.x402));
    } catch (error) {
      logger?.warn?.(
        `[agent-kit] failed to initialise Ax LLM client: ${error.message}`,
        error
      );
      return null;
    }
  })();
  return {
    ax: axInstance,
    isConfigured() {
      return Boolean(axInstance);
    }
  };
}
function resolveOptions(options) {
  const env = readEnv(options.env);
  const provider = options.provider ?? env.AX_PROVIDER ?? env.AXLLM_PROVIDER ?? env.OPENAI_PROVIDER ?? DEFAULT_PROVIDER2;
  const model = options.model ?? env.AX_MODEL ?? env.AXLLM_MODEL ?? env.OPENAI_MODEL ?? DEFAULT_MODEL2;
  const apiKey = options.apiKey ?? env.OPENAI_API_KEY;
  const temperature = options.temperature ?? parseNumber(
    env.AX_TEMPERATURE ?? env.AXLLM_TEMPERATURE ?? env.OPENAI_TEMPERATURE
  );
  const debug = options.debug ?? parseBoolean(env.AX_DEBUG ?? env.AXLLM_DEBUG) ?? false;
  return { provider, model, apiKey, temperature, debug };
}
function buildCreateOptions(resolved, overrides) {
  const x402 = overrides ? { ...overrides } : {};
  const aiOverrides = overrides?.ai ? { ...overrides.ai } : {};
  const aiConfigOverrides = aiOverrides.config && typeof aiOverrides.config === "object" ? { ...aiOverrides.config } : void 0;
  const aiOptionOverrides = aiOverrides.options && typeof aiOverrides.options === "object" ? { ...aiOverrides.options } : void 0;
  const finalTemperature = aiConfigOverrides && "temperature" in aiConfigOverrides ? aiConfigOverrides.temperature : resolved.temperature;
  const finalConfig = {
    stream: true,
    model: aiConfigOverrides?.model ?? x402.model ?? resolved.model,
    ...aiConfigOverrides ?? {},
    ...finalTemperature !== void 0 ? { temperature: finalTemperature } : {}
  };
  const finalOptions = {
    ...aiOptionOverrides ?? {},
    ...resolved.debug ? { debug: resolved.debug } : {}
  };
  const apiKey = aiOverrides.apiKey ?? resolved.apiKey ?? (typeof process !== "undefined" ? process.env.OPENAI_API_KEY : void 0);
  if (!apiKey) {
    throw new Error(
      "[agent-kit] createAxLLMClient requires an OpenAI API key (set apiKey or OPENAI_API_KEY)"
    );
  }
  const name = aiOverrides.name ?? resolved.provider;
  const finalAi = {
    ...aiOverrides,
    name,
    apiKey,
    config: finalConfig,
    options: finalOptions
  };
  const createOptions = {
    ...x402,
    model: x402.model ?? resolved.model,
    ai: finalAi
  };
  if (!createOptions.account && !createOptions.privateKey) {
    const envPrivateKey = typeof process !== "undefined" ? process.env.PRIVATE_KEY : void 0;
    if (envPrivateKey) {
      createOptions.privateKey = envPrivateKey;
    }
  }
  return createOptions;
}
function readEnv(env) {
  if (env) return env;
  if (typeof process !== "undefined" && process?.env) {
    return process.env;
  }
  return {};
}
function parseBoolean(value) {
  if (value === void 0) return void 0;
  if (value.trim() === "") return void 0;
  return ["1", "true", "yes", "on"].includes(value.toLowerCase());
}
function parseNumber(value) {
  if (value === void 0) return void 0;
  const numeric = Number.parseFloat(value);
  return Number.isFinite(numeric) ? numeric : void 0;
}

// src/config.ts
var DEFAULT_FACILITATOR_URL = "https://facilitator.daydreams.systems";
var DEFAULT_PAYMENT_WALLET_ADDRESS = "0xb308ed39d67D0d4BAe5BC2FAEF60c66BBb6AE429";
var DEFAULT_NETWORK = "base-sepolia";
var DEFAULT_AGENT_API_BASE_URL = "http://localhost:8787";
var defaultConfig = {
  payments: {
    facilitatorUrl: DEFAULT_FACILITATOR_URL,
    payTo: DEFAULT_PAYMENT_WALLET_ADDRESS,
    network: DEFAULT_NETWORK,
    defaultPrice: void 0
  },
  wallet: {
    apiBaseUrl: DEFAULT_AGENT_API_BASE_URL,
    maxPaymentBaseUnits: void 0,
    maxPaymentUsd: void 0
  }
};
function parseBigIntEnv(value) {
  if (!value) return void 0;
  try {
    const parsed = BigInt(value);
    return parsed > 0n ? parsed : void 0;
  } catch {
    return void 0;
  }
}
function parseNumberEnv(value) {
  if (!value) return void 0;
  const numeric = Number(value);
  if (!Number.isFinite(numeric) || numeric <= 0) return void 0;
  return numeric;
}
var environmentConfig = {
  payments: {
    facilitatorUrl: process.env.FACILITATOR_URL,
    payTo: process.env.ADDRESS,
    network: process.env.NETWORK,
    defaultPrice: process.env.DEFAULT_PRICE ?? void 0
  },
  wallet: {
    apiBaseUrl: process.env.LUCID_API_URL ?? process.env.VITE_API_URL ?? void 0,
    maxPaymentBaseUnits: parseBigIntEnv(
      process.env.AGENT_WALLET_MAX_PAYMENT_BASE_UNITS
    ),
    maxPaymentUsd: parseNumberEnv(process.env.AGENT_WALLET_MAX_PAYMENT_USDC)
  }
};
var runtimeOverrides = {};
function assignDefined(target, source) {
  if (!source) return;
  for (const [key, value] of Object.entries(source)) {
    if (value !== void 0) {
      target[key] = value;
    }
  }
}
function applyOverrides(base, overrides) {
  if (!overrides) return base;
  const next = {
    payments: { ...base.payments },
    wallet: { ...base.wallet }
  };
  assignDefined(next.payments, overrides.payments);
  assignDefined(next.wallet, overrides.wallet);
  return next;
}
function getAgentKitConfig() {
  const withEnv = applyOverrides(defaultConfig, environmentConfig);
  return applyOverrides(withEnv, runtimeOverrides);
}

// src/utils/utils.ts
var ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
function normalizeDomain(domain) {
  return domain?.trim?.().toLowerCase?.() ?? "";
}
function normalizeAddress(value) {
  if (!value) {
    throw new Error("invalid hex address");
  }
  const trimmed = value.trim();
  if (!/^0x[0-9a-fA-F]{40}$/.test(trimmed)) {
    throw new Error(`invalid hex address: ${value}`);
  }
  return trimmed.toLowerCase();
}
function sanitizeAddress(value) {
  if (!value) return ZERO_ADDRESS;
  try {
    return normalizeAddress(value);
  } catch {
    return ZERO_ADDRESS;
  }
}
function toJsonSchemaOrUndefined(s) {
  if (!s) return void 0;
  try {
    return z.toJSONSchema(s);
  } catch {
    return void 0;
  }
}
function paymentsFromEnv(params) {
  const { payments } = getAgentKitConfig();
  return {
    payTo: payments.payTo,
    facilitatorUrl: payments.facilitatorUrl,
    network: payments.network,
    defaultPrice: params?.defaultPrice ?? payments.defaultPrice
  };
}

export { ZERO_ADDRESS, accountFromPrivateKey, createAxLLMClient, createX402Fetch, createX402LLM, normalizeAddress, normalizeDomain, paymentsFromEnv, sanitizeAddress, toJsonSchemaOrUndefined, x402LLM };
//# sourceMappingURL=utils.js.map
//# sourceMappingURL=utils.js.map