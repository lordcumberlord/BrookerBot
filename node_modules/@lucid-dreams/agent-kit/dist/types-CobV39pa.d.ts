import { ZodObject } from 'zod';
import { Network, SolanaAddress, Resource } from 'x402-hono';

declare const CONTACT_ADDRESS_DATA_KEY: "contact_picker.ContactAddress";
type ContactAddress = {
    city?: string | null;
    country?: string | null;
    dependent_locality?: string | null;
    organization?: string | null;
    phone_number?: string | null;
    postal_code?: string | null;
    recipient?: string | null;
    region?: string | null;
    sorting_code?: string | null;
    address_line?: string[] | null;
};
declare const PAYMENT_METHOD_DATA_KEY: "payment_request.PaymentMethodData";
type PaymentCurrencyAmount = {
    currency: string;
    value: number;
};
type PaymentItem = {
    label: string;
    amount: PaymentCurrencyAmount;
    pending?: boolean | null;
    refund_period?: number;
};
type PaymentShippingOption = {
    id: string;
    label: string;
    amount: PaymentCurrencyAmount;
    selected?: boolean | null;
};
type PaymentOptions = {
    request_payer_name?: boolean | null;
    request_payer_email?: boolean | null;
    request_payer_phone?: boolean | null;
    request_shipping?: boolean | null;
    shipping_type?: "shipping" | "delivery" | "pickup" | null;
};
type PaymentMethodData = {
    supported_methods: string;
    data?: Record<string, unknown>;
};
type PaymentDetailsModifier = {
    supported_methods: string;
    total?: PaymentItem;
    additional_display_items?: PaymentItem[];
    data?: unknown;
};
type PaymentDetailsInit = {
    id: string;
    display_items: PaymentItem[];
    shipping_options?: PaymentShippingOption[];
    modifiers?: PaymentDetailsModifier[];
    total: PaymentItem;
};
type PaymentRequest = {
    method_data: PaymentMethodData[];
    details: PaymentDetailsInit;
    options?: PaymentOptions;
    shipping_address?: ContactAddress;
};
type PaymentResponse = {
    request_id: string;
    method_name: string;
    details?: Record<string, unknown>;
    shipping_address?: ContactAddress;
    shipping_option?: PaymentShippingOption;
    payer_name?: string | null;
    payer_email?: string | null;
    payer_phone?: string | null;
};
declare const INTENT_MANDATE_DATA_KEY: "ap2.mandates.IntentMandate";
declare const CART_MANDATE_DATA_KEY: "ap2.mandates.CartMandate";
declare const PAYMENT_MANDATE_DATA_KEY: "ap2.mandates.PaymentMandate";
type IntentMandate = {
    user_cart_confirmation_required: boolean;
    natural_language_description: string;
    merchants?: string[] | null;
    skus?: string[] | null;
    requires_refundability?: boolean | null;
    intent_expiry: string;
};
type CartContents = {
    id: string;
    user_cart_confirmation_required: boolean;
    payment_request: PaymentRequest;
    cart_expiry: string;
    merchant_name: string;
};
type CartMandate = {
    contents: CartContents;
    merchant_authorization?: string | null;
};
type PaymentMandateContents = {
    payment_mandate_id: string;
    payment_details_id: string;
    payment_details_total: PaymentItem;
    payment_response: PaymentResponse;
    merchant_agent: string;
    timestamp: string;
};
type PaymentMandate = {
    payment_mandate_contents: PaymentMandateContents;
    user_authorization?: string | null;
};
declare const AP2_EXTENSION_URI: "https://github.com/google-agentic-commerce/ap2/tree/v0.1";
type AP2Role = "merchant" | "shopper" | "credentials-provider" | "payment-processor";
type AP2ExtensionParams = {
    roles: [AP2Role, ...AP2Role[]];
    [key: string]: unknown;
};
type AP2ExtensionDescriptor = {
    uri: typeof AP2_EXTENSION_URI;
    description?: string;
    required?: boolean;
    params: AP2ExtensionParams;
};

type TrustModel = "feedback" | "inference-validation" | "tee-attestation" | string;
type RegistrationEntry = {
    agentId: number | string;
    agentAddress: string;
    signature?: string;
    [key: string]: unknown;
};
type TrustConfig = {
    registrations?: RegistrationEntry[];
    trustModels?: TrustModel[];
    validationRequestsUri?: string;
    validationResponsesUri?: string;
    feedbackDataUri?: string;
};
type Usage = {
    prompt_tokens?: number;
    completion_tokens?: number;
    total_tokens?: number;
};
type AgentMeta = {
    name: string;
    version: string;
    description?: string;
};
type AgentContext = {
    key: string;
    input: any;
    signal: AbortSignal;
    headers: Headers;
    runId: string;
};
type StreamEnvelopeBase = {
    runId?: string;
    sequence?: number;
    createdAt?: string;
    metadata?: Record<string, unknown>;
};
type StreamRunStartEnvelope = StreamEnvelopeBase & {
    kind: "run-start";
    runId: string;
};
type StreamTextEnvelope = StreamEnvelopeBase & {
    kind: "text";
    text: string;
    mime?: string;
    role?: string;
};
type StreamDeltaEnvelope = StreamEnvelopeBase & {
    kind: "delta";
    delta: string;
    mime?: string;
    final?: boolean;
    role?: string;
};
type StreamAssetInlineTransfer = {
    transfer: "inline";
    data: string;
};
type StreamAssetExternalTransfer = {
    transfer: "external";
    href: string;
    expiresAt?: string;
};
type StreamAssetEnvelope = StreamEnvelopeBase & {
    kind: "asset";
    assetId: string;
    mime: string;
    name?: string;
    sizeBytes?: number;
} & (StreamAssetInlineTransfer | StreamAssetExternalTransfer);
type StreamControlEnvelope = StreamEnvelopeBase & {
    kind: "control";
    control: string;
    payload?: unknown;
};
type StreamErrorEnvelope = StreamEnvelopeBase & {
    kind: "error";
    code: string;
    message: string;
    retryable?: boolean;
};
type StreamRunEndEnvelope = StreamEnvelopeBase & {
    kind: "run-end";
    runId: string;
    status: "succeeded" | "failed" | "cancelled";
    output?: unknown;
    usage?: Usage;
    model?: string;
    error?: {
        code: string;
        message?: string;
    };
};
type StreamEnvelope = StreamRunStartEnvelope | StreamTextEnvelope | StreamDeltaEnvelope | StreamAssetEnvelope | StreamControlEnvelope | StreamErrorEnvelope | StreamRunEndEnvelope;
type StreamPushEnvelope = Exclude<StreamEnvelope, StreamRunStartEnvelope | StreamRunEndEnvelope>;
type StreamResult = {
    output?: unknown;
    usage?: Usage;
    model?: string;
    status?: "succeeded" | "failed" | "cancelled";
    error?: {
        code: string;
        message?: string;
    };
    metadata?: Record<string, unknown>;
};
type EntrypointDef = {
    key: string;
    description?: string;
    input?: ZodObject;
    output?: ZodObject;
    streaming?: boolean;
    price?: string | {
        invoke?: string;
        stream?: string;
    };
    network?: Network;
    handler?: (ctx: AgentContext) => Promise<{
        output: any;
        usage?: Usage;
        model?: string;
    }>;
    stream?: (ctx: AgentContext, emit: (chunk: StreamPushEnvelope) => Promise<void>) => Promise<StreamResult>;
};
type Manifest = {
    name: string;
    version: string;
    description?: string;
    entrypoints: Record<string, {
        description?: string;
        streaming: boolean;
        input_schema?: any;
        output_schema?: any;
        pricing?: {
            invoke?: string;
            stream?: string;
        };
    }>;
};
type PaymentMethod = {
    method: "x402";
    payee: `0x${string}` | SolanaAddress;
    network: Network;
    endpoint?: Resource;
    priceModel?: {
        default?: string;
    };
    extensions?: {
        [vendor: string]: unknown;
    };
};
type AgentCapabilities = {
    streaming?: boolean;
    pushNotifications?: boolean;
    stateTransitionHistory?: boolean;
    extensions?: Array<AP2ExtensionDescriptor | Record<string, unknown>>;
};
type AgentCard = {
    name: string;
    description?: string;
    url?: string;
    provider?: {
        organization?: string;
        url?: string;
    };
    version?: string;
    capabilities?: AgentCapabilities;
    defaultInputModes?: string[];
    defaultOutputModes?: string[];
    skills?: Array<{
        id: string;
        name?: string;
        description?: string;
        tags?: string[];
        examples?: string[];
        inputModes?: string[];
        outputModes?: string[];
        [key: string]: unknown;
    }>;
    supportsAuthenticatedExtendedCard?: boolean;
    payments?: PaymentMethod[];
    registrations?: RegistrationEntry[];
    trustModels?: TrustModel[];
    ValidationRequestsURI?: string;
    ValidationResponsesURI?: string;
    FeedbackDataURI?: string;
    [key: string]: unknown;
};
type AgentCardWithEntrypoints = AgentCard & {
    entrypoints: Manifest["entrypoints"];
};
type PaymentsConfig = {
    payTo: `0x${string}` | SolanaAddress;
    facilitatorUrl: Resource;
    network: Network;
    defaultPrice?: string;
};
type AP2Config = {
    roles: AP2Role[];
    description?: string;
    required?: boolean;
};

export { type AgentMeta as A, type PaymentDetailsModifier as B, CONTACT_ADDRESS_DATA_KEY as C, type PaymentDetailsInit as D, type EntrypointDef as E, type PaymentRequest as F, type PaymentResponse as G, CART_MANDATE_DATA_KEY as H, INTENT_MANDATE_DATA_KEY as I, PAYMENT_MANDATE_DATA_KEY as J, type IntentMandate as K, type CartContents as L, type Manifest as M, type CartMandate as N, type PaymentMandateContents as O, type PaymentsConfig as P, type PaymentMandate as Q, type RegistrationEntry as R, type StreamEnvelopeBase as S, type TrustConfig as T, type Usage as U, AP2_EXTENSION_URI as V, type AP2Role as W, type AP2ExtensionParams as X, type AP2ExtensionDescriptor as Y, type AP2Config as a, type AgentCardWithEntrypoints as b, type TrustModel as c, type AgentContext as d, type StreamRunStartEnvelope as e, type StreamTextEnvelope as f, type StreamDeltaEnvelope as g, type StreamAssetInlineTransfer as h, type StreamAssetExternalTransfer as i, type StreamAssetEnvelope as j, type StreamControlEnvelope as k, type StreamErrorEnvelope as l, type StreamRunEndEnvelope as m, type StreamEnvelope as n, type StreamPushEnvelope as o, type StreamResult as p, type PaymentMethod as q, type AgentCapabilities as r, type AgentCard as s, type ContactAddress as t, PAYMENT_METHOD_DATA_KEY as u, type PaymentCurrencyAmount as v, type PaymentItem as w, type PaymentShippingOption as x, type PaymentOptions as y, type PaymentMethodData as z };
