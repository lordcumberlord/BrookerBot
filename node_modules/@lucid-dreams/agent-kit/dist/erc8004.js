import 'zod';

// src/utils/utils.ts
var ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
function normalizeDomain(domain) {
  return domain?.trim?.().toLowerCase?.() ?? "";
}
function normalizeAddress(value) {
  if (!value) {
    throw new Error("invalid hex address");
  }
  const trimmed = value.trim();
  if (!/^0x[0-9a-fA-F]{40}$/.test(trimmed)) {
    throw new Error(`invalid hex address: ${value}`);
  }
  return trimmed.toLowerCase();
}

// src/erc8004.ts
var IDENTITY_REGISTRY_ABI = [
  {
    type: "function",
    name: "New",
    stateMutability: "nonpayable",
    inputs: [
      { name: "agentDomain", type: "string" },
      { name: "agentAddress", type: "address" }
    ],
    outputs: [{ name: "agentId", type: "uint256" }]
  },
  {
    type: "function",
    name: "Update",
    stateMutability: "nonpayable",
    inputs: [
      { name: "agentId", type: "uint256" },
      { name: "agentDomain", type: "string" },
      { name: "agentAddress", type: "address" }
    ],
    outputs: [{ name: "ok", type: "bool" }]
  },
  {
    type: "function",
    name: "Get",
    stateMutability: "view",
    inputs: [{ name: "agentId", type: "uint256" }],
    outputs: [
      { name: "agentId", type: "uint256" },
      { name: "agentDomain", type: "string" },
      { name: "agentAddress", type: "address" }
    ]
  },
  {
    type: "function",
    name: "ResolveByDomain",
    stateMutability: "view",
    inputs: [{ name: "agentDomain", type: "string" }],
    outputs: [
      { name: "agentId", type: "uint256" },
      { name: "agentDomain", type: "string" },
      { name: "agentAddress", type: "address" }
    ]
  },
  {
    type: "function",
    name: "ResolveByAddress",
    stateMutability: "view",
    inputs: [{ name: "agentAddress", type: "address" }],
    outputs: [
      { name: "agentId", type: "uint256" },
      { name: "agentDomain", type: "string" },
      { name: "agentAddress", type: "address" }
    ]
  }
];
function createIdentityRegistryClient(options) {
  const {
    address,
    chainId,
    publicClient,
    walletClient,
    namespace = "eip155"
  } = options;
  function ensureWalletClient() {
    if (!walletClient) {
      throw new Error(
        "identity registry client requires walletClient for writes"
      );
    }
    return walletClient;
  }
  async function readRecord(fn, args) {
    const result = await publicClient.readContract({
      address,
      abi: IDENTITY_REGISTRY_ABI,
      functionName: fn,
      args
    });
    if (!result) return null;
    const [agentId, agentDomain, agentAddress] = result;
    if (!agentDomain && (!agentAddress || agentAddress === ZERO_ADDRESS)) {
      return null;
    }
    return {
      agentId,
      agentDomain,
      agentAddress: normalizeAddress(agentAddress)
    };
  }
  return {
    address,
    chainId,
    async get(agentId) {
      const id = BigInt(agentId);
      return readRecord("Get", [id]);
    },
    resolveByDomain(domain) {
      const normalized = normalizeDomain(domain);
      return readRecord("ResolveByDomain", [normalized]);
    },
    resolveByAddress(rawAddress) {
      const normalized = normalizeAddress(rawAddress);
      return readRecord("ResolveByAddress", [normalized]);
    },
    async register(input) {
      const wallet = ensureWalletClient();
      const normalizedDomain = normalizeDomain(input.domain);
      const normalizedAddress = normalizeAddress(
        input.agentAddress ?? wallet.account?.address ?? ZERO_ADDRESS
      );
      if (!normalizedDomain) {
        throw new Error("agent domain is required");
      }
      if (!normalizedAddress || normalizedAddress === ZERO_ADDRESS) {
        throw new Error("agent address is required");
      }
      const txHash = await wallet.writeContract({
        address,
        abi: IDENTITY_REGISTRY_ABI,
        functionName: "New",
        args: [normalizedDomain, normalizedAddress]
      });
      let agentId;
      try {
        const record = await readRecord("ResolveByDomain", [normalizedDomain]);
        agentId = record?.agentId;
      } catch {
        agentId = void 0;
      }
      return {
        transactionHash: txHash,
        agentAddress: normalizedAddress,
        agentId
      };
    },
    async update(input) {
      const wallet = ensureWalletClient();
      const agentId = BigInt(input.agentId);
      const normalizedDomain = typeof input.domain === "string" ? normalizeDomain(input.domain) : "";
      const normalizedAddress = typeof input.agentAddress === "string" ? normalizeAddress(input.agentAddress) : ZERO_ADDRESS;
      if (!normalizedDomain && (!normalizedAddress || normalizedAddress === ZERO_ADDRESS)) {
        throw new Error("update requires domain and/or agentAddress");
      }
      const txHash = await wallet.writeContract({
        address,
        abi: IDENTITY_REGISTRY_ABI,
        functionName: "Update",
        args: [
          agentId,
          normalizedDomain,
          normalizedAddress && normalizedAddress !== ZERO_ADDRESS ? normalizedAddress : ZERO_ADDRESS
        ]
      });
      let resultingRecord = null;
      try {
        if (normalizedDomain) {
          resultingRecord = await readRecord("ResolveByDomain", [
            normalizedDomain
          ]);
        }
        if (!resultingRecord) {
          resultingRecord = await readRecord("Get", [agentId]);
        }
      } catch {
        resultingRecord = null;
      }
      return {
        transactionHash: txHash,
        agentId: resultingRecord?.agentId ?? agentId
      };
    },
    toRegistrationEntry(record, signature) {
      if (chainId == null) {
        throw new Error(
          "identity registry client needs chainId to build CAIP-10 registration entries"
        );
      }
      const agentAddress = toCaip10({
        namespace,
        chainId,
        address: record.agentAddress
      });
      const entry = {
        agentId: Number(record.agentId),
        agentAddress
      };
      if (signature) {
        entry.signature = signature;
      }
      return entry;
    }
  };
}
function toCaip10(params) {
  const namespace = params.namespace ?? "eip155";
  const chainRef = typeof params.chainId === "number" ? params.chainId.toString(10) : `${params.chainId ?? ""}`;
  if (!chainRef) throw new Error("chainId is required for CAIP-10");
  const address = params.address?.toLowerCase?.();
  if (!address || !address.startsWith("0x")) {
    throw new Error("address must be a hex string");
  }
  return `${namespace}:${chainRef}:${address}`;
}
async function signAgentDomainProof(options) {
  const { domain, address, chainId, nonce, signer } = options;
  const normalizedDomain = normalizeDomain(domain);
  if (!normalizedDomain) throw new Error("domain is required");
  const normalizedAddress = normalizeAddress(address);
  if (!normalizedAddress || normalizedAddress === ZERO_ADDRESS) {
    throw new Error("address must be a valid hex address");
  }
  const message = buildOwnershipMessage({
    domain: normalizedDomain,
    address: normalizedAddress,
    chainId,
    nonce
  });
  const signature = await invokeSignMessage(signer, message);
  return signature;
}
function buildTrustConfigFromIdentity(record, options) {
  const chainRef = options?.chainId;
  if (chainRef == null) {
    throw new Error(
      "chainId is required to generate trust config registration entry"
    );
  }
  const entry = {
    agentId: Number(record.agentId),
    agentAddress: toCaip10({
      namespace: options?.namespace,
      chainId: chainRef,
      address: record.agentAddress
    })
  };
  if (options?.signature) entry.signature = options.signature;
  return {
    registrations: [entry],
    ...options?.trustOverrides
  };
}
function buildOwnershipMessage(params) {
  const lines = [
    "ERC-8004 Agent Ownership Proof",
    `Domain: ${params.domain}`,
    `Address: ${params.address.toLowerCase()}`,
    `ChainId: ${params.chainId}`
  ];
  if (params.nonce) {
    lines.push(`Nonce: ${params.nonce}`);
  }
  return lines.join("\n");
}
async function invokeSignMessage(signer, message) {
  const candidate = signer;
  if (typeof candidate.signMessage !== "function") {
    throw new Error("signer does not expose signMessage");
  }
  try {
    const result2 = await candidate.signMessage(message);
    if (typeof result2 === "string") return result2;
  } catch (_) {
  }
  const result = await candidate.signMessage({ message });
  if (typeof result === "string") return result;
  throw new Error("signMessage did not return a signature string");
}
async function bootstrapTrust(options) {
  const normalizedDomain = normalizeDomain(options.domain);
  if (!normalizedDomain) {
    throw new Error("domain is required to bootstrap trust state");
  }
  const shouldRegister = Boolean(
    options.registerIfMissing && !options.skipRegister
  );
  const client = createIdentityRegistryClient({
    address: options.registryAddress,
    chainId: options.chainId,
    publicClient: options.publicClient,
    walletClient: options.walletClient,
    namespace: options.namespace
  });
  let record = await client.resolveByDomain(normalizedDomain).catch(() => null);
  let transactionHash;
  let didRegister = false;
  if (!record && options.onMissing) {
    const handled = await options.onMissing({
      client,
      normalizedDomain
    });
    if (handled) {
      record = handled;
    }
  }
  if (!record && shouldRegister) {
    const registration = await client.register({ domain: normalizedDomain });
    transactionHash = registration.transactionHash;
    didRegister = true;
    record = await client.resolveByDomain(normalizedDomain).catch(() => null);
    if (!record && registration.agentId != null) {
      record = {
        agentId: registration.agentId,
        agentDomain: normalizedDomain,
        agentAddress: registration.agentAddress
      };
    }
  }
  if (!record) {
    return {
      trust: void 0,
      record: null,
      transactionHash,
      didRegister
    };
  }
  let signature;
  if (options.signer) {
    signature = await signAgentDomainProof({
      domain: record.agentDomain,
      address: record.agentAddress,
      chainId: options.chainId,
      signer: options.signer,
      nonce: options.signatureNonce
    });
  }
  const trust = buildTrustConfigFromIdentity(record, {
    chainId: options.chainId,
    namespace: options.namespace,
    signature,
    trustOverrides: options.trustOverrides
  });
  return {
    trust,
    record,
    transactionHash,
    signature,
    didRegister
  };
}
var DEFAULT_CHAIN_ID = 84532;
var DEFAULT_NAMESPACE = "eip155";
var DEFAULT_TRUST_MODELS = [
  "feedback",
  "inference-validation"
];
var defaultLogger = {
  info: typeof console !== "undefined" && typeof console.info === "function" ? console.info.bind(console) : () => {
  },
  warn: typeof console !== "undefined" && typeof console.warn === "function" ? console.warn.bind(console) : () => {
  }
};
function parsePositiveInteger(value) {
  if (!value) return void 0;
  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed <= 0) return void 0;
  return Math.trunc(parsed);
}
function resolveTrustOverrides(domain, overrides, fallback) {
  const result = {};
  if (domain) {
    result.trustModels = DEFAULT_TRUST_MODELS;
    const origin = domain.startsWith("http") ? domain : `https://${domain}`;
    result.validationRequestsUri = `${origin}/validation/requests.json`;
    result.validationResponsesUri = `${origin}/validation/responses.json`;
    result.feedbackDataUri = `${origin}/feedback.json`;
  }
  if (fallback) {
    if (fallback.trustModels !== void 0) {
      result.trustModels = fallback.trustModels;
    }
    if (fallback.validationRequestsUri !== void 0) {
      result.validationRequestsUri = fallback.validationRequestsUri;
    }
    if (fallback.validationResponsesUri !== void 0) {
      result.validationResponsesUri = fallback.validationResponsesUri;
    }
    if (fallback.feedbackDataUri !== void 0) {
      result.feedbackDataUri = fallback.feedbackDataUri;
    }
  }
  if (overrides) {
    if (overrides.trustModels !== void 0) {
      result.trustModels = overrides.trustModels;
    }
    if (overrides.validationRequestsUri !== void 0) {
      result.validationRequestsUri = overrides.validationRequestsUri;
    }
    if (overrides.validationResponsesUri !== void 0) {
      result.validationResponsesUri = overrides.validationResponsesUri;
    }
    if (overrides.feedbackDataUri !== void 0) {
      result.feedbackDataUri = overrides.feedbackDataUri;
    }
  }
  return Object.keys(result).length > 0 ? result : void 0;
}
function synthesizeTrustConfig(params) {
  try {
    const agentAddress = toCaip10({
      chainId: params.chainId,
      address: params.address,
      namespace: params.namespace
    });
    const entry = {
      agentId: Number(params.fallbackAgentId ?? 0),
      agentAddress
    };
    if (params.signature) {
      entry.signature = params.signature;
    }
    const trust = {
      registrations: [entry],
      ...params.overrides
    };
    return {
      trust,
      record: void 0,
      transactionHash: void 0,
      signature: params.signature,
      didRegister: void 0,
      synthetic: true
    };
  } catch (error) {
    params.warn(
      "[agent-kit] unable to synthesise CAIP-10 identity entry",
      error
    );
    return null;
  }
}
async function bootstrapIdentity(options = {}) {
  const env = options.env ?? (typeof process !== "undefined" && typeof process.env === "object" ? process.env : {});
  const logger = {
    info: options.logger?.info ?? defaultLogger.info,
    warn: options.logger?.warn ?? defaultLogger.warn
  };
  const resolvedChainId = options.chainId ?? parsePositiveInteger(env.CHAIN_ID) ?? DEFAULT_CHAIN_ID;
  const domain = options.domain ?? env.AGENT_DOMAIN;
  const namespace = options.namespace ?? options.fallback?.namespace ?? DEFAULT_NAMESPACE;
  const registryAddress = options.registryAddress ?? env.IDENTITY_REGISTRY_ADDRESS;
  const rpcUrl = options.rpcUrl ?? env.RPC_URL;
  let publicClient = options.publicClient;
  let walletClient = options.walletClient;
  let signer = options.signer;
  if (!publicClient && options.makeClients && rpcUrl) {
    const produced = await options.makeClients({
      chainId: resolvedChainId,
      rpcUrl,
      env
    });
    if (produced?.publicClient) {
      publicClient = produced.publicClient;
      walletClient = walletClient ?? produced.walletClient;
      signer = signer ?? produced.signer ?? produced.walletClient;
    }
  }
  if (!signer && walletClient) {
    signer = walletClient;
  }
  const fallbackOverrides = resolveTrustOverrides(domain, void 0, {
    trustModels: options.fallback?.trustModels ?? (domain ? void 0 : DEFAULT_TRUST_MODELS),
    validationRequestsUri: options.fallback?.validationRequestsUri,
    validationResponsesUri: options.fallback?.validationResponsesUri,
    feedbackDataUri: options.fallback?.feedbackDataUri
  });
  const resolvedOverrides = resolveTrustOverrides(
    domain,
    options.trustOverrides,
    fallbackOverrides
  );
  if (domain && registryAddress && publicClient) {
    try {
      const result = await bootstrapTrust({
        domain,
        chainId: resolvedChainId,
        registryAddress,
        namespace,
        publicClient,
        walletClient,
        signer,
        signatureNonce: options.signatureNonce ?? env.IDENTITY_SIGNATURE_NONCE,
        registerIfMissing: options.registerIfMissing ?? env.REGISTER_IDENTITY === "true",
        skipRegister: options.skipRegister,
        trustOverrides: resolvedOverrides
      });
      if (result.trust) {
        return result;
      }
      logger.warn(
        "[agent-kit] identity not found in registry; falling back to synthetic trust"
      );
    } catch (error) {
      logger.warn(
        "[agent-kit] failed to bootstrap ERC-8004 trust; falling back to synthetic trust",
        error
      );
    }
  }
  const fallbackAddress = options.fallback?.address ?? env.ADDRESS;
  if (!fallbackAddress) {
    logger.warn(
      "[agent-kit] unable to resolve fallback identity address; skipping trust metadata"
    );
    return {};
  }
  const fallbackSignature = options.fallback?.signature ?? env.IDENTITY_FALLBACK_SIGNATURE ?? "0xdeadbeef";
  const synthetic = synthesizeTrustConfig({
    address: fallbackAddress,
    chainId: resolvedChainId,
    namespace,
    fallbackAgentId: options.fallback?.agentId,
    signature: fallbackSignature,
    overrides: resolvedOverrides,
    warn: logger.warn
  });
  if (synthetic) {
    return synthetic;
  }
  return {};
}
async function importViemModules() {
  try {
    const viem = await import('viem');
    const accounts = await import('viem/accounts');
    const chains = await import('viem/chains').catch(() => ({}));
    const baseSepoliaChain = chains.baseSepolia ?? { id: DEFAULT_CHAIN_ID };
    return {
      createPublicClient: viem.createPublicClient,
      createWalletClient: viem.createWalletClient,
      http: viem.http,
      privateKeyToAccount: accounts.privateKeyToAccount,
      baseSepolia: baseSepoliaChain
    };
  } catch (error) {
    defaultLogger.warn(
      "[agent-kit] viem helpers unavailable; install viem to use makeViemClientsFromEnv",
      error
    );
    return null;
  }
}
function resolveEnvObject(env) {
  if (env) return env;
  if (typeof process !== "undefined" && typeof process.env === "object") {
    return process.env;
  }
  return {};
}
async function makeViemClientsFromEnv(options = {}) {
  const env = resolveEnvObject(options.env);
  const modules = await importViemModules();
  if (!modules) return void 0;
  return ({ chainId, rpcUrl, env: runtimeEnv }) => {
    const effectiveRpcUrl = options.rpcUrl ?? rpcUrl ?? env.RPC_URL;
    if (!effectiveRpcUrl) {
      defaultLogger.warn(
        "[agent-kit] RPC_URL missing for viem client factory; skipping"
      );
      return null;
    }
    const transport = modules.http(effectiveRpcUrl);
    const chain = { ...modules.baseSepolia, id: chainId };
    const publicClient = modules.createPublicClient({ chain, transport });
    const mergedEnv = {
      ...env,
      ...runtimeEnv
    };
    const privateKey = options.privateKey ?? mergedEnv.PRIVATE_KEY;
    let walletClient = void 0;
    if (privateKey) {
      try {
        const account = modules.privateKeyToAccount(
          privateKey
        );
        walletClient = modules.createWalletClient({
          chain,
          account,
          transport
        });
      } catch (error) {
        defaultLogger.warn(
          "[agent-kit] failed to configure viem wallet client from PRIVATE_KEY",
          error
        );
      }
    }
    return {
      publicClient,
      walletClient,
      signer: walletClient
    };
  };
}

export { IDENTITY_REGISTRY_ABI, bootstrapIdentity, bootstrapTrust, buildTrustConfigFromIdentity, createIdentityRegistryClient, makeViemClientsFromEnv, signAgentDomainProof, toCaip10 };
//# sourceMappingURL=erc8004.js.map
//# sourceMappingURL=erc8004.js.map