import { ai } from '@ax-llm/ax';
import { privateKeyToAccount } from 'viem/accounts';
import { wrapFetchWithPayment, createSigner } from 'x402-fetch';
import { z } from 'zod';
import { paymentMiddleware } from 'x402-hono';
import { facilitator } from '@coinbase/x402';
import { Hono } from 'hono';
import { streamSSE } from 'hono/streaming';
import { html } from 'hono/html';

// src/ap2.ts
var CONTACT_ADDRESS_DATA_KEY = "contact_picker.ContactAddress";
var PAYMENT_METHOD_DATA_KEY = "payment_request.PaymentMethodData";
var INTENT_MANDATE_DATA_KEY = "ap2.mandates.IntentMandate";
var CART_MANDATE_DATA_KEY = "ap2.mandates.CartMandate";
var PAYMENT_MANDATE_DATA_KEY = "ap2.mandates.PaymentMandate";
var AP2_EXTENSION_URI = "https://github.com/google-agentic-commerce/ap2/tree/v0.1";
var DEFAULT_MODEL = "gpt-5";
var DEFAULT_PROVIDER = "openai";
var DEFAULT_API_URL = "http://localhost:3030/v1";
var createX402Fetch = ({
  account,
  fetchImpl
}) => {
  if (!account) {
    throw new Error("[agent-kit] createX402Fetch requires an account");
  }
  const paymentFetch = wrapFetchWithPayment(
    fetchImpl ?? fetch,
    account
  );
  return Object.assign(
    (input, init) => paymentFetch(input, init ?? {}),
    {
      preconnect: paymentFetch.preconnect ?? (async () => {
      })
    }
  );
};
var accountFromPrivateKey = (privateKey) => {
  if (!privateKey || privateKey.trim().length === 0) {
    throw new Error(
      "[agent-kit] accountFromPrivateKey requires a non-empty private key"
    );
  }
  return privateKeyToAccount(privateKey);
};
var createX402LLM = (options = {}) => {
  const account = options.account ?? (options.privateKey ? accountFromPrivateKey(options.privateKey) : void 0);
  if (!account) {
    throw new Error(
      "[agent-kit] createX402LLM requires either an account or a private key"
    );
  }
  const paymentFetch = options.fetch ?? createX402Fetch({ account, fetchImpl: options.fetchImpl });
  const aiOverrides = options.ai ?? {};
  const {
    config: configOverridesRaw,
    options: optionOverridesRaw,
    apiKey: apiKeyOverrideRaw,
    apiURL: apiUrlOverrideRaw,
    name: nameOverrideRaw,
    ...restAiProps
  } = aiOverrides;
  const configOverrides = configOverridesRaw && typeof configOverridesRaw === "object" ? configOverridesRaw : void 0;
  const optionOverrides = optionOverridesRaw && typeof optionOverridesRaw === "object" ? optionOverridesRaw : void 0;
  const explicitApiKey = typeof apiKeyOverrideRaw === "string" && apiKeyOverrideRaw.trim().length > 0 ? apiKeyOverrideRaw : void 0;
  const nameOverride = typeof nameOverrideRaw === "string" && nameOverrideRaw.trim().length > 0 ? nameOverrideRaw : void 0;
  const apiUrlOverride = typeof apiUrlOverrideRaw === "string" && apiUrlOverrideRaw.trim().length > 0 ? apiUrlOverrideRaw : void 0;
  const apiKey = explicitApiKey ?? process.env.OPENAI_API_KEY;
  if (!apiKey) {
    throw new Error(
      "[agent-kit] createX402LLM requires an OpenAI API key (set options.ai.apiKey or OPENAI_API_KEY)"
    );
  }
  const baseConfig = {
    stream: true,
    model: options.model ?? DEFAULT_MODEL
  };
  const finalConfig = {
    ...baseConfig,
    ...configOverrides ?? {}
  };
  const finalOptions = {
    ...optionOverrides ?? {},
    fetch: paymentFetch
  };
  const aiArgs = {
    ...restAiProps,
    name: nameOverride ?? DEFAULT_PROVIDER,
    apiKey,
    apiURL: apiUrlOverride ?? DEFAULT_API_URL,
    config: finalConfig,
    options: finalOptions
  };
  return ai(aiArgs);
};
var x402LLM = ({
  privateKey = process.env.PRIVATE_KEY,
  model = DEFAULT_MODEL,
  apiURL = DEFAULT_API_URL
}) => createX402LLM({
  privateKey,
  model,
  ai: { apiURL }
});

// src/utils/axllm.ts
var DEFAULT_PROVIDER2 = "openai";
var DEFAULT_MODEL2 = "gpt-5";
function createAxLLMClient(options = {}) {
  const resolved = resolveOptions(options);
  const logger = options.logger;
  const axInstance = (() => {
    if (options.client) return options.client;
    const fromFactory = options.clientFactory?.();
    if (fromFactory) return fromFactory;
    try {
      return createX402LLM(buildCreateOptions(resolved, options.x402));
    } catch (error) {
      logger?.warn?.(
        `[agent-kit] failed to initialise Ax LLM client: ${error.message}`,
        error
      );
      return null;
    }
  })();
  return {
    ax: axInstance,
    isConfigured() {
      return Boolean(axInstance);
    }
  };
}
function resolveOptions(options) {
  const env = readEnv(options.env);
  const provider = options.provider ?? env.AX_PROVIDER ?? env.AXLLM_PROVIDER ?? env.OPENAI_PROVIDER ?? DEFAULT_PROVIDER2;
  const model = options.model ?? env.AX_MODEL ?? env.AXLLM_MODEL ?? env.OPENAI_MODEL ?? DEFAULT_MODEL2;
  const apiKey = options.apiKey ?? env.OPENAI_API_KEY;
  const temperature = options.temperature ?? parseNumber(
    env.AX_TEMPERATURE ?? env.AXLLM_TEMPERATURE ?? env.OPENAI_TEMPERATURE
  );
  const debug = options.debug ?? parseBoolean(env.AX_DEBUG ?? env.AXLLM_DEBUG) ?? false;
  return { provider, model, apiKey, temperature, debug };
}
function buildCreateOptions(resolved, overrides) {
  const x402 = overrides ? { ...overrides } : {};
  const aiOverrides = overrides?.ai ? { ...overrides.ai } : {};
  const aiConfigOverrides = aiOverrides.config && typeof aiOverrides.config === "object" ? { ...aiOverrides.config } : void 0;
  const aiOptionOverrides = aiOverrides.options && typeof aiOverrides.options === "object" ? { ...aiOverrides.options } : void 0;
  const finalTemperature = aiConfigOverrides && "temperature" in aiConfigOverrides ? aiConfigOverrides.temperature : resolved.temperature;
  const finalConfig = {
    stream: true,
    model: aiConfigOverrides?.model ?? x402.model ?? resolved.model,
    ...aiConfigOverrides ?? {},
    ...finalTemperature !== void 0 ? { temperature: finalTemperature } : {}
  };
  const finalOptions = {
    ...aiOptionOverrides ?? {},
    ...resolved.debug ? { debug: resolved.debug } : {}
  };
  const apiKey = aiOverrides.apiKey ?? resolved.apiKey ?? (typeof process !== "undefined" ? process.env.OPENAI_API_KEY : void 0);
  if (!apiKey) {
    throw new Error(
      "[agent-kit] createAxLLMClient requires an OpenAI API key (set apiKey or OPENAI_API_KEY)"
    );
  }
  const name = aiOverrides.name ?? resolved.provider;
  const finalAi = {
    ...aiOverrides,
    name,
    apiKey,
    config: finalConfig,
    options: finalOptions
  };
  const createOptions = {
    ...x402,
    model: x402.model ?? resolved.model,
    ai: finalAi
  };
  if (!createOptions.account && !createOptions.privateKey) {
    const envPrivateKey = typeof process !== "undefined" ? process.env.PRIVATE_KEY : void 0;
    if (envPrivateKey) {
      createOptions.privateKey = envPrivateKey;
    }
  }
  return createOptions;
}
function readEnv(env) {
  if (env) return env;
  if (typeof process !== "undefined" && process?.env) {
    return process.env;
  }
  return {};
}
function parseBoolean(value) {
  if (value === void 0) return void 0;
  if (value.trim() === "") return void 0;
  return ["1", "true", "yes", "on"].includes(value.toLowerCase());
}
function parseNumber(value) {
  if (value === void 0) return void 0;
  const numeric = Number.parseFloat(value);
  return Number.isFinite(numeric) ? numeric : void 0;
}

// src/config.ts
var DEFAULT_FACILITATOR_URL = "https://facilitator.daydreams.systems";
var DEFAULT_PAYMENT_WALLET_ADDRESS = "0xb308ed39d67D0d4BAe5BC2FAEF60c66BBb6AE429";
var DEFAULT_NETWORK = "base-sepolia";
var DEFAULT_AGENT_API_BASE_URL = "http://localhost:8787";
var defaultConfig = {
  payments: {
    facilitatorUrl: DEFAULT_FACILITATOR_URL,
    payTo: DEFAULT_PAYMENT_WALLET_ADDRESS,
    network: DEFAULT_NETWORK,
    defaultPrice: void 0
  },
  wallet: {
    apiBaseUrl: DEFAULT_AGENT_API_BASE_URL,
    maxPaymentBaseUnits: void 0,
    maxPaymentUsd: void 0
  }
};
function parseBigIntEnv(value) {
  if (!value) return void 0;
  try {
    const parsed = BigInt(value);
    return parsed > 0n ? parsed : void 0;
  } catch {
    return void 0;
  }
}
function parseNumberEnv(value) {
  if (!value) return void 0;
  const numeric = Number(value);
  if (!Number.isFinite(numeric) || numeric <= 0) return void 0;
  return numeric;
}
var environmentConfig = {
  payments: {
    facilitatorUrl: process.env.FACILITATOR_URL,
    payTo: process.env.ADDRESS,
    network: process.env.NETWORK,
    defaultPrice: process.env.DEFAULT_PRICE ?? void 0
  },
  wallet: {
    apiBaseUrl: process.env.LUCID_API_URL ?? process.env.VITE_API_URL ?? void 0,
    maxPaymentBaseUnits: parseBigIntEnv(
      process.env.AGENT_WALLET_MAX_PAYMENT_BASE_UNITS
    ),
    maxPaymentUsd: parseNumberEnv(process.env.AGENT_WALLET_MAX_PAYMENT_USDC)
  }
};
var runtimeOverrides = {};
function assignDefined(target, source) {
  if (!source) return;
  for (const [key, value] of Object.entries(source)) {
    if (value !== void 0) {
      target[key] = value;
    }
  }
}
function applyOverrides(base, overrides) {
  if (!overrides) return base;
  const next = {
    payments: { ...base.payments },
    wallet: { ...base.wallet }
  };
  assignDefined(next.payments, overrides.payments);
  assignDefined(next.wallet, overrides.wallet);
  return next;
}
function mergeRuntimeOverrides(current, overrides) {
  const merged = {
    payments: { ...current.payments ?? {} },
    wallet: { ...current.wallet ?? {} }
  };
  assignDefined(merged.payments, overrides.payments);
  assignDefined(merged.wallet, overrides.wallet);
  if (merged.payments && Object.keys(merged.payments).length === 0) {
    delete merged.payments;
  }
  if (merged.wallet && Object.keys(merged.wallet).length === 0) {
    delete merged.wallet;
  }
  return merged;
}
function configureAgentKit(overrides) {
  runtimeOverrides = mergeRuntimeOverrides(runtimeOverrides, overrides);
}
function resetAgentKitConfigForTesting() {
  runtimeOverrides = {};
}
function getAgentKitConfig() {
  const withEnv = applyOverrides(defaultConfig, environmentConfig);
  return applyOverrides(withEnv, runtimeOverrides);
}

// src/utils/utils.ts
var ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
function normalizeDomain(domain) {
  return domain?.trim?.().toLowerCase?.() ?? "";
}
function normalizeAddress(value) {
  if (!value) {
    throw new Error("invalid hex address");
  }
  const trimmed = value.trim();
  if (!/^0x[0-9a-fA-F]{40}$/.test(trimmed)) {
    throw new Error(`invalid hex address: ${value}`);
  }
  return trimmed.toLowerCase();
}
function sanitizeAddress(value) {
  if (!value) return ZERO_ADDRESS;
  try {
    return normalizeAddress(value);
  } catch {
    return ZERO_ADDRESS;
  }
}
function toJsonSchemaOrUndefined(s) {
  if (!s) return void 0;
  try {
    return z.toJSONSchema(s);
  } catch {
    return void 0;
  }
}
function paymentsFromEnv(params) {
  const { payments } = getAgentKitConfig();
  return {
    payTo: payments.payTo,
    facilitatorUrl: payments.facilitatorUrl,
    network: payments.network,
    defaultPrice: params?.defaultPrice ?? payments.defaultPrice
  };
}

// src/erc8004.ts
var IDENTITY_REGISTRY_ABI = [
  {
    type: "function",
    name: "New",
    stateMutability: "nonpayable",
    inputs: [
      { name: "agentDomain", type: "string" },
      { name: "agentAddress", type: "address" }
    ],
    outputs: [{ name: "agentId", type: "uint256" }]
  },
  {
    type: "function",
    name: "Update",
    stateMutability: "nonpayable",
    inputs: [
      { name: "agentId", type: "uint256" },
      { name: "agentDomain", type: "string" },
      { name: "agentAddress", type: "address" }
    ],
    outputs: [{ name: "ok", type: "bool" }]
  },
  {
    type: "function",
    name: "Get",
    stateMutability: "view",
    inputs: [{ name: "agentId", type: "uint256" }],
    outputs: [
      { name: "agentId", type: "uint256" },
      { name: "agentDomain", type: "string" },
      { name: "agentAddress", type: "address" }
    ]
  },
  {
    type: "function",
    name: "ResolveByDomain",
    stateMutability: "view",
    inputs: [{ name: "agentDomain", type: "string" }],
    outputs: [
      { name: "agentId", type: "uint256" },
      { name: "agentDomain", type: "string" },
      { name: "agentAddress", type: "address" }
    ]
  },
  {
    type: "function",
    name: "ResolveByAddress",
    stateMutability: "view",
    inputs: [{ name: "agentAddress", type: "address" }],
    outputs: [
      { name: "agentId", type: "uint256" },
      { name: "agentDomain", type: "string" },
      { name: "agentAddress", type: "address" }
    ]
  }
];
function createIdentityRegistryClient(options) {
  const {
    address,
    chainId,
    publicClient,
    walletClient,
    namespace = "eip155"
  } = options;
  function ensureWalletClient() {
    if (!walletClient) {
      throw new Error(
        "identity registry client requires walletClient for writes"
      );
    }
    return walletClient;
  }
  async function readRecord(fn, args) {
    const result = await publicClient.readContract({
      address,
      abi: IDENTITY_REGISTRY_ABI,
      functionName: fn,
      args
    });
    if (!result) return null;
    const [agentId, agentDomain, agentAddress] = result;
    if (!agentDomain && (!agentAddress || agentAddress === ZERO_ADDRESS)) {
      return null;
    }
    return {
      agentId,
      agentDomain,
      agentAddress: normalizeAddress(agentAddress)
    };
  }
  return {
    address,
    chainId,
    async get(agentId) {
      const id = BigInt(agentId);
      return readRecord("Get", [id]);
    },
    resolveByDomain(domain) {
      const normalized = normalizeDomain(domain);
      return readRecord("ResolveByDomain", [normalized]);
    },
    resolveByAddress(rawAddress) {
      const normalized = normalizeAddress(rawAddress);
      return readRecord("ResolveByAddress", [normalized]);
    },
    async register(input) {
      const wallet = ensureWalletClient();
      const normalizedDomain = normalizeDomain(input.domain);
      const normalizedAddress = normalizeAddress(
        input.agentAddress ?? wallet.account?.address ?? ZERO_ADDRESS
      );
      if (!normalizedDomain) {
        throw new Error("agent domain is required");
      }
      if (!normalizedAddress || normalizedAddress === ZERO_ADDRESS) {
        throw new Error("agent address is required");
      }
      const txHash = await wallet.writeContract({
        address,
        abi: IDENTITY_REGISTRY_ABI,
        functionName: "New",
        args: [normalizedDomain, normalizedAddress]
      });
      let agentId;
      try {
        const record = await readRecord("ResolveByDomain", [normalizedDomain]);
        agentId = record?.agentId;
      } catch {
        agentId = void 0;
      }
      return {
        transactionHash: txHash,
        agentAddress: normalizedAddress,
        agentId
      };
    },
    async update(input) {
      const wallet = ensureWalletClient();
      const agentId = BigInt(input.agentId);
      const normalizedDomain = typeof input.domain === "string" ? normalizeDomain(input.domain) : "";
      const normalizedAddress = typeof input.agentAddress === "string" ? normalizeAddress(input.agentAddress) : ZERO_ADDRESS;
      if (!normalizedDomain && (!normalizedAddress || normalizedAddress === ZERO_ADDRESS)) {
        throw new Error("update requires domain and/or agentAddress");
      }
      const txHash = await wallet.writeContract({
        address,
        abi: IDENTITY_REGISTRY_ABI,
        functionName: "Update",
        args: [
          agentId,
          normalizedDomain,
          normalizedAddress && normalizedAddress !== ZERO_ADDRESS ? normalizedAddress : ZERO_ADDRESS
        ]
      });
      let resultingRecord = null;
      try {
        if (normalizedDomain) {
          resultingRecord = await readRecord("ResolveByDomain", [
            normalizedDomain
          ]);
        }
        if (!resultingRecord) {
          resultingRecord = await readRecord("Get", [agentId]);
        }
      } catch {
        resultingRecord = null;
      }
      return {
        transactionHash: txHash,
        agentId: resultingRecord?.agentId ?? agentId
      };
    },
    toRegistrationEntry(record, signature) {
      if (chainId == null) {
        throw new Error(
          "identity registry client needs chainId to build CAIP-10 registration entries"
        );
      }
      const agentAddress = toCaip10({
        namespace,
        chainId,
        address: record.agentAddress
      });
      const entry = {
        agentId: Number(record.agentId),
        agentAddress
      };
      if (signature) {
        entry.signature = signature;
      }
      return entry;
    }
  };
}
function toCaip10(params) {
  const namespace = params.namespace ?? "eip155";
  const chainRef = typeof params.chainId === "number" ? params.chainId.toString(10) : `${params.chainId ?? ""}`;
  if (!chainRef) throw new Error("chainId is required for CAIP-10");
  const address = params.address?.toLowerCase?.();
  if (!address || !address.startsWith("0x")) {
    throw new Error("address must be a hex string");
  }
  return `${namespace}:${chainRef}:${address}`;
}
async function signAgentDomainProof(options) {
  const { domain, address, chainId, nonce, signer } = options;
  const normalizedDomain = normalizeDomain(domain);
  if (!normalizedDomain) throw new Error("domain is required");
  const normalizedAddress = normalizeAddress(address);
  if (!normalizedAddress || normalizedAddress === ZERO_ADDRESS) {
    throw new Error("address must be a valid hex address");
  }
  const message = buildOwnershipMessage({
    domain: normalizedDomain,
    address: normalizedAddress,
    chainId,
    nonce
  });
  const signature = await invokeSignMessage(signer, message);
  return signature;
}
function buildTrustConfigFromIdentity(record, options) {
  const chainRef = options?.chainId;
  if (chainRef == null) {
    throw new Error(
      "chainId is required to generate trust config registration entry"
    );
  }
  const entry = {
    agentId: Number(record.agentId),
    agentAddress: toCaip10({
      namespace: options?.namespace,
      chainId: chainRef,
      address: record.agentAddress
    })
  };
  if (options?.signature) entry.signature = options.signature;
  return {
    registrations: [entry],
    ...options?.trustOverrides
  };
}
function buildOwnershipMessage(params) {
  const lines = [
    "ERC-8004 Agent Ownership Proof",
    `Domain: ${params.domain}`,
    `Address: ${params.address.toLowerCase()}`,
    `ChainId: ${params.chainId}`
  ];
  if (params.nonce) {
    lines.push(`Nonce: ${params.nonce}`);
  }
  return lines.join("\n");
}
async function invokeSignMessage(signer, message) {
  const candidate = signer;
  if (typeof candidate.signMessage !== "function") {
    throw new Error("signer does not expose signMessage");
  }
  try {
    const result2 = await candidate.signMessage(message);
    if (typeof result2 === "string") return result2;
  } catch (_) {
  }
  const result = await candidate.signMessage({ message });
  if (typeof result === "string") return result;
  throw new Error("signMessage did not return a signature string");
}
async function bootstrapTrust(options) {
  const normalizedDomain = normalizeDomain(options.domain);
  if (!normalizedDomain) {
    throw new Error("domain is required to bootstrap trust state");
  }
  const shouldRegister = Boolean(
    options.registerIfMissing && !options.skipRegister
  );
  const client = createIdentityRegistryClient({
    address: options.registryAddress,
    chainId: options.chainId,
    publicClient: options.publicClient,
    walletClient: options.walletClient,
    namespace: options.namespace
  });
  let record = await client.resolveByDomain(normalizedDomain).catch(() => null);
  let transactionHash;
  let didRegister = false;
  if (!record && options.onMissing) {
    const handled = await options.onMissing({
      client,
      normalizedDomain
    });
    if (handled) {
      record = handled;
    }
  }
  if (!record && shouldRegister) {
    const registration = await client.register({ domain: normalizedDomain });
    transactionHash = registration.transactionHash;
    didRegister = true;
    record = await client.resolveByDomain(normalizedDomain).catch(() => null);
    if (!record && registration.agentId != null) {
      record = {
        agentId: registration.agentId,
        agentDomain: normalizedDomain,
        agentAddress: registration.agentAddress
      };
    }
  }
  if (!record) {
    return {
      trust: void 0,
      record: null,
      transactionHash,
      didRegister
    };
  }
  let signature;
  if (options.signer) {
    signature = await signAgentDomainProof({
      domain: record.agentDomain,
      address: record.agentAddress,
      chainId: options.chainId,
      signer: options.signer,
      nonce: options.signatureNonce
    });
  }
  const trust = buildTrustConfigFromIdentity(record, {
    chainId: options.chainId,
    namespace: options.namespace,
    signature,
    trustOverrides: options.trustOverrides
  });
  return {
    trust,
    record,
    transactionHash,
    signature,
    didRegister
  };
}
var DEFAULT_CHAIN_ID = 84532;
var DEFAULT_NAMESPACE = "eip155";
var DEFAULT_TRUST_MODELS = [
  "feedback",
  "inference-validation"
];
var defaultLogger = {
  info: typeof console !== "undefined" && typeof console.info === "function" ? console.info.bind(console) : () => {
  },
  warn: typeof console !== "undefined" && typeof console.warn === "function" ? console.warn.bind(console) : () => {
  }
};
function parsePositiveInteger(value) {
  if (!value) return void 0;
  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed <= 0) return void 0;
  return Math.trunc(parsed);
}
function resolveTrustOverrides(domain, overrides, fallback) {
  const result = {};
  if (domain) {
    result.trustModels = DEFAULT_TRUST_MODELS;
    const origin = domain.startsWith("http") ? domain : `https://${domain}`;
    result.validationRequestsUri = `${origin}/validation/requests.json`;
    result.validationResponsesUri = `${origin}/validation/responses.json`;
    result.feedbackDataUri = `${origin}/feedback.json`;
  }
  if (fallback) {
    if (fallback.trustModels !== void 0) {
      result.trustModels = fallback.trustModels;
    }
    if (fallback.validationRequestsUri !== void 0) {
      result.validationRequestsUri = fallback.validationRequestsUri;
    }
    if (fallback.validationResponsesUri !== void 0) {
      result.validationResponsesUri = fallback.validationResponsesUri;
    }
    if (fallback.feedbackDataUri !== void 0) {
      result.feedbackDataUri = fallback.feedbackDataUri;
    }
  }
  if (overrides) {
    if (overrides.trustModels !== void 0) {
      result.trustModels = overrides.trustModels;
    }
    if (overrides.validationRequestsUri !== void 0) {
      result.validationRequestsUri = overrides.validationRequestsUri;
    }
    if (overrides.validationResponsesUri !== void 0) {
      result.validationResponsesUri = overrides.validationResponsesUri;
    }
    if (overrides.feedbackDataUri !== void 0) {
      result.feedbackDataUri = overrides.feedbackDataUri;
    }
  }
  return Object.keys(result).length > 0 ? result : void 0;
}
function synthesizeTrustConfig(params) {
  try {
    const agentAddress = toCaip10({
      chainId: params.chainId,
      address: params.address,
      namespace: params.namespace
    });
    const entry = {
      agentId: Number(params.fallbackAgentId ?? 0),
      agentAddress
    };
    if (params.signature) {
      entry.signature = params.signature;
    }
    const trust = {
      registrations: [entry],
      ...params.overrides
    };
    return {
      trust,
      record: void 0,
      transactionHash: void 0,
      signature: params.signature,
      didRegister: void 0,
      synthetic: true
    };
  } catch (error) {
    params.warn(
      "[agent-kit] unable to synthesise CAIP-10 identity entry",
      error
    );
    return null;
  }
}
async function bootstrapIdentity(options = {}) {
  const env = options.env ?? (typeof process !== "undefined" && typeof process.env === "object" ? process.env : {});
  const logger = {
    info: options.logger?.info ?? defaultLogger.info,
    warn: options.logger?.warn ?? defaultLogger.warn
  };
  const resolvedChainId = options.chainId ?? parsePositiveInteger(env.CHAIN_ID) ?? DEFAULT_CHAIN_ID;
  const domain = options.domain ?? env.AGENT_DOMAIN;
  const namespace = options.namespace ?? options.fallback?.namespace ?? DEFAULT_NAMESPACE;
  const registryAddress = options.registryAddress ?? env.IDENTITY_REGISTRY_ADDRESS;
  const rpcUrl = options.rpcUrl ?? env.RPC_URL;
  let publicClient = options.publicClient;
  let walletClient = options.walletClient;
  let signer = options.signer;
  if (!publicClient && options.makeClients && rpcUrl) {
    const produced = await options.makeClients({
      chainId: resolvedChainId,
      rpcUrl,
      env
    });
    if (produced?.publicClient) {
      publicClient = produced.publicClient;
      walletClient = walletClient ?? produced.walletClient;
      signer = signer ?? produced.signer ?? produced.walletClient;
    }
  }
  if (!signer && walletClient) {
    signer = walletClient;
  }
  const fallbackOverrides = resolveTrustOverrides(domain, void 0, {
    trustModels: options.fallback?.trustModels ?? (domain ? void 0 : DEFAULT_TRUST_MODELS),
    validationRequestsUri: options.fallback?.validationRequestsUri,
    validationResponsesUri: options.fallback?.validationResponsesUri,
    feedbackDataUri: options.fallback?.feedbackDataUri
  });
  const resolvedOverrides = resolveTrustOverrides(
    domain,
    options.trustOverrides,
    fallbackOverrides
  );
  if (domain && registryAddress && publicClient) {
    try {
      const result = await bootstrapTrust({
        domain,
        chainId: resolvedChainId,
        registryAddress,
        namespace,
        publicClient,
        walletClient,
        signer,
        signatureNonce: options.signatureNonce ?? env.IDENTITY_SIGNATURE_NONCE,
        registerIfMissing: options.registerIfMissing ?? env.REGISTER_IDENTITY === "true",
        skipRegister: options.skipRegister,
        trustOverrides: resolvedOverrides
      });
      if (result.trust) {
        return result;
      }
      logger.warn(
        "[agent-kit] identity not found in registry; falling back to synthetic trust"
      );
    } catch (error) {
      logger.warn(
        "[agent-kit] failed to bootstrap ERC-8004 trust; falling back to synthetic trust",
        error
      );
    }
  }
  const fallbackAddress = options.fallback?.address ?? env.ADDRESS;
  if (!fallbackAddress) {
    logger.warn(
      "[agent-kit] unable to resolve fallback identity address; skipping trust metadata"
    );
    return {};
  }
  const fallbackSignature = options.fallback?.signature ?? env.IDENTITY_FALLBACK_SIGNATURE ?? "0xdeadbeef";
  const synthetic = synthesizeTrustConfig({
    address: fallbackAddress,
    chainId: resolvedChainId,
    namespace,
    fallbackAgentId: options.fallback?.agentId,
    signature: fallbackSignature,
    overrides: resolvedOverrides,
    warn: logger.warn
  });
  if (synthetic) {
    return synthetic;
  }
  return {};
}
async function importViemModules() {
  try {
    const viem = await import('viem');
    const accounts = await import('viem/accounts');
    const chains = await import('viem/chains').catch(() => ({}));
    const baseSepoliaChain = chains.baseSepolia ?? { id: DEFAULT_CHAIN_ID };
    return {
      createPublicClient: viem.createPublicClient,
      createWalletClient: viem.createWalletClient,
      http: viem.http,
      privateKeyToAccount: accounts.privateKeyToAccount,
      baseSepolia: baseSepoliaChain
    };
  } catch (error) {
    defaultLogger.warn(
      "[agent-kit] viem helpers unavailable; install viem to use makeViemClientsFromEnv",
      error
    );
    return null;
  }
}
function resolveEnvObject(env) {
  if (env) return env;
  if (typeof process !== "undefined" && typeof process.env === "object") {
    return process.env;
  }
  return {};
}
async function makeViemClientsFromEnv(options = {}) {
  const env = resolveEnvObject(options.env);
  const modules = await importViemModules();
  if (!modules) return void 0;
  return ({ chainId, rpcUrl, env: runtimeEnv }) => {
    const effectiveRpcUrl = options.rpcUrl ?? rpcUrl ?? env.RPC_URL;
    if (!effectiveRpcUrl) {
      defaultLogger.warn(
        "[agent-kit] RPC_URL missing for viem client factory; skipping"
      );
      return null;
    }
    const transport = modules.http(effectiveRpcUrl);
    const chain = { ...modules.baseSepolia, id: chainId };
    const publicClient = modules.createPublicClient({ chain, transport });
    const mergedEnv = {
      ...env,
      ...runtimeEnv
    };
    const privateKey = options.privateKey ?? mergedEnv.PRIVATE_KEY;
    let walletClient = void 0;
    if (privateKey) {
      try {
        const account = modules.privateKeyToAccount(
          privateKey
        );
        walletClient = modules.createWalletClient({
          chain,
          account,
          transport
        });
      } catch (error) {
        defaultLogger.warn(
          "[agent-kit] failed to configure viem wallet client from PRIVATE_KEY",
          error
        );
      }
    }
    return {
      publicClient,
      walletClient,
      signer: walletClient
    };
  };
}
async function toAuthHeaders(getAuthHeaders) {
  if (!getAuthHeaders) return {};
  const headers = await getAuthHeaders();
  return headers ?? {};
}
function normalizeBaseUrl(baseUrl) {
  return baseUrl.endsWith("/") ? baseUrl.slice(0, -1) : baseUrl;
}
function buildUrl(baseUrl, agentRef, path) {
  const normalizedBase = normalizeBaseUrl(baseUrl);
  const encodedRef = encodeURIComponent(agentRef);
  return `${normalizedBase}/v1/agents/${encodedRef}${path}`;
}
async function parseResponse(response) {
  if (response.ok) {
    return await response.json();
  }
  let payload = null;
  try {
    payload = await response.json();
  } catch {
  }
  const message = payload?.message || payload?.error || `Wallet request failed (${response.status})`;
  const error = new Error(String(message));
  error.status = response.status;
  error.details = payload;
  throw error;
}
function createAgentWalletClient(options) {
  const { wallet } = getAgentKitConfig();
  const resolvedBase = options.baseUrl && options.baseUrl.trim().length > 0 ? options.baseUrl : wallet.apiBaseUrl;
  const baseUrl = normalizeBaseUrl(resolvedBase);
  const fetchImpl = options.fetch ?? fetch;
  async function postJson(path, body) {
    const url = buildUrl(baseUrl, options.agentRef, path);
    const headers = {
      "content-type": "application/json",
      ...await toAuthHeaders(options.getAuthHeaders) || {}
    };
    const response = await fetchImpl(url, {
      method: "POST",
      headers,
      body: JSON.stringify(body),
      credentials: "include"
    });
    return parseResponse(response);
  }
  return {
    sendTransaction(body) {
      return postJson(
        "/wallet/send-transaction",
        body
      );
    },
    signTransaction(body) {
      return postJson(
        "/wallet/sign-transaction",
        body
      );
    },
    signMessage(body) {
      return postJson(
        "/wallet/sign-message",
        body
      );
    },
    signTypedData(body) {
      return postJson(
        "/wallet/sign-typed-data",
        body
      );
    }
  };
}
function attachPreconnect(fetchImpl, baseFetch) {
  const upstream = baseFetch;
  const fallbackPreconnect = async () => {
  };
  const preconnectFn = typeof upstream.preconnect === "function" ? upstream.preconnect.bind(baseFetch) : fallbackPreconnect;
  fetchImpl.preconnect = preconnectFn;
  return fetchImpl;
}
function logWarning(logger, message, ...args) {
  if (logger?.warn) {
    logger.warn(message, ...args);
  } else {
    console.warn(message, ...args);
  }
}
function inferChainId(network) {
  if (!network) return void 0;
  const normalized = network.toLowerCase();
  if (normalized === "base" || normalized === "eip155:8453") return 8453;
  if (normalized === "base-sepolia" || normalized === "eip155:84532" || normalized === "base_testnet")
    return 84532;
  return void 0;
}
function resolveMaxPaymentBaseUnits(override) {
  if (typeof override === "bigint") return override;
  const { wallet } = getAgentKitConfig();
  if (typeof wallet.maxPaymentBaseUnits === "bigint") {
    return wallet.maxPaymentBaseUnits;
  }
  if (typeof wallet.maxPaymentUsd === "number") {
    return BigInt(Math.floor(wallet.maxPaymentUsd * 1e6));
  }
  return void 0;
}
function normalizeTypedData(input) {
  const primaryType = input.primary_type ?? input.primaryType;
  if (!primaryType) {
    throw new Error("Typed data missing primaryType");
  }
  return {
    domain: input.domain ?? {},
    types: input.types ?? {},
    message: input.message ?? {},
    primary_type: primaryType
  };
}
async function fetchAgentWalletAddress(baseUrl, agentRef, headers, fetchImpl) {
  try {
    const url = buildUrl(baseUrl, agentRef, "");
    const requestHeaders = {
      accept: "application/json",
      ...headers
    };
    const hasCookie = Boolean(requestHeaders.Cookie || requestHeaders.cookie);
    const response = await fetchImpl(url, {
      method: "GET",
      headers: requestHeaders,
      credentials: hasCookie ? "include" : void 0
    });
    if (!response.ok) return null;
    const body = await response.json().catch(() => null);
    return body?.billing?.wallet?.address ?? null;
  } catch {
    return null;
  }
}
function createAgentEvmSigner(opts) {
  let currentAddress = sanitizeAddress(opts.initialAddress);
  let currentChainId = opts.chainId;
  const signer = {
    chain: { id: currentChainId },
    transport: { type: "agent-wallet" },
    account: { address: currentAddress },
    async signTypedData(data) {
      const typedData = normalizeTypedData(data);
      const domainChain = typedData.domain?.chainId ?? typedData.domain?.chain_id;
      if (typeof domainChain !== "undefined") {
        const parsed = Number(domainChain);
        if (Number.isFinite(parsed) && parsed > 0) {
          currentChainId = parsed;
          signer.chain.id = parsed;
        }
      }
      const res = await opts.walletClient.signTypedData({
        typed_data: typedData,
        idempotency_key: crypto.randomUUID()
      });
      if (res?.wallet?.address) {
        currentAddress = sanitizeAddress(res.wallet.address);
        signer.account.address = currentAddress;
      }
      return res.signed.signature;
    },
    async signMessage(message) {
      const normalizedMessage = typeof message === "string" ? message : typeof message?.raw === "string" ? message.raw : JSON.stringify(message ?? "");
      const res = await opts.walletClient.signMessage({
        message: normalizedMessage
      });
      if (res?.wallet?.address) {
        currentAddress = sanitizeAddress(res.wallet.address);
        signer.account.address = currentAddress;
      }
      return res.signed.signature;
    }
  };
  return signer;
}
async function createAgentPaymentContext(options) {
  const { wallet } = getAgentKitConfig();
  const resolvedBase = options.baseUrl && options.baseUrl.trim().length > 0 ? options.baseUrl : wallet.apiBaseUrl;
  const baseUrl = normalizeBaseUrl(resolvedBase);
  const upstreamFetch = options.fetch ?? fetch;
  const apiFetch = options.apiFetch ?? upstreamFetch;
  const maxPayment = resolveMaxPaymentBaseUnits(options.maxPaymentBaseUnits);
  if (options.privateKey) {
    try {
      const signer = await createSigner(
        options.network ?? "base-sepolia",
        options.privateKey
      );
      const fetchWithPayment = attachPreconnect(
        wrapFetchWithPayment(upstreamFetch, signer, maxPayment),
        upstreamFetch
      );
      return {
        walletClient: null,
        signer,
        fetchWithPayment
      };
    } catch (error) {
      logWarning(
        options.logger,
        `[agent-kit] failed to initialise paid fetch with private key: ${error?.message || error}`
      );
      return {
        walletClient: null,
        signer: null,
        fetchWithPayment: null
      };
    }
  }
  const authHeaders = await toAuthHeaders(options.getAuthHeaders);
  if (!authHeaders || Object.keys(authHeaders).length === 0) {
    return {
      walletClient: null,
      signer: null,
      fetchWithPayment: null
    };
  }
  const walletClientFactory = options.walletClientFactory ?? createAgentWalletClient;
  const walletClient = walletClientFactory({
    agentRef: options.agentRef,
    baseUrl,
    getAuthHeaders: options.getAuthHeaders,
    fetch: apiFetch
  });
  const chainId = options.chainId ?? inferChainId(options.network);
  if (!chainId) {
    logWarning(
      options.logger,
      "[agent-kit] unable to derive chainId for payment signer; provide options.chainId or options.network"
    );
    return {
      walletClient,
      signer: null,
      fetchWithPayment: null
    };
  }
  try {
    const initialAddress = await fetchAgentWalletAddress(
      baseUrl,
      options.agentRef,
      authHeaders,
      apiFetch
    );
    const signer = createAgentEvmSigner({
      walletClient,
      initialAddress,
      chainId
    });
    const fetchWithPayment = attachPreconnect(
      wrapFetchWithPayment(
        upstreamFetch,
        signer,
        maxPayment
      ),
      upstreamFetch
    );
    return {
      walletClient,
      signer,
      fetchWithPayment
    };
  } catch (error) {
    logWarning(
      options.logger,
      `[agent-kit] failed to initialise agent wallet payment signer: ${error?.message || error}`
    );
    return {
      walletClient,
      signer: null,
      fetchWithPayment: null
    };
  }
}
function resolveProcessEnv() {
  if (typeof process !== "undefined" && typeof process.env === "object") {
    return process.env;
  }
  return {};
}
function toBearerToken(token) {
  if (!token) return void 0;
  const trimmed = token.trim();
  if (!trimmed) return void 0;
  return trimmed.startsWith("Bearer ") ? trimmed : `Bearer ${trimmed}`;
}
async function bootstrapAgentPaymentContext(options = {}) {
  const env = options.env ?? resolveProcessEnv();
  const agentRef = options.agentRef ?? env.AGENT_REF;
  if (!agentRef) {
    logWarning(
      options.logger,
      "[agent-kit] AGENT_REF missing; skipping payment bootstrap"
    );
    return null;
  }
  const authHeaders = options.getAuthHeaders ?? (async () => {
    const token = toBearerToken(env.AGENT_AUTH_TOKEN);
    if (!token) return {};
    return { Authorization: token };
  });
  try {
    const { payments } = getAgentKitConfig();
    const context = await createAgentPaymentContext({
      agentRef,
      network: payments.network,
      getAuthHeaders: authHeaders,
      fetch: options.fetch,
      apiFetch: options.apiFetch,
      walletClientFactory: options.walletClientFactory,
      logger: options.logger
    });
    if (!context.fetchWithPayment && !context.walletClient && !context.signer) {
      return null;
    }
    return context;
  } catch (error) {
    logWarning(
      options.logger,
      `[agent-kit] failed to bootstrap payment context: ${error?.message || error}`
    );
    return null;
  }
}

// src/pricing.ts
function resolveEntrypointPrice(entrypoint, payments, which) {
  if (typeof entrypoint.price === "string") return entrypoint.price;
  if (typeof entrypoint.price === "object" && entrypoint.price) {
    const value = entrypoint.price[which];
    if (value) return value;
  }
  return payments?.defaultPrice;
}
function withPayments({
  app,
  path,
  entrypoint,
  kind,
  payments,
  facilitator: facilitator$1 = facilitator,
  middlewareFactory = paymentMiddleware
}) {
  if (!payments) return false;
  const network = entrypoint.network ?? payments.network;
  if (!network) return false;
  const price = resolveEntrypointPrice(entrypoint, payments, kind);
  if (!price) return false;
  app.use(
    path,
    middlewareFactory(
      payments.payTo,
      { [path]: { price, network } },
      facilitator$1
    )
  );
  return true;
}

// src/manifest.ts
function buildManifest({
  meta,
  registry,
  origin,
  payments,
  ap2,
  trust
}) {
  const entrypoints = {};
  const entrypointList = Array.from(registry);
  const anyStreaming = entrypointList.some((e) => Boolean(e.stream));
  for (const e of entrypointList) {
    const manifestEntry = {
      description: e.description,
      streaming: Boolean(e.stream),
      input_schema: toJsonSchemaOrUndefined(e.input),
      output_schema: toJsonSchemaOrUndefined(e.output)
    };
    const invP = resolveEntrypointPrice(e, payments, "invoke");
    const strP = e.stream ? resolveEntrypointPrice(e, payments, "stream") : void 0;
    if (invP || strP) {
      const pricing = {};
      if (invP) pricing.invoke = invP;
      if (strP) pricing.stream = strP;
      manifestEntry.pricing = pricing;
    }
    entrypoints[e.key] = manifestEntry;
  }
  const defaultInputModes = ["application/json"];
  const defaultOutputModes = ["application/json", "text/plain"];
  const skills = entrypointList.map((e) => ({
    id: e.key,
    name: e.key,
    description: e.description,
    inputModes: defaultInputModes,
    outputModes: defaultOutputModes,
    streaming: Boolean(e.stream),
    x_input_schema: toJsonSchemaOrUndefined(e.input),
    x_output_schema: toJsonSchemaOrUndefined(e.output)
  }));
  const capabilities = {
    streaming: anyStreaming,
    pushNotifications: false,
    stateTransitionHistory: true
  };
  const resolvedAp2Config = ap2 ?? (payments ? { roles: ["merchant"], required: true } : void 0);
  if (resolvedAp2Config?.roles?.length) {
    const [firstRole, ...restRoles] = resolvedAp2Config.roles;
    if (!firstRole) {
      throw new Error("AP2 roles must contain at least one entry");
    }
    const roles = [firstRole, ...restRoles];
    const extension = {
      uri: AP2_EXTENSION_URI,
      description: resolvedAp2Config.description ?? "Agent Payments Protocol (AP2)",
      required: resolvedAp2Config.required ?? roles.includes("merchant"),
      params: { roles }
    };
    const existing = capabilities.extensions ?? [];
    const withoutAp2 = existing.filter(
      (ext) => !("uri" in ext && ext.uri === AP2_EXTENSION_URI)
    );
    capabilities.extensions = [...withoutAp2, extension];
  }
  const card = {
    name: meta.name,
    description: meta.description,
    url: origin.endsWith("/") ? origin : `${origin}/`,
    version: meta.version,
    provider: void 0,
    capabilities,
    defaultInputModes,
    defaultOutputModes,
    skills,
    supportsAuthenticatedExtendedCard: false,
    entrypoints
  };
  if (payments) {
    const pm = payments;
    const paymentMethod = {
      method: "x402",
      payee: pm.payTo,
      network: pm.network,
      endpoint: pm.facilitatorUrl,
      priceModel: pm.defaultPrice ? { default: pm.defaultPrice } : void 0,
      extensions: {
        x402: { facilitatorUrl: pm.facilitatorUrl }
      }
    };
    card.payments = [paymentMethod];
  }
  if (trust) {
    if (trust.registrations?.length) {
      card.registrations = trust.registrations;
    }
    if (trust.trustModels?.length) {
      const unique = Array.from(new Set(trust.trustModels));
      card.trustModels = unique;
    }
    if (trust.validationRequestsUri) {
      card.ValidationRequestsURI = trust.validationRequestsUri;
    }
    if (trust.validationResponsesUri) {
      card.ValidationResponsesURI = trust.validationResponsesUri;
    }
    if (trust.feedbackDataUri) {
      card.FeedbackDataURI = trust.feedbackDataUri;
    }
  }
  return card;
}
function createAgentApp(meta, opts) {
  if (opts?.config) {
    configureAgentKit(opts.config);
  }
  const resolvedConfig = getAgentKitConfig();
  const paymentsOption = opts?.payments;
  const shouldUseConfiguredPayments = paymentsOption === void 0 && (opts?.useConfigPayments || Boolean(opts?.config?.payments));
  const resolvedPayments = paymentsOption === false ? void 0 : paymentsOption ?? (shouldUseConfiguredPayments ? {
    payTo: resolvedConfig.payments.payTo,
    facilitatorUrl: resolvedConfig.payments.facilitatorUrl,
    network: resolvedConfig.payments.network,
    defaultPrice: resolvedConfig.payments.defaultPrice
  } : void 0);
  const app = new Hono();
  const registry = /* @__PURE__ */ new Map();
  const extractInput = (payload) => {
    if (payload && typeof payload === "object" && "input" in payload) {
      const { input } = payload;
      return input ?? {};
    }
    return {};
  };
  const listEntrypoints = () => Array.from(registry.values()).map((e) => ({
    key: e.key,
    description: e.description,
    streaming: Boolean(e.stream)
  }));
  const buildManifestForOrigin = (origin) => buildManifest({
    meta,
    registry: registry.values(),
    origin,
    payments: resolvedPayments,
    ap2: opts?.ap2,
    trust: opts?.trust
  });
  app.get("/health", (c) => c.json({ ok: true, version: meta.version }));
  app.get("/entrypoints", (c) => c.json({ items: listEntrypoints() }));
  app.get("/.well-known/agent.json", (c) => {
    const origin = new URL(c.req.url).origin;
    return c.json(buildManifestForOrigin(origin));
  });
  app.get("/.well-known/agent-card.json", (c) => {
    const origin = new URL(c.req.url).origin;
    return c.json(buildManifestForOrigin(origin));
  });
  const registerEntrypointRoutes = (ep) => {
    const invokePath = `/entrypoints/${ep.key}/invoke`;
    const streamPath = `/entrypoints/${ep.key}/stream`;
    withPayments({
      app,
      path: invokePath,
      entrypoint: ep,
      kind: "invoke",
      payments: resolvedPayments
    });
    if (ep.stream) {
      withPayments({
        app,
        path: streamPath,
        entrypoint: ep,
        kind: "stream",
        payments: resolvedPayments
      });
    }
    app.post(invokePath, async (c) => {
      const rawBody = await c.req.json().catch(() => void 0);
      const input = extractInput(rawBody);
      if (ep.input) {
        const parsed = ep.input.safeParse(input);
        if (!parsed.success) {
          return c.json(
            { error: { code: "invalid_input", issues: parsed.error.issues } },
            400
          );
        }
      }
      const runId = crypto.randomUUID();
      try {
        if (!ep.handler)
          return c.json({ error: { code: "not_implemented" } }, 501);
        const res = await ep.handler({
          key: ep.key,
          input,
          signal: c.req.raw.signal,
          headers: c.req.raw.headers,
          runId
        });
        return c.json({
          run_id: runId,
          status: "succeeded",
          output: res.output,
          usage: res.usage,
          model: res.model
        });
      } catch (err) {
        return c.json(
          {
            error: {
              code: "internal_error",
              message: err?.message || "error"
            }
          },
          500
        );
      }
    });
    app.post(streamPath, async (c) => {
      if (!ep.stream)
        return c.json(
          { error: { code: "stream_not_supported", key: ep.key } },
          400
        );
      const rawBody = await c.req.json().catch(() => void 0);
      const input = extractInput(rawBody);
      if (ep.input) {
        const parsed = ep.input.safeParse(input);
        if (!parsed.success) {
          return c.json(
            { error: { code: "invalid_input", issues: parsed.error.issues } },
            400
          );
        }
      }
      const runId = crypto.randomUUID();
      let seq = 0;
      const nowIso = () => (/* @__PURE__ */ new Date()).toISOString();
      const allocateSequence = () => seq++;
      return streamSSE(
        c,
        async (s) => {
          s.onAbort(() => {
          });
          const sendEnvelope = async (payload) => {
            const sequence = payload.sequence != null ? payload.sequence : allocateSequence();
            const createdAt = payload.createdAt ?? nowIso();
            const envelope = {
              ...payload,
              runId,
              sequence,
              createdAt
            };
            await s.writeSSE({
              event: envelope.kind,
              data: JSON.stringify(envelope),
              id: String(sequence)
            });
          };
          await sendEnvelope({ kind: "run-start", runId });
          const emit = async (chunk) => {
            await sendEnvelope(chunk);
          };
          try {
            const res = await ep.stream(
              {
                key: ep.key,
                input,
                signal: c.req.raw.signal,
                headers: c.req.raw.headers,
                runId
              },
              emit
            );
            await sendEnvelope({
              kind: "run-end",
              runId,
              status: res.status ?? "succeeded",
              output: res.output,
              usage: res.usage,
              model: res.model,
              error: res.error,
              metadata: res.metadata
            });
          } catch (err) {
            const message = err?.message || "error";
            await sendEnvelope({
              kind: "error",
              code: "internal_error",
              message
            });
            await sendEnvelope({
              kind: "run-end",
              runId,
              status: "failed",
              error: { code: "internal_error", message }
            });
          }
        },
        async (err, s) => {
          const message = err?.message || "error";
          const sequence = allocateSequence();
          const createdAt = nowIso();
          await s.writeSSE({
            event: "error",
            data: JSON.stringify({
              kind: "error",
              runId,
              sequence,
              createdAt,
              code: "stream_error",
              message
            }),
            id: String(sequence)
          });
          const endSequence = allocateSequence();
          await s.writeSSE({
            event: "run-end",
            data: JSON.stringify({
              kind: "run-end",
              runId,
              sequence: endSequence,
              createdAt: nowIso(),
              status: "failed",
              error: { code: "stream_error", message }
            }),
            id: String(endSequence)
          });
        }
      );
    });
  };
  const addEntrypoint = (def) => {
    if (!def.key) throw new Error("entrypoint.key required");
    registry.set(def.key, def);
    registerEntrypointRoutes(def);
  };
  if (opts?.entrypoints) {
    for (const entrypoint of opts.entrypoints) {
      addEntrypoint(entrypoint);
    }
  }
  app.get(
    "/",
    (c) => c.html(
      html`<!doctype html>
        <html lang="en">
          <head>
            <meta charset="utf-8" />
            <meta
              name="viewport"
              content="width=device-width, initial-scale=1, shrink-to-fit=no"
            />
            <title>Ax Flow Agent</title>
            <style>
              :root {
                color-scheme: light dark;
                font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                  sans-serif;
                background-color: #0f172a;
                color: #e2e8f0;
              }
              body {
                margin: 0;
                min-height: 100vh;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 3rem 1.5rem;
                background: radial-gradient(circle at top, #1e293b, #0f172a);
              }
              .card {
                max-width: 720px;
                width: 100%;
                background: rgba(15, 23, 42, 0.9);
                border: 1px solid rgba(148, 163, 184, 0.25);
                border-radius: 18px;
                box-shadow: 0 24px 60px rgba(15, 23, 42, 0.4);
                backdrop-filter: blur(14px);
                padding: 2.5rem 2rem;
              }
              h1 {
                margin: 0 0 0.75rem;
                font-size: clamp(1.5rem, 4vw, 2.5rem);
                letter-spacing: -0.02em;
              }
              p {
                margin: 0 0 1.75rem;
                color: rgba(226, 232, 240, 0.8);
                line-height: 1.6;
              }
              pre {
                margin: 0;
                padding: 1.25rem;
                background: rgba(15, 23, 42, 0.65);
                border-radius: 12px;
                border: 1px solid rgba(148, 163, 184, 0.2);
                overflow-x: auto;
                font-family: "JetBrains Mono", "Fira Code", ui-monospace,
                  SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
                  "Courier New", monospace;
                font-size: 0.875rem;
                line-height: 1.5;
                color: #e2e8f0;
              }
              a {
                color: #38bdf8;
              }
              .links {
                margin-top: 1rem;
                font-size: 0.875rem;
                color: rgba(226, 232, 240, 0.7);
              }
            </style>
          </head>
          <body>
            <main class="card">
              <h1>Ax Flow Agent</h1>
              <p>
                This example drives an AxFlow pipeline via <code>createAxLLMClient</code>.
                The AgentCard manifest is shown below for quick inspection.
              </p>
              <pre id="agent-card" aria-live="polite">Loading agent card</pre>
              <div class="links">
                View the JSON directly at
                <a href="/.well-known/agent-card.json">/.well-known/agent-card.json</a>.
              </div>
            </main>
            <script>
              const pre = document.getElementById("agent-card");
              fetch("/.well-known/agent-card.json")
                .then((res) => res.json())
                .then((card) => {
                  pre.textContent = JSON.stringify(card, null, 2);
                })
                .catch((error) => {
                  console.error("[examples] failed to load agent card", error);
                  pre.textContent = "Unable to load the agent card manifest.";
                });
            </script>
          </body>
        </html>`
    )
  );
  return {
    app,
    addEntrypoint,
    config: resolvedConfig,
    payments: resolvedPayments
  };
}

export { AP2_EXTENSION_URI, CART_MANDATE_DATA_KEY, CONTACT_ADDRESS_DATA_KEY, IDENTITY_REGISTRY_ABI, INTENT_MANDATE_DATA_KEY, PAYMENT_MANDATE_DATA_KEY, PAYMENT_METHOD_DATA_KEY, ZERO_ADDRESS, accountFromPrivateKey, bootstrapAgentPaymentContext, bootstrapIdentity, bootstrapTrust, buildManifest, buildTrustConfigFromIdentity, configureAgentKit, createAgentApp, createAgentPaymentContext, createAgentWalletClient, createAxLLMClient, createIdentityRegistryClient, createX402Fetch, createX402LLM, getAgentKitConfig, makeViemClientsFromEnv, normalizeAddress, normalizeDomain, paymentsFromEnv, resetAgentKitConfigForTesting, resolveEntrypointPrice, sanitizeAddress, signAgentDomainProof, toCaip10, toJsonSchemaOrUndefined, withPayments, x402LLM };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map